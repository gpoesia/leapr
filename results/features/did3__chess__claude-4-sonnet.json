{
  "used_features": [
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and penalty for blocked bishops\"\n    white_bishops = 0\n    black_bishops = 0\n    white_blocked = 0\n    black_blocked = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    white_blocked += 1\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    black_blocked += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 0.5\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 0.5\n    \n    return bishop_pair_bonus + (black_blocked - white_blocked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all black pieces to center of board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    black_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            black_pieces += 1\n            min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n            total_distance += min_center_distance\n    \n    return float(total_distance) if black_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of enemy pieces from their optimal squares\"\n    total_distance = 0\n    piece_count = 0\n    optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.F3, chess.C6, chess.F6, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.BISHOP: [chess.C4, chess.F4, chess.C5, chess.F5, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.QUEEN: [chess.D4, chess.E4, chess.D5, chess.E5]\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != chess.WHITE and piece.piece_type in optimal_squares:\n            min_distance = min(chess.square_distance(square, opt_sq) for opt_sq in optimal_squares[piece.piece_type])\n            total_distance += min_distance\n            piece_count += 1\n    \n    return float(total_distance / max(piece_count, 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of minor pieces compared to maximum possible\"\n    minor_piece_mobility = 0.0\n    minor_piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            max_mobility = 8 if piece.piece_type == chess.KNIGHT else 14\n            normalized_mobility = mobility / max_mobility\n            \n            if piece.color == chess.WHITE:\n                minor_piece_mobility += normalized_mobility\n            else:\n                minor_piece_mobility -= normalized_mobility\n            minor_piece_count += 1\n    \n    return minor_piece_mobility / max(1, minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility difference weighted by piece value\"\n    white_mobility = 0\n    black_mobility = 0\n    piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 1}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1)\n            if piece.color == chess.WHITE:\n                white_mobility += weight\n            else:\n                black_mobility += weight\n    \n    board.push(chess.Move.null())\n    try:\n        for move in board.legal_moves:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = piece_weights.get(piece.piece_type, 1)\n                if piece.color == chess.BLACK:\n                    black_mobility += weight\n                else:\n                    white_mobility += weight\n    except:\n        pass\n    finally:\n        board.pop()\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between knights and bishops for current position\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between white and black pieces (total legal moves)\"\n    current_turn = board.turn\n    white_mobility = 0\n    black_mobility = 0\n    \n    # Count white moves\n    if current_turn == chess.WHITE:\n        white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        if not board.is_checkmate() and not board.is_stalemate():\n            black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        if not board.is_checkmate() and not board.is_stalemate():\n            white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    white_moves = 0\n    black_moves = 0\n    if board.turn == chess.WHITE:\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns weighted by pawn advancement\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_val = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += file_val * (rank + 1)\n            else:\n                black_score += file_val * (8 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_total_distance = 0\n    black_total_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    for square, piece in piece_map.items():\n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            white_total_distance += min_distance\n            white_pieces += 1\n        else:\n            black_total_distance += min_distance\n            black_pieces += 1\n    \n    white_avg = white_total_distance / white_pieces if white_pieces > 0 else 0\n    black_avg = black_total_distance / black_pieces if black_pieces > 0 else 0\n    \n    return black_avg - white_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between white and black pieces (total legal moves)\"\n    current_turn = board.turn\n    white_mobility = 0\n    black_mobility = 0\n    \n    # Count white moves\n    if current_turn == chess.WHITE:\n        white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        if not board.is_checkmate() and not board.is_stalemate():\n            black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        if not board.is_checkmate() and not board.is_stalemate():\n            white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between knights and bishops for current position\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_control = 0\n    black_central_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_central_control += white_attackers\n        black_central_control += black_attackers\n    \n    return float(white_central_control - black_central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns on the 6th or 7th rank for promotion potential\"\n    advanced_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 5:  # 6th or 7th rank\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:  # 2nd or 1st rank\n                advanced_pawns -= 1\n    \n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between white and black pieces (total legal moves)\"\n    current_turn = board.turn\n    white_mobility = 0\n    black_mobility = 0\n    \n    # Count white moves\n    if current_turn == chess.WHITE:\n        white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        if not board.is_checkmate() and not board.is_stalemate():\n            black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        if not board.is_checkmate() and not board.is_stalemate():\n            white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all black pieces to center of board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    black_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            black_pieces += 1\n            min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n            total_distance += min_center_distance\n    \n    return float(total_distance) if black_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all black pieces to center of board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    black_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            black_pieces += 1\n            min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n            total_distance += min_center_distance\n    \n    return float(total_distance) if black_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have crossed the middle of the board (advanced pawns)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns -= 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by distance from opponent pieces\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_safety = 0.0\n    black_safety = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, white_king_square)\n            white_safety += max(0, 8 - distance)\n        elif piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, black_king_square)\n            black_safety += max(0, 8 - distance)\n    \n    return white_safety - black_safety\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can give check in one move\"\n    def check_givers(color):\n        count = 0\n        temp_board = board.copy()\n        temp_board.turn = color\n        for move in temp_board.legal_moves:\n            temp_board.push(move)\n            if temp_board.is_check():\n                count += 1\n            temp_board.pop()\n        return count\n    return float(check_givers(chess.WHITE) - check_givers(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in opponent's half of the board\"\n    white_in_black_half = 0\n    black_in_white_half = 0\n    white_total = 0\n    black_total = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_total += 1\n            if rank >= 4:\n                white_in_black_half += 1\n        else:\n            black_total += 1\n            if rank <= 3:\n                black_in_white_half += 1\n    \n    if white_total + black_total == 0:\n        return 0.0\n    return float((white_in_black_half - black_in_white_half) / (white_total + black_total))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares attacked by white queen\"\n    queen_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN and piece.color == chess.WHITE:\n            queen_attacks += len(board.attacks(square))\n    return float(queen_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Minimum number of moves for black king to reach any corner\"\n    black_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king = square\n            break\n    if black_king is None:\n        return 8.0\n    corners = [chess.A1, chess.A8, chess.H1, chess.H8]\n    min_distance = min(chess.square_distance(black_king, corner) for corner in corners)\n    return float(min_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond the 4th/5th rank and are supported by another pawn\"\n    supported_advanced_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                # Check for supporting pawns\n                if file > 0 and board.piece_at(square - 9) and board.piece_at(square - 9).piece_type == chess.PAWN and board.piece_at(square - 9).color == chess.WHITE:\n                    supported_advanced_pawns += 1\n                elif file < 7 and board.piece_at(square - 7) and board.piece_at(square - 7).piece_type == chess.PAWN and board.piece_at(square - 7).color == chess.WHITE:\n                    supported_advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                if file > 0 and board.piece_at(square + 7) and board.piece_at(square + 7).piece_type == chess.PAWN and board.piece_at(square + 7).color == chess.BLACK:\n                    supported_advanced_pawns -= 1\n                elif file < 7 and board.piece_at(square + 9) and board.piece_at(square + 9).piece_type == chess.PAWN and board.piece_at(square + 9).color == chess.BLACK:\n                    supported_advanced_pawns -= 1\n    return float(supported_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces weighted by their material value\"\n    undefended_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        defenders = len(board.attackers(piece.color, square))\n        attackers = len(board.attackers(not piece.color, square))\n        \n        if defenders == 0 and attackers > 0:\n            value = piece_values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                undefended_value -= value\n            else:\n                undefended_value += value\n    \n    return undefended_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can escape to edge files (a or h)\"\n    escape_count = 0\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK:\n            to_file = chess.square_file(move.to_square)\n            if to_file == 0 or to_file == 7:\n                escape_count += 1\n                break\n    return float(escape_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted sum of piece mobility considering piece values\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    mobility_score = 0.0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                mobility_score += weight\n            else:\n                mobility_score -= weight\n    \n    return mobility_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality based on isolated and doubled pawns\"\n    white_pawns = []\n    black_pawns = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns.append(square)\n            else:\n                black_pawns.append(square)\n    \n    def count_structure_weaknesses(pawns):\n        files = [chess.square_file(p) for p in pawns]\n        file_counts = [0] * 8\n        for f in files:\n            file_counts[f] += 1\n        \n        doubled = sum(max(0, count - 1) for count in file_counts)\n        \n        isolated = 0\n        for f in range(8):\n            if file_counts[f] > 0:\n                has_neighbor = False\n                if f > 0 and file_counts[f-1] > 0:\n                    has_neighbor = True\n                if f < 7 and file_counts[f+1] > 0:\n                    has_neighbor = True\n                if not has_neighbor:\n                    isolated += file_counts[f]\n        \n        return doubled + isolated\n    \n    white_weakness = count_structure_weaknesses(white_pawns)\n    black_weakness = count_structure_weaknesses(black_pawns)\n    \n    return black_weakness - white_weakness\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by their advancement and safety\"\n    passed_score = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            color = piece.color\n            \n            # Check if pawn is passed\n            is_passed = True\n            enemy_color = not color\n            \n            for enemy_square in chess.SQUARES:\n                enemy_piece = board.piece_at(enemy_square)\n                if enemy_piece and enemy_piece.color == enemy_color and enemy_piece.piece_type == chess.PAWN:\n                    enemy_file = chess.square_file(enemy_square)\n                    enemy_rank = chess.square_rank(enemy_square)\n                    \n                    if abs(enemy_file - file) <= 1:\n                        if color == chess.WHITE and enemy_rank >= rank:\n                            is_passed = False\n                            break\n                        elif color == chess.BLACK and enemy_rank <= rank:\n                            is_passed = False\n                            break\n            \n            if is_passed:\n                advancement = rank if color == chess.WHITE else (7 - rank)\n                safety = 1.0 if not board.is_attacked_by(enemy_color, square) else 0.5\n                multiplier = 1.0 if color == chess.WHITE else -1.0\n                passed_score += multiplier * advancement * safety\n    \n    return passed_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on distance to enemy pieces\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if not white_king_square or not black_king_square:\n        return 0.0\n    \n    white_danger = 0.0\n    black_danger = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            white_dist = chess.square_distance(white_king_square, square)\n            black_dist = chess.square_distance(black_king_square, square)\n            piece_value = [0, 1, 3, 3, 5, 9][piece.piece_type]\n            \n            if piece.color == chess.BLACK:\n                white_danger += piece_value / max(1, white_dist)\n            else:\n                black_danger += piece_value / max(1, black_dist)\n    \n    return black_danger - white_danger\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of minor pieces positioned on optimal squares for their type\"\n    optimal_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            center_distance = abs(3.5 - rank) + abs(3.5 - file)\n            score = max(0, 7 - center_distance) / 7\n            optimal_score += score if piece.color == chess.WHITE else -score\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if (rank + file) % 2 == 0:  # Light squared bishop\n                score = 1 if abs(rank - file) <= 2 else 0.5\n            else:  # Dark squared bishop\n                score = 1 if abs(rank + file - 7) <= 2 else 0.5\n            optimal_score += score if piece.color == chess.WHITE else -score\n    \n    return float(optimal_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by distance from opponent pieces\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_safety = 0.0\n    black_safety = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, white_king_square)\n            white_safety += max(0, 8 - distance)\n        elif piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, black_king_square)\n            black_safety += max(0, 8 - distance)\n    \n    return white_safety - black_safety\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality based on isolated and doubled pawns\"\n    white_pawns = []\n    black_pawns = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns.append(square)\n            else:\n                black_pawns.append(square)\n    \n    def count_structure_weaknesses(pawns):\n        files = [chess.square_file(p) for p in pawns]\n        file_counts = [0] * 8\n        for f in files:\n            file_counts[f] += 1\n        \n        doubled = sum(max(0, count - 1) for count in file_counts)\n        \n        isolated = 0\n        for f in range(8):\n            if file_counts[f] > 0:\n                has_neighbor = False\n                if f > 0 and file_counts[f-1] > 0:\n                    has_neighbor = True\n                if f < 7 and file_counts[f+1] > 0:\n                    has_neighbor = True\n                if not has_neighbor:\n                    isolated += file_counts[f]\n        \n        return doubled + isolated\n    \n    white_weakness = count_structure_weaknesses(white_pawns)\n    black_weakness = count_structure_weaknesses(black_pawns)\n    \n    return black_weakness - white_weakness\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Heavy pieces (queens and rooks) on open or semi-open files\"\n    heavy_on_open = 0\n    for file_idx in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(file_idx + rank * 8) and \n                         board.piece_at(file_idx + rank * 8).piece_type == chess.PAWN and \n                         board.piece_at(file_idx + rank * 8).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(file_idx + rank * 8) and \n                         board.piece_at(file_idx + rank * 8).piece_type == chess.PAWN and \n                         board.piece_at(file_idx + rank * 8).color == chess.BLACK)\n        \n        if white_pawns == 0 or black_pawns == 0:\n            for rank in range(8):\n                piece = board.piece_at(file_idx + rank * 8)\n                if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                    heavy_on_open += 1 if piece.color == chess.WHITE else -1\n    return float(heavy_on_open)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond their 4th rank\"\n    advanced_pawns = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns -= 1\n    \n    return advanced_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the center four squares in one move\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_reach = 0\n    black_reach = 0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece and piece.color == chess.WHITE:\n                white_reach += 1\n            elif piece and piece.color == chess.BLACK:\n                black_reach += 1\n    \n    return float(white_reach - black_reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking squares adjacent to the enemy king\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    # Find enemy king\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    # Get adjacent squares to enemy king\n    king_file = chess.square_file(enemy_king_square)\n    king_rank = chess.square_rank(enemy_king_square)\n    \n    attack_count = 0\n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file = king_file + file_offset\n            new_rank = king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                target_square = chess.square(new_file, new_rank)\n                if board.is_attacked_by(friendly_color, target_square):\n                    attack_count += 1\n    \n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that are pinned or skewered\"\n    pinned_count = 0\n    opponent_color = not board.turn\n    king_square = board.king(opponent_color)\n    if king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and piece.piece_type != chess.KING:\n            attackers = board.attackers(board.turn, square)\n            for attacker_sq in attackers:\n                attacker_piece = board.piece_at(attacker_sq)\n                if attacker_piece and attacker_piece.piece_type in [chess.BISHOP, chess.ROOK, chess.QUEEN]:\n                    if chess.square_distance(attacker_sq, king_square) > chess.square_distance(square, king_square):\n                        pinned_count += 1\n                        break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of escape squares available\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_escapes = 0\n    black_escapes = 0\n    \n    if white_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(white_king_square) + dx\n                rank = chess.square_rank(white_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.BLACK:\n                        if not board.is_attacked_by(chess.BLACK, escape_square):\n                            white_escapes += 1\n    \n    if black_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(black_king_square) + dx\n                rank = chess.square_rank(black_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.WHITE:\n                        if not board.is_attacked_by(chess.WHITE, escape_square):\n                            black_escapes += 1\n    \n    return float(white_escapes - black_escapes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and penalty for blocked bishops\"\n    white_bishops = 0\n    black_bishops = 0\n    white_blocked = 0\n    black_blocked = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    white_blocked += 1\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    black_blocked += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 0.5\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 0.5\n    \n    return bishop_pair_bonus + (black_blocked - white_blocked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of opponent's pieces from their own king\"\n    enemy_color = not board.turn\n    enemy_king_sq = board.king(enemy_color)\n    if enemy_king_sq is None:\n        return 0.0\n    \n    enemy_pieces = [sq for sq, piece in board.piece_map().items() \n                   if piece.color == enemy_color and piece.piece_type != chess.KING]\n    if not enemy_pieces:\n        return 0.0\n    \n    total_distance = sum(chess.square_distance(enemy_king_sq, sq) for sq in enemy_pieces)\n    return total_distance / len(enemy_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can reach the 8th/1st rank in one move\"\n    white_promotion_threats = 0\n    black_promotion_threats = 0\n    \n    for move in board.legal_moves:\n        if move.promotion:\n            if board.turn == chess.WHITE:\n                white_promotion_threats += 1\n            else:\n                black_promotion_threats += 1\n        elif chess.square_rank(move.to_square) == 7 and board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE:\n            white_promotion_threats += 1\n        elif chess.square_rank(move.to_square) == 0 and board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK:\n            black_promotion_threats += 1\n    \n    return float(white_promotion_threats - black_promotion_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility weighted by piece value in endgame\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    total_pieces = len(board.piece_map())\n    endgame_factor = max(0, 1.0 - (total_pieces - 6) / 26.0)\n    \n    white_mobility = black_mobility = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0) * endgame_factor\n            if piece.color == chess.WHITE:\n                white_mobility += mobility_value\n            else:\n                black_mobility += mobility_value\n    \n    board.turn = not board.turn\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0) * endgame_factor\n            if piece.color == chess.BLACK:\n                black_mobility += mobility_value\n            else:\n                white_mobility += mobility_value\n    board.turn = not board.turn\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting squares\"\n    starting_positions = {\n        chess.A1: (chess.ROOK, chess.WHITE), chess.H1: (chess.ROOK, chess.WHITE),\n        chess.B1: (chess.KNIGHT, chess.WHITE), chess.G1: (chess.KNIGHT, chess.WHITE),\n        chess.C1: (chess.BISHOP, chess.WHITE), chess.F1: (chess.BISHOP, chess.WHITE),\n        chess.D1: (chess.QUEEN, chess.WHITE), chess.E1: (chess.KING, chess.WHITE),\n        chess.A8: (chess.ROOK, chess.BLACK), chess.H8: (chess.ROOK, chess.BLACK),\n        chess.B8: (chess.KNIGHT, chess.BLACK), chess.G8: (chess.KNIGHT, chess.BLACK),\n        chess.C8: (chess.BISHOP, chess.BLACK), chess.F8: (chess.BISHOP, chess.BLACK),\n        chess.D8: (chess.QUEEN, chess.BLACK), chess.E8: (chess.KING, chess.BLACK)\n    }\n    count = 0\n    for square in range(16, 48):  # Add pawn squares\n        if chess.square_rank(square) == 1:\n            starting_positions[square] = (chess.PAWN, chess.WHITE)\n        elif chess.square_rank(square) == 6:\n            starting_positions[square] = (chess.PAWN, chess.BLACK)\n    \n    for square, (expected_type, expected_color) in starting_positions.items():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == expected_type and piece.color == expected_color:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces that can be captured by opponent\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            continue\n        attackers = board.attackers(board.turn, square)\n        defenders = board.attackers(not board.turn, square)\n        if attackers and not defenders:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king within 2 squares\"\n    king_square = board.king(chess.WHITE) if board.king(chess.WHITE) else -1\n    if king_square == -1:\n        return 0.0\n    white_defenders = 0\n    black_defenders = 0\n    \n    for square in range(64):\n        if chess.square_distance(square, king_square) <= 2:\n            white_defenders += len(board.attackers(chess.WHITE, square))\n    \n    king_square = board.king(chess.BLACK) if board.king(chess.BLACK) else -1\n    if king_square != -1:\n        for square in range(64):\n            if chess.square_distance(square, king_square) <= 2:\n                black_defenders += len(board.attackers(chess.BLACK, square))\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pawns minus average rank of black pawns\"\n    white_pawn_ranks = []\n    black_pawn_ranks = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawn_ranks.append(rank)\n            else:\n                black_pawn_ranks.append(rank)\n    \n    white_avg = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0.0\n    black_avg = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0.0\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares based on classical piece placement principles\"\n    score = 0.0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and 1 <= rank <= 5:\n                score += 1.0\n            elif piece.color == chess.BLACK and 2 <= rank <= 6:\n                score += 1.0\n        elif piece.piece_type == chess.KNIGHT:\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                score += 1.0\n        elif piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                score += 1.0 if rank >= 2 else 0.5\n            else:\n                score += 1.0 if rank <= 5 else 0.5\n        elif piece.piece_type == chess.ROOK:\n            if rank == 0 or rank == 7 or file == 0 or file == 7:\n                score += 0.5\n        elif piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE and rank <= 1:\n                score += 1.0\n            elif piece.color == chess.BLACK and rank >= 6:\n                score += 1.0\n    \n    return score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of pawns in front of castled king position\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    safety_score = 0.0\n    \n    if white_king_square and chess.square_file(white_king_square) >= 5:\n        for file_offset in [-1, 0, 1]:\n            file = chess.square_file(white_king_square) + file_offset\n            if 0 <= file <= 7:\n                pawn_square = chess.square(file, 1)\n                piece = board.piece_at(pawn_square)\n                if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                    safety_score += 1.0\n    \n    if black_king_square and chess.square_file(black_king_square) >= 5:\n        for file_offset in [-1, 0, 1]:\n            file = chess.square_file(black_king_square) + file_offset\n            if 0 <= file <= 7:\n                pawn_square = chess.square(file, 6)\n                piece = board.piece_at(pawn_square)\n                if piece and piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                    safety_score -= 1.0\n    \n    return safety_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can give check in one move\"\n    def check_givers(color):\n        count = 0\n        temp_board = board.copy()\n        temp_board.turn = color\n        for move in temp_board.legal_moves:\n            temp_board.push(move)\n            if temp_board.is_check():\n                count += 1\n            temp_board.pop()\n        return count\n    return float(check_givers(chess.WHITE) - check_givers(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    white_moves = 0\n    black_moves = 0\n    if board.turn == chess.WHITE:\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all friendly pieces to enemy king\"\n    enemy_color = not board.turn\n    enemy_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            total_distance += chess.square_distance(square, enemy_king_square)\n            piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total value of pieces that can move to center squares e4, e5, d4, d5\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    total_value = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                value = piece_values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total_value += value\n                else:\n                    total_value -= value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost strength based on advanced squares protected by pawns\"\n    outpost_score = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        multiplier = 1 if color == chess.WHITE else -1\n        enemy_color = not color\n        \n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.KNIGHT and piece.color == color:\n                rank = chess.square_rank(square)\n                file_idx = chess.square_file(square)\n                \n                # Check if in enemy territory\n                advanced = (color == chess.WHITE and rank >= 4) or (color == chess.BLACK and rank <= 3)\n                \n                if advanced:\n                    # Check if protected by own pawn\n                    protected = False\n                    pawn_rank = rank - 1 if color == chess.WHITE else rank + 1\n                    \n                    for pawn_file in [file_idx - 1, file_idx + 1]:\n                        if 0 <= pawn_file <= 7 and 0 <= pawn_rank <= 7:\n                            pawn_square = chess.square(pawn_file, pawn_rank)\n                            pawn_piece = board.piece_at(pawn_square)\n                            if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == color:\n                                protected = True\n                                break\n                    \n                    if protected:\n                        outpost_score += 1 * multiplier\n    \n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces in the opponent's half of the board\"\n    pieces_in_enemy_half = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 4:\n            pieces_in_enemy_half += 1\n        elif piece.color == chess.BLACK and rank <= 3:\n            pieces_in_enemy_half += 1\n    return float(pieces_in_enemy_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from all enemy pieces to their own king\"\n    enemy_color = not board.turn\n    enemy_king_square = board.king(enemy_color)\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == enemy_color and piece.piece_type != chess.KING:\n            total_distance += chess.square_distance(square, enemy_king_square)\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that are undefended by pawns in their current position\"\n    undefended = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        defended_by_pawn = False\n        color = piece.color\n        pawn_attacks = []\n        \n        if color == chess.WHITE:\n            if chess.square_rank(square) > 0:\n                if chess.square_file(square) > 0:\n                    pawn_attacks.append(square - 9)\n                if chess.square_file(square) < 7:\n                    pawn_attacks.append(square - 7)\n        else:\n            if chess.square_rank(square) < 7:\n                if chess.square_file(square) > 0:\n                    pawn_attacks.append(square + 7)\n                if chess.square_file(square) < 7:\n                    pawn_attacks.append(square + 9)\n        \n        for pawn_sq in pawn_attacks:\n            defender = board.piece_at(pawn_sq)\n            if defender and defender.piece_type == chess.PAWN and defender.color == color:\n                defended_by_pawn = True\n                break\n        \n        if not defended_by_pawn:\n            undefended += 1 if color == chess.WHITE else -1\n    \n    return float(undefended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    white_moves = 0\n    black_moves = 0\n    if board.turn == chess.WHITE:\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king activity measured by squares the king can reach in 2 moves\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    \n    white_reach = set()\n    black_reach = set()\n    \n    if white_king_sq is not None:\n        for sq in range(64):\n            if chess.square_distance(white_king_sq, sq) <= 2:\n                white_reach.add(sq)\n    \n    if black_king_sq is not None:\n        for sq in range(64):\n            if chess.square_distance(black_king_sq, sq) <= 2:\n                black_reach.add(sq)\n    \n    return len(white_reach) - len(black_reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Activity score based on piece mobility weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_mobility = 0.0\n    black_mobility = 0.0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white_mobility += mobility_value\n            else:\n                black_mobility += mobility_value\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of enemy pieces within 3 squares of our king to total enemy pieces\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    enemy_pieces_near_king = 0\n    total_enemy_pieces = 0\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            total_enemy_pieces += 1\n            piece_file, piece_rank = chess.square_file(square), chess.square_rank(square)\n            if abs(piece_file - king_file) <= 3 and abs(piece_rank - king_rank) <= 3:\n                enemy_pieces_near_king += 1\n    \n    return float(enemy_pieces_near_king) / max(1.0, float(total_enemy_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn islands for both sides combined\"\n    white_files = set()\n    black_files = set()\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_files.add(file)\n            else:\n                black_files.add(file)\n    \n    def count_islands(files):\n        if not files:\n            return 0\n        sorted_files = sorted(files)\n        islands = 1\n        for i in range(1, len(sorted_files)):\n            if sorted_files[i] - sorted_files[i-1] > 1:\n                islands += 1\n        return islands\n    \n    return float(count_islands(white_files) + count_islands(black_files))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond the 4th rank for the side to move\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                count += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on the same rank as opponent king\"\n    piece_map = board.piece_map()\n    white_king_square = black_king_square = None\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_king_rank = chess.square_rank(white_king_square)\n    black_king_rank = chess.square_rank(black_king_square)\n    \n    white_pieces_on_black_king_rank = sum(1 for sq, piece in piece_map.items() \n                                        if piece.color == chess.WHITE and chess.square_rank(sq) == black_king_rank)\n    black_pieces_on_white_king_rank = sum(1 for sq, piece in piece_map.items() \n                                        if piece.color == chess.BLACK and chess.square_rank(sq) == white_king_rank)\n    \n    return float(white_pieces_on_black_king_rank - black_pieces_on_white_king_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defended multiple times\"\n    multiply_defended = 0\n    for square, piece in board.piece_map().items():\n        defenders = board.attackers(piece.color, square)\n        if len(defenders) >= 2:\n            multiply_defended += 1\n    return float(multiply_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted sum of pieces by their distance from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    white_centralization = 0\n    black_centralization = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n            \n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        centralization_score = piece_values[piece.piece_type] * (8 - min_distance)\n        \n        if piece.color == chess.WHITE:\n            white_centralization += centralization_score\n        else:\n            black_centralization += centralization_score\n    \n    return (white_centralization - black_centralization) / 100.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of pawns in front of castled king position\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    safety_score = 0.0\n    \n    if white_king_square and chess.square_file(white_king_square) >= 5:\n        for file_offset in [-1, 0, 1]:\n            file = chess.square_file(white_king_square) + file_offset\n            if 0 <= file <= 7:\n                pawn_square = chess.square(file, 1)\n                piece = board.piece_at(pawn_square)\n                if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                    safety_score += 1.0\n    \n    if black_king_square and chess.square_file(black_king_square) >= 5:\n        for file_offset in [-1, 0, 1]:\n            file = chess.square_file(black_king_square) + file_offset\n            if 0 <= file <= 7:\n                pawn_square = chess.square(file, 6)\n                piece = board.piece_at(pawn_square)\n                if piece and piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                    safety_score -= 1.0\n    \n    return safety_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the center four squares in one move\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = 1.0 if piece.color == chess.WHITE else -1.0\n                center_control += weight\n    \n    return center_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Relative piece activity measured by mobility difference\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        mobility = 0\n        if piece.piece_type == chess.PAWN:\n            mobility = 0.5\n        elif piece.piece_type == chess.KNIGHT:\n            mobility = len([sq for sq in [square + delta for delta in [-17, -15, -10, -6, 6, 10, 15, 17]] if 0 <= sq <= 63])\n        elif piece.piece_type in [chess.BISHOP, chess.ROOK, chess.QUEEN]:\n            mobility = len(list(board.attacks(square)))\n        \n        if piece.color == chess.WHITE:\n            white_mobility += mobility\n        else:\n            black_mobility += mobility\n    \n    total_mobility = white_mobility + black_mobility\n    if total_mobility == 0:\n        return 0.0\n    return float((white_mobility - black_mobility) / total_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to the center four squares (d4, d5, e4, e5)\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_count = 0\n    black_count = 0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece and piece.color == chess.WHITE:\n                white_count += 1\n            elif piece and piece.color == chess.BLACK:\n                black_count += 1\n    \n    return white_count - black_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility between current player and opponent\"\n    current_mobility = len(list(board.legal_moves))\n    \n    board.push(chess.Move.null())\n    opponent_mobility = len(list(board.legal_moves)) if not board.is_check() else 0\n    board.pop()\n    \n    return float(current_mobility - opponent_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_total_distance = 0\n    black_total_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    for square, piece in piece_map.items():\n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            white_total_distance += min_distance\n            white_pieces += 1\n        else:\n            black_total_distance += min_distance\n            black_pieces += 1\n    \n    white_avg = white_total_distance / white_pieces if white_pieces > 0 else 0\n    black_avg = black_total_distance / black_pieces if black_pieces > 0 else 0\n    \n    return black_avg - white_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their 4th rank\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                count += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of squares any white piece can attack\"\n    max_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attacks = len(board.attackers(chess.WHITE, square))\n            if piece.piece_type != chess.KING:\n                attack_count = 0\n                for target_square in range(64):\n                    if board.is_attacked_by(chess.WHITE, target_square):\n                        attack_count += 1\n            max_attacks = max(max_attacks, attacks)\n    return float(max_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking squares adjacent to the enemy king\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    # Find enemy king\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    # Get adjacent squares to enemy king\n    king_file = chess.square_file(enemy_king_square)\n    king_rank = chess.square_rank(enemy_king_square)\n    \n    attack_count = 0\n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file = king_file + file_offset\n            new_rank = king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                target_square = chess.square(new_file, new_rank)\n                if board.is_attacked_by(friendly_color, target_square):\n                    attack_count += 1\n    \n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the 4th rank for white or 5th rank for black\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in enemy territory vs own territory\"\n    white_in_enemy = 0\n    black_in_enemy = 0\n    white_total = 0\n    black_total = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.piece_type != chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_total += 1\n                if rank >= 4:\n                    white_in_enemy += 1\n            else:\n                black_total += 1\n                if rank <= 3:\n                    black_in_enemy += 1\n    \n    white_ratio = white_in_enemy / max(white_total, 1)\n    black_ratio = black_in_enemy / max(black_total, 1)\n    \n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their starting squares\"\n    total_distance = 0\n    piece_count = 0\n    starting_positions = {\n        chess.WHITE: {\n            chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n            chess.ROOK: [chess.A1, chess.H1],\n            chess.KNIGHT: [chess.B1, chess.G1],\n            chess.BISHOP: [chess.C1, chess.F1],\n            chess.QUEEN: [chess.D1],\n            chess.KING: [chess.E1]\n        },\n        chess.BLACK: {\n            chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n            chess.ROOK: [chess.A8, chess.H8],\n            chess.KNIGHT: [chess.B8, chess.G8],\n            chess.BISHOP: [chess.C8, chess.F8],\n            chess.QUEEN: [chess.D8],\n            chess.KING: [chess.E8]\n        }\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in starting_positions[piece.color]:\n            min_dist = min(chess.square_distance(square, start_sq) \n                          for start_sq in starting_positions[piece.color][piece.piece_type])\n            total_distance += min_dist\n            piece_count += 1\n    \n    return float(total_distance / piece_count if piece_count > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of major pieces (queen, rook) to total pieces for material imbalance assessment\"\n    white_major = 0\n    black_major = 0\n    white_total = 0\n    black_total = 0\n    \n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                white_major += 1\n        else:\n            black_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                black_major += 1\n    \n    white_ratio = white_major / max(white_total, 1)\n    black_ratio = black_major / max(black_total, 1)\n    \n    return white_ratio - black_ratio\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares (knights on outposts, bishops on long diagonals)\"\n    optimal_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            # Knights are better in center and advanced positions\n            if 2 <= file <= 5 and 2 <= rank <= 5:\n                optimal_pieces += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type == chess.BISHOP:\n            # Count bishops on long diagonals\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if file == rank or file + rank == 7:  # Main diagonals\n                optimal_pieces += 1 if piece.color == chess.WHITE else -1\n    \n    return float(optimal_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    white_moves = 0\n    black_moves = 0\n    if board.turn == chess.WHITE:\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces on the 6th rank or higher\"\n    count = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            rank = chess.square_rank(square)\n            if rank >= 5:  # 6th rank or higher\n                count += 1\n    return count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pawn moves available between white and black\"\n    white_pawn_moves = 0\n    black_pawn_moves = 0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawn_moves += 1\n            else:\n                black_pawn_moves += 1\n    \n    return float(white_pawn_moves - black_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to their nearest enemy piece\"\n    total_distance = 0\n    piece_map = board.piece_map()\n    for square1, piece1 in piece_map.items():\n        min_distance = 14\n        for square2, piece2 in piece_map.items():\n            if piece1.color != piece2.color:\n                distance = chess.square_distance(square1, square2)\n                min_distance = min(min_distance, distance)\n        total_distance += min_distance\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares based on classical piece placement principles\"\n    score = 0.0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and 1 <= rank <= 5:\n                score += 1.0\n            elif piece.color == chess.BLACK and 2 <= rank <= 6:\n                score += 1.0\n        elif piece.piece_type == chess.KNIGHT:\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                score += 1.0\n        elif piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                score += 1.0 if rank >= 2 else 0.5\n            else:\n                score += 1.0 if rank <= 5 else 0.5\n        elif piece.piece_type == chess.ROOK:\n            if rank == 0 or rank == 7 or file == 0 or file == 7:\n                score += 0.5\n        elif piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE and rank <= 1:\n                score += 1.0\n            elif piece.color == chess.BLACK and rank >= 6:\n                score += 1.0\n    \n    return score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance between kings weighted by material remaining on board\"\n    king_squares = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            king_squares.append(square)\n    \n    if len(king_squares) != 2:\n        return 0.0\n    \n    king_distance = chess.square_distance(king_squares[0], king_squares[1])\n    total_material = sum(1 for piece in board.piece_map().values() \n                        if piece.piece_type != chess.KING)\n    \n    if total_material == 0:\n        return float(king_distance)\n    \n    return float(king_distance) * (10.0 / max(total_material, 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        weight = 1.0 if piece.color == chess.WHITE else -1.0\n        total_distance += weight * min_center_dist\n        piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and penalty for blocked bishops\"\n    white_bishops = 0\n    black_bishops = 0\n    white_blocked = 0\n    black_blocked = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    white_blocked += 1\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    black_blocked += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 0.5\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 0.5\n    \n    return bishop_pair_bonus + (black_blocked - white_blocked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of major pieces (queen, rook) to total pieces for material imbalance assessment\"\n    white_major = 0\n    black_major = 0\n    white_total = 0\n    black_total = 0\n    \n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                white_major += 1\n        else:\n            black_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                black_major += 1\n    \n    white_ratio = white_major / max(white_total, 1)\n    black_ratio = black_major / max(black_total, 1)\n    \n    return white_ratio - black_ratio\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the opponent's back two ranks in one move\"\n    count = 0\n    white_targets = set(range(56, 64)) | set(range(48, 56))  # 7th and 8th ranks\n    black_targets = set(range(0, 8)) | set(range(8, 16))     # 1st and 2nd ranks\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.color == chess.WHITE and move.to_square in white_targets:\n            count += 1\n        elif piece and piece.color == chess.BLACK and move.to_square in black_targets:\n            count -= 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by pawns in the opponent's territory\"\n    white_control = 0\n    black_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if piece.color == chess.WHITE and rank >= 4:\n                if file > 0 and rank < 7:\n                    white_control += 1\n                if file < 7 and rank < 7:\n                    white_control += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                if file > 0 and rank > 0:\n                    black_control += 1\n                if file < 7 and rank > 0:\n                    black_control += 1\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their starting files versus displaced files\"\n    piece_map = board.piece_map()\n    displaced_white = 0\n    displaced_black = 0\n    total_white = 0\n    total_black = 0\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        file_idx = chess.square_file(square)\n        starting_files = {chess.ROOK: [0, 7], chess.KNIGHT: [1, 6], chess.BISHOP: [2, 5], \n                         chess.QUEEN: [3], chess.KING: [4]}\n        \n        if piece.color == chess.WHITE:\n            total_white += 1\n            if piece.piece_type in starting_files and file_idx not in starting_files[piece.piece_type]:\n                displaced_white += 1\n        else:\n            total_black += 1\n            if piece.piece_type in starting_files and file_idx not in starting_files[piece.piece_type]:\n                displaced_black += 1\n    \n    white_ratio = displaced_white / max(total_white, 1)\n    black_ratio = displaced_black / max(total_black, 1)\n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the 4th rank for white or 5th rank for black\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance between kings multiplied by material imbalance\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    king_distance = chess.square_distance(white_king, black_king)\n    \n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(king_distance * (white_material - black_material))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king within 2 squares\"\n    king_square = board.king(chess.WHITE) if board.king(chess.WHITE) else -1\n    if king_square == -1:\n        return 0.0\n    white_defenders = 0\n    black_defenders = 0\n    \n    for square in range(64):\n        if chess.square_distance(square, king_square) <= 2:\n            white_defenders += len(board.attackers(chess.WHITE, square))\n    \n    king_square = board.king(chess.BLACK) if board.king(chess.BLACK) else -1\n    if king_square != -1:\n        for square in range(64):\n            if chess.square_distance(square, king_square) <= 2:\n                black_defenders += len(board.attackers(chess.BLACK, square))\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on squares adjacent to the opponent king\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    white_king_sq = board.king(chess.BLACK)\n    black_king_sq = board.king(chess.WHITE)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_threats = 0\n    black_threats = 0\n    \n    # Check squares adjacent to black king\n    for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n        adj_sq = black_king_sq + delta\n        if 0 <= adj_sq < 64 and chess.square_distance(black_king_sq, adj_sq) == 1:\n            white_threats += len(board.attackers(chess.WHITE, adj_sq))\n    \n    # Check squares adjacent to white king  \n    for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n        adj_sq = white_king_sq + delta\n        if 0 <= adj_sq < 64 and chess.square_distance(white_king_sq, adj_sq) == 1:\n            black_threats += len(board.attackers(chess.BLACK, adj_sq))\n    \n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on edge squares of the board\"\n    edge_pieces = 0\n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if file == 0 or file == 7 or rank == 0 or rank == 7:\n            edge_pieces += 1\n    return float(edge_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can capture on the next move\"\n    white_captures = 0\n    black_captures = 0\n    \n    # Count capturing moves for current player\n    for move in board.legal_moves:\n        if board.piece_at(move.to_square) is not None:\n            if board.turn == chess.WHITE:\n                white_captures += 1\n            else:\n                black_captures += 1\n    \n    # Switch turns and count for other player\n    board_copy = board.copy()\n    board_copy.push(chess.Move.null())\n    if not board_copy.is_valid():\n        return float(white_captures - black_captures)\n    \n    for move in board_copy.legal_moves:\n        if board_copy.piece_at(move.to_square) is not None:\n            if board_copy.turn == chess.WHITE:\n                white_captures += 1\n            else:\n                black_captures += 1\n    \n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pawns minus average rank of black pawns\"\n    white_pawn_ranks = []\n    black_pawn_ranks = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawn_ranks.append(rank)\n            else:\n                black_pawn_ranks.append(rank)\n    \n    white_avg = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0.0\n    black_avg = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0.0\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their starting squares\"\n    starting_squares = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, \n                     chess.D1: chess.QUEEN, chess.E1: chess.KING, chess.F1: chess.BISHOP, \n                     chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP,\n                     chess.D8: chess.QUEEN, chess.E8: chess.KING, chess.F8: chess.BISHOP,\n                     chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    white_on_start = 0\n    black_on_start = 0\n    \n    for square, expected_piece in starting_squares[chess.WHITE].items():\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.WHITE and piece.piece_type == expected_piece:\n            white_on_start += 1\n    \n    for square, expected_piece in starting_squares[chess.BLACK].items():\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.BLACK and piece.piece_type == expected_piece:\n            black_on_start += 1\n    \n    return black_on_start - white_on_start\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to the opponent's king\"\n    opp_color = not board.turn\n    opp_king = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == opp_color:\n            opp_king = square\n            break\n    \n    if opp_king is None:\n        return 0.0\n    \n    king_adjacent = []\n    king_file, king_rank = chess.square_file(opp_king), chess.square_rank(opp_king)\n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            f, r = king_file + df, king_rank + dr\n            if 0 <= f <= 7 and 0 <= r <= 7:\n                king_adjacent.append(chess.square(f, r))\n    \n    attacking_pieces = 0\n    for move in board.legal_moves:\n        if move.to_square in king_adjacent:\n            attacking_pieces += 1\n    \n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting squares\"\n    starting_positions = {\n        chess.A1: (chess.ROOK, chess.WHITE), chess.H1: (chess.ROOK, chess.WHITE),\n        chess.B1: (chess.KNIGHT, chess.WHITE), chess.G1: (chess.KNIGHT, chess.WHITE),\n        chess.C1: (chess.BISHOP, chess.WHITE), chess.F1: (chess.BISHOP, chess.WHITE),\n        chess.D1: (chess.QUEEN, chess.WHITE), chess.E1: (chess.KING, chess.WHITE),\n        chess.A8: (chess.ROOK, chess.BLACK), chess.H8: (chess.ROOK, chess.BLACK),\n        chess.B8: (chess.KNIGHT, chess.BLACK), chess.G8: (chess.KNIGHT, chess.BLACK),\n        chess.C8: (chess.BISHOP, chess.BLACK), chess.F8: (chess.BISHOP, chess.BLACK),\n        chess.D8: (chess.QUEEN, chess.BLACK), chess.E8: (chess.KING, chess.BLACK)\n    }\n    count = 0\n    for square in range(16, 48):  # Add pawn squares\n        if chess.square_rank(square) == 1:\n            starting_positions[square] = (chess.PAWN, chess.WHITE)\n        elif chess.square_rank(square) == 6:\n            starting_positions[square] = (chess.PAWN, chess.BLACK)\n    \n    for square, (expected_type, expected_color) in starting_positions.items():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == expected_type and piece.color == expected_color:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    # Count current player mobility\n    current_mobility = len(list(board.legal_moves))\n    \n    # Switch turns to count opponent mobility\n    board.push(chess.Move.null())\n    opponent_mobility = len(list(board.legal_moves))\n    board.pop()\n    \n    if board.turn == chess.WHITE:\n        white_mobility = current_mobility\n        black_mobility = opponent_mobility\n    else:\n        black_mobility = current_mobility\n        white_mobility = opponent_mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of total piece material to starting material (measures how much material remains)\"\n    total_material = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                   chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        total_material += piece_values[piece.piece_type]\n    \n    starting_material = 78  # 16 pawns + 4 rooks + 4 bishops + 4 knights + 2 queens\n    \n    if starting_material == 0:\n        return 1.0\n    \n    return float(total_material) / starting_material\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to their nearest enemy piece\"\n    total_distance = 0\n    piece_map = board.piece_map()\n    for square1, piece1 in piece_map.items():\n        min_distance = 14\n        for square2, piece2 in piece_map.items():\n            if piece1.color != piece2.color:\n                distance = chess.square_distance(square1, square2)\n                min_distance = min(min_distance, distance)\n        total_distance += min_distance\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of files with only one color's pieces\"\n    file_control = [0] * 8  # -1 for black only, 1 for white only, 0 for mixed/empty\n    for square, piece in board.piece_map().items():\n        file_idx = chess.square_file(square)\n        current = file_control[file_idx]\n        piece_value = 1 if piece.color == chess.WHITE else -1\n        if current == 0:\n            file_control[file_idx] = piece_value\n        elif current != piece_value:\n            file_control[file_idx] = 0  # Mixed file\n    return float(sum(1 for control in file_control if control != 0))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances between all white pieces and black king\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance = chess.square_distance(square, black_king_square)\n            total_distance += distance\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to their own back rank\"\n    count = 0\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    back_rank = 0 if current_color == chess.WHITE else 7\n    \n    for move in board.legal_moves:\n        if chess.square_rank(move.to_square) == back_rank:\n            piece = board.piece_at(move.from_square)\n            if piece and piece.color == current_color:\n                count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece activity measured by average distance from starting squares\"\n    white_distance = 0\n    black_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    starting_squares = {\n        chess.WHITE: {chess.ROOK: [chess.A1, chess.H1], chess.KNIGHT: [chess.B1, chess.G1], \n                     chess.BISHOP: [chess.C1, chess.F1], chess.QUEEN: [chess.D1], chess.KING: [chess.E1]},\n        chess.BLACK: {chess.ROOK: [chess.A8, chess.H8], chess.KNIGHT: [chess.B8, chess.G8],\n                     chess.BISHOP: [chess.C8, chess.F8], chess.QUEEN: [chess.D8], chess.KING: [chess.E8]}\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        if piece.color == chess.WHITE:\n            if piece.piece_type in starting_squares[chess.WHITE]:\n                min_dist = min(chess.square_distance(square, start_sq) \n                             for start_sq in starting_squares[chess.WHITE][piece.piece_type])\n                white_distance += min_dist\n                white_pieces += 1\n        else:\n            if piece.piece_type in starting_squares[chess.BLACK]:\n                min_dist = min(chess.square_distance(square, start_sq)\n                             for start_sq in starting_squares[chess.BLACK][piece.piece_type])\n                black_distance += min_dist\n                black_pieces += 1\n    \n    white_avg = white_distance / max(1, white_pieces)\n    black_avg = black_distance / max(1, black_pieces)\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of rooks from center files\"\n    total_distance = 0.0\n    rook_count = 0\n    \n    piece_map = board.piece_map()\n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.ROOK:\n            file_pos = chess.square_file(square)\n            distance_from_center = min(abs(file_pos - 3), abs(file_pos - 4))\n            total_distance += distance_from_center\n            rook_count += 1\n    \n    return total_distance / max(rook_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_total_distance = 0\n    black_total_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    for square, piece in piece_map.items():\n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            white_total_distance += min_distance\n            white_pieces += 1\n        else:\n            black_total_distance += min_distance\n            black_pieces += 1\n    \n    white_avg = white_total_distance / white_pieces if white_pieces > 0 else 0\n    black_avg = black_total_distance / black_pieces if black_pieces > 0 else 0\n    \n    return black_avg - white_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in rook activity measured by horizontal and vertical mobility\"\n    white_rook_mobility = 0\n    black_rook_mobility = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            mobility = 0\n            for direction in [8, -8, 1, -1]:  # vertical and horizontal\n                test_square = square\n                while True:\n                    test_square += direction\n                    if test_square < 0 or test_square > 63:\n                        break\n                    if abs(chess.square_file(test_square) - chess.square_file(test_square - direction)) > 1:\n                        break\n                    if board.piece_at(test_square) is None:\n                        mobility += 1\n                    else:\n                        if board.piece_at(test_square).color != piece.color:\n                            mobility += 1\n                        break\n            if piece.color == chess.WHITE:\n                white_rook_mobility += mobility\n            else:\n                black_rook_mobility += mobility\n    return float(white_rook_mobility - black_rook_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond the 4th/5th rank and are supported by another pawn\"\n    supported_advanced_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                # Check for supporting pawns\n                if file > 0 and board.piece_at(square - 9) and board.piece_at(square - 9).piece_type == chess.PAWN and board.piece_at(square - 9).color == chess.WHITE:\n                    supported_advanced_pawns += 1\n                elif file < 7 and board.piece_at(square - 7) and board.piece_at(square - 7).piece_type == chess.PAWN and board.piece_at(square - 7).color == chess.WHITE:\n                    supported_advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                if file > 0 and board.piece_at(square + 7) and board.piece_at(square + 7).piece_type == chess.PAWN and board.piece_at(square + 7).color == chess.BLACK:\n                    supported_advanced_pawns -= 1\n                elif file < 7 and board.piece_at(square + 9) and board.piece_at(square + 9).piece_type == chess.PAWN and board.piece_at(square + 9).color == chess.BLACK:\n                    supported_advanced_pawns -= 1\n    return float(supported_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on edge squares of the board\"\n    edge_pieces = 0\n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if file == 0 or file == 7 or rank == 0 or rank == 7:\n            edge_pieces += 1\n    return float(edge_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces that can be trapped or have limited escape squares\"\n    trapped_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            continue\n            \n        # Count escape squares for this piece\n        escape_squares = 0\n        piece_moves = []\n        \n        # Generate pseudo-legal moves for this piece type from its position\n        temp_board = board.copy()\n        temp_board.turn = piece.color\n        \n        for move in temp_board.legal_moves:\n            if move.from_square == square:\n                piece_moves.append(move)\n        \n        for move in piece_moves:\n            # Check if destination is safe\n            if not temp_board.is_attacked_by(board.turn, move.to_square):\n                escape_squares += 1\n        \n        # Pieces with very few escape squares contribute to trapping score\n        if escape_squares <= 2:\n            piece_value = [0, 1, 3, 3, 5, 9, 0][piece.piece_type]\n            trapped_score += piece_value * (3 - escape_squares)\n    \n    return trapped_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of total piece material to starting material (measures how much material remains)\"\n    total_material = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                   chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        total_material += piece_values[piece.piece_type]\n    \n    starting_material = 78  # 16 pawns + 4 rooks + 4 bishops + 4 knights + 2 queens\n    \n    if starting_material == 0:\n        return 1.0\n    \n    return float(total_material) / starting_material\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of escape squares available to both kings\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_escapes = 0\n    black_escapes = 0\n    \n    for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n        white_target = white_king_square + delta\n        if 0 <= white_target < 64 and abs(chess.square_file(white_target) - chess.square_file(white_king_square)) <= 1:\n            if not board.is_attacked_by(chess.BLACK, white_target):\n                white_escapes += 1\n        \n        black_target = black_king_square + delta\n        if 0 <= black_target < 64 and abs(chess.square_file(black_target) - chess.square_file(black_king_square)) <= 1:\n            if not board.is_attacked_by(chess.WHITE, black_target):\n                black_escapes += 1\n    \n    return white_escapes - black_escapes\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king safety measured by number of escape squares\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_escape = 0\n    black_escape = 0\n    \n    for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n        white_sq = white_king_square + delta\n        black_sq = black_king_square + delta\n        \n        if 0 <= white_sq <= 63 and not board.piece_at(white_sq):\n            white_escape += 1\n        if 0 <= black_sq <= 63 and not board.piece_at(black_sq):\n            black_escape += 1\n    \n    return float(white_escape - black_escape)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled exclusively by our pieces\"\n    our_color = board.turn\n    opponent_color = not our_color\n    \n    exclusive_control = 0\n    for square in chess.SQUARES:\n        our_attackers = len(board.attackers(our_color, square))\n        enemy_attackers = len(board.attackers(opponent_color, square))\n        \n        if our_attackers > 0 and enemy_attackers == 0:\n            exclusive_control += 1\n    \n    return float(exclusive_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in tempo measured by pieces moved from starting squares weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    starting_squares = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, chess.D1: chess.QUEEN,\n                     chess.E1: chess.KING, chess.F1: chess.BISHOP, chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP, chess.D8: chess.QUEEN,\n                     chess.E8: chess.KING, chess.F8: chess.BISHOP, chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    white_tempo = black_tempo = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            rank = chess.square_rank(square)\n            if rank == 1 and square in starting_squares[chess.WHITE] and starting_squares[chess.WHITE][square] == piece.piece_type:\n                continue\n            elif rank == 1 and piece.piece_type == chess.PAWN:\n                continue\n            white_tempo += piece_values.get(piece.piece_type, 0)\n        else:\n            rank = chess.square_rank(square)\n            if rank == 6 and square in starting_squares[chess.BLACK] and starting_squares[chess.BLACK][square] == piece.piece_type:\n                continue\n            elif rank == 6 and piece.piece_type == chess.PAWN:\n                continue\n            black_tempo += piece_values.get(piece.piece_type, 0)\n    \n    return float(white_tempo - black_tempo)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by pawns in the opponent's territory\"\n    white_control = 0\n    black_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if piece.color == chess.WHITE and rank >= 4:\n                if file > 0 and rank < 7:\n                    white_control += 1\n                if file < 7 and rank < 7:\n                    white_control += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                if file > 0 and rank > 0:\n                    black_control += 1\n                if file < 7 and rank > 0:\n                    black_control += 1\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in endgame vs opening squares\"\n    edge_squares = 0\n    center_squares = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if rank in [0, 1, 6, 7] or file in [0, 1, 6, 7]:\n            edge_squares += 1\n        else:\n            center_squares += 1\n    \n    total = edge_squares + center_squares\n    if total == 0:\n        return 0.0\n    \n    return float(edge_squares) / float(total)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Product of material advantage and king safety differential\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    material_diff = white_material - black_material\n    \n    white_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.WHITE)\n    black_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.BLACK)\n    safety_diff = black_king_attacks - white_king_attacks\n    \n    return float(material_diff * (safety_diff + 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value weighted by distance from the center of the board\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_value = 0.0\n    \n    for square, piece in board.piece_map().items():\n        base_value = piece_values.get(piece.piece_type, 0)\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        weight = 1.0 / (1.0 + min_center_dist * 0.2)\n        \n        if piece.color == chess.WHITE:\n            total_value += base_value * weight\n        else:\n            total_value -= base_value * weight\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on light squares vs dark squares\"\n    light_square_pieces = 0\n    dark_square_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        if (file + rank) % 2 == 0:  # Dark square\n            dark_square_pieces += 1\n        else:  # Light square\n            light_square_pieces += 1\n    \n    return float(light_square_pieces - dark_square_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between knights and bishops for current position\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of pawns in front of castled king position\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    safety_score = 0.0\n    \n    if white_king_square and chess.square_file(white_king_square) >= 5:\n        for file_offset in [-1, 0, 1]:\n            file = chess.square_file(white_king_square) + file_offset\n            if 0 <= file <= 7:\n                pawn_square = chess.square(file, 1)\n                piece = board.piece_at(pawn_square)\n                if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                    safety_score += 1.0\n    \n    if black_king_square and chess.square_file(black_king_square) >= 5:\n        for file_offset in [-1, 0, 1]:\n            file = chess.square_file(black_king_square) + file_offset\n            if 0 <= file <= 7:\n                pawn_square = chess.square(file, 6)\n                piece = board.piece_at(pawn_square)\n                if piece and piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                    safety_score -= 1.0\n    \n    return safety_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of defended pieces to total pieces for current player\"\n    current_color = board.turn\n    defended = 0\n    total = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == current_color:\n            total += 1\n            if board.attackers(current_color, square):\n                defended += 1\n    if total == 0:\n        return 0.0\n    return float(defended) / float(total)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that can move to the center four squares\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                value = piece_values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total_value += value\n                else:\n                    total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns weighted by pawn advancement\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_val = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += file_val * (rank + 1)\n            else:\n                black_score += file_val * (8 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their optimal squares\"\n    white_optimal = 0\n    black_optimal = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                if piece.color == chess.WHITE:\n                    white_optimal += 1\n                else:\n                    black_optimal += 1\n        elif piece.piece_type == chess.BISHOP:\n            if rank != 0 and rank != 7:\n                if piece.color == chess.WHITE:\n                    white_optimal += 1\n                else:\n                    black_optimal += 1\n    \n    return float(white_optimal - black_optimal)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Product of material advantage and king safety differential\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    material_diff = white_material - black_material\n    \n    white_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.WHITE)\n    black_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.BLACK)\n    safety_diff = black_king_attacks - white_king_attacks\n    \n    return float(material_diff * (safety_diff + 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to their nearest enemy piece\"\n    total_distance = 0\n    piece_map = board.piece_map()\n    for square1, piece1 in piece_map.items():\n        min_distance = 14\n        for square2, piece2 in piece_map.items():\n            if piece1.color != piece2.color:\n                distance = chess.square_distance(square1, square2)\n                min_distance = min(min_distance, distance)\n        total_distance += min_distance\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook confinement score based on horizontal and vertical movement restrictions\"\n    confinement = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            file_moves = 0\n            rank_moves = 0\n            \n            # Count available moves in file and rank\n            for target in range(64):\n                if chess.square_file(target) == chess.square_file(square) or chess.square_rank(target) == chess.square_rank(square):\n                    move = chess.Move(square, target)\n                    if move in board.legal_moves:\n                        if chess.square_file(target) == chess.square_file(square):\n                            file_moves += 1\n                        else:\n                            rank_moves += 1\n            \n            # Higher confinement when fewer moves available\n            rook_confinement = max(0, 14 - file_moves - rank_moves)\n            confinement += rook_confinement if piece.color == chess.WHITE else -rook_confinement\n    \n    return confinement\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in the next move\"\n    check_threats = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_threats += 1\n        board.pop()\n    \n    return float(check_threats if board.turn == chess.WHITE else -check_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to center in one move\"\n    center_adjacent = [chess.C3, chess.C4, chess.C5, chess.D3, chess.D6, chess.E3, chess.E6, chess.F3, chess.F4, chess.F5]\n    count = 0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_adjacent:\n            piece = board.piece_at(move.from_square)\n            if piece and piece.color == chess.WHITE:\n                count += 1\n            elif piece and piece.color == chess.BLACK:\n                count -= 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by how advanced they are\"\n    passed_count = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (rank - 1) * (1.0 if piece.color == chess.WHITE else -1.0)\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (6 - rank) * (-1.0)\n    \n    return passed_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on squares adjacent to the opponent king\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    white_king_sq = board.king(chess.BLACK)\n    black_king_sq = board.king(chess.WHITE)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_threats = 0\n    black_threats = 0\n    \n    # Check squares adjacent to black king\n    for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n        adj_sq = black_king_sq + delta\n        if 0 <= adj_sq < 64 and chess.square_distance(black_king_sq, adj_sq) == 1:\n            white_threats += len(board.attackers(chess.WHITE, adj_sq))\n    \n    # Check squares adjacent to white king  \n    for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n        adj_sq = white_king_sq + delta\n        if 0 <= adj_sq < 64 and chess.square_distance(white_king_sq, adj_sq) == 1:\n            black_threats += len(board.attackers(chess.BLACK, adj_sq))\n    \n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total Manhattan distance of all pieces from board center\"\n    total_distance = 0.0\n    center_files = [3.5, 3.5]  # Between d and e files\n    center_ranks = [3.5, 3.5]  # Between 4th and 5th ranks\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        distance_to_center = abs(file - center_files[0]) + abs(rank - center_ranks[0])\n        total_distance += distance_to_center\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on squares adjacent to the opponent king\"\n    opponent_color = not board.turn\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == opponent_color:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    adjacent_squares = []\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            f, r = king_file + df, king_rank + dr\n            if 0 <= f <= 7 and 0 <= r <= 7:\n                adjacent_squares.append(chess.square(f, r))\n    \n    capture_count = 0\n    for move in board.legal_moves:\n        if move.to_square in adjacent_squares and board.piece_at(move.to_square):\n            capture_count += 1\n    \n    return float(capture_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the 4th rank for white or 5th rank for black\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their ideal central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            min_dist = min(chess.square_distance(square, center) for center in central_squares)\n            if piece.color == chess.WHITE:\n                total_distance += min_dist\n            else:\n                total_distance -= min_dist\n            piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on squares of their optimal color (light/dark square compatibility)\"\n    optimal_placement = 0\n    for square, piece in board.piece_map().items():\n        square_color = (chess.square_rank(square) + chess.square_file(square)) % 2\n        if piece.piece_type == chess.BISHOP:\n            # Bishops should ideally control both light and dark squares in coordination\n            optimal_placement += 0.5\n        elif piece.piece_type == chess.KNIGHT:\n            # Knights work well on squares opposite to the majority of pawns\n            if square_color == 1:  # Dark squares often better for knights\n                optimal_placement += 1\n        elif piece.piece_type == chess.KING:\n            # King safety often better on squares matching pawn shelter color\n            if square_color == 0:  # Light squares\n                optimal_placement += 1\n    return float(optimal_placement)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_control = 0\n    black_central_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_central_control += white_attackers\n        black_central_control += black_attackers\n    \n    return float(white_central_control - black_central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on next move weighted by target value\"\n    capture_weight = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            if captured_piece:\n                weight = piece_values.get(captured_piece.piece_type, 0)\n                if board.turn == chess.WHITE:\n                    capture_weight += weight\n                else:\n                    capture_weight -= weight\n    \n    return capture_weight\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of pieces from the center files\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in piece_map.items():\n        file = chess.square_file(square)\n        center_distance = min(abs(file - 3), abs(file - 4))\n        if piece.color == chess.WHITE:\n            total_distance += center_distance\n        else:\n            total_distance -= center_distance\n        piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns weighted by pawn advancement\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_val = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += file_val * (rank + 1)\n            else:\n                black_score += file_val * (8 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of all pieces weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0\n    weighted_rank_sum = 0\n    \n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            value = piece_values[piece.piece_type]\n            rank = chess.square_rank(square)\n            if piece.color == chess.BLACK:\n                rank = 7 - rank\n            \n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return float(weighted_rank_sum / total_value) if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of enemy pieces within 3 squares of own king that could give check\"\n    own_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            own_king_square = square\n            break\n    \n    if own_king_square is None:\n        return 0.0\n    \n    threat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(own_king_square, square)\n            if distance <= 3:\n                # Check if this piece type could potentially give check from its current position\n                if piece.piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT]:\n                    threat_count += 1\n    \n    return float(threat_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can move to safety from white attacks\"\n    safe_moves = 0\n    if board.turn != chess.BLACK:\n        board.turn = chess.BLACK\n        turn_changed = True\n    else:\n        turn_changed = False\n    \n    for move in board.legal_moves:\n        board.push(move)\n        to_square = move.to_square\n        if not board.is_attacked_by(chess.WHITE, to_square):\n            safe_moves += 1\n        board.pop()\n    \n    if turn_changed:\n        board.turn = chess.WHITE\n    return float(safe_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of piece values on central four squares\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                   chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_value = 0.0\n    \n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            value = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                total_value += value\n            else:\n                total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can capture on the next move\"\n    white_captures = 0\n    black_captures = 0\n    \n    # Count capturing moves for current player\n    for move in board.legal_moves:\n        if board.piece_at(move.to_square) is not None:\n            if board.turn == chess.WHITE:\n                white_captures += 1\n            else:\n                black_captures += 1\n    \n    # Switch turns and count for other player\n    board_copy = board.copy()\n    board_copy.push(chess.Move.null())\n    if not board_copy.is_valid():\n        return float(white_captures - black_captures)\n    \n    for move in board_copy.legal_moves:\n        if board_copy.piece_at(move.to_square) is not None:\n            if board_copy.turn == chess.WHITE:\n                white_captures += 1\n            else:\n                black_captures += 1\n    \n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by pieces in the center four squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlled_count = 0.0\n    \n    for center_sq in center_squares:\n        piece = board.piece_at(center_sq)\n        if piece is not None:\n            for target_sq in range(64):\n                if board.is_attacked_by(piece.color, target_sq):\n                    controlled_count += 1.0\n    \n    return controlled_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can be captured by white pieces in one move\"\n    capturable_pieces = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move) and board.turn == chess.WHITE:\n            capturable_pieces += 1\n        elif board.is_capture(move) and board.turn == chess.BLACK:\n            capturable_pieces -= 1\n    \n    return float(capturable_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king safety measured by escape squares available\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    \n    white_escape = 0\n    black_escape = 0\n    \n    if white_king_sq:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(white_king_sq) + dx\n                rank = chess.square_rank(white_king_sq) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    sq = chess.square(file, rank)\n                    if not board.piece_at(sq) and not board.is_attacked_by(chess.BLACK, sq):\n                        white_escape += 1\n    \n    if black_king_sq:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(black_king_sq) + dx\n                rank = chess.square_rank(black_king_sq) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    sq = chess.square(file, rank)\n                    if not board.piece_at(sq) and not board.is_attacked_by(chess.WHITE, sq):\n                        black_escape += 1\n    \n    return float(white_escape - black_escape)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on the same rank or file as opponent king\"\n    piece_map = board.piece_map()\n    white_king_sq = None\n    black_king_sq = None\n    \n    for sq, piece in piece_map.items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = sq\n            else:\n                black_king_sq = sq\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    aligned_pieces = 0\n    \n    for sq, piece in piece_map.items():\n        if piece.piece_type != chess.KING:\n            if piece.color == chess.WHITE:\n                if (chess.square_file(sq) == chess.square_file(black_king_sq) or \n                    chess.square_rank(sq) == chess.square_rank(black_king_sq)):\n                    aligned_pieces += 1\n            else:\n                if (chess.square_file(sq) == chess.square_file(white_king_sq) or \n                    chess.square_rank(sq) == chess.square_rank(white_king_sq)):\n                    aligned_pieces -= 1\n    \n    return float(aligned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pieces defending each other in a chain formation\"\n    defended_pieces = 0\n    piece_map = board.piece_map()\n    for square, piece in piece_map.items():\n        defenders = board.attackers(piece.color, square)\n        if len(defenders) >= 2:\n            defended_pieces += 1\n    return float(defended_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total number of squares controlled by queens on the board\"\n    controlled_squares = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            for target_square in range(64):\n                if board.attackers(piece.color, target_square) & {square}:\n                    controlled_squares += 1\n    \n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can give check in one move\"\n    white_checks = 0\n    black_checks = 0\n    \n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            if board.turn == chess.BLACK:\n                white_checks += 1\n            else:\n                black_checks += 1\n        board.pop()\n    \n    return white_checks - black_checks\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total Manhattan distance of all pieces from board center\"\n    total_distance = 0.0\n    center_files = [3.5, 3.5]  # Between d and e files\n    center_ranks = [3.5, 3.5]  # Between 4th and 5th ranks\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        distance_to_center = abs(file - center_files[0]) + abs(rank - center_ranks[0])\n        total_distance += distance_to_center\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on light squares vs dark squares for current player\"\n    light_count = 0\n    dark_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_count += 1\n            else:\n                light_count += 1\n    return float(light_count - dark_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces between white and black\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type != chess.KING)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type != chess.KING)\n    return float(white_pieces - black_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average number of escape squares available to major pieces\"\n    escape_count = 0\n    major_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            major_pieces += 1\n            escapes = 0\n            for target_square in chess.SQUARES:\n                if target_square != square:\n                    try:\n                        move = chess.Move(square, target_square)\n                        if move in board.legal_moves:\n                            escapes += 1\n                    except:\n                        continue\n            if piece.color == chess.WHITE:\n                escape_count += escapes\n            else:\n                escape_count -= escapes\n                \n    return float(escape_count / max(1, major_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces that can be captured by opponent\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            continue\n        attackers = board.attackers(board.turn, square)\n        defenders = board.attackers(not board.turn, square)\n        if attackers and not defenders:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King vulnerability measured by number of empty squares in 2-square radius\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    def count_empty_nearby(king_square):\n        if king_square is None:\n            return 0\n        count = 0\n        king_file = chess.square_file(king_square)\n        king_rank = chess.square_rank(king_square)\n        \n        for file_offset in range(-2, 3):\n            for rank_offset in range(-2, 3):\n                if file_offset == 0 and rank_offset == 0:\n                    continue\n                new_file = king_file + file_offset\n                new_rank = king_rank + rank_offset\n                if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                    square = chess.square(new_file, new_rank)\n                    if board.piece_at(square) is None:\n                        count += 1\n        return count\n    \n    white_empty = count_empty_nearby(white_king_square)\n    black_empty = count_empty_nearby(black_king_square)\n    \n    return float(black_empty - white_empty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares versus suboptimal squares\"\n    optimal_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        file, rank = chess.square_file(square), chess.square_rank(square)\n        score = 0.0\n        \n        if piece.piece_type == chess.KNIGHT:\n            if 2 <= file <= 5 and 2 <= rank <= 5:\n                score = 1.0\n        elif piece.piece_type == chess.BISHOP:\n            if abs(file - rank) <= 2 or abs(file + rank - 7) <= 2:\n                score = 0.8\n        elif piece.piece_type == chess.ROOK:\n            if rank == 0 or rank == 7 or file == 3 or file == 4:\n                score = 0.6\n        elif piece.piece_type == chess.QUEEN:\n            if 1 <= file <= 6 and 1 <= rank <= 6:\n                score = 0.7\n        elif piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and rank >= 4:\n                score = 0.5\n            elif piece.color == chess.BLACK and rank <= 3:\n                score = 0.5\n        \n        if piece.color == chess.WHITE:\n            optimal_score += score\n        else:\n            optimal_score -= score\n    \n    return optimal_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on light vs dark squares\"\n    light_pieces = 0\n    dark_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_pieces += 1\n            else:\n                light_pieces += 1\n        else:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_pieces -= 1\n            else:\n                light_pieces -= 1\n    \n    return float(light_pieces - dark_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the 8th rank in one move\"\n    count = 0\n    eighth_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    \n    for move in board.legal_moves:\n        if move.to_square in eighth_rank_squares:\n            count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on squares adjacent to the opponent king\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_captures = 0\n    black_captures = 0\n    \n    # Check squares around each king\n    for king_sq, attacking_color, captures in [(white_king_sq, chess.BLACK, lambda: black_captures), \n                                               (black_king_sq, chess.WHITE, lambda: white_captures)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                if file_offset == 0 and rank_offset == 0:\n                    continue\n                adj_file = king_file + file_offset\n                adj_rank = king_rank + rank_offset\n                if 0 <= adj_file <= 7 and 0 <= adj_rank <= 7:\n                    adj_sq = chess.square(adj_file, adj_rank)\n                    attackers = len(board.attackers(attacking_color, adj_sq))\n                    if attacking_color == chess.BLACK:\n                        black_captures += attackers\n                    else:\n                        white_captures += attackers\n    \n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns for pawn structure evaluation\"\n    file_occupation = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_num = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                file_occupation += file_num\n            else:\n                file_occupation -= file_num\n    return float(file_occupation)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on light squares to pieces on dark squares for material advantage side\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    white_material = sum(1 for piece in piece_map.values() if piece.color == chess.WHITE and piece.piece_type != chess.KING)\n    black_material = sum(1 for piece in piece_map.values() if piece.color == chess.BLACK and piece.piece_type != chess.KING)\n    \n    if white_material == black_material:\n        return 0.0\n    \n    stronger_color = chess.WHITE if white_material > black_material else chess.BLACK\n    \n    light_squares = 0\n    dark_squares = 0\n    \n    for square, piece in piece_map.items():\n        if piece.color == stronger_color and piece.piece_type != chess.KING:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_squares += 1\n            else:\n                light_squares += 1\n    \n    total_pieces = light_squares + dark_squares\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(light_squares) / float(total_pieces) - 0.5\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of minor pieces from their starting positions\"\n    advancement = 0.0\n    count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                if piece.piece_type == chess.KNIGHT:\n                    advancement += max(0, rank - 0)\n                else:\n                    advancement += max(0, rank - 0)\n            else:\n                if piece.piece_type == chess.KNIGHT:\n                    advancement -= max(0, 7 - rank)\n                else:\n                    advancement -= max(0, 7 - rank)\n            count += 1\n    \n    return advancement / max(1, count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    board.turn = current_turn\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from all pieces to their respective starting squares\"\n    starting_positions = {\n        (chess.WHITE, chess.ROOK): [chess.A1, chess.H1],\n        (chess.WHITE, chess.KNIGHT): [chess.B1, chess.G1],\n        (chess.WHITE, chess.BISHOP): [chess.C1, chess.F1],\n        (chess.WHITE, chess.QUEEN): [chess.D1],\n        (chess.WHITE, chess.KING): [chess.E1],\n        (chess.BLACK, chess.ROOK): [chess.A8, chess.H8],\n        (chess.BLACK, chess.KNIGHT): [chess.B8, chess.G8],\n        (chess.BLACK, chess.BISHOP): [chess.C8, chess.F8],\n        (chess.BLACK, chess.QUEEN): [chess.D8],\n        (chess.BLACK, chess.KING): [chess.E8]\n    }\n    \n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.PAWN:\n            key = (piece.color, piece.piece_type)\n            if key in starting_positions:\n                min_dist = min(chess.square_distance(square, start_sq) for start_sq in starting_positions[key])\n                total_distance += min_dist\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by distance from opponent pieces\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_safety = 0.0\n    black_safety = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, white_king_square)\n            white_safety += max(0, 8 - distance)\n        elif piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, black_king_square)\n            black_safety += max(0, 8 - distance)\n    \n    return white_safety - black_safety\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between white pieces and black king\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    white_pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_pieces.append(square)\n    \n    if not white_pieces:\n        return 0.0\n    \n    total_distance = sum(chess.square_distance(square, black_king_square) for square in white_pieces)\n    return float(total_distance) / len(white_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white piece mobility to total pieces on board\"\n    white_mobility = len(list(move for move in board.legal_moves if board.turn == chess.WHITE))\n    if board.turn == chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.WHITE\n        white_mobility = len(list(board_copy.legal_moves))\n    \n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_mobility) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns for pawn structure evaluation\"\n    file_occupation = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_num = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                file_occupation += file_num\n            else:\n                file_occupation -= file_num\n    return float(file_occupation)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of queen mobility weighted by distance from enemy king\"\n    mobility_score = 0.0\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN and piece.color == board.turn:\n            queen_moves = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    queen_moves += 1\n            distance = chess.square_distance(square, enemy_king_square)\n            mobility_score += queen_moves / max(1, distance)\n    \n    return mobility_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece activity measured by average distance from starting squares\"\n    white_distance = 0\n    black_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    starting_squares = {\n        chess.WHITE: {chess.ROOK: [chess.A1, chess.H1], chess.KNIGHT: [chess.B1, chess.G1], \n                     chess.BISHOP: [chess.C1, chess.F1], chess.QUEEN: [chess.D1], chess.KING: [chess.E1]},\n        chess.BLACK: {chess.ROOK: [chess.A8, chess.H8], chess.KNIGHT: [chess.B8, chess.G8],\n                     chess.BISHOP: [chess.C8, chess.F8], chess.QUEEN: [chess.D8], chess.KING: [chess.E8]}\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        if piece.color == chess.WHITE:\n            if piece.piece_type in starting_squares[chess.WHITE]:\n                min_dist = min(chess.square_distance(square, start_sq) \n                             for start_sq in starting_squares[chess.WHITE][piece.piece_type])\n                white_distance += min_dist\n                white_pieces += 1\n        else:\n            if piece.piece_type in starting_squares[chess.BLACK]:\n                min_dist = min(chess.square_distance(square, start_sq)\n                             for start_sq in starting_squares[chess.BLACK][piece.piece_type])\n                black_distance += min_dist\n                black_pieces += 1\n    \n    white_avg = white_distance / max(1, white_pieces)\n    black_avg = black_distance / max(1, black_pieces)\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can escape to edge files (a or h)\"\n    escape_count = 0\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK:\n            to_file = chess.square_file(move.to_square)\n            if to_file == 0 or to_file == 7:\n                escape_count += 1\n                break\n    return float(escape_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can move to the center four squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_attackers = 0\n    black_attackers = 0\n    \n    for square in center_squares:\n        white_attackers += len(board.attackers(chess.WHITE, square))\n        black_attackers += len(board.attackers(chess.BLACK, square))\n    \n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on distance to enemy pieces\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if not white_king_square or not black_king_square:\n        return 0.0\n    \n    white_danger = 0.0\n    black_danger = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            white_dist = chess.square_distance(white_king_square, square)\n            black_dist = chess.square_distance(black_king_square, square)\n            piece_value = [0, 1, 3, 3, 5, 9][piece.piece_type]\n            \n            if piece.color == chess.BLACK:\n                white_danger += piece_value / max(1, white_dist)\n            else:\n                black_danger += piece_value / max(1, black_dist)\n    \n    return black_danger - white_danger\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of squares between black king and all black pieces\"\n    black_king_square = None\n    black_pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            if piece.piece_type == chess.KING:\n                black_king_square = square\n            else:\n                black_pieces.append(square)\n    if black_king_square is None:\n        return 0.0\n    return float(sum(chess.square_distance(black_king_square, piece_square) \n                    for piece_square in black_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defended by pawns weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_score = 0\n    black_score = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        defended_by_pawn = False\n        if piece.color == chess.WHITE:\n            # Check if defended by white pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square - 9)  # SW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square - 7)  # SE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.WHITE:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                white_score += piece_values.get(piece.piece_type, 0)\n        else:\n            # Check if defended by black pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square + 7)  # NW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square + 9)  # NE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.BLACK:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                black_score += piece_values.get(piece.piece_type, 0)\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can legally move\"\n    if board.turn != chess.BLACK:\n        board = board.copy()\n        board.turn = chess.BLACK\n    \n    mobile_pieces = set()\n    for move in board.legal_moves:\n        from_square = move.from_square\n        mobile_pieces.add(from_square)\n    \n    return float(len(mobile_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can give check in one move\"\n    def check_givers(color):\n        count = 0\n        temp_board = board.copy()\n        temp_board.turn = color\n        for move in temp_board.legal_moves:\n            temp_board.push(move)\n            if temp_board.is_check():\n                count += 1\n            temp_board.pop()\n        return count\n    return float(check_givers(chess.WHITE) - check_givers(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can reach promotion squares in 3 moves or less\"\n    count = 0.0\n    promotion_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for promo_sq in promotion_squares:\n                if chess.square_distance(square, promo_sq) <= 3:\n                    count += 1.0\n                    break\n    return count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility difference weighted by piece value\"\n    white_mobility = 0\n    black_mobility = 0\n    piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 1}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1)\n            if piece.color == chess.WHITE:\n                white_mobility += weight\n            else:\n                black_mobility += weight\n    \n    board.push(chess.Move.null())\n    try:\n        for move in board.legal_moves:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = piece_weights.get(piece.piece_type, 1)\n                if piece.color == chess.BLACK:\n                    black_mobility += weight\n                else:\n                    white_mobility += weight\n    except:\n        pass\n    finally:\n        board.pop()\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of squares between black king and all black pieces\"\n    black_king_square = None\n    black_pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            if piece.piece_type == chess.KING:\n                black_king_square = square\n            else:\n                black_pieces.append(square)\n    if black_king_square is None:\n        return 0.0\n    return float(sum(chess.square_distance(black_king_square, piece_square) \n                    for piece_square in black_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking squares adjacent to enemy king\"\n    enemy_color = not board.turn\n    enemy_king_sq = board.king(enemy_color)\n    if enemy_king_sq is None:\n        return 0.0\n    \n    king_file = chess.square_file(enemy_king_sq)\n    king_rank = chess.square_rank(enemy_king_sq)\n    adjacent_squares = []\n    \n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            new_file = king_file + df\n            new_rank = king_rank + dr\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adjacent_squares.append(chess.square(new_file, new_rank))\n    \n    attacking_pieces = 0\n    for square in adjacent_squares:\n        attacking_pieces += len(board.attackers(board.turn, square))\n    \n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking squares adjacent to the enemy king\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    # Find enemy king\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    # Get adjacent squares to enemy king\n    king_file = chess.square_file(enemy_king_square)\n    king_rank = chess.square_rank(enemy_king_square)\n    \n    attack_count = 0\n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file = king_file + file_offset\n            new_rank = king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                target_square = chess.square(new_file, new_rank)\n                if board.is_attacked_by(friendly_color, target_square):\n                    attack_count += 1\n    \n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of squares between black king and all black pieces\"\n    black_king_square = None\n    black_pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            if piece.piece_type == chess.KING:\n                black_king_square = square\n            else:\n                black_pieces.append(square)\n    if black_king_square is None:\n        return 0.0\n    return float(sum(chess.square_distance(black_king_square, piece_square) \n                    for piece_square in black_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces under attack that cannot be defended\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            enemy_color = chess.BLACK\n        else:\n            enemy_color = chess.WHITE\n        \n        if board.is_attacked_by(enemy_color, square):\n            defenders = len(board.attackers(piece.color, square))\n            if defenders == 0:\n                hanging_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted sum of pieces on files with no pawns (open files)\"\n    open_files = []\n    for file_idx in range(8):\n        has_pawn = False\n        for rank_idx in range(8):\n            square = chess.square(file_idx, rank_idx)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                has_pawn = True\n                break\n        if not has_pawn:\n            open_files.append(file_idx)\n    \n    score = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        if chess.square_file(square) in open_files:\n            value = piece_values.get(piece.piece_type, 0)\n            score += value if piece.color == chess.WHITE else -value\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to the opponent's king\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    opponent_color = not board.turn\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == opponent_color:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    adjacent_squares = []\n    \n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            new_file, new_rank = king_file + df, king_rank + dr\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adjacent_squares.append(chess.square(new_file, new_rank))\n    \n    attackers = 0\n    for square in adjacent_squares:\n        if board.is_attacked_by(board.turn, square):\n            attackers += 1\n    \n    return float(attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares the white king can reach in exactly two moves\"\n    if not board.piece_at(chess.A1):\n        return 0.0\n    \n    white_king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING and piece.color == chess.WHITE:\n            white_king_square = square\n            break\n    \n    if white_king_square is None:\n        return 0.0\n    \n    reachable_in_two = set()\n    for first_move in range(64):\n        if chess.square_distance(white_king_square, first_move) == 1:\n            for second_move in range(64):\n                if chess.square_distance(first_move, second_move) == 1:\n                    reachable_in_two.add(second_move)\n    \n    return float(len(reachable_in_two))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of squares between black king and all black pieces\"\n    black_king_square = None\n    black_pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            if piece.piece_type == chess.KING:\n                black_king_square = square\n            else:\n                black_pieces.append(square)\n    if black_king_square is None:\n        return 0.0\n    return float(sum(chess.square_distance(black_king_square, piece_square) \n                    for piece_square in black_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of minor pieces from their starting positions\"\n    advancement = 0.0\n    count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                if piece.piece_type == chess.KNIGHT:\n                    advancement += max(0, rank - 0)\n                else:\n                    advancement += max(0, rank - 0)\n            else:\n                if piece.piece_type == chess.KNIGHT:\n                    advancement -= max(0, 7 - rank)\n                else:\n                    advancement -= max(0, 7 - rank)\n            count += 1\n    \n    return advancement / max(1, count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled exclusively by current player\"\n    exclusive_squares = 0\n    \n    for square in chess.SQUARES:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        if board.turn and white_attackers > 0 and black_attackers == 0:\n            exclusive_squares += 1\n        elif not board.turn and black_attackers > 0 and white_attackers == 0:\n            exclusive_squares += 1\n    \n    return float(exclusive_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns weighted by pawn advancement\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_val = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += file_val * (rank + 1)\n            else:\n                black_score += file_val * (8 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on opponent's half of the board\"\n    white_pieces_advanced = black_pieces_advanced = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 4:\n            white_pieces_advanced += 1\n        elif piece.color == chess.BLACK and rank <= 3:\n            black_pieces_advanced += 1\n    return float(white_pieces_advanced - black_pieces_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can deliver checkmate in one move\"\n    checkmate_threats = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            checkmate_threats += 1\n        board.pop()\n    return float(checkmate_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can be captured in one move\"\n    if not board.turn:\n        return 0.0\n    \n    capturable_pieces = 0\n    for move in board.legal_moves:\n        if board.is_capture(move):\n            capturable_pieces += 1\n    \n    return float(capturable_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on the kingside vs queenside files for material distribution balance\"\n    white_kingside = white_queenside = black_kingside = black_queenside = 0\n    piece_map = board.piece_map()\n    for square, piece in piece_map.items():\n        file = chess.square_file(square)\n        if file >= 4:  # Files e-h\n            if piece.color == chess.WHITE:\n                white_kingside += 1\n            else:\n                black_kingside += 1\n        else:  # Files a-d\n            if piece.color == chess.WHITE:\n                white_queenside += 1\n            else:\n                black_queenside += 1\n    \n    white_ratio = white_kingside / max(white_queenside, 1)\n    black_ratio = black_kingside / max(black_queenside, 1)\n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        total_distance += min_center_dist\n        piece_count += 1\n    \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation based on square control and support\"\n    outpost_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                supported = bool(board.attackers(chess.WHITE, square))\n                enemy_pawns_attack = False\n                for f in [file-1, file+1]:\n                    if 0 <= f <= 7:\n                        for r in range(rank+1, 8):\n                            check_square = chess.square(f, r)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                enemy_pawns_attack = True\n                                break\n                if supported and not enemy_pawns_attack:\n                    outpost_score += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                supported = bool(board.attackers(chess.BLACK, square))\n                enemy_pawns_attack = False\n                for f in [file-1, file+1]:\n                    if 0 <= f <= 7:\n                        for r in range(rank-1, -1, -1):\n                            check_square = chess.square(f, r)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                enemy_pawns_attack = True\n                                break\n                if supported and not enemy_pawns_attack:\n                    outpost_score -= 1\n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can escape to squares not attacked by opponent pawns\"\n    escape_count = 0\n    opponent_color = not board.turn\n    \n    # Get squares attacked by opponent pawns\n    pawn_attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == opponent_color:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            # Pawn attack squares\n            if piece.color == chess.WHITE:\n                if rank < 7:\n                    if file > 0:\n                        pawn_attacked_squares.add(chess.square(file - 1, rank + 1))\n                    if file < 7:\n                        pawn_attacked_squares.add(chess.square(file + 1, rank + 1))\n            else:\n                if rank > 0:\n                    if file > 0:\n                        pawn_attacked_squares.add(chess.square(file - 1, rank - 1))\n                    if file < 7:\n                        pawn_attacked_squares.add(chess.square(file + 1, rank - 1))\n    \n    # Count pieces that can move to safe squares\n    for move in board.legal_moves:\n        if move.to_square not in pawn_attacked_squares:\n            escape_count += 1\n    \n    return float(escape_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n            if piece.color == chess.WHITE:\n                total_distance -= min_center_dist\n            else:\n                total_distance += min_center_dist\n            piece_count += 1\n    \n    return float(total_distance) / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum distance any black piece needs to travel to defend their king\"\n    black_king_sq = board.king(chess.BLACK)\n    if black_king_sq is None:\n        return 0.0\n    \n    max_distance = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and square != black_king_sq:\n            distance = chess.square_distance(square, black_king_sq)\n            max_distance = max(max_distance, float(distance))\n    \n    return max_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on promotion squares or files leading to promotion\"\n    promotion_score = 0.0\n    \n    for file in range(8):\n        white_pawns_on_file = 0\n        black_pawns_on_file = 0\n        \n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns_on_file += 1\n                    if rank >= 5:\n                        promotion_score += (rank - 4) * 0.5\n                else:\n                    black_pawns_on_file += 1\n                    if rank <= 2:\n                        promotion_score -= (3 - rank) * 0.5\n    \n    return promotion_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of minor pieces positioned on optimal squares for their type\"\n    optimal_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            center_distance = abs(3.5 - rank) + abs(3.5 - file)\n            score = max(0, 7 - center_distance) / 7\n            optimal_score += score if piece.color == chess.WHITE else -score\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if (rank + file) % 2 == 0:  # Light squared bishop\n                score = 1 if abs(rank - file) <= 2 else 0.5\n            else:  # Dark squared bishop\n                score = 1 if abs(rank + file - 7) <= 2 else 0.5\n            optimal_score += score if piece.color == chess.WHITE else -score\n    \n    return float(optimal_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between white pieces (cohesion measure)\"\n    white_pieces = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE]\n    if len(white_pieces) <= 1:\n        return 0.0\n    \n    total_distance = 0\n    pairs = 0\n    for i in range(len(white_pieces)):\n        for j in range(i + 1, len(white_pieces)):\n            total_distance += chess.square_distance(white_pieces[i], white_pieces[j])\n            pairs += 1\n    \n    return float(total_distance / pairs) if pairs > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on back two ranks to total pieces\"\n    back_rank_pieces = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        total_pieces += 1\n        rank = chess.square_rank(square)\n        if (piece.color == chess.WHITE and rank <= 1) or (piece.color == chess.BLACK and rank >= 6):\n            back_rank_pieces += 1\n    \n    if total_pieces == 0:\n        return 0.0\n    return float(back_rank_pieces) / float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond the 4th/5th rank (passed pawns and advanced pawns)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that can be captured in one move by white\"\n    captures = 0\n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captures += 1\n    return float(captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility difference weighted by piece value\"\n    white_mobility = 0\n    black_mobility = 0\n    piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 1}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1)\n            if piece.color == chess.WHITE:\n                white_mobility += weight\n            else:\n                black_mobility += weight\n    \n    board.push(chess.Move.null())\n    try:\n        for move in board.legal_moves:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = piece_weights.get(piece.piece_type, 1)\n                if piece.color == chess.BLACK:\n                    black_mobility += weight\n                else:\n                    white_mobility += weight\n    except:\n        pass\n    finally:\n        board.pop()\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking enemy pieces of higher value\"\n    white_attacks_up = 0\n    black_attacks_up = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(not piece.color, square)\n        for attacker_square in attackers:\n            attacker = board.piece_at(attacker_square)\n            if attacker and piece_values[piece.piece_type] > piece_values[attacker.piece_type]:\n                if attacker.color == chess.WHITE:\n                    white_attacks_up += 1\n                else:\n                    black_attacks_up += 1\n    \n    return float(white_attacks_up - black_attacks_up)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece stability measured by number of pieces that cannot be easily displaced\"\n    stable_pieces = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n        \n        attackers = board.attackers(not piece.color, square)\n        defenders = board.attackers(piece.color, square)\n        \n        if len(defenders) > len(attackers):\n            stable_pieces += 1\n        elif len(defenders) == len(attackers) and len(defenders) > 0:\n            stable_pieces += 0.5\n    \n    return float(stable_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of queen moves that attack multiple enemy pieces simultaneously\"\n    count = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.QUEEN:\n            board.push(move)\n            attacks = 0\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            for target_square in chess.SQUARES:\n                target_piece = board.piece_at(target_square)\n                if target_piece and target_piece.color == enemy_color:\n                    if board.is_attacked_by(piece.color, target_square):\n                        attacks += 1\n            board.pop()\n            if attacks >= 2:\n                count += 1 if piece.color == chess.WHITE else -1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that are undefended\"\n    undefended_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            defenders = board.attackers(chess.BLACK, square)\n            if len(defenders) == 0:\n                undefended_count += 1\n    \n    return float(undefended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of inverse distances from white pieces to black king\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    total_inverse_distance = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, black_king_square)\n            if distance > 0:\n                total_inverse_distance += 1.0 / distance\n    \n    return total_inverse_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on optimal color squares for their piece type\"\n    optimal_count = 0\n    total_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            total_pieces += 1\n            is_light_square = (chess.square_file(square) + chess.square_rank(square)) % 2 == 1\n            if piece.piece_type == chess.BISHOP:\n                if (piece.color == chess.WHITE and is_light_square) or (piece.color == chess.BLACK and not is_light_square):\n                    optimal_count += 1\n            elif piece.piece_type in [chess.KNIGHT, chess.KING]:\n                optimal_count += 0.5\n            else:\n                optimal_count += 1\n    return optimal_count / max(total_pieces, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of pawns relative to their starting positions\"\n    pawn_advancement = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                advancement = rank - 1\n            else:\n                advancement = 6 - rank\n            pawn_advancement += max(0, advancement)\n            pawn_count += 1\n    \n    return pawn_advancement / max(pawn_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king on adjacent squares\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    defenders = 0\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    \n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file, new_rank = king_file + file_offset, king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adjacent_square = chess.square(new_file, new_rank)\n                piece = board.piece_at(adjacent_square)\n                if piece and piece.color == board.turn:\n                    defenders += 1\n    \n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = float('inf')\n        for center_sq in center_squares:\n            distance = chess.square_distance(square, center_sq)\n            min_center_distance = min(min_center_distance, distance)\n        \n        # Weight by piece value\n        piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                       chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n        weight = piece_values.get(piece.piece_type, 0)\n        \n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance * weight\n        else:\n            total_distance += min_center_distance * weight\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on squares of their optimal color (light/dark square compatibility)\"\n    optimal_placement = 0\n    for square, piece in board.piece_map().items():\n        square_color = (chess.square_rank(square) + chess.square_file(square)) % 2\n        if piece.piece_type == chess.BISHOP:\n            # Bishops should ideally control both light and dark squares in coordination\n            optimal_placement += 0.5\n        elif piece.piece_type == chess.KNIGHT:\n            # Knights work well on squares opposite to the majority of pawns\n            if square_color == 1:  # Dark squares often better for knights\n                optimal_placement += 1\n        elif piece.piece_type == chess.KING:\n            # King safety often better on squares matching pawn shelter color\n            if square_color == 0:  # Light squares\n                optimal_placement += 1\n    return float(optimal_placement)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on the same rank as each king\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_king_rank = chess.square_rank(white_king_square)\n    black_king_rank = chess.square_rank(black_king_square)\n    \n    white_pieces_on_white_king_rank = 0\n    black_pieces_on_black_king_rank = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if rank == white_king_rank and piece.color == chess.WHITE:\n            white_pieces_on_white_king_rank += 1\n        if rank == black_king_rank and piece.color == chess.BLACK:\n            black_pieces_on_black_king_rank += 1\n    \n    return float(white_pieces_on_white_king_rank - black_pieces_on_black_king_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can deliver check in one move\"\n    count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            count += 1\n        board.pop()\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces pinned to their own king\"\n    count = 0\n    current_color = board.turn\n    \n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == current_color:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == current_color and piece.piece_type != chess.KING:\n            # Temporarily remove piece and see if king is in check\n            original_piece = board.remove_piece_at(square)\n            if board.is_attacked_by(not current_color, king_square):\n                count += 1\n            board.set_piece_at(square, original_piece)\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted control of key central and extended central squares by both sides\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    extended_central = [chess.C3, chess.C4, chess.C5, chess.C6, chess.D3, chess.D6, \n                       chess.E3, chess.E6, chess.F3, chess.F4, chess.F5, chess.F6]\n    \n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_control += white_attackers * 2\n        black_control += black_attackers * 2\n    \n    for square in extended_central:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_control += white_attackers\n        black_control += black_attackers\n    \n    return white_control - black_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure imbalance - doubled, isolated, and backward pawns difference\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    white_pawns = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE]\n    black_pawns = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK]\n    \n    # Check for doubled pawns\n    white_files = [chess.square_file(sq) for sq in white_pawns]\n    black_files = [chess.square_file(sq) for sq in black_pawns]\n    \n    for file in range(8):\n        if white_files.count(file) > 1:\n            white_penalty += (white_files.count(file) - 1) * 0.5\n        if black_files.count(file) > 1:\n            black_penalty += (black_files.count(file) - 1) * 0.5\n    \n    # Check for isolated pawns\n    for sq in white_pawns:\n        file = chess.square_file(sq)\n        if not any(chess.square_file(p) in [file-1, file+1] for p in white_pawns):\n            white_penalty += 0.3\n    \n    for sq in black_pawns:\n        file = chess.square_file(sq)\n        if not any(chess.square_file(p) in [file-1, file+1] for p in black_pawns):\n            black_penalty += 0.3\n    \n    return black_penalty - white_penalty\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to safety when attacked\"\n    retreat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(chess.BLACK, move.to_square):\n                            retreat_count += 1\n                            board.pop()\n                            break\n                        board.pop()\n        else:\n            if board.is_attacked_by(chess.WHITE, square):\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(chess.WHITE, move.to_square):\n                            retreat_count -= 1\n                            board.pop()\n                            break\n                        board.pop()\n    return float(retreat_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King centralization score in endgame scenarios\"\n    piece_map = board.piece_map()\n    total_pieces = len(piece_map)\n    \n    if total_pieces > 10:\n        return 0.0\n    \n    white_king = None\n    black_king = None\n    for sq, piece in piece_map.items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = sq\n            else:\n                black_king = sq\n    \n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_score = 0.0\n    black_score = 0.0\n    \n    if white_king:\n        white_score = min(chess.square_distance(white_king, center) for center in center_squares)\n    if black_king:\n        black_score = min(chess.square_distance(black_king, center) for center in center_squares)\n    \n    return black_score - white_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Relative piece activity measured by mobility difference\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        mobility = 0\n        if piece.piece_type == chess.PAWN:\n            mobility = 0.5\n        elif piece.piece_type == chess.KNIGHT:\n            mobility = len([sq for sq in [square + delta for delta in [-17, -15, -10, -6, 6, 10, 15, 17]] if 0 <= sq <= 63])\n        elif piece.piece_type in [chess.BISHOP, chess.ROOK, chess.QUEEN]:\n            mobility = len(list(board.attacks(square)))\n        \n        if piece.color == chess.WHITE:\n            white_mobility += mobility\n        else:\n            black_mobility += mobility\n    \n    total_mobility = white_mobility + black_mobility\n    if total_mobility == 0:\n        return 0.0\n    return float((white_mobility - black_mobility) / total_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces minus average rank of black pieces\"\n    white_total = 0\n    white_count = 0\n    black_total = 0\n    black_count = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_total += rank\n            white_count += 1\n        else:\n            black_total += rank\n            black_count += 1\n    \n    white_avg = white_total / white_count if white_count > 0 else 0\n    black_avg = black_total / black_count if black_count > 0 else 0\n    \n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    white_moves = 0\n    black_moves = 0\n    if board.turn == chess.WHITE:\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in pawn advancement score between white and black\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += rank\n            else:\n                black_score += (7 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in queen mobility between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.QUEEN:\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance between the two kings multiplied by material imbalance\"\n    white_king_square = None\n    black_king_square = None\n    material_diff = 0\n    \n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n        else:\n            value = piece_values[piece.piece_type]\n            material_diff += value if piece.color == chess.WHITE else -value\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    king_distance = chess.square_distance(white_king_square, black_king_square)\n    return float(king_distance * material_diff)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on squares of their optimal color (light/dark square compatibility)\"\n    optimal_placement = 0\n    for square, piece in board.piece_map().items():\n        square_color = (chess.square_rank(square) + chess.square_file(square)) % 2\n        if piece.piece_type == chess.BISHOP:\n            # Bishops should ideally control both light and dark squares in coordination\n            optimal_placement += 0.5\n        elif piece.piece_type == chess.KNIGHT:\n            # Knights work well on squares opposite to the majority of pawns\n            if square_color == 1:  # Dark squares often better for knights\n                optimal_placement += 1\n        elif piece.piece_type == chess.KING:\n            # King safety often better on squares matching pawn shelter color\n            if square_color == 0:  # Light squares\n                optimal_placement += 1\n    return float(optimal_placement)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can escape to squares not attacked by opponent pawns\"\n    escape_count = 0\n    opponent_color = not board.turn\n    \n    # Get squares attacked by opponent pawns\n    pawn_attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == opponent_color:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            # Pawn attack squares\n            if piece.color == chess.WHITE:\n                if rank < 7:\n                    if file > 0:\n                        pawn_attacked_squares.add(chess.square(file - 1, rank + 1))\n                    if file < 7:\n                        pawn_attacked_squares.add(chess.square(file + 1, rank + 1))\n            else:\n                if rank > 0:\n                    if file > 0:\n                        pawn_attacked_squares.add(chess.square(file - 1, rank - 1))\n                    if file < 7:\n                        pawn_attacked_squares.add(chess.square(file + 1, rank - 1))\n    \n    # Count pieces that can move to safe squares\n    for move in board.legal_moves:\n        if move.to_square not in pawn_attacked_squares:\n            escape_count += 1\n    \n    return float(escape_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the 7th or 8th rank in one move\"\n    count = 0\n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        piece = board.piece_at(move.from_square)\n        if piece and piece.color == chess.WHITE and to_rank >= 6:\n            count += 1\n        elif piece and piece.color == chess.BLACK and to_rank <= 1:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in queen activity between white and black measured by attacked squares\"\n    white_queen_activity = 0\n    black_queen_activity = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            attacks = len(list(board.attacks(square)))\n            if piece.color == chess.WHITE:\n                white_queen_activity += attacks\n            else:\n                black_queen_activity += attacks\n    \n    return float(white_queen_activity - black_queen_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to opponent's side of board in one move\"\n    crossing_pieces = 0\n    \n    for move in board.legal_moves:\n        to_square = move.to_square\n        to_rank = chess.square_rank(to_square)\n        \n        if board.turn == chess.WHITE and to_rank >= 4:\n            crossing_pieces += 1\n        elif board.turn == chess.BLACK and to_rank <= 3:\n            crossing_pieces += 1\n    \n    return float(crossing_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the opponent's back two ranks in one move\"\n    pieces_threatening_back_ranks = 0\n    enemy_color = not board.turn\n    \n    if board.turn == chess.WHITE:\n        target_ranks = [6, 7]  # 7th and 8th ranks\n    else:\n        target_ranks = [0, 1]  # 1st and 2nd ranks\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in range(64):\n                if chess.square_rank(target_square) in target_ranks:\n                    if board.attackers(board.turn, target_square) & {square}:\n                        pieces_threatening_back_ranks += 1\n                        break\n    \n    return float(pieces_threatening_back_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking squares adjacent to the enemy king\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    # Find enemy king\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    # Get adjacent squares to enemy king\n    king_file = chess.square_file(enemy_king_square)\n    king_rank = chess.square_rank(enemy_king_square)\n    \n    attack_count = 0\n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file = king_file + file_offset\n            new_rank = king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                target_square = chess.square(new_file, new_rank)\n                if board.is_attacked_by(friendly_color, target_square):\n                    attack_count += 1\n    \n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and penalty for blocked bishops\"\n    white_bishops = 0\n    black_bishops = 0\n    white_blocked = 0\n    black_blocked = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    white_blocked += 1\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    black_blocked += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 0.5\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 0.5\n    \n    return bishop_pair_bonus + (black_blocked - white_blocked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king safety measured by escape squares available\"\n    def king_escape_squares(color):\n        king_square = board.king(color)\n        if king_square is None:\n            return 0\n        escape_count = 0\n        king_rank = chess.square_rank(king_square)\n        king_file = chess.square_file(king_square)\n        \n        for dr in [-1, 0, 1]:\n            for df in [-1, 0, 1]:\n                if dr == 0 and df == 0:\n                    continue\n                new_rank = king_rank + dr\n                new_file = king_file + df\n                if 0 <= new_rank <= 7 and 0 <= new_file <= 7:\n                    new_square = chess.square(new_file, new_rank)\n                    if not board.is_attacked_by(not color, new_square):\n                        escape_count += 1\n        return escape_count\n    \n    white_escape = king_escape_squares(chess.WHITE)\n    black_escape = king_escape_squares(chess.BLACK)\n    return float(white_escape - black_escape)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can attack multiple enemy pieces simultaneously\"\n    multi_attackers = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            continue\n        \n        attacked_enemies = 0\n        for target_square, target_piece in board.piece_map().items():\n            if target_piece.color != piece.color and board.is_attacked_by(piece.color, target_square):\n                attacked_enemies += 1\n        \n        if attacked_enemies > 1:\n            multi_attackers += 1\n    \n    return float(multi_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn breaks available to current player\"\n    breaks = 0\n    my_color = board.turn\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.PAWN:\n            target_piece = board.piece_at(move.to_square)\n            if target_piece and target_piece.color != my_color:\n                breaks += 1\n            else:\n                # Check if advancing to attack squares\n                to_file = chess.square_file(move.to_square)\n                to_rank = chess.square_rank(move.to_square)\n                for file_offset in [-1, 1]:\n                    if 0 <= to_file + file_offset <= 7:\n                        diag_square = chess.square(to_file + file_offset, to_rank)\n                        diag_piece = board.piece_at(diag_square)\n                        if diag_piece and diag_piece.color != my_color and diag_piece.piece_type == chess.PAWN:\n                            breaks += 1\n    \n    return float(breaks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between same-colored pieces\"\n    white_squares = []\n    black_squares = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_squares.append(square)\n        else:\n            black_squares.append(square)\n    \n    white_avg_dist = 0.0\n    black_avg_dist = 0.0\n    \n    if len(white_squares) > 1:\n        total_dist = 0\n        pairs = 0\n        for i in range(len(white_squares)):\n            for j in range(i + 1, len(white_squares)):\n                total_dist += chess.square_distance(white_squares[i], white_squares[j])\n                pairs += 1\n        white_avg_dist = total_dist / pairs if pairs > 0 else 0\n    \n    if len(black_squares) > 1:\n        total_dist = 0\n        pairs = 0\n        for i in range(len(black_squares)):\n            for j in range(i + 1, len(black_squares)):\n                total_dist += chess.square_distance(black_squares[i], black_squares[j])\n                pairs += 1\n        black_avg_dist = total_dist / pairs if pairs > 0 else 0\n    \n    return black_avg_dist - white_avg_dist\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn majority strength on each flank weighted by advancement\"\n    queenside_files = [0, 1, 2, 3]  # a-d files\n    kingside_files = [4, 5, 6, 7]   # e-h files\n    \n    def count_pawn_majority(files):\n        white_pawns = 0\n        black_pawns = 0\n        white_advancement = 0\n        black_advancement = 0\n        \n        for file in files:\n            for rank in range(8):\n                square = chess.square(file, rank)\n                piece = board.piece_at(square)\n                if piece and piece.piece_type == chess.PAWN:\n                    if piece.color == chess.WHITE:\n                        white_pawns += 1\n                        white_advancement += rank\n                    else:\n                        black_pawns += 1\n                        black_advancement += (7 - rank)\n        \n        majority_diff = white_pawns - black_pawns\n        if majority_diff > 0:\n            return majority_diff + white_advancement * 0.1\n        elif majority_diff < 0:\n            return majority_diff - black_advancement * 0.1\n        return 0.0\n    \n    queenside_score = count_pawn_majority(queenside_files)\n    kingside_score = count_pawn_majority(kingside_files)\n    \n    return queenside_score + kingside_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of pawns relative to their starting positions\"\n    pawn_advancement = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                advancement = rank - 1\n            else:\n                advancement = 6 - rank\n            pawn_advancement += max(0, advancement)\n            pawn_count += 1\n    \n    return pawn_advancement / max(pawn_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to safety when attacked\"\n    count = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                # Check if piece can move to a safe square\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(chess.BLACK, move.to_square):\n                            count += 1\n                            board.pop()\n                            break\n                        board.pop()\n        else:\n            if board.is_attacked_by(chess.WHITE, square):\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(chess.WHITE, move.to_square):\n                            count += 1\n                            board.pop()\n                            break\n                        board.pop()\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility between current player and opponent\"\n    current_mobility = len(list(board.legal_moves))\n    \n    board.push(chess.Move.null())\n    opponent_mobility = len(list(board.legal_moves)) if not board.is_check() else 0\n    board.pop()\n    \n    return float(current_mobility - opponent_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total number of pieces remaining on the board\"\n    return float(len(board.piece_map()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces to their respective kings\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        king_square = white_king if piece.color == chess.WHITE else black_king\n        distance = chess.square_distance(square, king_square)\n        total_distance += distance\n        piece_count += 1\n    \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        total_distance += min_center_dist\n        piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual defense between pieces\"\n    white_coordination = 0\n    black_coordination = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            defenders = len(board.attackers(piece.color, square))\n            if piece.color == chess.WHITE:\n                white_coordination += defenders\n            else:\n                black_coordination += defenders\n    \n    return white_coordination - black_coordination\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Minimum number of moves for black king to reach any corner\"\n    black_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king = square\n            break\n    if black_king is None:\n        return 8.0\n    corners = [chess.A1, chess.A8, chess.H1, chess.H8]\n    min_distance = min(chess.square_distance(black_king, corner) for corner in corners)\n    return float(min_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of doubled pawns for both sides with penalty weighting\"\n    doubled_pawns = 0\n    white_pawns_by_file = [0] * 8\n    black_pawns_by_file = [0] * 8\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_idx = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_pawns_by_file[file_idx] += 1\n            else:\n                black_pawns_by_file[file_idx] += 1\n    \n    for count in white_pawns_by_file:\n        if count > 1:\n            doubled_pawns -= (count - 1)\n    \n    for count in black_pawns_by_file:\n        if count > 1:\n            doubled_pawns += (count - 1)\n    \n    return float(doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of all pawns weighted by file centrality\"\n    total_weighted_rank = 0.0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            # Central files get higher weight\n            file_weight = 1.0 + (3.5 - abs(file - 3.5)) * 0.2\n            \n            if piece.color == chess.WHITE:\n                weighted_rank = rank * file_weight\n            else:\n                weighted_rank = (7 - rank) * file_weight\n            \n            total_weighted_rank += weighted_rank\n            pawn_count += 1\n    \n    return total_weighted_rank / max(pawn_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond their 4th rank\"\n    advanced_pawns = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns -= 1\n    \n    return advanced_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted sum of pieces by their distance from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    white_centralization = 0\n    black_centralization = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n            \n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        centralization_score = piece_values[piece.piece_type] * (8 - min_distance)\n        \n        if piece.color == chess.WHITE:\n            white_centralization += centralization_score\n        else:\n            black_centralization += centralization_score\n    \n    return (white_centralization - black_centralization) / 100.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the current player's king\"\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    king_square = board.king(current_color)\n    if king_square is None:\n        return 0.0\n    \n    defenders = board.attackers(current_color, king_square)\n    return float(len(defenders))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces that have zero legal moves available\"\n    if board.turn != chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.BLACK\n    else:\n        board_copy = board\n    \n    immobilized_pieces = 0\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            black_pieces.append(square)\n    \n    for piece_square in black_pieces:\n        has_legal_move = False\n        for move in board_copy.legal_moves:\n            if move.from_square == piece_square:\n                has_legal_move = True\n                break\n        if not has_legal_move:\n            immobilized_pieces += 1\n    \n    return float(immobilized_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn breaks available to current player\"\n    breaks = 0\n    my_color = board.turn\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.PAWN:\n            target_piece = board.piece_at(move.to_square)\n            if target_piece and target_piece.color != my_color:\n                breaks += 1\n            else:\n                # Check if advancing to attack squares\n                to_file = chess.square_file(move.to_square)\n                to_rank = chess.square_rank(move.to_square)\n                for file_offset in [-1, 1]:\n                    if 0 <= to_file + file_offset <= 7:\n                        diag_square = chess.square(to_file + file_offset, to_rank)\n                        diag_piece = board.piece_at(diag_square)\n                        if diag_piece and diag_piece.color != my_color and diag_piece.piece_type == chess.PAWN:\n                            breaks += 1\n    \n    return float(breaks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of own pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0\n    weighted_rank_sum = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if piece.color == chess.BLACK:\n                rank = 7 - rank\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return float(weighted_rank_sum / total_value) if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of current player's pieces (normalized 0-1)\"\n    total_rank = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            rank = chess.square_rank(square)\n            if board.turn == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            total_rank += rank\n            piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return float(total_rank) / (piece_count * 7.0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of pieces within 2 squares of king\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    white_defenders = 0\n    black_defenders = 0\n    \n    if white_king_square is not None:\n        for square in chess.SQUARES:\n            if chess.square_distance(square, white_king_square) <= 2:\n                piece = board.piece_at(square)\n                if piece and piece.color == chess.WHITE and piece.piece_type != chess.KING:\n                    white_defenders += 1\n    \n    if black_king_square is not None:\n        for square in chess.SQUARES:\n            if chess.square_distance(square, black_king_square) <= 2:\n                piece = board.piece_at(square)\n                if piece and piece.color == chess.BLACK and piece.piece_type != chess.KING:\n                    black_defenders += 1\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to the opponent's king\"\n    opp_color = not board.turn\n    opp_king = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == opp_color:\n            opp_king = square\n            break\n    \n    if opp_king is None:\n        return 0.0\n    \n    king_adjacent = []\n    king_file, king_rank = chess.square_file(opp_king), chess.square_rank(opp_king)\n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            f, r = king_file + df, king_rank + dr\n            if 0 <= f <= 7 and 0 <= r <= 7:\n                king_adjacent.append(chess.square(f, r))\n    \n    attacking_pieces = 0\n    for move in board.legal_moves:\n        if move.to_square in king_adjacent:\n            attacking_pieces += 1\n    \n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the 4th rank for white or 5th rank for black\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on the opponent's half of the board\"\n    white_on_black_half = 0\n    black_on_white_half = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 4:\n            white_on_black_half += 1\n        elif piece.color == chess.BLACK and rank <= 3:\n            black_on_white_half += 1\n    \n    return float(white_on_black_half - black_on_white_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from all pieces to their nearest enemy piece\"\n    white_squares = []\n    black_squares = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            if piece.color == chess.WHITE:\n                white_squares.append(square)\n            else:\n                black_squares.append(square)\n    \n    total_distance = 0\n    for w_sq in white_squares:\n        min_dist = 14\n        for b_sq in black_squares:\n            dist = chess.square_distance(w_sq, b_sq)\n            min_dist = min(min_dist, dist)\n        total_distance += min_dist\n    \n    for b_sq in black_squares:\n        min_dist = 14\n        for w_sq in white_squares:\n            dist = chess.square_distance(b_sq, w_sq)\n            min_dist = min(min_dist, dist)\n        total_distance += min_dist\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of rooks on open or semi-open files\"\n    open_file_rooks = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.ROOK and piece.color == board.turn:\n            file = chess.square_file(square)\n            has_own_pawn = False\n            has_enemy_pawn = False\n            \n            for rank in range(8):\n                file_square = chess.square(file, rank)\n                file_piece = piece_map.get(file_square)\n                if file_piece and file_piece.piece_type == chess.PAWN:\n                    if file_piece.color == board.turn:\n                        has_own_pawn = True\n                    else:\n                        has_enemy_pawn = True\n            \n            if not has_own_pawn:  # Open or semi-open file\n                open_file_rooks += 1\n    \n    return float(open_file_rooks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of moves any white piece can make\"\n    max_moves = 0\n    if board.turn == chess.WHITE:\n        piece_moves = {}\n        for move in board.legal_moves:\n            from_square = move.from_square\n            if from_square not in piece_moves:\n                piece_moves[from_square] = 0\n            piece_moves[from_square] += 1\n        if piece_moves:\n            max_moves = max(piece_moves.values())\n    return float(max_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn breakthrough potential measured by clear paths to promotion\"\n    score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            promotion_rank = 7\n            direction = 1\n        else:\n            promotion_rank = 0\n            direction = -1\n        clear_path = True\n        for check_rank in range(rank + direction, promotion_rank + direction, direction):\n            check_square = chess.square(file, check_rank)\n            if board.piece_at(check_square) is not None:\n                clear_path = False\n                break\n        if clear_path:\n            advancement = abs(rank - (0 if piece.color == chess.WHITE else 7))\n            multiplier = 1.0 if piece.color == chess.WHITE else -1.0\n            score += multiplier * (advancement * advancement)\n    return score\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares (knights on center, bishops on long diagonals)\"\n    optimal_count = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT and square in center_squares:\n            optimal_count += 1\n        elif piece.piece_type == chess.BISHOP:\n            file_rank = chess.square_file(square) + chess.square_rank(square)\n            if file_rank == 7 or abs(chess.square_file(square) - chess.square_rank(square)) == 0:\n                optimal_count += 1\n    return float(optimal_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white rooks on open or semi-open files\"\n    white_rooks = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK and piece.color == chess.WHITE:\n            white_rooks.append(square)\n    \n    if not white_rooks:\n        return 0.0\n    \n    open_semi_open_rooks = 0\n    for rook_square in white_rooks:\n        rook_file = chess.square_file(rook_square)\n        white_pawns_on_file = 0\n        black_pawns_on_file = 0\n        \n        for rank in range(8):\n            square = chess.square(rook_file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns_on_file += 1\n                else:\n                    black_pawns_on_file += 1\n        \n        if white_pawns_on_file == 0:\n            open_semi_open_rooks += 1\n    \n    return float(open_semi_open_rooks) / len(white_rooks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces weighted by their material value\"\n    undefended_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        defenders = len(board.attackers(piece.color, square))\n        attackers = len(board.attackers(not piece.color, square))\n        \n        if defenders == 0 and attackers > 0:\n            value = piece_values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                undefended_value -= value\n            else:\n                undefended_value += value\n    \n    return undefended_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces remaining on the board indicating endgame stage\"\n    return float(len(board.piece_map()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of file distances of all pawns from center files\"\n    total_distance = 0\n    center_files = [3, 4]  # d and e files\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            min_dist = min(abs(file - cf) for cf in center_files)\n            total_distance += min_dist\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn chains (connected pawns) for both sides with length weighting\"\n    def count_pawn_chains(color):\n        pawns = []\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                pawns.append(square)\n        \n        chains = 0\n        visited = set()\n        for pawn in pawns:\n            if pawn in visited:\n                continue\n            chain_length = 1\n            visited.add(pawn)\n            file = chess.square_file(pawn)\n            rank = chess.square_rank(pawn)\n            # Check diagonal connections\n            for df in [-1, 1]:\n                for dr in [-1, 1]:\n                    new_file, new_rank = file + df, rank + dr\n                    if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                        new_square = chess.square(new_file, new_rank)\n                        if new_square in pawns and new_square not in visited:\n                            chain_length += 1\n                            visited.add(new_square)\n            if chain_length > 1:\n                chains += chain_length\n        return chains\n    \n    white_chains = count_pawn_chains(chess.WHITE)\n    black_chains = count_pawn_chains(chess.BLACK)\n    return float(white_chains - black_chains)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average number of squares each piece can move to weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_mobility = 0.0\n    total_value = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            value = piece_values.get(piece.piece_type, 0)\n            total_mobility += mobility * value\n            total_value += value\n    \n    return total_mobility / max(1, total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average piece value density in 3x3 zones around each piece\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_density = 0.0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n            \n        zone_value = 0\n        rank, file = chess.square_rank(square), chess.square_file(square)\n        \n        for r in range(max(0, rank-1), min(8, rank+2)):\n            for f in range(max(0, file-1), min(8, file+2)):\n                zone_square = chess.square(f, r)\n                zone_piece = board.piece_at(zone_square)\n                if zone_piece:\n                    zone_value += piece_values.get(zone_piece.piece_type, 0)\n        \n        total_density += zone_value\n        piece_count += 1\n    \n    return total_density / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of piece mobility in endgame vs opening for current position\"\n    total_pieces = len(board.piece_map())\n    if total_pieces > 16:\n        return 1.0  # Not an endgame\n    \n    mobility_score = 0\n    for square, piece in board.piece_map().items():\n        piece_mobility = 0\n        for move in board.legal_moves:\n            if move.from_square == square:\n                piece_mobility += 1\n        \n        # Weight by piece value and endgame activity\n        piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                      chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 4}.get(piece.piece_type, 0)\n        mobility_score += piece_mobility * piece_value * (1 if piece.color == chess.WHITE else -1)\n    \n    # Scale by remaining material to get endgame mobility ratio\n    return mobility_score / max(total_pieces, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces developed from starting squares\"\n    developed = 0\n    starting_squares = {\n        chess.B1: chess.KNIGHT, chess.G1: chess.KNIGHT, chess.C1: chess.BISHOP, \n        chess.F1: chess.BISHOP, chess.D1: chess.QUEEN, chess.E1: chess.KING,\n        chess.B8: chess.KNIGHT, chess.G8: chess.KNIGHT, chess.C8: chess.BISHOP, \n        chess.F8: chess.BISHOP, chess.D8: chess.QUEEN, chess.E8: chess.KING\n    }\n    \n    for square, piece_type in starting_squares.items():\n        piece = board.piece_at(square)\n        if not piece or piece.piece_type != piece_type:\n            developed += 1\n    \n    return float(developed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on the next move weighted by target value\"\n    capture_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            if captured_piece:\n                value = piece_values.get(captured_piece.piece_type, 0)\n                if board.turn == chess.WHITE:\n                    capture_value += value\n                else:\n                    capture_value -= value\n    \n    return capture_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0\n    weighted_rank_sum = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    if total_value == 0:\n        return 0.0\n    return weighted_rank_sum / total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of empty squares between the two kings\"\n    white_king = None\n    black_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    if white_king is None or black_king is None:\n        return 0.0\n    \n    white_file, white_rank = chess.square_file(white_king), chess.square_rank(white_king)\n    black_file, black_rank = chess.square_file(black_king), chess.square_rank(black_king)\n    \n    min_file, max_file = min(white_file, black_file), max(white_file, black_file)\n    min_rank, max_rank = min(white_rank, black_rank), max(white_rank, black_rank)\n    \n    empty_count = 0.0\n    for file in range(min_file, max_file + 1):\n        for rank in range(min_rank, max_rank + 1):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is None and square != white_king and square != black_king:\n                empty_count += 1.0\n    \n    return empty_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum distance any black piece can move in one legal move\"\n    if board.turn != chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.BLACK\n    else:\n        board_copy = board\n    \n    max_distance = 0.0\n    for move in board_copy.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.color == chess.BLACK:\n            distance = chess.square_distance(move.from_square, move.to_square)\n            max_distance = max(max_distance, distance)\n    \n    return float(max_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares versus suboptimal squares\"\n    optimal_count = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n            \n        total_pieces += 1\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Define optimal conditions for each piece type\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and 1 <= rank <= 5:\n                optimal_count += 1\n            elif piece.color == chess.BLACK and 2 <= rank <= 6:\n                optimal_count += 1\n        elif piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if 2 <= file <= 5 and 2 <= rank <= 5:  # Central squares\n                optimal_count += 1\n        elif piece.piece_type == chess.ROOK:\n            if rank == 0 or rank == 7 or file == 0 or file == 7:  # Edges or back rank\n                optimal_count += 1\n        elif piece.piece_type == chess.QUEEN:\n            if 1 <= file <= 6 and 1 <= rank <= 6:  # Avoid edges\n                optimal_count += 1\n    \n    if total_pieces == 0:\n        return 0.0\n    return float(optimal_count) / float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in pawn island count between white and black\"\n    def count_pawn_islands(color):\n        islands = 0\n        files_with_pawns = set()\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                files_with_pawns.add(chess.square_file(square))\n        \n        if not files_with_pawns:\n            return 0\n            \n        sorted_files = sorted(files_with_pawns)\n        islands = 1\n        for i in range(1, len(sorted_files)):\n            if sorted_files[i] - sorted_files[i-1] > 1:\n                islands += 1\n        return islands\n    \n    white_islands = count_pawn_islands(chess.WHITE)\n    black_islands = count_pawn_islands(chess.BLACK)\n    return float(white_islands - black_islands) if board.turn else float(black_islands - white_islands)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending own back rank squares\"\n    def count_back_rank_defenders(color):\n        rank = 0 if color == chess.WHITE else 7\n        defenders = 0\n        for file in range(8):\n            square = rank * 8 + file\n            defenders += len(board.attackers(color, square))\n        return defenders\n    \n    white_defenders = count_back_rank_defenders(chess.WHITE)\n    black_defenders = count_back_rank_defenders(chess.BLACK)\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares (knights on outposts, bishops on long diagonals)\"\n    optimal_count = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.KNIGHT:\n            # Knights are optimal on central squares and outposts\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            if 2 <= file <= 5 and 2 <= rank <= 5:  # Central squares\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops are optimal on long diagonals\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            if file == rank or file + rank == 7:  # Main diagonals\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n    \n    return float(optimal_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares based on piece type\"\n    optimal_count = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type == chess.BISHOP:\n            if rank != 0 and rank != 7 and file != 0 and file != 7:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type == chess.ROOK:\n            if rank == 1 or rank == 6 or file == 3 or file == 4:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n    \n    return float(optimal_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces under attack that cannot be defended\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            enemy_color = chess.BLACK\n        else:\n            enemy_color = chess.WHITE\n        \n        if board.is_attacked_by(enemy_color, square):\n            defenders = len(board.attackers(piece.color, square))\n            if defenders == 0:\n                hanging_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that can move to the center four squares\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                value = piece_values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total_value += value\n                else:\n                    total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pinned pieces weighted by their value\"\n    pinned_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_pinned(chess.WHITE, square):\n                pinned_value -= piece_values.get(piece.piece_type, 0)\n        else:\n            if board.is_pinned(chess.BLACK, square):\n                pinned_value += piece_values.get(piece.piece_type, 0)\n    \n    return pinned_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares the white king can move to safely\"\n    white_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.WHITE:\n            white_king = square\n            break\n    if white_king is None:\n        return 0.0\n    safe_moves = 0\n    king_moves = [(1,0), (1,1), (1,-1), (-1,0), (-1,1), (-1,-1), (0,1), (0,-1)]\n    king_file = chess.square_file(white_king)\n    king_rank = chess.square_rank(white_king)\n    for df, dr in king_moves:\n        new_file = king_file + df\n        new_rank = king_rank + dr\n        if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n            target_square = chess.square(new_file, new_rank)\n            target_piece = board.piece_at(target_square)\n            if target_piece is None or target_piece.color == chess.BLACK:\n                if not board.is_attacked_by(chess.BLACK, target_square):\n                    safe_moves += 1\n    return float(safe_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of minor pieces positioned on optimal squares for their type\"\n    optimal_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            center_distance = abs(3.5 - rank) + abs(3.5 - file)\n            score = max(0, 7 - center_distance) / 7\n            optimal_score += score if piece.color == chess.WHITE else -score\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if (rank + file) % 2 == 0:  # Light squared bishop\n                score = 1 if abs(rank - file) <= 2 else 0.5\n            else:  # Dark squared bishop\n                score = 1 if abs(rank + file - 7) <= 2 else 0.5\n            optimal_score += score if piece.color == chess.WHITE else -score\n    \n    return float(optimal_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen activity score based on number of squares it can reach\"\n    white_queen_activity = 0\n    black_queen_activity = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            attackers = len(board.attackers(piece.color, square))\n            moves_from_square = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    moves_from_square += 1\n            \n            activity = moves_from_square\n            if piece.color == chess.WHITE:\n                white_queen_activity += activity\n            else:\n                black_queen_activity += activity\n    \n    return float(white_queen_activity - black_queen_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of all pieces from the center files (d,e)\"\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        file_num = chess.square_file(square)\n        center_distance = min(abs(file_num - 3), abs(file_num - 4))\n        total_distance += center_distance\n        piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king safety measured by number of pieces within 2 squares of each king\"\n    white_king_square = None\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_defenders = 0\n    black_defenders = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            if chess.square_distance(square, white_king_square) <= 2:\n                if piece.color == chess.WHITE:\n                    white_defenders += 1\n            if chess.square_distance(square, black_king_square) <= 2:\n                if piece.color == chess.BLACK:\n                    black_defenders += 1\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of minimum moves needed for all pawns to promote weighted by advancement\"\n    total_weighted_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                moves_to_promote = 7 - rank\n                advancement_weight = rank / 7.0\n            else:\n                moves_to_promote = rank\n                advancement_weight = (7 - rank) / 7.0\n            \n            weighted_distance = moves_to_promote * (1.0 + advancement_weight)\n            if piece.color == chess.WHITE:\n                total_weighted_distance += weighted_distance\n            else:\n                total_weighted_distance -= weighted_distance\n    \n    return total_weighted_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can attack multiple black pieces simultaneously\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attacked_black_pieces = 0\n            for target_square in chess.SQUARES:\n                target_piece = board.piece_at(target_square)\n                if target_piece and target_piece.color == chess.BLACK:\n                    if board.is_attacked_by(chess.WHITE, target_square):\n                        attacked_squares = board.attackers(chess.WHITE, target_square)\n                        if square in attacked_squares:\n                            attacked_black_pieces += 1\n            if attacked_black_pieces >= 2:\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum distance any black piece can move in one legal move\"\n    if board.turn != chess.BLACK:\n        board_copy = board.copy()\n        board_copy.turn = chess.BLACK\n    else:\n        board_copy = board\n    \n    max_distance = 0.0\n    for move in board_copy.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.color == chess.BLACK:\n            distance = chess.square_distance(move.from_square, move.to_square)\n            max_distance = max(max_distance, distance)\n    \n    return float(max_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king on adjacent squares\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    defenders = 0\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    \n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file, new_rank = king_file + file_offset, king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adjacent_square = chess.square(new_file, new_rank)\n                piece = board.piece_at(adjacent_square)\n                if piece and piece.color == board.turn:\n                    defenders += 1\n    \n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces weighted by their material value\"\n    undefended_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        defenders = len(board.attackers(piece.color, square))\n        attackers = len(board.attackers(not piece.color, square))\n        \n        if defenders == 0 and attackers > 0:\n            value = piece_values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                undefended_value -= value\n            else:\n                undefended_value += value\n    \n    return undefended_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that can be captured with tempo next move\"\n    tempo_captures = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            if captured_piece:\n                board.push(move)\n                if board.is_check():\n                    tempo_captures += piece_values.get(captured_piece.piece_type, 0)\n                board.pop()\n    \n    return tempo_captures\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their optimal squares (knights on outposts, bishops on long diagonals)\"\n    white_optimal = 0\n    black_optimal = 0\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights on central squares or outposts\n            if piece.color == chess.WHITE:\n                if rank >= 4 and 2 <= file <= 5:\n                    white_optimal += 1\n            else:\n                if rank <= 3 and 2 <= file <= 5:\n                    black_optimal += 1\n        \n        elif piece.piece_type == chess.BISHOP:\n            # Bishops on long diagonals\n            if (file == rank) or (file + rank == 7):\n                if piece.color == chess.WHITE:\n                    white_optimal += 1\n                else:\n                    black_optimal += 1\n    \n    return float(white_optimal - black_optimal)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of controlled central squares to total central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlled = 0\n    my_color = board.turn\n    \n    for square in central_squares:\n        if board.is_attacked_by(my_color, square):\n            controlled += 1\n    \n    return float(controlled) / 4.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on light squares to pieces on dark squares\"\n    light_pieces = 0\n    dark_pieces = 0\n    for square, piece in board.piece_map().items():\n        if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n            dark_pieces += 1\n        else:\n            light_pieces += 1\n    total = light_pieces + dark_pieces\n    return float(light_pieces / total) if total > 0 else 0.5\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces that can be captured next move\"\n    capturable = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            capturable += 1\n    \n    return float(capturable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns on their original files vs displaced pawns\"\n    original_files = 0\n    total_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            total_pawns += 1\n            file_idx = chess.square_file(square)\n            rank_idx = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank_idx > 1:\n                original_files += 1\n            elif piece.color == chess.BLACK and rank_idx < 6:\n                original_files += 1\n    return original_files - (total_pawns - original_files) if total_pawns > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of current player's pieces weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_rank = 0.0\n    total_weight = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if not board.turn:\n                rank = 7 - rank\n            weight = piece_values[piece.piece_type]\n            total_weighted_rank += rank * weight\n            total_weight += weight\n    \n    if total_weight == 0:\n        return 0.0\n    return total_weighted_rank / total_weight\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of pieces that can be captured in one move by either side\"\n    max_captures = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            if captured_piece:\n                piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                               chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n                value = piece_values.get(captured_piece.piece_type, 0)\n                max_captures = max(max_captures, value)\n    \n    return float(max_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces remaining on the board indicating endgame stage\"\n    return float(len(board.piece_map()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in one move\"\n    check_count = 0\n    current_color = board.turn\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance between the two kings measured in squares\"\n    white_king = None\n    black_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    if white_king is None or black_king is None:\n        return 0.0\n    return float(chess.square_distance(white_king, black_king))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the 8th/1st rank in one move\"\n    white_promotion_threats = 0\n    black_promotion_threats = 0\n    \n    for move in board.legal_moves:\n        from_square = move.from_square\n        to_square = move.to_square\n        piece = board.piece_at(from_square)\n        \n        if piece and piece.color == chess.WHITE:\n            if chess.square_rank(to_square) == 7:  # 8th rank\n                white_promotion_threats += 1\n        elif piece and piece.color == chess.BLACK:\n            if chess.square_rank(to_square) == 0:  # 1st rank\n                black_promotion_threats += 1\n    \n    return white_promotion_threats - black_promotion_threats\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances between friendly pieces measuring coordination\"\n    pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            pieces.append(square)\n    \n    if len(pieces) < 2:\n        return 0.0\n    \n    total_distance = 0\n    count = 0\n    for i in range(len(pieces)):\n        for j in range(i + 1, len(pieces)):\n            total_distance += chess.square_distance(pieces[i], pieces[j])\n            count += 1\n    \n    return float(total_distance) / float(count) if count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of minimum distances from black pieces to safe squares near their king\"\n    black_king_square = board.king(chess.BLACK)\n    if black_king_square is None:\n        return 0.0\n    \n    king_adjacent = []\n    king_rank = chess.square_rank(black_king_square)\n    king_file = chess.square_file(black_king_square)\n    \n    for dr in [-1, 0, 1]:\n        for df in [-1, 0, 1]:\n            r, f = king_rank + dr, king_file + df\n            if 0 <= r <= 7 and 0 <= f <= 7:\n                king_adjacent.append(r * 8 + f)\n    \n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            min_dist = min(chess.square_distance(square, adj) for adj in king_adjacent)\n            total_distance += min_dist\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on the same diagonal as the enemy king\"\n    enemy_king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING and piece.color != board.turn:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    king_rank, king_file = chess.square_rank(enemy_king_square), chess.square_file(enemy_king_square)\n    diagonal_pieces = 0\n    total_pieces = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            total_pieces += 1\n            piece_rank, piece_file = chess.square_rank(square), chess.square_file(square)\n            if abs(piece_rank - king_rank) == abs(piece_file - king_file):\n                diagonal_pieces += 1\n    \n    return float(diagonal_pieces / max(total_pieces, 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Product of material advantage and king safety differential\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    material_diff = white_material - black_material\n    \n    white_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.WHITE)\n    black_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.BLACK)\n    safety_diff = black_king_attacks - white_king_attacks\n    \n    return float(material_diff * (safety_diff + 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that cannot move without exposing their king to check\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    opponent_color = not board.turn\n    piece_map = board.piece_map()\n    pinned_pieces = 0\n    \n    # Switch to opponent's turn to check their moves\n    board.push(chess.Move.null())\n    \n    for square, piece in piece_map.items():\n        if piece.color == opponent_color and piece.piece_type != chess.KING:\n            legal_moves_from_square = [move for move in board.legal_moves if move.from_square == square]\n            if len(legal_moves_from_square) == 0:\n                pinned_pieces += 1\n    \n    board.pop()\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file position of white pieces minus average file position of black pieces\"\n    white_files = []\n    black_files = []\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_files.append(chess.square_file(sq))\n        else:\n            black_files.append(chess.square_file(sq))\n    white_avg = sum(white_files) / len(white_files) if white_files else 3.5\n    black_avg = sum(black_files) / len(black_files) if black_files else 3.5\n    return float(white_avg - black_avg)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on distance from opponent pieces\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_safety = 0.0\n    black_safety = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            white_safety += chess.square_distance(white_king_square, square)\n        elif piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            black_safety += chess.square_distance(black_king_square, square)\n    \n    return white_safety - black_safety\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of pieces weighted by their attacking potential\"\n    total_weighted_rank = 0.0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            weighted_rank = rank\n        else:\n            weighted_rank = 7 - rank\n            \n        attack_count = len(board.attackers(piece.color, square))\n        weight = max(1, attack_count)\n        total_weighted_rank += weighted_rank * weight\n        total_pieces += weight\n    \n    if total_pieces == 0:\n        return 0.0\n    return total_weighted_rank / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        weight = 1.0 if piece.color == chess.WHITE else -1.0\n        total_distance += weight * min_center_dist\n        piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in pawn structure mobility - number of squares pawns can potentially advance\"\n    white_mobility = 0\n    black_mobility = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                for r in range(rank + 1, 8):\n                    target_square = chess.square(file, r)\n                    if board.piece_at(target_square) is None:\n                        white_mobility += 1\n                    else:\n                        break\n            else:\n                for r in range(rank - 1, -1, -1):\n                    target_square = chess.square(file, r)\n                    if board.piece_at(target_square) is None:\n                        black_mobility += 1\n                    else:\n                        break\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the current player's king\"\n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    \n    defenders = len(board.attackers(board.turn, king_square))\n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility difference weighted by piece value\"\n    white_mobility = 0\n    black_mobility = 0\n    piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 1}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1)\n            if piece.color == chess.WHITE:\n                white_mobility += weight\n            else:\n                black_mobility += weight\n    \n    board.push(chess.Move.null())\n    try:\n        for move in board.legal_moves:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = piece_weights.get(piece.piece_type, 1)\n                if piece.color == chess.BLACK:\n                    black_mobility += weight\n                else:\n                    white_mobility += weight\n    except:\n        pass\n    finally:\n        board.pop()\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can reach the center four squares in two moves\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_reach = 0\n    black_reach = 0\n    \n    for square, piece in board.piece_map().items():\n        for center in center_squares:\n            if chess.square_distance(square, center) <= 2:\n                if piece.color == chess.WHITE:\n                    white_reach += 1\n                else:\n                    black_reach += 1\n                break\n    \n    return float(white_reach - black_reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can deliver check in one move\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their starting rank vs advanced pieces\"\n    on_starting = 0\n    advanced = 0\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    starting_rank = 0 if current_color == chess.WHITE else 7\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == current_color and piece.piece_type != chess.PAWN:\n            rank = chess.square_rank(square)\n            if rank == starting_rank:\n                on_starting += 1\n            else:\n                advanced += 1\n    \n    total = on_starting + advanced\n    return float(on_starting / total) if total > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces minus average rank of black pieces\"\n    white_ranks = []\n    black_ranks = []\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_ranks.append(rank)\n        else:\n            black_ranks.append(rank)\n    \n    white_avg = sum(white_ranks) / len(white_ranks) if white_ranks else 0\n    black_avg = sum(black_ranks) / len(black_ranks) if black_ranks else 0\n    \n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by how advanced they are\"\n    passed_count = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (rank - 1) * (1.0 if piece.color == chess.WHITE else -1.0)\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (6 - rank) * (-1.0)\n    \n    return passed_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of all pieces from the center files\"\n    total_distance = 0\n    piece_count = 0\n    center_files = {3, 4}  # d and e files\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        min_center_dist = min(abs(file - cf) for cf in center_files)\n        total_distance += min_center_dist\n        piece_count += 1\n    \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of own pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0\n    weighted_rank_sum = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if piece.color == chess.BLACK:\n                rank = 7 - rank\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return float(weighted_rank_sum / total_value) if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_total_distance = 0\n    black_total_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    for square, piece in piece_map.items():\n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            white_total_distance += min_distance\n            white_pieces += 1\n        else:\n            black_total_distance += min_distance\n            black_pieces += 1\n    \n    white_avg = white_total_distance / white_pieces if white_pieces > 0 else 0\n    black_avg = black_total_distance / black_pieces if black_pieces > 0 else 0\n    \n    return black_avg - white_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares in black's half controlled by white pieces\"\n    controlled_squares = 0\n    \n    for square in range(32, 64):  # Black's half of the board\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares += 1\n    \n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on squares of the same color as the player's king square\"\n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    \n    king_square_color = (chess.square_file(king_square) + chess.square_rank(king_square)) % 2\n    count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            square_color = (chess.square_file(square) + chess.square_rank(square)) % 2\n            if square_color == king_square_color:\n                count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in tempo measured by pieces moved from starting squares weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    starting_squares = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, chess.D1: chess.QUEEN,\n                     chess.E1: chess.KING, chess.F1: chess.BISHOP, chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP, chess.D8: chess.QUEEN,\n                     chess.E8: chess.KING, chess.F8: chess.BISHOP, chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    white_tempo = black_tempo = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            rank = chess.square_rank(square)\n            if rank == 1 and square in starting_squares[chess.WHITE] and starting_squares[chess.WHITE][square] == piece.piece_type:\n                continue\n            elif rank == 1 and piece.piece_type == chess.PAWN:\n                continue\n            white_tempo += piece_values.get(piece.piece_type, 0)\n        else:\n            rank = chess.square_rank(square)\n            if rank == 6 and square in starting_squares[chess.BLACK] and starting_squares[chess.BLACK][square] == piece.piece_type:\n                continue\n            elif rank == 6 and piece.piece_type == chess.PAWN:\n                continue\n            black_tempo += piece_values.get(piece.piece_type, 0)\n    \n    return float(white_tempo - black_tempo)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of defended pieces to total pieces for current player\"\n    current_color = board.turn\n    defended = 0\n    total = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == current_color:\n            total += 1\n            if board.attackers(current_color, square):\n                defended += 1\n    if total == 0:\n        return 0.0\n    return float(defended) / float(total)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted sum of piece activity based on number of legal moves each piece can make\"\n    total_activity = 0.0\n    piece_weights = {chess.PAWN: 0.5, chess.KNIGHT: 2.0, chess.BISHOP: 2.0, \n                    chess.ROOK: 3.0, chess.QUEEN: 5.0, chess.KING: 1.0}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1.0)\n            multiplier = 1.0 if piece.color == chess.WHITE else -1.0\n            total_activity += weight * multiplier\n    \n    return total_activity\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of files where white has pawns closer to promotion than black\"\n    file_advantage = 0\n    \n    for file_idx in range(8):\n        white_best_rank = -1\n        black_best_rank = -1\n        \n        for rank in range(8):\n            square = chess.square(file_idx, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_best_rank = max(white_best_rank, rank)\n                else:\n                    black_best_rank = max(black_best_rank, 7 - rank)\n        \n        if white_best_rank > black_best_rank:\n            file_advantage += 1\n    \n    return float(file_advantage)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pinned pieces weighted by their value\"\n    pinned_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_pinned(chess.WHITE, square):\n                pinned_value -= piece_values.get(piece.piece_type, 0)\n        else:\n            if board.is_pinned(chess.BLACK, square):\n                pinned_value += piece_values.get(piece.piece_type, 0)\n    \n    return pinned_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can attack the enemy king in one move\"\n    white_king_sq = board.king(chess.BLACK)\n    black_king_sq = board.king(chess.WHITE)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_attackers = len(board.attackers(chess.WHITE, white_king_sq))\n    black_attackers = len(board.attackers(chess.BLACK, black_king_sq))\n    \n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can move to the 4 central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_count = 0\n    black_count = 0\n    \n    for move in board.legal_moves:\n        if move.to_square in central_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                if piece.color == chess.WHITE:\n                    white_count += 1\n                else:\n                    black_count += 1\n    \n    return float(white_count - black_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance from white king to white pawns minus distance from black king to black pawns\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_pawn_distances = []\n    black_pawn_distances = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawn_distances.append(chess.square_distance(white_king_square, square))\n            else:\n                black_pawn_distances.append(chess.square_distance(black_king_square, square))\n    \n    white_avg = sum(white_pawn_distances) / len(white_pawn_distances) if white_pawn_distances else 0\n    black_avg = sum(black_pawn_distances) / len(black_pawn_distances) if black_pawn_distances else 0\n    \n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of defended pieces between white and black\"\n    white_defended = 0\n    black_defended = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if len(board.attackers(chess.WHITE, square)) > 0:\n                white_defended += 1\n        else:\n            if len(board.attackers(chess.BLACK, square)) > 0:\n                black_defended += 1\n    return float(white_defended - black_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces on their optimal squares in endgame\"\n    piece_map = board.piece_map()\n    optimal_count = 0\n    for sq, piece in piece_map.items():\n        if piece.color == chess.WHITE:\n            if piece.piece_type == chess.KING and len(piece_map) <= 8:\n                rank, file = chess.square_rank(sq), chess.square_file(sq)\n                if 2 <= rank <= 5 and 2 <= file <= 5:\n                    optimal_count += 1\n            elif piece.piece_type == chess.ROOK:\n                if chess.square_rank(sq) == 6 or chess.square_file(sq) in [0, 7]:\n                    optimal_count += 1\n    return float(optimal_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to their own king\"\n    total_distance = 0\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, white_king_square)\n        else:\n            total_distance -= chess.square_distance(square, black_king_square)\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending the king's adjacent squares\"\n    def count_king_defenders(color):\n        king_square = board.king(color)\n        if king_square is None:\n            return 0\n        defenders = 0\n        king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n        for df in [-1, 0, 1]:\n            for dr in [-1, 0, 1]:\n                if df == 0 and dr == 0:\n                    continue\n                f, r = king_file + df, king_rank + dr\n                if 0 <= f <= 7 and 0 <= r <= 7:\n                    target_square = chess.square(f, r)\n                    defenders += len(board.attackers(color, target_square))\n        return defenders\n    return float(count_king_defenders(chess.WHITE) - count_king_defenders(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility difference weighted by piece value\"\n    white_mobility = 0\n    black_mobility = 0\n    piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 1}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1)\n            if piece.color == chess.WHITE:\n                white_mobility += weight\n            else:\n                black_mobility += weight\n    \n    board.push(chess.Move.null())\n    try:\n        for move in board.legal_moves:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = piece_weights.get(piece.piece_type, 1)\n                if piece.color == chess.BLACK:\n                    black_mobility += weight\n                else:\n                    white_mobility += weight\n    except:\n        pass\n    finally:\n        board.pop()\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares in black's half controlled by white pieces\"\n    controlled_squares = 0\n    \n    for square in range(32, 64):  # Black's half of the board\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares += 1\n    \n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from black pawns to white king\"\n    white_king_square = None\n    total_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.WHITE:\n            white_king_square = square\n            break\n    \n    if white_king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, white_king_square)\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares to total pieces\"\n    optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.F3, chess.C6, chess.F6, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.BISHOP: [chess.C4, chess.F4, chess.C5, chess.F5],\n        chess.ROOK: [chess.D1, chess.E1, chess.D8, chess.E8, chess.A7, chess.B7, chess.G7, chess.H7]\n    }\n    \n    optimal_count = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]:\n            total_pieces += 1\n            if piece.piece_type in optimal_squares and square in optimal_squares[piece.piece_type]:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n    \n    return optimal_count / max(1, total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending the back rank\"\n    white_back_defenders = 0\n    black_back_defenders = 0\n    \n    for file in range(8):\n        square = chess.square(file, 0)\n        white_back_defenders += len(board.attackers(chess.WHITE, square))\n        square = chess.square(file, 7)\n        black_back_defenders += len(board.attackers(chess.BLACK, square))\n    \n    return float(white_back_defenders - black_back_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defended by pieces of lower value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.color == board.turn:\n            defenders = board.attackers(piece.color, square)\n            for defender_square in defenders:\n                defender = piece_map.get(defender_square)\n                if defender and piece_values[defender.piece_type] < piece_values[piece.piece_type]:\n                    count += 1\n                    break\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of opponent's pieces from their own king\"\n    enemy_color = not board.turn\n    enemy_king_sq = board.king(enemy_color)\n    if enemy_king_sq is None:\n        return 0.0\n    \n    enemy_pieces = [sq for sq, piece in board.piece_map().items() \n                   if piece.color == enemy_color and piece.piece_type != chess.KING]\n    if not enemy_pieces:\n        return 0.0\n    \n    total_distance = sum(chess.square_distance(enemy_king_sq, sq) for sq in enemy_pieces)\n    return total_distance / len(enemy_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on the same rank as opponent king\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_king_rank = chess.square_rank(white_king_square)\n    black_king_rank = chess.square_rank(black_king_square)\n    \n    count = 0\n    for square, piece in board.piece_map().items():\n        piece_rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and piece_rank == black_king_rank:\n            count += 1\n        elif piece.color == chess.BLACK and piece_rank == white_king_rank:\n            count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of all pieces from their starting files\"\n    total_distance = 0.0\n    piece_count = 0\n    starting_files = {\n        chess.ROOK: [0, 7], chess.KNIGHT: [1, 6], chess.BISHOP: [2, 5],\n        chess.QUEEN: [3], chess.KING: [4], chess.PAWN: list(range(8))\n    }\n    \n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece:\n            current_file = chess.square_file(square)\n            if piece.piece_type in starting_files:\n                min_distance = min(abs(current_file - sf) for sf in starting_files[piece.piece_type])\n                total_distance += min_distance\n                piece_count += 1\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that would be undefended after a capture\"\n    undefended_after_capture = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            board.push(move)\n            for square, piece in board.piece_map().items():\n                if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n                    undefended_after_capture += 1\n            board.pop()\n    \n    return float(undefended_after_capture)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of controlled central squares to total central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlled = 0\n    my_color = board.turn\n    \n    for square in central_squares:\n        if board.is_attacked_by(my_color, square):\n            controlled += 1\n    \n    return float(controlled) / 4.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average number of attackers per enemy piece\"\n    enemy_pieces = []\n    total_attackers = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            enemy_pieces.append(square)\n            total_attackers += len(board.attackers(board.turn, square))\n    if len(enemy_pieces) == 0:\n        return 0.0\n    return float(total_attackers) / len(enemy_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference between white and black piece activity measured by average moves per piece\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    if white_pieces == 0 and black_pieces == 0:\n        return 0.0\n    \n    white_moves = sum(1 for move in board.legal_moves) if board.turn == chess.WHITE else 0\n    if board.turn == chess.BLACK:\n        board.push(chess.Move.null())\n        board.turn = chess.WHITE\n        white_moves = sum(1 for move in board.legal_moves)\n        board.pop()\n    \n    board.push(chess.Move.null())\n    black_moves = sum(1 for move in board.legal_moves) if board.turn == chess.BLACK else 0\n    if board.turn == chess.WHITE:\n        board.turn = chess.BLACK\n        black_moves = sum(1 for move in board.legal_moves)\n    board.pop()\n    \n    white_activity = white_moves / white_pieces if white_pieces > 0 else 0.0\n    black_activity = black_moves / black_pieces if black_pieces > 0 else 0.0\n    \n    return white_activity - black_activity\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Product of white queen mobility and distance from black king\"\n    white_queen_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN and piece.color == chess.WHITE:\n            white_queen_square = square\n        elif piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n    \n    if white_queen_square is None or black_king_square is None:\n        return 0.0\n    \n    queen_mobility = 0\n    for move in board.legal_moves:\n        if move.from_square == white_queen_square:\n            queen_mobility += 1\n    \n    distance = chess.square_distance(white_queen_square, black_king_square)\n    return float(queen_mobility * distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on the same file as enemy king\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    # Find enemy king\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    king_file = chess.square_file(enemy_king_square)\n    \n    friendly_count = 0\n    enemy_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if chess.square_file(square) == king_file:\n            if piece.color == friendly_color:\n                friendly_count += 1\n            else:\n                enemy_count += 1\n    \n    return float(friendly_count - enemy_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of enemy pieces from their starting squares\"\n    enemy_color = chess.BLACK if board.turn else chess.WHITE\n    total_distance = 0.0\n    piece_count = 0\n    \n    starting_ranks = {chess.WHITE: [0, 1], chess.BLACK: [6, 7]}\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color:\n            current_rank = chess.square_rank(square)\n            min_distance = min(abs(current_rank - rank) for rank in starting_ranks[enemy_color])\n            total_distance += min_distance\n            piece_count += 1\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average number of squares each piece type can move to\"\n    piece_mobility = {}\n    piece_counts = {}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            piece_type = piece.piece_type\n            if piece_type not in piece_mobility:\n                piece_mobility[piece_type] = 0\n                piece_counts[piece_type] = set()\n            piece_mobility[piece_type] += 1\n            piece_counts[piece_type].add(move.from_square)\n    \n    total_avg = 0\n    type_count = 0\n    for piece_type in piece_mobility:\n        if len(piece_counts[piece_type]) > 0:\n            avg_mobility = piece_mobility[piece_type] / len(piece_counts[piece_type])\n            total_avg += avg_mobility\n            type_count += 1\n    \n    return total_avg / type_count if type_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to opponent's side of board in one move\"\n    crossing_pieces = 0\n    \n    for move in board.legal_moves:\n        to_square = move.to_square\n        to_rank = chess.square_rank(to_square)\n        \n        if board.turn == chess.WHITE and to_rank >= 4:\n            crossing_pieces += 1\n        elif board.turn == chess.BLACK and to_rank <= 3:\n            crossing_pieces += 1\n    \n    return float(crossing_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of consecutive ranks without any pieces\"\n    rank_occupancy = [False] * 8\n    \n    for square in board.piece_map().keys():\n        rank = chess.square_rank(square)\n        rank_occupancy[rank] = True\n    \n    max_empty_consecutive = 0\n    current_empty = 0\n    \n    for occupied in rank_occupancy:\n        if not occupied:\n            current_empty += 1\n            max_empty_consecutive = max(max_empty_consecutive, current_empty)\n        else:\n            current_empty = 0\n    \n    return float(max_empty_consecutive)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can capture undefended enemy pieces\"\n    white_captures = 0\n    black_captures = 0\n    for square, piece in board.piece_map().items():\n        attackers_white = len(board.attackers(chess.WHITE, square))\n        attackers_black = len(board.attackers(chess.BLACK, square))\n        if piece.color == chess.BLACK and attackers_white > 0 and attackers_black == 0:\n            white_captures += 1\n        elif piece.color == chess.WHITE and attackers_black > 0 and attackers_white == 0:\n            black_captures += 1\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = float('inf')\n        for center_sq in center_squares:\n            distance = chess.square_distance(square, center_sq)\n            min_center_distance = min(min_center_distance, distance)\n        \n        # Weight by piece value\n        piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                       chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n        weight = piece_values.get(piece.piece_type, 0)\n        \n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance * weight\n        else:\n            total_distance += min_center_distance * weight\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average piece value density in 3x3 zones around each piece\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_density = 0.0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n            \n        zone_value = 0\n        rank, file = chess.square_rank(square), chess.square_file(square)\n        \n        for r in range(max(0, rank-1), min(8, rank+2)):\n            for f in range(max(0, file-1), min(8, file+2)):\n                zone_square = chess.square(f, r)\n                zone_piece = board.piece_at(zone_square)\n                if zone_piece:\n                    zone_value += piece_values.get(zone_piece.piece_type, 0)\n        \n        total_density += zone_value\n        piece_count += 1\n    \n    return total_density / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference between white and black piece activity measured by average moves per piece\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    if white_pieces == 0 and black_pieces == 0:\n        return 0.0\n    \n    white_moves = sum(1 for move in board.legal_moves) if board.turn == chess.WHITE else 0\n    if board.turn == chess.BLACK:\n        board.push(chess.Move.null())\n        board.turn = chess.WHITE\n        white_moves = sum(1 for move in board.legal_moves)\n        board.pop()\n    \n    board.push(chess.Move.null())\n    black_moves = sum(1 for move in board.legal_moves) if board.turn == chess.BLACK else 0\n    if board.turn == chess.WHITE:\n        board.turn = chess.BLACK\n        black_moves = sum(1 for move in board.legal_moves)\n    board.pop()\n    \n    white_activity = white_moves / white_pieces if white_pieces > 0 else 0.0\n    black_activity = black_moves / black_pieces if black_pieces > 0 else 0.0\n    \n    return white_activity - black_activity\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the middle of the board\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of controlled central squares to total central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlled = 0\n    my_color = board.turn\n    \n    for square in central_squares:\n        if board.is_attacked_by(my_color, square):\n            controlled += 1\n    \n    return float(controlled) / 4.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of current player's pieces\"\n    pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            rank = chess.square_rank(square)\n            if board.turn == chess.BLACK:\n                rank = 7 - rank\n            pieces.append(rank)\n    if not pieces:\n        return 0.0\n    return float(sum(pieces) / len(pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on squares attacked by opponent pieces\"\n    white_on_attacked = 0\n    black_on_attacked = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                white_on_attacked += 1\n        else:\n            if board.is_attacked_by(chess.WHITE, square):\n                black_on_attacked += 1\n    \n    return float(white_on_attacked - black_on_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond their 4th rank\"\n    advanced_pawns = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns -= 1\n    \n    return advanced_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of defended pieces between white and black\"\n    white_defended = 0\n    black_defended = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.attackers(chess.WHITE, square):\n                white_defended += 1\n        else:\n            if board.attackers(chess.BLACK, square):\n                black_defended += 1\n    return float(white_defended - black_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending the king between white and black\"\n    def king_defenders(color):\n        king_square = None\n        piece_map = board.piece_map()\n        for square, piece in piece_map.items():\n            if piece.piece_type == chess.KING and piece.color == color:\n                king_square = square\n                break\n        \n        if king_square is None:\n            return 0\n        \n        defenders = 0\n        for square in chess.SQUARES:\n            piece = piece_map.get(square)\n            if piece and piece.color == color and piece.piece_type != chess.KING:\n                if king_square in board.attackers(color, square):\n                    defenders += 1\n        return defenders\n    \n    white_defenders = king_defenders(chess.WHITE)\n    black_defenders = king_defenders(chess.BLACK)\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from black pawns to white king\"\n    white_king_square = None\n    total_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.WHITE:\n            white_king_square = square\n            break\n    \n    if white_king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, white_king_square)\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on the kingside vs queenside files\"\n    kingside_count = 0\n    queenside_count = 0\n    for square in board.piece_map():\n        file = chess.square_file(square)\n        if file >= 4:  # Files E-H\n            kingside_count += 1\n        else:  # Files A-D\n            queenside_count += 1\n    return float(kingside_count - queenside_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white pieces in enemy half to black pieces in friendly half\"\n    white_in_enemy_half = 0\n    black_in_friendly_half = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 4:\n            white_in_enemy_half += 1\n        elif piece.color == chess.BLACK and rank <= 3:\n            black_in_friendly_half += 1\n    \n    if black_in_friendly_half == 0:\n        return float(white_in_enemy_half * 2)\n    \n    return float(white_in_enemy_half) / float(black_in_friendly_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility difference weighted by piece value\"\n    white_mobility = 0\n    black_mobility = 0\n    piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 1}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_weights.get(piece.piece_type, 1)\n            if piece.color == chess.WHITE:\n                white_mobility += weight\n            else:\n                black_mobility += weight\n    \n    board.push(chess.Move.null())\n    try:\n        for move in board.legal_moves:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                weight = piece_weights.get(piece.piece_type, 1)\n                if piece.color == chess.BLACK:\n                    black_mobility += weight\n                else:\n                    white_mobility += weight\n    except:\n        pass\n    finally:\n        board.pop()\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that can move to the center four squares\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                value = piece_values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total_value += value\n                else:\n                    total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of pawns relative to their starting positions\"\n    pawn_advancement = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                advancement = rank - 1\n            else:\n                advancement = 6 - rank\n            pawn_advancement += max(0, advancement)\n            pawn_count += 1\n    \n    return pawn_advancement / max(pawn_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting squares for the opponent\"\n    opponent_color = not board.turn\n    starting_pieces = 0\n    \n    starting_positions = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, \n                     chess.D1: chess.QUEEN, chess.E1: chess.KING, chess.F1: chess.BISHOP, \n                     chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP,\n                     chess.D8: chess.QUEEN, chess.E8: chess.KING, chess.F8: chess.BISHOP,\n                     chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    for square, expected_piece_type in starting_positions[opponent_color].items():\n        piece = board.piece_at(square)\n        if piece and piece.color == opponent_color and piece.piece_type == expected_piece_type:\n            starting_pieces += 1\n    \n    return float(starting_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in one move\"\n    checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            checks += 1\n        board.pop()\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of central squares by pawns and pieces\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = 0.0\n    black_control = 0.0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 2.0\n            else:\n                black_control += 2.0\n        \n        white_control += white_attackers\n        black_control += black_attackers\n    \n    return white_control - black_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the 8th rank in one move\"\n    count = 0\n    eighth_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    \n    for move in board.legal_moves:\n        if move.to_square in eighth_rank_squares:\n            count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of escape squares available\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_escapes = 0\n    black_escapes = 0\n    \n    if white_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(white_king_square) + dx\n                rank = chess.square_rank(white_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.BLACK:\n                        if not board.is_attacked_by(chess.BLACK, escape_square):\n                            white_escapes += 1\n    \n    if black_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(black_king_square) + dx\n                rank = chess.square_rank(black_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.WHITE:\n                        if not board.is_attacked_by(chess.WHITE, escape_square):\n                            black_escapes += 1\n    \n    return float(white_escapes - black_escapes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of major pieces to total pieces for current player\"\n    our_major = our_total = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            our_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                our_major += 1\n    return float(our_major / our_total if our_total > 0 else 0.0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to safety when attacked\"\n    safe_retreats = 0\n    for move in board.legal_moves:\n        if board.is_attacked_by(not board.turn, move.from_square):\n            board.push(move)\n            if not board.is_attacked_by(not board.turn, move.to_square):\n                safe_retreats += 1\n            board.pop()\n    return float(safe_retreats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of safe squares for queens between white and black\"\n    white_queen_safety = 0\n    black_queen_safety = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            safety_count = 0\n            for target_square in range(64):\n                if not board.is_attacked_by(not piece.color, target_square):\n                    safety_count += 1\n            \n            if piece.color == chess.WHITE:\n                white_queen_safety = safety_count\n            else:\n                black_queen_safety = safety_count\n    \n    return float(white_queen_safety - black_queen_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between knights and bishops for current position\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    pieces_controlling_center = 0\n    for move in board.legal_moves:\n        if move.to_square in central_squares:\n            pieces_controlling_center += 1\n    return float(pieces_controlling_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on squares of opposite color to their starting squares\"\n    opposite_color = 0\n    for square, piece in board.piece_map().items():\n        square_color = (chess.square_rank(square) + chess.square_file(square)) % 2\n        if piece.piece_type == chess.PAWN:\n            continue\n        if piece.color == chess.WHITE:\n            original_rank = 0 if piece.piece_type in [chess.ROOK, chess.KNIGHT, chess.BISHOP, chess.QUEEN, chess.KING] else -1\n        else:\n            original_rank = 7 if piece.piece_type in [chess.ROOK, chess.KNIGHT, chess.BISHOP, chess.QUEEN, chess.KING] else -1\n        if original_rank >= 0:\n            current_rank = chess.square_rank(square)\n            if current_rank != original_rank:\n                opposite_color += 1\n    return float(opposite_color)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum distance any black piece needs to travel to defend their king\"\n    black_king_sq = board.king(chess.BLACK)\n    if black_king_sq is None:\n        return 0.0\n    \n    max_distance = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and square != black_king_sq:\n            distance = chess.square_distance(square, black_king_sq)\n            max_distance = max(max_distance, float(distance))\n    \n    return max_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of pieces from the center files\"\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            file_pos = chess.square_file(square)\n            center_distance = min(abs(file_pos - 3), abs(file_pos - 4))\n            total_distance += center_distance\n            piece_count += 1\n    \n    return total_distance / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance -= min_center_distance\n        else:\n            total_distance += min_center_distance\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    \n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in one move\"\n    checking_moves = 0\n    \n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            checking_moves += 1\n        board.pop()\n    \n    return float(checking_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares where pieces can be captured without recapture\"\n    hanging_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        opponent_color = not piece.color\n        if board.is_attacked_by(opponent_color, square):\n            if not board.is_attacked_by(piece.color, square):\n                hanging_pieces += 1 if piece.color == chess.BLACK else -1\n    \n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting squares\"\n    starting_positions = {\n        chess.A1: (chess.ROOK, chess.WHITE), chess.H1: (chess.ROOK, chess.WHITE),\n        chess.B1: (chess.KNIGHT, chess.WHITE), chess.G1: (chess.KNIGHT, chess.WHITE),\n        chess.C1: (chess.BISHOP, chess.WHITE), chess.F1: (chess.BISHOP, chess.WHITE),\n        chess.D1: (chess.QUEEN, chess.WHITE), chess.E1: (chess.KING, chess.WHITE),\n        chess.A8: (chess.ROOK, chess.BLACK), chess.H8: (chess.ROOK, chess.BLACK),\n        chess.B8: (chess.KNIGHT, chess.BLACK), chess.G8: (chess.KNIGHT, chess.BLACK),\n        chess.C8: (chess.BISHOP, chess.BLACK), chess.F8: (chess.BISHOP, chess.BLACK),\n        chess.D8: (chess.QUEEN, chess.BLACK), chess.E8: (chess.KING, chess.BLACK)\n    }\n    \n    count = 0.0\n    for square in range(chess.A2, chess.H2 + 1):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n            count += 1.0\n    \n    for square in range(chess.A7, chess.H7 + 1):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n            count += 1.0\n    \n    for square, (piece_type, color) in starting_positions.items():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == piece_type and piece.color == color:\n            count += 1.0\n    \n    return count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on back ranks versus advanced positions\"\n    piece_counts = {'back': 0, 'advanced': 0}\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        \n        if piece.color == chess.WHITE:\n            if rank <= 2:\n                piece_counts['back'] += 1\n            elif rank >= 5:\n                piece_counts['advanced'] += 1\n        else:\n            if rank >= 5:\n                piece_counts['back'] += 1\n            elif rank <= 2:\n                piece_counts['advanced'] += 1\n    \n    total = piece_counts['back'] + piece_counts['advanced']\n    if total == 0:\n        return 0.0\n    \n    return float(piece_counts['advanced']) / float(total)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their starting files versus displaced files\"\n    piece_map = board.piece_map()\n    displaced_white = 0\n    displaced_black = 0\n    total_white = 0\n    total_black = 0\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        file_idx = chess.square_file(square)\n        starting_files = {chess.ROOK: [0, 7], chess.KNIGHT: [1, 6], chess.BISHOP: [2, 5], \n                         chess.QUEEN: [3], chess.KING: [4]}\n        \n        if piece.color == chess.WHITE:\n            total_white += 1\n            if piece.piece_type in starting_files and file_idx not in starting_files[piece.piece_type]:\n                displaced_white += 1\n        else:\n            total_black += 1\n            if piece.piece_type in starting_files and file_idx not in starting_files[piece.piece_type]:\n                displaced_black += 1\n    \n    white_ratio = displaced_white / max(total_white, 1)\n    black_ratio = displaced_black / max(total_black, 1)\n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen activity measured by number of squares it attacks weighted by square importance\"\n    activity = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.QUEEN:\n            attacks = 0\n            for target in chess.SQUARES:\n                if board.is_attacked_by(piece.color, target):\n                    rank = chess.square_rank(target)\n                    file = chess.square_file(target)\n                    center_distance = abs(3.5 - file) + abs(3.5 - rank)\n                    importance = 1.0 / (1.0 + center_distance * 0.2)\n                    if piece.color == chess.WHITE and rank >= 4:\n                        importance *= 1.3\n                    elif piece.color == chess.BLACK and rank <= 3:\n                        importance *= 1.3\n                    attacks += importance\n            if piece.color == chess.WHITE:\n                activity += attacks\n            else:\n                activity -= attacks\n    return activity\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces to pawns for each side indicating endgame transition\"\n    white_pieces = 0\n    white_pawns = 0\n    black_pieces = 0\n    black_pawns = 0\n    \n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            if piece.piece_type == chess.PAWN:\n                white_pawns += 1\n            else:\n                white_pieces += 1\n        else:\n            if piece.piece_type == chess.PAWN:\n                black_pawns += 1\n            else:\n                black_pieces += 1\n    \n    white_ratio = white_pieces / max(white_pawns, 1)\n    black_ratio = black_pieces / max(black_pawns, 1)\n    \n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces on the 7th and 8th ranks\"\n    piece_map = board.piece_map()\n    count = 0\n    for square, piece in piece_map.items():\n        if piece.color == chess.WHITE:\n            rank = chess.square_rank(square)\n            if rank == 6 or rank == 7:  # 7th and 8th ranks (0-indexed)\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted piece activity based on number of legal moves per piece type\"\n    weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    current_turn = board.turn\n    \n    white_activity = 0\n    black_activity = 0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = weights.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white_activity += weight\n            else:\n                black_activity += weight\n    \n    board.turn = not board.turn\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = weights.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white_activity += weight\n            else:\n                black_activity += weight\n    \n    board.turn = current_turn\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance of closest enemy piece to own king\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_min_distance = 8\n    black_min_distance = 8\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            white_min_distance = min(white_min_distance, chess.square_distance(white_king_square, square))\n        else:\n            black_min_distance = min(black_min_distance, chess.square_distance(black_king_square, square))\n    \n    return float(black_min_distance - white_min_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by pawns weighted by their distance from enemy king\"\n    black_king_sq = None\n    white_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_control = 0.0\n    black_control = 0.0\n    \n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square):\n            attackers = board.attackers(chess.WHITE, square)\n            for attacker_sq in attackers:\n                piece = board.piece_at(attacker_sq)\n                if piece and piece.piece_type == chess.PAWN:\n                    distance_to_black_king = chess.square_distance(square, black_king_sq)\n                    white_control += 8.0 - distance_to_black_king\n        \n        if board.is_attacked_by(chess.BLACK, square):\n            attackers = board.attackers(chess.BLACK, square)\n            for attacker_sq in attackers:\n                piece = board.piece_at(attacker_sq)\n                if piece and piece.piece_type == chess.PAWN:\n                    distance_to_white_king = chess.square_distance(square, white_king_sq)\n                    black_control += 8.0 - distance_to_white_king\n    \n    return white_control - black_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Opposition control in king and pawn endgames\"\n    total_pieces = len(board.piece_map())\n    if total_pieces > 6:\n        return 0.0\n    \n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    if not white_king_sq or not black_king_sq:\n        return 0.0\n    \n    # Check if kings are in opposition (same file/rank, odd distance)\n    king_distance = chess.square_distance(white_king_sq, black_king_sq)\n    same_file = chess.square_file(white_king_sq) == chess.square_file(black_king_sq)\n    same_rank = chess.square_rank(white_king_sq) == chess.square_rank(black_king_sq)\n    \n    if (same_file or same_rank) and king_distance % 2 == 1:\n        return 1.0 if board.turn == chess.WHITE else -1.0\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece coordination measured by mutual protection\"\n    white_protected = 0\n    black_protected = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        protection_count = len(attackers) - 1  # Subtract 1 to exclude the piece itself\n        if piece.color == chess.WHITE:\n            white_protected += max(0, protection_count)\n        else:\n            black_protected += max(0, protection_count)\n    return float(white_protected - black_protected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king activity measured by distance from center of board\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    # Calculate distance from center for each king\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    \n    white_min_dist = min(chess.square_distance(white_king_square, center) for center in center_squares)\n    black_min_dist = min(chess.square_distance(black_king_square, center) for center in center_squares)\n    \n    # Lower distance is better (more active), so subtract black from white\n    return float(black_min_dist - white_min_dist)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defended by pawns weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_score = 0\n    black_score = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        defended_by_pawn = False\n        if piece.color == chess.WHITE:\n            # Check if defended by white pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square - 9)  # SW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square - 7)  # SE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.WHITE:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                white_score += piece_values.get(piece.piece_type, 0)\n        else:\n            # Check if defended by black pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square + 7)  # NW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square + 9)  # NE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.BLACK:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                black_score += piece_values.get(piece.piece_type, 0)\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_mobility = 0\n    black_central_mobility = 0\n    \n    for move in board.legal_moves:\n        if move.to_square in central_squares:\n            piece = board.piece_at(move.from_square)\n            if piece and piece.color == chess.WHITE:\n                white_central_mobility += 1\n            elif piece and piece.color == chess.BLACK:\n                black_central_mobility += 1\n    \n    return white_central_mobility - black_central_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of pawns relative to their starting positions\"\n    pawn_advancement = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                advancement = rank - 1\n            else:\n                advancement = 6 - rank\n            pawn_advancement += max(0, advancement)\n            pawn_count += 1\n    \n    return pawn_advancement / max(pawn_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat safely when attacked\"\n    def safe_retreats(color):\n        retreats = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                if board.is_attacked_by(not color, square):\n                    for move in board.legal_moves:\n                        if move.from_square == square:\n                            board.push(move)\n                            if not board.is_attacked_by(not color, move.to_square):\n                                retreats += 1\n                                board.pop()\n                                break\n                            board.pop()\n        return retreats\n    \n    white_retreats = safe_retreats(chess.WHITE)\n    black_retreats = safe_retreats(chess.BLACK)\n    return float(white_retreats - black_retreats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of queen moves that attack multiple enemy pieces simultaneously\"\n    count = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.QUEEN:\n            board.push(move)\n            attacks = 0\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            for target_square in chess.SQUARES:\n                target_piece = board.piece_at(target_square)\n                if target_piece and target_piece.color == enemy_color:\n                    if board.is_attacked_by(piece.color, target_square):\n                        attacks += 1\n            board.pop()\n            if attacks >= 2:\n                count += 1 if piece.color == chess.WHITE else -1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all pieces to their own king\"\n    total_distance = 0\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, white_king_square)\n        else:\n            total_distance -= chess.square_distance(square, black_king_square)\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white to black piece mobility\"\n    white_moves = 0\n    black_moves = 0\n    \n    current_turn = board.turn\n    board.turn = chess.WHITE\n    white_moves = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    \n    if black_moves == 0:\n        return 100.0 if white_moves > 0 else 1.0\n    return float(white_moves) / float(black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces weighted by their material value\"\n    undefended_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        defenders = len(board.attackers(piece.color, square))\n        attackers = len(board.attackers(not piece.color, square))\n        \n        if defenders == 0 and attackers > 0:\n            value = piece_values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                undefended_value -= value\n            else:\n                undefended_value += value\n    \n    return undefended_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by escape squares availability\"\n    white_king_safety = 0.0\n    black_king_safety = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            escape_squares = 0\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            for df in [-1, 0, 1]:\n                for dr in [-1, 0, 1]:\n                    if df == 0 and dr == 0:\n                        continue\n                    new_file = file + df\n                    new_rank = rank + dr\n                    if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                        escape_square = chess.square(new_file, new_rank)\n                        escape_piece = board.piece_at(escape_square)\n                        if not escape_piece or escape_piece.color != piece.color:\n                            if not board.is_attacked_by(not piece.color, escape_square):\n                                escape_squares += 1\n            \n            if piece.color == chess.WHITE:\n                white_king_safety = escape_squares\n            else:\n                black_king_safety = escape_squares\n    \n    return white_king_safety - black_king_safety\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of defended pieces between white and black\"\n    white_defended = 0\n    black_defended = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.attackers(chess.WHITE, square):\n                white_defended += 1\n        else:\n            if board.attackers(chess.BLACK, square):\n                black_defended += 1\n    return float(white_defended - black_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces that can be forked by a single piece move\"\n    fork_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        from_square = move.to_square\n        piece = board.piece_at(from_square)\n        if piece:\n            attacked_squares = board.attacks(from_square)\n            enemy_pieces = 0\n            for sq in attacked_squares:\n                target = board.piece_at(sq)\n                if target and target.color != piece.color:\n                    enemy_pieces += 1\n            if enemy_pieces >= 2:\n                fork_count += 1\n        board.pop()\n    return float(fork_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of king moves that would reduce distance to opponent pawns\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    \n    opponent_pawns = [sq for sq, piece in board.piece_map().items() \n                     if piece.piece_type == chess.PAWN and piece.color != board.turn]\n    \n    if not opponent_pawns:\n        return 0.0\n    \n    current_min_dist = min(chess.square_distance(king_square, pawn_sq) for pawn_sq in opponent_pawns)\n    improving_moves = 0\n    \n    for move in board.legal_moves:\n        if board.piece_at(move.from_square) and board.piece_at(move.from_square).piece_type == chess.KING:\n            new_min_dist = min(chess.square_distance(move.to_square, pawn_sq) for pawn_sq in opponent_pawns)\n            if new_min_dist < current_min_dist:\n                improving_moves += 1\n    \n    return float(improving_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares where white pieces can move that are closer to black king than white king\"\n    white_king_sq = None\n    black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    count = 0\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE:\n            dist_to_black_king = chess.square_distance(move.to_square, black_king_sq)\n            dist_to_white_king = chess.square_distance(move.to_square, white_king_sq)\n            if dist_to_black_king < dist_to_white_king:\n                count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of all pieces from starting positions\"\n    total_advancement = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        \n        if piece.color == chess.WHITE:\n            if piece.piece_type == chess.PAWN:\n                advancement = rank - 1\n            else:\n                advancement = rank\n        else:\n            if piece.piece_type == chess.PAWN:\n                advancement = 6 - rank\n            else:\n                advancement = 7 - rank\n        \n        total_advancement += max(0, advancement)\n        piece_count += 1\n    \n    return total_advancement / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of defended pieces to total pieces for current player\"\n    my_color = board.turn\n    total_pieces = 0\n    defended_pieces = 0\n    \n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == my_color and piece.piece_type != chess.KING:\n            total_pieces += 1\n            if board.is_attacked_by(my_color, square):\n                defended_pieces += 1\n    \n    if total_pieces == 0:\n        return 0.0\n    return float(defended_pieces) / float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of escape squares available\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_escapes = 0\n    black_escapes = 0\n    \n    if white_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(white_king_square) + dx\n                rank = chess.square_rank(white_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.BLACK:\n                        if not board.is_attacked_by(chess.BLACK, escape_square):\n                            white_escapes += 1\n    \n    if black_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(black_king_square) + dx\n                rank = chess.square_rank(black_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.WHITE:\n                        if not board.is_attacked_by(chess.WHITE, escape_square):\n                            black_escapes += 1\n    \n    return float(white_escapes - black_escapes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat to safety when attacked\"\n    def count_safe_retreats(color):\n        retreat_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square):\n                # Count safe squares this piece can move to\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        if not board.is_attacked_by(not color, move.to_square):\n                            retreat_count += 1\n                            break\n        return retreat_count\n    \n    if board.turn:\n        return float(count_safe_retreats(chess.WHITE) - count_safe_retreats(chess.BLACK))\n    else:\n        return float(count_safe_retreats(chess.BLACK) - count_safe_retreats(chess.WHITE))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the 4th rank for white or 5th rank for black\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value on squares that are two moves away from promotion\"\n    total_value = 0.0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank == 5:  # 6th rank for white\n            total_value += piece_values.get(piece.piece_type, 0)\n        elif piece.color == chess.BLACK and rank == 2:  # 3rd rank for black\n            total_value += piece_values.get(piece.piece_type, 0)\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in opponent's half of the board\"\n    white_in_black_half = 0\n    black_in_white_half = 0\n    white_total = 0\n    black_total = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_total += 1\n            if rank >= 4:\n                white_in_black_half += 1\n        else:\n            black_total += 1\n            if rank <= 3:\n                black_in_white_half += 1\n    \n    white_ratio = white_in_black_half / max(white_total, 1)\n    black_ratio = black_in_white_half / max(black_total, 1)\n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares where white pieces can move that are closer to black king than white king\"\n    white_king_sq = None\n    black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    count = 0\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE:\n            dist_to_black_king = chess.square_distance(move.to_square, black_king_sq)\n            dist_to_white_king = chess.square_distance(move.to_square, white_king_sq)\n            if dist_to_black_king < dist_to_white_king:\n                count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on light squares minus pieces on dark squares\"\n    light_count = 0\n    dark_count = 0\n    for square, piece in board.piece_map().items():\n        if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n            dark_count += 1\n        else:\n            light_count += 1\n    return float(light_count - dark_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of all pieces from their king\"\n    piece_map = board.piece_map()\n    white_king = black_king = None\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    white_total = white_count = black_total = black_count = 0\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type != chess.KING:\n            king_square = white_king if piece.color == chess.WHITE else black_king\n            file_distance = abs(chess.square_file(square) - chess.square_file(king_square))\n            \n            if piece.color == chess.WHITE:\n                white_total += file_distance\n                white_count += 1\n            else:\n                black_total += file_distance\n                black_count += 1\n    \n    white_avg = white_total / max(white_count, 1)\n    black_avg = black_total / max(black_count, 1)\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of all pawns on the board\"\n    pawn_ranks = []\n    \n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                pawn_ranks.append(rank)\n            else:\n                pawn_ranks.append(7 - rank)\n    \n    if not pawn_ranks:\n        return 0.0\n    return sum(pawn_ranks) / len(pawn_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average file distance of rooks from center files\"\n    total_distance = 0.0\n    rook_count = 0\n    \n    piece_map = board.piece_map()\n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.ROOK:\n            file_pos = chess.square_file(square)\n            distance_from_center = min(abs(file_pos - 3), abs(file_pos - 4))\n            total_distance += distance_from_center\n            rook_count += 1\n    \n    return total_distance / max(rook_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weakness based on isolated and doubled pawns\"\n    white_pawns = []\n    black_pawns = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns.append(square)\n            else:\n                black_pawns.append(square)\n    \n    def count_weak_pawns(pawns):\n        weak_count = 0\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if file not in files:\n                files[file] = []\n            files[file].append(pawn)\n        \n        for file, file_pawns in files.items():\n            if len(file_pawns) > 1:\n                weak_count += len(file_pawns) - 1\n            \n            has_neighbor = False\n            for neighbor_file in [file - 1, file + 1]:\n                if 0 <= neighbor_file <= 7 and neighbor_file in files:\n                    has_neighbor = True\n                    break\n            if not has_neighbor:\n                weak_count += 1\n        \n        return weak_count\n    \n    return count_weak_pawns(black_pawns) - count_weak_pawns(white_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can be promoted to queen in the next few moves\"\n    promotion_potential = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_potential += (rank - 4)\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_potential += (3 - rank)\n    \n    return float(promotion_potential)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can reach the center four squares\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_reach = 0\n    black_reach = 0\n    \n    for square in center_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_reach += white_attackers\n        black_reach += black_attackers\n    \n    return float(white_reach - black_reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between white and black pieces (total legal moves)\"\n    current_turn = board.turn\n    white_mobility = 0\n    black_mobility = 0\n    \n    # Count white moves\n    if current_turn == chess.WHITE:\n        white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        if not board.is_checkmate() and not board.is_stalemate():\n            black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        if not board.is_checkmate() and not board.is_stalemate():\n            white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum distance between any two pieces of the same color\"\n    max_dist_white = max_dist_black = 0\n    white_squares = []\n    black_squares = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_squares.append(square)\n        else:\n            black_squares.append(square)\n    \n    for i, sq1 in enumerate(white_squares):\n        for sq2 in white_squares[i+1:]:\n            max_dist_white = max(max_dist_white, chess.square_distance(sq1, sq2))\n    \n    for i, sq1 in enumerate(black_squares):\n        for sq2 in black_squares[i+1:]:\n            max_dist_black = max(max_dist_black, chess.square_distance(sq1, sq2))\n    \n    return float(max_dist_white - max_dist_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pawn promotion squares each side controls or attacks\"\n    white_control = 0\n    black_control = 0\n    \n    for file in range(8):\n        eighth_rank = chess.square(file, 7)\n        first_rank = chess.square(file, 0)\n        \n        if board.is_attacked_by(chess.WHITE, eighth_rank):\n            white_control += 1\n        if board.is_attacked_by(chess.BLACK, first_rank):\n            black_control += 1\n    \n    return white_control - black_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat to safety when attacked\"\n    white_safe_retreats = 0\n    black_safe_retreats = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(not piece.color, square):\n            retreat_count = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    board.push(move)\n                    if not board.is_attacked_by(not piece.color, move.to_square):\n                        retreat_count += 1\n                    board.pop()\n            \n            if piece.color == chess.WHITE:\n                white_safe_retreats += retreat_count\n            else:\n                black_safe_retreats += retreat_count\n    \n    return float(white_safe_retreats - black_safe_retreats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that can move to the center four squares\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                value = piece_values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total_value += value\n                else:\n                    total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of all pieces for the side to move\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    ranks = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            rank = chess.square_rank(square)\n            if color == chess.BLACK:\n                rank = 7 - rank\n            ranks.append(rank)\n    \n    return sum(ranks) / len(ranks) if ranks else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending the back rank between white and black\"\n    white_back_rank_defenders = 0\n    black_back_rank_defenders = 0\n    \n    # Count white pieces defending rank 1\n    for square in range(chess.A1, chess.H1 + 1):\n        defenders = board.attackers(chess.WHITE, square)\n        white_back_rank_defenders += len(defenders)\n    \n    # Count black pieces defending rank 8  \n    for square in range(chess.A8, chess.H8 + 1):\n        defenders = board.attackers(chess.BLACK, square)\n        black_back_rank_defenders += len(defenders)\n        \n    return float(white_back_rank_defenders - black_back_rank_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black pieces\"\n    white_moves = 0\n    black_moves = 0\n    if board.turn == chess.WHITE:\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_moves = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        white_moves = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on light squares vs dark squares for current player\"\n    light_pieces = 0\n    dark_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_pieces += 1\n            else:\n                light_pieces += 1\n    \n    total = light_pieces + dark_pieces\n    if total == 0:\n        return 0.0\n    return float(light_pieces) / float(total)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen activity measured by number of squares it attacks weighted by square importance\"\n    activity = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.QUEEN:\n            attacks = 0\n            for target in chess.SQUARES:\n                if board.is_attacked_by(piece.color, target):\n                    rank = chess.square_rank(target)\n                    file = chess.square_file(target)\n                    center_distance = abs(3.5 - file) + abs(3.5 - rank)\n                    importance = 1.0 / (1.0 + center_distance * 0.2)\n                    if piece.color == chess.WHITE and rank >= 4:\n                        importance *= 1.3\n                    elif piece.color == chess.BLACK and rank <= 3:\n                        importance *= 1.3\n                    attacks += importance\n            if piece.color == chess.WHITE:\n                activity += attacks\n            else:\n                activity -= attacks\n    return activity\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of enemy pieces within 3 squares of our king to total enemy pieces\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    enemy_pieces_near_king = 0\n    total_enemy_pieces = 0\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            total_enemy_pieces += 1\n            piece_file, piece_rank = chess.square_file(square), chess.square_rank(square)\n            if abs(piece_file - king_file) <= 3 and abs(piece_rank - king_rank) <= 3:\n                enemy_pieces_near_king += 1\n    \n    return float(enemy_pieces_near_king) / max(1.0, float(total_enemy_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white pieces to total pieces on the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.5\n    white_pieces = sum(1 for piece in piece_map.values() if piece.color == chess.WHITE)\n    total_pieces = len(piece_map)\n    return white_pieces / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces under direct attack by white pieces\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            if board.is_attacked_by(chess.WHITE, square):\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their starting rank vs advanced pieces\"\n    on_starting = 0\n    advanced = 0\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    starting_rank = 0 if current_color == chess.WHITE else 7\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == current_color and piece.piece_type != chess.PAWN:\n            rank = chess.square_rank(square)\n            if rank == starting_rank:\n                on_starting += 1\n            else:\n                advanced += 1\n    \n    total = on_starting + advanced\n    return float(on_starting / total) if total > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance from white king to black king\"\n    white_king = None\n    black_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    if white_king is None or black_king is None:\n        return 0.0\n    return float(chess.square_distance(white_king, black_king))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their starting squares\"\n    total_distance = 0\n    piece_count = 0\n    starting_squares = {\n        (chess.PAWN, chess.WHITE): [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        (chess.PAWN, chess.BLACK): [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        (chess.ROOK, chess.WHITE): [chess.A1, chess.H1],\n        (chess.ROOK, chess.BLACK): [chess.A8, chess.H8],\n        (chess.KNIGHT, chess.WHITE): [chess.B1, chess.G1],\n        (chess.KNIGHT, chess.BLACK): [chess.B8, chess.G8],\n        (chess.BISHOP, chess.WHITE): [chess.C1, chess.F1],\n        (chess.BISHOP, chess.BLACK): [chess.C8, chess.F8],\n        (chess.QUEEN, chess.WHITE): [chess.D1],\n        (chess.QUEEN, chess.BLACK): [chess.D8],\n        (chess.KING, chess.WHITE): [chess.E1],\n        (chess.KING, chess.BLACK): [chess.E8],\n    }\n    \n    for square, piece in board.piece_map().items():\n        if (piece.piece_type, piece.color) in starting_squares:\n            min_dist = min(chess.square_distance(square, start_sq) for start_sq in starting_squares[(piece.piece_type, piece.color)])\n            total_distance += min_dist\n            piece_count += 1\n    \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in enemy half of the board\"\n    pieces_in_enemy_half = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            total_pieces += 1\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3):\n                pieces_in_enemy_half += 1\n    \n    return float(pieces_in_enemy_half / max(1, total_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond the 4th rank for the side to move\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == board.turn:\n                if piece.color == chess.WHITE and rank >= 4:\n                    count += 1\n                elif piece.color == chess.BLACK and rank <= 3:\n                    count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average number of legal moves per piece for the side to move\"\n    pieces = [piece for piece in board.piece_map().values() if piece.color == board.turn]\n    if not pieces:\n        return 0.0\n    return float(len(list(board.legal_moves))) / len(pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of hanging pieces (attacked and undefended) weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_hanging = 0\n    black_hanging = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece is None:\n            continue\n            \n        enemy_color = not piece.color\n        ally_color = piece.color\n        \n        # Check if piece is attacked and undefended\n        if board.is_attacked_by(enemy_color, square) and not board.is_attacked_by(ally_color, square):\n            value = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                black_hanging += value  # White's hanging piece benefits black\n            else:\n                white_hanging += value  # Black's hanging piece benefits white\n    \n    return white_hanging - black_hanging\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by how advanced they are\"\n    passed_count = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (rank - 1) * (1.0 if piece.color == chess.WHITE else -1.0)\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (6 - rank) * (-1.0)\n    \n    return passed_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled in the center four squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlled = 0\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled -= 1\n    return float(controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in queen activity measured by squares attacked by each queen\"\n    white_queen_attacks = 0\n    black_queen_attacks = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            if piece.color == chess.WHITE:\n                white_queen_attacks = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(square) and board.piece_at(square).piece_type == chess.QUEEN])\n            else:\n                black_queen_attacks = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(square) and board.piece_at(square).piece_type == chess.QUEEN])\n    \n    return white_queen_attacks - black_queen_attacks\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_attacks = 0\n    black_central_attacks = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_central_attacks += white_attackers\n        black_central_attacks += black_attackers\n    \n    return float(white_central_attacks - black_central_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king on adjacent squares\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    \n    if king_square is None:\n        return 0.0\n    \n    defenders = 0\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    \n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file, new_rank = king_file + file_offset, king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adjacent_square = chess.square(new_file, new_rank)\n                piece = board.piece_at(adjacent_square)\n                if piece and piece.color == board.turn:\n                    defenders += 1\n    \n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of total piece mobility to total pieces on board\"\n    total_moves = sum(1 for _ in board.legal_moves)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    mobility_ratio = total_moves / total_pieces\n    return mobility_ratio if board.turn == chess.WHITE else -mobility_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility between white and black\"\n    current_turn = board.turn\n    \n    board.turn = chess.WHITE\n    white_mobility = len(list(board.legal_moves))\n    \n    board.turn = chess.BLACK\n    black_mobility = len(list(board.legal_moves))\n    \n    board.turn = current_turn\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces within 2 squares of own king\"\n    kings = [(board.king(chess.WHITE), chess.BLACK), (board.king(chess.BLACK), chess.WHITE)]\n    total_threats = 0\n    \n    for king_square, enemy_color in kings:\n        if king_square is None:\n            continue\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == enemy_color:\n                if chess.square_distance(king_square, square) <= 2:\n                    total_threats += 1\n    \n    return float(total_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces minus average rank of black pieces\"\n    white_ranks = []\n    black_ranks = []\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_ranks.append(rank)\n        else:\n            black_ranks.append(rank)\n    \n    white_avg = sum(white_ranks) / len(white_ranks) if white_ranks else 0\n    black_avg = sum(black_ranks) / len(black_ranks) if black_ranks else 0\n    \n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the own king's adjacent squares\"\n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    defenders = 0\n    king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            adj_file, adj_rank = king_file + file_offset, king_rank + rank_offset\n            if 0 <= adj_file <= 7 and 0 <= adj_rank <= 7:\n                adj_square = chess.square(adj_file, adj_rank)\n                if board.is_attacked_by(board.turn, adj_square):\n                    defenders += 1\n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        total_distance += min_center_dist\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    return float(total_distance / piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance += min_center_dist\n        else:\n            total_distance -= min_center_dist\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by pawns in the opponent's territory\"\n    white_control = 0\n    black_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if piece.color == chess.WHITE and rank >= 4:\n                if file > 0 and rank < 7:\n                    white_control += 1\n                if file < 7 and rank < 7:\n                    white_control += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                if file > 0 and rank > 0:\n                    black_control += 1\n                if file < 7 and rank > 0:\n                    black_control += 1\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of opponent's pieces from their own king\"\n    enemy_color = not board.turn\n    enemy_king_sq = board.king(enemy_color)\n    if enemy_king_sq is None:\n        return 0.0\n    \n    enemy_pieces = [sq for sq, piece in board.piece_map().items() \n                   if piece.color == enemy_color and piece.piece_type != chess.KING]\n    if not enemy_pieces:\n        return 0.0\n    \n    total_distance = sum(chess.square_distance(enemy_king_sq, sq) for sq in enemy_pieces)\n    return total_distance / len(enemy_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted sum of piece mobility considering piece values\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    mobility_score = 0.0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                mobility_score += weight\n            else:\n                mobility_score -= weight\n    \n    return mobility_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending the respective kings\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    white_defenders = len(board.attackers(chess.WHITE, white_king_sq)) if white_king_sq else 0\n    black_defenders = len(board.attackers(chess.BLACK, black_king_sq)) if black_king_sq else 0\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances between queen and friendly knights\"\n    queen_pos = None\n    knight_positions = []\n    \n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if piece.piece_type == chess.QUEEN:\n                queen_pos = square\n            elif piece.piece_type == chess.KNIGHT:\n                knight_positions.append(square)\n    \n    if queen_pos is None or not knight_positions:\n        return 8.0\n    \n    total_distance = sum(chess.square_distance(queen_pos, knight_pos) for knight_pos in knight_positions)\n    return total_distance / len(knight_positions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of total piece mobility to total pieces on board\"\n    total_moves = sum(1 for _ in board.legal_moves)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    mobility_ratio = total_moves / total_pieces\n    return mobility_ratio if board.turn == chess.WHITE else -mobility_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their starting files\"\n    white_on_start = 0\n    black_on_start = 0\n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        if piece.color == chess.WHITE:\n            if piece.piece_type == chess.ROOK and file in [0, 7]:\n                white_on_start += 1\n            elif piece.piece_type == chess.KNIGHT and file in [1, 6]:\n                white_on_start += 1\n            elif piece.piece_type == chess.BISHOP and file in [2, 5]:\n                white_on_start += 1\n            elif piece.piece_type == chess.QUEEN and file == 3:\n                white_on_start += 1\n            elif piece.piece_type == chess.KING and file == 4:\n                white_on_start += 1\n        else:\n            if piece.piece_type == chess.ROOK and file in [0, 7]:\n                black_on_start += 1\n            elif piece.piece_type == chess.KNIGHT and file in [1, 6]:\n                black_on_start += 1\n            elif piece.piece_type == chess.BISHOP and file in [2, 5]:\n                black_on_start += 1\n            elif piece.piece_type == chess.QUEEN and file == 3:\n                black_on_start += 1\n            elif piece.piece_type == chess.KING and file == 4:\n                black_on_start += 1\n    return float(white_on_start - black_on_start)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of squares any white piece attacks\"\n    max_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece and piece.color == chess.WHITE:\n            attacks = len(board.attackers(chess.WHITE, square))\n            if attacks > max_attacks:\n                max_attacks = attacks\n    return float(max_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending key central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_defenders = 0\n    black_defenders = 0\n    \n    for square in central_squares:\n        white_defenders += len(board.attackers(chess.WHITE, square))\n        black_defenders += len(board.attackers(chess.BLACK, square))\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of consecutive ranks without any pieces\"\n    rank_occupancy = [False] * 8\n    \n    for square in board.piece_map().keys():\n        rank = chess.square_rank(square)\n        rank_occupancy[rank] = True\n    \n    max_empty_consecutive = 0\n    current_empty = 0\n    \n    for occupied in rank_occupancy:\n        if not occupied:\n            current_empty += 1\n            max_empty_consecutive = max(max_empty_consecutive, current_empty)\n        else:\n            current_empty = 0\n    \n    return float(max_empty_consecutive)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn breakthrough opportunities considering king support\"\n    breakthrough_count = 0.0\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if piece.color == chess.WHITE and rank >= 4:\n                # Check if path to promotion is clear\n                clear_path = True\n                for r in range(rank + 1, 8):\n                    blocking_square = chess.square(file, r)\n                    if board.piece_at(blocking_square) is not None:\n                        clear_path = False\n                        break\n                \n                if clear_path:\n                    king_support = 1.0 / max(1, chess.square_distance(white_king, square))\n                    breakthrough_count += king_support\n            \n            elif piece.color == chess.BLACK and rank <= 3:\n                clear_path = True\n                for r in range(rank - 1, -1, -1):\n                    blocking_square = chess.square(file, r)\n                    if board.piece_at(blocking_square) is not None:\n                        clear_path = False\n                        break\n                \n                if clear_path:\n                    king_support = 1.0 / max(1, chess.square_distance(black_king, square))\n                    breakthrough_count -= king_support\n    \n    return breakthrough_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum number of pieces that can be captured by white in one move\"\n    max_captures = 0\n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            if captured_piece:\n                piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n                value = piece_values.get(captured_piece.piece_type, 0)\n                max_captures = max(max_captures, value)\n    return float(max_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of defended to undefended pieces for current player\"\n    defended = 0\n    undefended = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.attackers(board.turn, square):\n                defended += 1\n            else:\n                undefended += 1\n    \n    total = defended + undefended\n    return defended / total if total > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from pieces to enemy king\"\n    enemy_king = board.king(not board.turn)\n    if not enemy_king:\n        return 0.0\n    \n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = chess.square_distance(square, enemy_king)\n            total_distance += distance\n    \n    return float(total_distance) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by how advanced they are\"\n    passed_count = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (rank - 1) * (1.0 if piece.color == chess.WHITE else -1.0)\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (6 - rank) * (-1.0)\n    \n    return passed_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled in opponent's half of the board\"\n    white_control = black_control = 0\n    for square in range(64):\n        rank = chess.square_rank(square)\n        if rank >= 4:  # White's attacking half\n            if board.is_attacked_by(chess.WHITE, square):\n                white_control += 1\n        if rank <= 3:  # Black's attacking half\n            if board.is_attacked_by(chess.BLACK, square):\n                black_control += 1\n    return white_control - black_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on distance from opponent pieces\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_safety = 0.0\n    black_safety = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            white_safety += chess.square_distance(white_king_square, square)\n        elif piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            black_safety += chess.square_distance(black_king_square, square)\n    \n    return white_safety - black_safety\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of weak squares (undefended and not occupied by pawns) in enemy camp\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    weak_squares = 0\n    enemy_ranks = [5, 6, 7] if enemy_color == chess.BLACK else [0, 1, 2]\n    \n    for rank in enemy_ranks:\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            \n            # Skip if occupied by enemy pawn\n            if piece and piece.piece_type == chess.PAWN and piece.color == enemy_color:\n                continue\n            \n            # Check if square is defended by enemy\n            if not board.is_attacked_by(enemy_color, square):\n                weak_squares += 1\n    \n    return float(weak_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares to total pieces\"\n    optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.F3, chess.C6, chess.F6, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.BISHOP: [chess.C4, chess.F4, chess.C5, chess.F5],\n        chess.ROOK: [chess.D1, chess.E1, chess.D8, chess.E8, chess.A7, chess.B7, chess.G7, chess.H7]\n    }\n    \n    optimal_count = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]:\n            total_pieces += 1\n            if piece.piece_type in optimal_squares and square in optimal_squares[piece.piece_type]:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n    \n    return optimal_count / max(1, total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in enemy territory vs own territory\"\n    own_pieces_forward = 0\n    total_own_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_own_pieces += 1\n            rank = chess.square_rank(square)\n            if board.turn == chess.WHITE and rank >= 4:\n                own_pieces_forward += 1\n            elif board.turn == chess.BLACK and rank <= 3:\n                own_pieces_forward += 1\n    \n    if total_own_pieces == 0:\n        return 0.0\n    \n    return float(own_pieces_forward) / float(total_own_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between white and black heavy pieces\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            attacks = len(board.attackers(piece.color, square))\n            moves = len([move for move in board.legal_moves if move.from_square == square])\n            mobility = attacks + moves\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on files containing enemy pieces\"\n    white_files = set()\n    black_files = set()\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        if piece.color == chess.WHITE:\n            white_files.add(file)\n        else:\n            black_files.add(file)\n    \n    white_on_black_files = 0\n    black_on_white_files = 0\n    \n    for square, piece in board.piece_map().items():\n        file = chess.square_file(square)\n        if piece.color == chess.WHITE and file in black_files:\n            white_on_black_files += 1\n        elif piece.color == chess.BLACK and file in white_files:\n            black_on_white_files += 1\n    \n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    if total_white == 0 and total_black == 0:\n        return 0.0\n    \n    white_ratio = white_on_black_files / total_white if total_white > 0 else 0.0\n    black_ratio = black_on_white_files / total_black if total_black > 0 else 0.0\n    \n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of doubled pawns between white and black\"\n    def count_doubled_pawns(color):\n        files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN and piece.color == color:\n                files[chess.square_file(square)] += 1\n        return sum(max(0, count - 1) for count in files)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares to total pieces\"\n    optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.F3, chess.C6, chess.F6, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.BISHOP: [chess.C4, chess.F4, chess.C5, chess.F5],\n        chess.ROOK: [chess.D1, chess.E1, chess.D8, chess.E8, chess.A7, chess.B7, chess.G7, chess.H7]\n    }\n    \n    optimal_count = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]:\n            total_pieces += 1\n            if piece.piece_type in optimal_squares and square in optimal_squares[piece.piece_type]:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n    \n    return optimal_count / max(1, total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in queen activity measured by squares attacked by each queen\"\n    white_queen_attacks = 0\n    black_queen_attacks = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            if piece.color == chess.WHITE:\n                white_queen_attacks = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(square) and board.piece_at(square).piece_type == chess.QUEEN])\n            else:\n                black_queen_attacks = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(square) and board.piece_at(square).piece_type == chess.QUEEN])\n    \n    return white_queen_attacks - black_queen_attacks\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of squares controlled in opponent's half of the board\"\n    controlled_squares = 0\n    for square in range(64):\n        rank = chess.square_rank(square)\n        target_ranks = [4, 5, 6, 7] if board.turn else [0, 1, 2, 3]\n        if rank in target_ranks and board.is_attacked_by(board.turn, square):\n            controlled_squares += 1\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of total piece mobility to total pieces on board\"\n    total_moves = sum(1 for _ in board.legal_moves)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    mobility_ratio = total_moves / total_pieces\n    return mobility_ratio if board.turn == chess.WHITE else -mobility_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and penalty for blocked bishops\"\n    white_bishops = 0\n    black_bishops = 0\n    white_blocked = 0\n    black_blocked = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    white_blocked += 1\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    black_blocked += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 0.5\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 0.5\n    \n    return bishop_pair_bonus + (black_blocked - white_blocked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn breakthrough potential measured by clear paths to promotion\"\n    score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            promotion_rank = 7\n            direction = 1\n        else:\n            promotion_rank = 0\n            direction = -1\n        clear_path = True\n        for check_rank in range(rank + direction, promotion_rank + direction, direction):\n            check_square = chess.square(file, check_rank)\n            if board.piece_at(check_square) is not None:\n                clear_path = False\n                break\n        if clear_path:\n            advancement = abs(rank - (0 if piece.color == chess.WHITE else 7))\n            multiplier = 1.0 if piece.color == chess.WHITE else -1.0\n            score += multiplier * (advancement * advancement)\n    return score\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces in the opponent's half of the board\"\n    pieces_in_enemy_half = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 4:\n            pieces_in_enemy_half += 1\n        elif piece.color == chess.BLACK and rank <= 3:\n            pieces_in_enemy_half += 1\n    return float(pieces_in_enemy_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of minor pieces positioned on optimal squares for their type\"\n    optimal_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            center_distance = abs(3.5 - rank) + abs(3.5 - file)\n            score = max(0, 7 - center_distance) / 7\n            optimal_score += score if piece.color == chess.WHITE else -score\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if (rank + file) % 2 == 0:  # Light squared bishop\n                score = 1 if abs(rank - file) <= 2 else 0.5\n            else:  # Dark squared bishop\n                score = 1 if abs(rank + file - 7) <= 2 else 0.5\n            optimal_score += score if piece.color == chess.WHITE else -score\n    \n    return float(optimal_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can give check in one move\"\n    check_count = 0\n    current_turn = board.turn\n    board.turn = chess.WHITE\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    board.turn = current_turn\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety score based on number of pieces around each king\"\n    white_king_safety = 0\n    black_king_safety = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            king_square = square\n            safety_count = 0\n            \n            # Check 8 squares around king\n            for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n                neighbor_square = king_square + delta\n                if 0 <= neighbor_square < 64:\n                    neighbor_piece = board.piece_at(neighbor_square)\n                    if neighbor_piece and neighbor_piece.color == piece.color:\n                        safety_count += 1\n            \n            if piece.color == chess.WHITE:\n                white_king_safety = safety_count\n            else:\n                black_king_safety = safety_count\n    \n    return float(white_king_safety - black_king_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces that are undefended and can be attacked\"\n    undefended_attackable = 0\n    enemy_color = not board.turn\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color:\n            defenders = len(board.attackers(enemy_color, square))\n            attackers = len(board.attackers(board.turn, square))\n            if defenders == 0 and attackers > 0:\n                undefended_attackable += 1\n    \n    return float(undefended_attackable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces defending the back rank between white and black\"\n    white_back_rank_defenders = 0\n    black_back_rank_defenders = 0\n    \n    # Count white pieces defending rank 1\n    for square in range(chess.A1, chess.H1 + 1):\n        defenders = board.attackers(chess.WHITE, square)\n        white_back_rank_defenders += len(defenders)\n    \n    # Count black pieces defending rank 8  \n    for square in range(chess.A8, chess.H8 + 1):\n        defenders = board.attackers(chess.BLACK, square)\n        black_back_rank_defenders += len(defenders)\n        \n    return float(white_back_rank_defenders - black_back_rank_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can support a pawn advance to the 6th/7th rank\"\n    support_count = 0\n    advance_rank = 5 if board.turn == chess.WHITE else 2\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            pawn_rank = chess.square_rank(square)\n            if (board.turn == chess.WHITE and pawn_rank >= 4) or (board.turn == chess.BLACK and pawn_rank <= 3):\n                file = chess.square_file(square)\n                target_square = chess.square(file, advance_rank)\n                supporters = len(board.attackers(board.turn, target_square))\n                if supporters > 0:\n                    support_count += supporters\n    \n    return float(support_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in queen mobility between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.QUEEN:\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond their 4th rank\"\n    advanced_pawns = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns -= 1\n    \n    return advanced_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of values of black pieces under attack weighted by attack frequency\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                   chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    total_threat_value = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.BLACK:\n            attackers = len(board.attackers(chess.WHITE, square))\n            if attackers > 0:\n                total_threat_value += piece_values[piece.piece_type] * attackers\n    \n    return total_threat_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on opponent's half of the board\"\n    white_advanced = 0\n    black_advanced = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                white_advanced += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                black_advanced += 1\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat to safety when attacked\"\n    white_safe_retreats = 0\n    black_safe_retreats = 0\n    \n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            safe_squares = 0\n            test_board = board.copy()\n            test_board.remove_piece_at(square)\n            \n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if not test_board.is_attacked_by(not piece.color, move.to_square):\n                        safe_squares += 1\n            \n            if piece.color == chess.WHITE:\n                white_safe_retreats += min(safe_squares, 3)\n            else:\n                black_safe_retreats += min(safe_squares, 3)\n    \n    return white_safe_retreats - black_safe_retreats\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces within 2 squares of our king that are undefended\"\n    our_king_square = board.king(board.turn)\n    if our_king_square is None:\n        return 0.0\n    \n    vulnerable_attackers = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(our_king_square, square)\n            if distance <= 2:\n                if not board.is_attacked_by(not piece.color, square):\n                    vulnerable_attackers += 1\n    \n    return float(vulnerable_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by pawns in opponent's half of board\"\n    my_color = chess.WHITE if board.turn else chess.BLACK\n    target_ranks = range(4, 8) if my_color == chess.WHITE else range(0, 4)\n    \n    controlled_squares = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == my_color:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if my_color == chess.WHITE:\n                attack_squares = []\n                if rank < 7 and file > 0:\n                    attack_squares.append(chess.square(file - 1, rank + 1))\n                if rank < 7 and file < 7:\n                    attack_squares.append(chess.square(file + 1, rank + 1))\n            else:\n                attack_squares = []\n                if rank > 0 and file > 0:\n                    attack_squares.append(chess.square(file - 1, rank - 1))\n                if rank > 0 and file < 7:\n                    attack_squares.append(chess.square(file + 1, rank - 1))\n            \n            for sq in attack_squares:\n                if chess.square_rank(sq) in target_ranks:\n                    controlled_squares += 1\n    \n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of backward pawns that cannot advance safely\"\n    backward_pawns = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type != chess.PAWN:\n            continue\n            \n        file_idx = chess.square_file(square)\n        rank_idx = chess.square_rank(square)\n        \n        if piece.color == chess.WHITE:\n            advance_square = square + 8 if rank_idx < 7 else None\n        else:\n            advance_square = square - 8 if rank_idx > 0 else None\n            \n        if advance_square and board.is_attacked_by(not piece.color, advance_square):\n            if piece.color == chess.WHITE:\n                backward_pawns += 1\n            else:\n                backward_pawns -= 1\n    \n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of active pieces to total pieces for current player\"\n    piece_map = board.piece_map()\n    current_color = board.turn\n    \n    total_pieces = 0\n    active_pieces = 0\n    \n    for square, piece in piece_map.items():\n        if piece.color == current_color and piece.piece_type != chess.KING:\n            total_pieces += 1\n            moves = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    moves += 1\n            if moves > 0:\n                active_pieces += 1\n    \n    if total_pieces == 0:\n        return 0.0\n    return float(active_pieces) / float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance from white major pieces to black king\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    major_pieces = []\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            major_pieces.append(square)\n    \n    if not major_pieces:\n        return 0.0\n    \n    total_distance = sum(chess.square_distance(square, black_king_square) for square in major_pieces)\n    return float(total_distance) / len(major_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares attacked by white queen\"\n    queen_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN and piece.color == chess.WHITE:\n            queen_attacks += len(board.attacks(square))\n    return float(queen_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can attack the black king in two moves\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            # Check squares this piece can reach in one move\n            temp_board = board.copy()\n            temp_board.turn = chess.WHITE\n            for move in temp_board.legal_moves:\n                if move.from_square == square:\n                    temp_board.push(move)\n                    if temp_board.is_attacked_by(chess.WHITE, black_king_square):\n                        count += 1\n                        temp_board.pop()\n                        break\n                    temp_board.pop()\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of white piece values weighted by their proximity to black king\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type != chess.KING:\n            distance = chess.square_distance(square, black_king_square)\n            weight = 8 - distance if distance < 8 else 1\n            total_weighted_value += piece_values[piece.piece_type] * weight\n    \n    return total_weighted_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of piece values on central four squares\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                   chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_value = 0.0\n    \n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            value = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                total_value += value\n            else:\n                total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of enemy pieces from their king\"\n    enemy_color = not board.turn\n    enemy_king = board.king(enemy_color)\n    if enemy_king is None:\n        return 0.0\n    \n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            total_distance += chess.square_distance(square, enemy_king)\n            piece_count += 1\n    \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of minimum moves needed for all pawns to promote weighted by advancement\"\n    total_weighted_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                moves_to_promote = 7 - rank\n                advancement_weight = rank / 7.0\n            else:\n                moves_to_promote = rank\n                advancement_weight = (7 - rank) / 7.0\n            \n            weighted_distance = moves_to_promote * (1.0 + advancement_weight)\n            if piece.color == chess.WHITE:\n                total_weighted_distance += weighted_distance\n            else:\n                total_weighted_distance -= weighted_distance\n    \n    return total_weighted_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled exclusively by one side\"\n    white_controlled = set()\n    black_controlled = set()\n    \n    for square in range(64):\n        white_attacks = len(board.attackers(chess.WHITE, square))\n        black_attacks = len(board.attackers(chess.BLACK, square))\n        \n        if white_attacks > 0 and black_attacks == 0:\n            white_controlled.add(square)\n        elif black_attacks > 0 and white_attacks == 0:\n            black_controlled.add(square)\n    \n    return float(len(white_controlled) - len(black_controlled))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure evaluation focusing on isolated and backward pawns\"\n    pawn_structure_score = 0.0\n    for color in [chess.WHITE, chess.BLACK]:\n        multiplier = 1.0 if color == chess.WHITE else -1.0\n        pawn_files = set()\n        for square, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN and piece.color == color:\n                pawn_files.add(chess.square_file(square))\n        \n        for square, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN and piece.color == color:\n                file = chess.square_file(square)\n                # Check for isolated pawns\n                if (file - 1) not in pawn_files and (file + 1) not in pawn_files:\n                    pawn_structure_score -= 0.5 * multiplier\n    return pawn_structure_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced past the 5th rank relative to their starting position\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by black pieces (a=0, h=7)\"\n    file_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            file_sum += chess.square_file(square)\n    return float(file_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured without immediate recapture\"\n    safe_captures = 0\n    current_color = board.turn\n    \n    for move in board.legal_moves:\n        if board.piece_at(move.to_square):  # Capture move\n            board.push(move)\n            \n            # Check if the capturing piece can be immediately recaptured\n            can_recapture = board.is_attacked_by(not current_color, move.to_square)\n            \n            if not can_recapture:\n                safe_captures += 1\n            \n            board.pop()\n    \n    return float(safe_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces minus average rank of black pieces\"\n    white_ranks = []\n    black_ranks = []\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_ranks.append(rank)\n        else:\n            black_ranks.append(rank)\n    \n    white_avg = sum(white_ranks) / len(white_ranks) if white_ranks else 0\n    black_avg = sum(black_ranks) / len(black_ranks) if black_ranks else 0\n    \n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average number of squares each piece type can move to\"\n    piece_mobility = {}\n    piece_counts = {}\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            piece_type = piece.piece_type\n            if piece_type not in piece_mobility:\n                piece_mobility[piece_type] = 0\n                piece_counts[piece_type] = 0\n            piece_mobility[piece_type] += 1\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_counts[piece.piece_type] = piece_counts.get(piece.piece_type, 0) + 1\n    \n    total_avg_mobility = 0.0\n    for piece_type in piece_mobility:\n        if piece_counts[piece_type] > 0:\n            total_avg_mobility += piece_mobility[piece_type] / piece_counts[piece_type]\n    \n    return total_avg_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their starting squares\"\n    total_distance = 0\n    piece_count = 0\n    starting_positions = {\n        chess.WHITE: {\n            chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n            chess.ROOK: [chess.A1, chess.H1],\n            chess.KNIGHT: [chess.B1, chess.G1],\n            chess.BISHOP: [chess.C1, chess.F1],\n            chess.QUEEN: [chess.D1],\n            chess.KING: [chess.E1]\n        },\n        chess.BLACK: {\n            chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n            chess.ROOK: [chess.A8, chess.H8],\n            chess.KNIGHT: [chess.B8, chess.G8],\n            chess.BISHOP: [chess.C8, chess.F8],\n            chess.QUEEN: [chess.D8],\n            chess.KING: [chess.E8]\n        }\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in starting_positions[piece.color]:\n            min_dist = min(chess.square_distance(square, start_sq) \n                          for start_sq in starting_positions[piece.color][piece.piece_type])\n            total_distance += min_dist\n            piece_count += 1\n    \n    return float(total_distance / piece_count if piece_count > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    pieces_controlling_center = 0\n    for move in board.legal_moves:\n        if move.to_square in central_squares:\n            pieces_controlling_center += 1\n    return float(pieces_controlling_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat to safety when attacked\"\n    white_safe_retreats = 0\n    black_safe_retreats = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece is None:\n            continue\n            \n        # Check if piece is attacked\n        enemy_color = not piece.color\n        if board.is_attacked_by(enemy_color, square):\n            # Count safe retreat squares\n            retreat_count = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    # Temporarily make move to check safety\n                    board.push(move)\n                    if not board.is_attacked_by(enemy_color, move.to_square):\n                        retreat_count += 1\n                    board.pop()\n            \n            if piece.color == chess.WHITE:\n                white_safe_retreats += retreat_count\n            else:\n                black_safe_retreats += retreat_count\n    \n    return white_safe_retreats - black_safe_retreats\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queens to total material value on the board\"\n    total_value = 0\n    queen_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value\n        if piece.piece_type == chess.QUEEN:\n            queen_value += value\n    \n    return queen_value / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares between enemy king and nearest friendly major piece\"\n    piece_map = board.piece_map()\n    enemy_king_square = None\n    friendly_major_pieces = []\n    \n    enemy_color = chess.BLACK if board.turn else chess.WHITE\n    friendly_color = chess.WHITE if board.turn else chess.BLACK\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n        elif piece.color == friendly_color and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            friendly_major_pieces.append(square)\n    \n    if enemy_king_square is None or not friendly_major_pieces:\n        return 10.0\n    \n    min_distance = min(chess.square_distance(enemy_king_square, piece_sq) for piece_sq in friendly_major_pieces)\n    return float(min_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by how advanced they are\"\n    passed_count = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (rank - 1) * (1.0 if piece.color == chess.WHITE else -1.0)\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_count += (6 - rank) * (-1.0)\n    \n    return passed_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on distance to enemy pieces\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if not white_king_square or not black_king_square:\n        return 0.0\n    \n    white_danger = 0.0\n    black_danger = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            white_dist = chess.square_distance(white_king_square, square)\n            black_dist = chess.square_distance(black_king_square, square)\n            piece_value = [0, 1, 3, 3, 5, 9][piece.piece_type]\n            \n            if piece.color == chess.BLACK:\n                white_danger += piece_value / max(1, white_dist)\n            else:\n                black_danger += piece_value / max(1, black_dist)\n    \n    return black_danger - white_danger\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to safety when attacked\"\n    retreat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(chess.BLACK, move.to_square):\n                            retreat_count += 1\n                            board.pop()\n                            break\n                        board.pop()\n        else:\n            if board.is_attacked_by(chess.WHITE, square):\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(chess.WHITE, move.to_square):\n                            retreat_count -= 1\n                            board.pop()\n                            break\n                        board.pop()\n    return float(retreat_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on light squares to pieces on dark squares for both sides combined\"\n    light_squares = 0\n    dark_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_squares += 1\n            else:\n                light_squares += 1\n    if dark_squares == 0:\n        return 10.0 if light_squares > 0 else 1.0\n    return light_squares / dark_squares\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook connectivity and coordination measured by rooks on same rank or file\"\n    white_rooks = []\n    black_rooks = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            if piece.color == chess.WHITE:\n                white_rooks.append(square)\n            else:\n                black_rooks.append(square)\n    \n    white_coord = 0\n    black_coord = 0\n    \n    for i in range(len(white_rooks)):\n        for j in range(i + 1, len(white_rooks)):\n            if chess.square_file(white_rooks[i]) == chess.square_file(white_rooks[j]) or \\\n               chess.square_rank(white_rooks[i]) == chess.square_rank(white_rooks[j]):\n                white_coord += 1\n    \n    for i in range(len(black_rooks)):\n        for j in range(i + 1, len(black_rooks)):\n            if chess.square_file(black_rooks[i]) == chess.square_file(black_rooks[j]) or \\\n               chess.square_rank(black_rooks[i]) == chess.square_rank(black_rooks[j]):\n                black_coord += 1\n    \n    return white_coord - black_coord\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their optimal squares\"\n    optimal_scores = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        score = 0\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            center_distance = abs(file - 3.5) + abs(rank - 3.5)\n            score = max(0, 4 - center_distance) / 4\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if (file + rank) % 7 == 0 or abs(file - rank) <= 1:\n                score = 1.0\n        elif piece.piece_type == chess.ROOK:\n            # Rooks better on open/semi-open files and 7th/8th ranks\n            if piece.color == chess.WHITE and rank >= 6:\n                score = 0.5\n            elif piece.color == chess.BLACK and rank <= 1:\n                score = 0.5\n        \n        optimal_scores[piece.color] += score\n    \n    return optimal_scores[chess.WHITE] - optimal_scores[chess.BLACK]\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can capture enemy pieces next move\"\n    white_captures = 0\n    black_captures = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            piece = board.piece_at(move.from_square)\n            if piece and piece.color == chess.WHITE:\n                white_captures += 1\n            elif piece and piece.color == chess.BLACK:\n                black_captures += 1\n    \n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in one move\"\n    check_count = 0\n    current_color = board.turn\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares the black king can move to safely\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    safe_squares = 0\n    king_moves = [\n        black_king_square + 8, black_king_square - 8,\n        black_king_square + 1, black_king_square - 1,\n        black_king_square + 9, black_king_square - 9,\n        black_king_square + 7, black_king_square - 7\n    ]\n    \n    for move_square in king_moves:\n        if 0 <= move_square <= 63:\n            if not board.is_attacked_by(chess.WHITE, move_square):\n                if board.piece_at(move_square) is None or board.piece_at(move_square).color == chess.WHITE:\n                    safe_squares += 1\n    \n    return float(safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces minus average rank of black pieces\"\n    white_ranks = []\n    black_ranks = []\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_ranks.append(rank)\n        else:\n            black_ranks.append(rank)\n    \n    if not white_ranks or not black_ranks:\n        return 0.0\n    \n    return sum(white_ranks) / len(white_ranks) - sum(black_ranks) / len(black_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of enemy pieces from their optimal squares\"\n    total_distance = 0\n    piece_count = 0\n    optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.F3, chess.C6, chess.F6, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.BISHOP: [chess.C4, chess.F4, chess.C5, chess.F5, chess.D4, chess.E4, chess.D5, chess.E5],\n        chess.QUEEN: [chess.D4, chess.E4, chess.D5, chess.E5]\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != chess.WHITE and piece.piece_type in optimal_squares:\n            min_distance = min(chess.square_distance(square, opt_sq) for opt_sq in optimal_squares[piece.piece_type])\n            total_distance += min_distance\n            piece_count += 1\n    \n    return float(total_distance / max(piece_count, 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of rooks on open or semi-open files\"\n    open_file_rooks = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            file_idx = chess.square_file(square)\n            has_own_pawn = False\n            has_enemy_pawn = False\n            for rank in range(8):\n                check_square = chess.square(file_idx, rank)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        has_own_pawn = True\n                    else:\n                        has_enemy_pawn = True\n            if not has_own_pawn:\n                weight = 1.0 if piece.color == chess.WHITE else -1.0\n                open_file_rooks += weight * (2.0 if not has_enemy_pawn else 1.0)\n    return open_file_rooks\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Product of material advantage and king safety differential\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) \n                        for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    material_diff = white_material - black_material\n    \n    white_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.WHITE)\n    black_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) \n                            and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING \n                            and board.piece_at(square).color == chess.BLACK)\n    safety_diff = black_king_attacks - white_king_attacks\n    \n    return float(material_diff * (safety_diff + 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    pieces_controlling_center = 0\n    for move in board.legal_moves:\n        if move.to_square in central_squares:\n            pieces_controlling_center += 1\n    return float(pieces_controlling_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces between kingside and queenside\"\n    kingside_count = 0\n    queenside_count = 0\n    for square in board.piece_map():\n        file = chess.square_file(square)\n        if file >= 4:\n            kingside_count += 1\n        else:\n            queenside_count += 1\n    return float(kingside_count - queenside_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to safety when attacked\"\n    safe_retreats = 0\n    for move in board.legal_moves:\n        if board.is_attacked_by(not board.turn, move.from_square):\n            board.push(move)\n            if not board.is_attacked_by(not board.turn, move.to_square):\n                safe_retreats += 1\n            board.pop()\n    return float(safe_retreats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of knight moves to total legal moves\"\n    knight_moves = 0\n    total_moves = 0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            knight_moves += 1\n        total_moves += 1\n    \n    return float(knight_moves / total_moves) if total_moves > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Maximum Manhattan distance between any two pieces of the same color\"\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_pieces.append(square)\n        else:\n            black_pieces.append(square)\n    \n    white_max_dist = 0.0\n    black_max_dist = 0.0\n    \n    for i in range(len(white_pieces)):\n        for j in range(i + 1, len(white_pieces)):\n            dist = chess.square_distance(white_pieces[i], white_pieces[j])\n            white_max_dist = max(white_max_dist, dist)\n    \n    for i in range(len(black_pieces)):\n        for j in range(i + 1, len(black_pieces)):\n            dist = chess.square_distance(black_pieces[i], black_pieces[j])\n            black_max_dist = max(black_max_dist, dist)\n    \n    return white_max_dist - black_max_dist\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking the opponent's king zone (3x3 around king)\"\n    white_attackers = black_attackers = 0\n    white_king_sq = black_king_sq = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    # Check 3x3 zone around each king\n    for king_sq, attacking_color in [(white_king_sq, chess.BLACK), (black_king_sq, chess.WHITE)]:\n        king_file = chess.square_file(king_sq)\n        king_rank = chess.square_rank(king_sq)\n        \n        for file_offset in [-1, 0, 1]:\n            for rank_offset in [-1, 0, 1]:\n                target_file = king_file + file_offset\n                target_rank = king_rank + rank_offset\n                \n                if 0 <= target_file <= 7 and 0 <= target_rank <= 7:\n                    target_sq = chess.square(target_file, target_rank)\n                    attackers = len(board.attackers(attacking_color, target_sq))\n                    \n                    if attacking_color == chess.WHITE:\n                        white_attackers += attackers\n                    else:\n                        black_attackers += attackers\n    \n    return white_attackers - black_attackers\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on the back two ranks for both sides combined\"\n    count = 0\n    for square in range(64):\n        rank = chess.square_rank(square)\n        if rank in [0, 1, 6, 7]:\n            piece = board.piece_at(square)\n            if piece is not None:\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares in black's half controlled by white pieces\"\n    controlled_squares = 0\n    \n    for square in range(32, 64):  # Black's half of the board\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares += 1\n    \n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility weighted by piece value in endgame\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    total_pieces = len(board.piece_map())\n    endgame_factor = max(0, 1.0 - (total_pieces - 6) / 26.0)\n    \n    white_mobility = black_mobility = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0) * endgame_factor\n            if piece.color == chess.WHITE:\n                white_mobility += mobility_value\n            else:\n                black_mobility += mobility_value\n    \n    board.turn = not board.turn\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0) * endgame_factor\n            if piece.color == chess.BLACK:\n                black_mobility += mobility_value\n            else:\n                white_mobility += mobility_value\n    board.turn = not board.turn\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king safety based on distance to nearest enemy piece\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_min_dist = 8\n    black_min_dist = 8\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            white_min_dist = min(white_min_dist, chess.square_distance(white_king_square, square))\n        elif piece.color == chess.WHITE:\n            black_min_dist = min(black_min_dist, chess.square_distance(black_king_square, square))\n    \n    return float(black_min_dist - white_min_dist)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn breaks available to current player\"\n    breaks = 0\n    my_color = board.turn\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.PAWN:\n            target_piece = board.piece_at(move.to_square)\n            if target_piece and target_piece.color != my_color:\n                breaks += 1\n            else:\n                # Check if advancing to attack squares\n                to_file = chess.square_file(move.to_square)\n                to_rank = chess.square_rank(move.to_square)\n                for file_offset in [-1, 1]:\n                    if 0 <= to_file + file_offset <= 7:\n                        diag_square = chess.square(to_file + file_offset, to_rank)\n                        diag_piece = board.piece_at(diag_square)\n                        if diag_piece and diag_piece.color != my_color and diag_piece.piece_type == chess.PAWN:\n                            breaks += 1\n    \n    return float(breaks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on squares attacked by opponent pieces\"\n    white_on_attacked = 0\n    black_on_attacked = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                white_on_attacked += 1\n        else:\n            if board.is_attacked_by(chess.WHITE, square):\n                black_on_attacked += 1\n    \n    return float(white_on_attacked - black_on_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of pieces within 2 squares of king\"\n    white_king_square = None\n    black_king_square = None\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    white_defenders = 0\n    black_defenders = 0\n    \n    if white_king_square is not None:\n        for square in chess.SQUARES:\n            if chess.square_distance(square, white_king_square) <= 2:\n                piece = board.piece_at(square)\n                if piece and piece.color == chess.WHITE and piece.piece_type != chess.KING:\n                    white_defenders += 1\n    \n    if black_king_square is not None:\n        for square in chess.SQUARES:\n            if chess.square_distance(square, black_king_square) <= 2:\n                piece = board.piece_at(square)\n                if piece and piece.color == chess.BLACK and piece.piece_type != chess.KING:\n                    black_defenders += 1\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of passed pawns weighted by how advanced they are\"\n    passed_pawns = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            color = piece.color\n            \n            is_passed = True\n            if color == chess.WHITE:\n                for test_rank in range(rank + 1, 8):\n                    for test_file in range(max(0, file - 1), min(8, file + 2)):\n                        test_square = chess.square(test_file, test_rank)\n                        test_piece = board.piece_at(test_square)\n                        if test_piece and test_piece.piece_type == chess.PAWN and test_piece.color == chess.BLACK:\n                            is_passed = False\n                            break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_pawns += (rank + 1) / 8.0\n            else:\n                for test_rank in range(0, rank):\n                    for test_file in range(max(0, file - 1), min(8, file + 2)):\n                        test_square = chess.square(test_file, test_rank)\n                        test_piece = board.piece_at(test_square)\n                        if test_piece and test_piece.piece_type == chess.PAWN and test_piece.color == chess.WHITE:\n                            is_passed = False\n                            break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    passed_pawns -= (8 - rank) / 8.0\n    return passed_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    pieces_controlling_center = 0\n    for move in board.legal_moves:\n        if move.to_square in central_squares:\n            pieces_controlling_center += 1\n    return float(pieces_controlling_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king weighted by their proximity\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_defense = 0.0\n    black_defense = 0.0\n    \n    if white_king_square:\n        for square in board.attackers(chess.WHITE, white_king_square):\n            distance = chess.square_distance(square, white_king_square)\n            white_defense += 1.0 / (distance + 1)\n    \n    if black_king_square:\n        for square in board.attackers(chess.BLACK, black_king_square):\n            distance = chess.square_distance(square, black_king_square)\n            black_defense += 1.0 / (distance + 1)\n    \n    return white_defense - black_defense\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares versus suboptimal squares\"\n    optimal_count = 0\n    total_pieces = 0\n    \n    optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.C6, chess.F3, chess.F6, chess.D4, chess.D5, chess.E4, chess.E5],\n        chess.BISHOP: [chess.C4, chess.F4, chess.C5, chess.F5, chess.D4, chess.D5, chess.E4, chess.E5],\n        chess.ROOK: [chess.D1, chess.E1, chess.D8, chess.E8],\n        chess.QUEEN: [chess.D4, chess.D5, chess.E4, chess.E5]\n    }\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in optimal_squares:\n            total_pieces += 1\n            if square in optimal_squares[piece.piece_type]:\n                optimal_count += 1\n    \n    return optimal_count / max(total_pieces, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in pawn breakthrough potential between white and black\"\n    white_potential = 0.0\n    black_potential = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if piece.color == chess.WHITE:\n                # Check path to promotion\n                clear_path = True\n                for r in range(rank + 1, 8):\n                    blocking_square = chess.square(file, r)\n                    blocking_piece = board.piece_at(blocking_square)\n                    if blocking_piece and blocking_piece.color == chess.BLACK:\n                        clear_path = False\n                        break\n                if clear_path:\n                    white_potential += (7 - rank) ** 2\n            else:\n                # Check path to promotion for black\n                clear_path = True\n                for r in range(rank - 1, -1, -1):\n                    blocking_square = chess.square(file, r)\n                    blocking_piece = board.piece_at(blocking_square)\n                    if blocking_piece and blocking_piece.color == chess.WHITE:\n                        clear_path = False\n                        break\n                if clear_path:\n                    black_potential += rank ** 2\n    \n    return white_potential - black_potential\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance from white queen to black king if both are on same rank or file\"\n    black_king_square = None\n    white_queen_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n        elif piece.piece_type == chess.QUEEN and piece.color == chess.WHITE:\n            white_queen_square = square\n    \n    if black_king_square is None or white_queen_square is None:\n        return 8.0\n    \n    queen_file = chess.square_file(white_queen_square)\n    queen_rank = chess.square_rank(white_queen_square)\n    king_file = chess.square_file(black_king_square)\n    king_rank = chess.square_rank(black_king_square)\n    \n    # Check if on same rank or file\n    if queen_rank == king_rank:\n        return float(abs(queen_file - king_file))\n    elif queen_file == king_file:\n        return float(abs(queen_rank - king_rank))\n    else:\n        return 8.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white pieces to total pieces on the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.5\n    white_pieces = sum(1 for piece in piece_map.values() if piece.color == chess.WHITE)\n    total_pieces = len(piece_map)\n    return white_pieces / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in enemy territory vs own territory\"\n    white_in_enemy = 0\n    black_in_enemy = 0\n    white_total = 0\n    black_total = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.piece_type != chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_total += 1\n                if rank >= 4:\n                    white_in_enemy += 1\n            else:\n                black_total += 1\n                if rank <= 3:\n                    black_in_enemy += 1\n    \n    white_ratio = white_in_enemy / max(white_total, 1)\n    black_ratio = black_in_enemy / max(black_total, 1)\n    \n    return white_ratio - black_ratio\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their optimal squares in endgame\"\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n            \n        piece_count += 1\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        if piece.piece_type == chess.KING:\n            # Kings should be centralized in endgame\n            center_distance = max(abs(file - 3.5), abs(rank - 3.5))\n            total_distance += center_distance\n        elif piece.piece_type == chess.PAWN:\n            # Pawns should advance\n            if piece.color == chess.WHITE:\n                total_distance += (7 - rank)\n            else:\n                total_distance += rank\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can deliver checkmate in one move\"\n    checkmate_threats = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            checkmate_threats += 1\n        board.pop()\n    return float(checkmate_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of escape squares available\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_escapes = 0\n    black_escapes = 0\n    \n    if white_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(white_king_square) + dx\n                rank = chess.square_rank(white_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.BLACK:\n                        if not board.is_attacked_by(chess.BLACK, escape_square):\n                            white_escapes += 1\n    \n    if black_king_square:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                file = chess.square_file(black_king_square) + dx\n                rank = chess.square_rank(black_king_square) + dy\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    escape_square = chess.square(file, rank)\n                    if not board.piece_at(escape_square) or board.piece_at(escape_square).color == chess.WHITE:\n                        if not board.is_attacked_by(chess.WHITE, escape_square):\n                            black_escapes += 1\n    \n    return float(white_escapes - black_escapes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of white pieces to total pieces on the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.5\n    white_pieces = sum(1 for piece in piece_map.values() if piece.color == chess.WHITE)\n    total_pieces = len(piece_map)\n    return white_pieces / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of white piece values multiplied by their distance to black king\"\n    black_king_square = board.king(chess.BLACK)\n    if black_king_square is None:\n        return 0.0\n    \n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance = chess.square_distance(black_king_square, square)\n            value = piece_values.get(piece.piece_type, 0)\n            total_weighted_distance += value * distance\n    \n    return total_weighted_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King escape squares in case of back rank threats\"\n    escape_squares = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n        king_rank = chess.square_rank(king_square)\n        back_rank = 0 if color == chess.WHITE else 7\n        if king_rank == back_rank:\n            for delta in [-9, -8, -7, -1, 1, 7, 8, 9]:\n                escape_square = king_square + delta\n                if 0 <= escape_square < 64:\n                    if not board.piece_at(escape_square):\n                        if not board.is_attacked_by(not color, escape_square):\n                            escape_squares += 1 if color == chess.WHITE else -1\n    return float(escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can reach the back rank in two moves or fewer\"\n    count = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.color == chess.WHITE:\n            rank = chess.square_rank(square)\n            if rank >= 6:\n                count += 1\n            elif rank >= 4 and piece.piece_type in [chess.ROOK, chess.QUEEN]:\n                count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility between current player and opponent\"\n    current_mobility = len(list(board.legal_moves))\n    \n    board.push(chess.Move.null())\n    try:\n        opponent_mobility = len(list(board.legal_moves))\n    except:\n        opponent_mobility = 0\n    finally:\n        board.pop()\n    \n    return float(current_mobility - opponent_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled around the opponent's king\"\n    opp_king = board.king(not board.turn)\n    if not opp_king:\n        return 0.0\n    controlled = 0\n    king_file = chess.square_file(opp_king)\n    king_rank = chess.square_rank(opp_king)\n    for f_offset in [-1, 0, 1]:\n        for r_offset in [-1, 0, 1]:\n            new_file = king_file + f_offset\n            new_rank = king_rank + r_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                sq = chess.square(new_file, new_rank)\n                if board.is_attacked_by(board.turn, sq):\n                    controlled += 1\n    return float(controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can move to opponent's last rank\"\n    white_pieces_to_rank8 = 0\n    black_pieces_to_rank1 = 0\n    \n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        if board.turn == chess.WHITE and to_rank == 7:\n            white_pieces_to_rank8 += 1\n        elif board.turn == chess.BLACK and to_rank == 0:\n            black_pieces_to_rank1 += 1\n    \n    board.turn = not board.turn\n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        if board.turn == chess.WHITE and to_rank == 7:\n            white_pieces_to_rank8 += 1\n        elif board.turn == chess.BLACK and to_rank == 0:\n            black_pieces_to_rank1 += 1\n    board.turn = not board.turn\n    \n    return float(white_pieces_to_rank8 - black_pieces_to_rank1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on files with pawns versus open files\"\n    white_score = 0\n    black_score = 0\n    for file_idx in range(8):\n        has_pawn = False\n        white_pieces = 0\n        black_pieces = 0\n        for rank in range(8):\n            square = chess.square(file_idx, rank)\n            piece = board.piece_at(square)\n            if piece:\n                if piece.piece_type == chess.PAWN:\n                    has_pawn = True\n                if piece.color == chess.WHITE:\n                    white_pieces += 1\n                else:\n                    black_pieces += 1\n        if has_pawn:\n            white_score += white_pieces\n            black_score += black_pieces\n        else:\n            white_score -= white_pieces * 0.5\n            black_score -= black_pieces * 0.5\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their optimal squares based on piece type\"\n    piece_optimal_squares = {\n        chess.KNIGHT: [chess.C3, chess.C6, chess.F3, chess.F6, chess.D4, chess.D5, chess.E4, chess.E5],\n        chess.BISHOP: [chess.C1, chess.F1, chess.C8, chess.F8, chess.D4, chess.D5, chess.E4, chess.E5],\n        chess.ROOK: [chess.A1, chess.H1, chess.A8, chess.H8, chess.D1, chess.E1, chess.D8, chess.E8]\n    }\n    white_optimal = black_optimal = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type in piece_optimal_squares:\n            if square in piece_optimal_squares[piece.piece_type]:\n                if piece.color == chess.WHITE:\n                    white_optimal += 1\n                else:\n                    black_optimal += 1\n    return float(white_optimal - black_optimal)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that have moved from their starting squares\"\n    starting_positions = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, chess.D1: chess.QUEEN,\n                     chess.E1: chess.KING, chess.F1: chess.BISHOP, chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP, chess.D8: chess.QUEEN,\n                     chess.E8: chess.KING, chess.F8: chess.BISHOP, chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    moved_pieces = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        for square, expected_piece in starting_positions[color].items():\n            piece = board.piece_at(square)\n            if not piece or piece.piece_type != expected_piece or piece.color != color:\n                moved_pieces += 1\n    \n    return float(moved_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen mobility difference between white and black\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            mobility = 0\n            # Count queen moves from this square\n            queen_directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\n            for dr, df in queen_directions:\n                current_rank = chess.square_rank(square)\n                current_file = chess.square_file(square)\n                \n                for distance in range(1, 8):\n                    new_rank = current_rank + dr * distance\n                    new_file = current_file + df * distance\n                    \n                    if not (0 <= new_rank < 8 and 0 <= new_file < 8):\n                        break\n                    \n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    \n                    if target_piece is None:\n                        mobility += 1\n                    elif target_piece.color != piece.color:\n                        mobility += 1\n                        break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defended by pawns weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_score = 0\n    black_score = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        defended_by_pawn = False\n        if piece.color == chess.WHITE:\n            # Check if defended by white pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square - 9)  # SW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square - 7)  # SE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.WHITE:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                white_score += piece_values.get(piece.piece_type, 0)\n        else:\n            # Check if defended by black pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square + 7)  # NW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square + 9)  # NE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.BLACK:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                black_score += piece_values.get(piece.piece_type, 0)\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation based on square control and support\"\n    outpost_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                supported = bool(board.attackers(chess.WHITE, square))\n                enemy_pawns_attack = False\n                for f in [file-1, file+1]:\n                    if 0 <= f <= 7:\n                        for r in range(rank+1, 8):\n                            check_square = chess.square(f, r)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                enemy_pawns_attack = True\n                                break\n                if supported and not enemy_pawns_attack:\n                    outpost_score += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                supported = bool(board.attackers(chess.BLACK, square))\n                enemy_pawns_attack = False\n                for f in [file-1, file+1]:\n                    if 0 <= f <= 7:\n                        for r in range(rank-1, -1, -1):\n                            check_square = chess.square(f, r)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                enemy_pawns_attack = True\n                                break\n                if supported and not enemy_pawns_attack:\n                    outpost_score -= 1\n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king in a 2-square radius\"\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    king_square = board.king(current_color)\n    if king_square is None:\n        return 0.0\n    \n    defenders = 0\n    king_file = chess.square_file(king_square)\n    king_rank = chess.square_rank(king_square)\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == current_color and piece.piece_type != chess.KING:\n            piece_file = chess.square_file(square)\n            piece_rank = chess.square_rank(square)\n            if abs(piece_file - king_file) <= 2 and abs(piece_rank - king_rank) <= 2:\n                defenders += 1\n    \n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting squares weighted by game phase\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    starting_squares = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, chess.D1: chess.QUEEN,\n                     chess.E1: chess.KING, chess.F1: chess.BISHOP, chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP, chess.D8: chess.QUEEN,\n                     chess.E8: chess.KING, chess.F8: chess.BISHOP, chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    total_material = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values())\n    if total_material == 0:\n        return 0.0\n    \n    undeveloped_score = 0.0\n    for color in [chess.WHITE, chess.BLACK]:\n        for square, expected_piece in starting_squares[color].items():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == expected_piece:\n                weight = piece_values.get(expected_piece, 0)\n                undeveloped_score += weight * (1 if color == chess.WHITE else -1)\n    \n    return undeveloped_score / max(total_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat to safety when attacked\"\n    white_safe_retreats = 0\n    black_safe_retreats = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING and board.is_attacked_by(not piece.color, square):\n            retreat_count = 0\n            for target_square in range(64):\n                if chess.square_distance(square, target_square) == 1:\n                    if not board.piece_at(target_square) or board.piece_at(target_square).color != piece.color:\n                        if not board.is_attacked_by(not piece.color, target_square):\n                            retreat_count += 1\n            \n            if piece.color == chess.WHITE:\n                white_safe_retreats += retreat_count\n            else:\n                black_safe_retreats += retreat_count\n    \n    return float(white_safe_retreats - black_safe_retreats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Minimum number of moves required for each side to promote a pawn\"\n    white_min_moves = 8\n    black_min_moves = 8\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                moves_to_promote = 7 - rank\n                white_min_moves = min(white_min_moves, moves_to_promote)\n            else:\n                moves_to_promote = rank\n                black_min_moves = min(black_min_moves, moves_to_promote)\n    return float(white_min_moves - black_min_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in mobility between queens on the board\"\n    white_queen_mobility = 0\n    black_queen_mobility = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.QUEEN:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_queen_mobility += mobility\n            else:\n                black_queen_mobility += mobility\n    \n    return float(white_queen_mobility - black_queen_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces attacking squares adjacent to the enemy king\"\n    enemy_color = not board.turn\n    friendly_color = board.turn\n    \n    # Find enemy king\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    # Get adjacent squares to enemy king\n    king_file = chess.square_file(enemy_king_square)\n    king_rank = chess.square_rank(enemy_king_square)\n    \n    attack_count = 0\n    for file_offset in [-1, 0, 1]:\n        for rank_offset in [-1, 0, 1]:\n            if file_offset == 0 and rank_offset == 0:\n                continue\n            new_file = king_file + file_offset\n            new_rank = king_rank + rank_offset\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                target_square = chess.square(new_file, new_rank)\n                if board.is_attacked_by(friendly_color, target_square):\n                    attack_count += 1\n    \n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can reach the 8th rank in one move\"\n    white_can_reach_8th = 0\n    black_can_reach_1st = 0\n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        piece = board.piece_at(move.from_square)\n        if piece:\n            if piece.color == chess.WHITE and to_rank == 7:\n                white_can_reach_8th += 1\n            elif piece.color == chess.BLACK and to_rank == 0:\n                black_can_reach_1st += 1\n    return float(white_can_reach_8th - black_can_reach_1st)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give discovered attacks by moving away from aligned pieces\"\n    discovered_attacks = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.color == chess.WHITE:\n            for direction in [(1,0), (0,1), (-1,0), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)]:\n                current_sq = square\n                blocking_piece = None\n                \n                file, rank = chess.square_file(current_sq), chess.square_rank(current_sq)\n                new_file, new_rank = file + direction[0], rank + direction[1]\n                \n                while 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                    check_sq = chess.square(new_file, new_rank)\n                    check_piece = board.piece_at(check_sq)\n                    \n                    if check_piece and check_piece.color == chess.WHITE:\n                        if check_piece.piece_type in [chess.ROOK, chess.QUEEN] and direction in [(1,0), (0,1), (-1,0), (0,-1)]:\n                            discovered_attacks += 1\n                        elif check_piece.piece_type in [chess.BISHOP, chess.QUEEN] and direction in [(1,1), (1,-1), (-1,1), (-1,-1)]:\n                            discovered_attacks += 1\n                        break\n                    elif check_piece:\n                        break\n                    \n                    new_file += direction[0]\n                    new_rank += direction[1]\n    \n    # Same for black pieces\n    for square, piece in piece_map.items():\n        if piece.color == chess.BLACK:\n            for direction in [(1,0), (0,1), (-1,0), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)]:\n                current_sq = square\n                \n                file, rank = chess.square_file(current_sq), chess.square_rank(current_sq)\n                new_file, new_rank = file + direction[0], rank + direction[1]\n                \n                while 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                    check_sq = chess.square(new_file, new_rank)\n                    check_piece = board.piece_at(check_sq)\n                    \n                    if check_piece and check_piece.color == chess.BLACK:\n                        if check_piece.piece_type in [chess.ROOK, chess.QUEEN] and direction in [(1,0), (0,1), (-1,0), (0,-1)]:\n                            discovered_attacks -= 1\n                        elif check_piece.piece_type in [chess.BISHOP, chess.QUEEN] and direction in [(1,1), (1,-1), (-1,1), (-1,-1)]:\n                            discovered_attacks -= 1\n                        break\n                    elif check_piece:\n                        break\n                    \n                    new_file += direction[0]\n                    new_rank += direction[1]\n    \n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their starting rank vs advanced pieces\"\n    on_starting = 0\n    advanced = 0\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    starting_rank = 0 if current_color == chess.WHITE else 7\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == current_color and piece.piece_type != chess.PAWN:\n            rank = chess.square_rank(square)\n            if rank == starting_rank:\n                on_starting += 1\n            else:\n                advanced += 1\n    \n    total = on_starting + advanced\n    return float(on_starting / total) if total > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation based on square control and support\"\n    outpost_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                supported = bool(board.attackers(chess.WHITE, square))\n                enemy_pawns_attack = False\n                for f in [file-1, file+1]:\n                    if 0 <= f <= 7:\n                        for r in range(rank+1, 8):\n                            check_square = chess.square(f, r)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                enemy_pawns_attack = True\n                                break\n                if supported and not enemy_pawns_attack:\n                    outpost_score += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                supported = bool(board.attackers(chess.BLACK, square))\n                enemy_pawns_attack = False\n                for f in [file-1, file+1]:\n                    if 0 <= f <= 7:\n                        for r in range(rank-1, -1, -1):\n                            check_square = chess.square(f, r)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                enemy_pawns_attack = True\n                                break\n                if supported and not enemy_pawns_attack:\n                    outpost_score -= 1\n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their optimal squares (knights on outposts, bishops on long diagonals)\"\n    score = 0.0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.KNIGHT:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            # Knights on central squares and advanced outposts\n            if piece.color == chess.WHITE:\n                if rank >= 3 and 2 <= file <= 5:\n                    if not any(board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN \n                             and board.piece_at(sq).color == chess.BLACK \n                             for sq in [square + 7, square + 9] if 0 <= sq < 64):\n                        score += 1.0 if piece.color == chess.WHITE else -1.0\n            else:\n                if rank <= 4 and 2 <= file <= 5:\n                    if not any(board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN \n                             and board.piece_at(sq).color == chess.WHITE \n                             for sq in [square - 7, square - 9] if 0 <= sq < 64):\n                        score += -1.0 if piece.color == chess.BLACK else 1.0\n        \n        elif piece.piece_type == chess.BISHOP:\n            # Bishops on long diagonals\n            if square in [chess.A1, chess.B2, chess.C3, chess.D4, chess.E5, chess.F6, chess.G7, chess.H8,\n                         chess.A8, chess.B7, chess.C6, chess.D5, chess.E4, chess.F3, chess.G2, chess.H1]:\n                score += 0.5 if piece.color == chess.WHITE else -0.5\n    \n    return score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from their own king\"\n    white_king_sq = black_king_sq = None\n    white_pieces = []\n    black_pieces = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_sq = square\n            else:\n                black_king_sq = square\n        else:\n            if piece.color == chess.WHITE:\n                white_pieces.append(square)\n            else:\n                black_pieces.append(square)\n    \n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king_sq, sq) for sq in white_pieces)\n    black_dist = sum(chess.square_distance(black_king_sq, sq) for sq in black_pieces)\n    \n    total_pieces = len(white_pieces) + len(black_pieces)\n    if total_pieces == 0:\n        return 0.0\n    \n    return (black_dist - white_dist) / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces for the side to move\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not board.attackers(board.turn, square):\n                count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to the center four squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_attackers = 0\n    black_center_attackers = 0\n    \n    for square in center_squares:\n        white_attackers = board.attackers(chess.WHITE, square)\n        black_attackers = board.attackers(chess.BLACK, square)\n        white_center_attackers += len(white_attackers)\n        black_center_attackers += len(black_attackers)\n    \n    return float(white_center_attackers - black_center_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their optimal squares\"\n    def optimal_square_bonus(piece, square):\n        if piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            return 1.0 if 2 <= file <= 5 and 2 <= rank <= 5 else 0.0\n        elif piece.piece_type == chess.BISHOP:\n            return 1.0 if len(list(board.attacks(square))) >= 7 else 0.0\n        elif piece.piece_type == chess.ROOK:\n            file_pieces = sum(1 for sq in chess.SquareSet(chess.BB_FILES[chess.square_file(square)]) if board.piece_at(sq))\n            rank_pieces = sum(1 for sq in chess.SquareSet(chess.BB_RANKS[chess.square_rank(square)]) if board.piece_at(sq))\n            return 1.0 if file_pieces <= 3 or rank_pieces <= 3 else 0.0\n        return 0.0\n    white_optimal = sum(optimal_square_bonus(piece, sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_optimal = sum(optimal_square_bonus(piece, sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_optimal - black_optimal)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces trapped on back two ranks\"\n    trapped_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            rank = chess.square_rank(sq)\n            if rank >= 6:  # 7th and 8th ranks for black\n                if piece.piece_type != chess.KING and piece.piece_type != chess.PAWN:\n                    trapped_count += 1\n    return float(trapped_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of enemy pieces that can be captured on the next move\"\n    capture_count = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            capture_count += 1\n    \n    return float(capture_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to the 7th or 8th rank\"\n    count = 0\n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        if to_rank >= 6:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece activity (sum of attack squares) between white and black\"\n    white_attacks = set()\n    black_attacks = set()\n    for square in chess.SQUARES:\n        white_attackers = board.attackers(chess.WHITE, square)\n        black_attackers = board.attackers(chess.BLACK, square)\n        if white_attackers:\n            white_attacks.add(square)\n        if black_attackers:\n            black_attacks.add(square)\n    return float(len(white_attacks) - len(black_attacks))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of safe squares around each king\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    if white_king_sq is None or black_king_sq is None:\n        return 0.0\n    \n    white_safe = 0\n    black_safe = 0\n    \n    for sq in [white_king_sq - 9, white_king_sq - 8, white_king_sq - 7, white_king_sq - 1, \n               white_king_sq + 1, white_king_sq + 7, white_king_sq + 8, white_king_sq + 9]:\n        if 0 <= sq <= 63 and not board.is_attacked_by(chess.BLACK, sq):\n            white_safe += 1\n            \n    for sq in [black_king_sq - 9, black_king_sq - 8, black_king_sq - 7, black_king_sq - 1,\n               black_king_sq + 1, black_king_sq + 7, black_king_sq + 8, black_king_sq + 9]:\n        if 0 <= sq <= 63 and not board.is_attacked_by(chess.WHITE, sq):\n            black_safe += 1\n    \n    return float(white_safe - black_safe)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on their optimal squares\"\n    optimal_scores = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        score = 0\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            center_distance = abs(file - 3.5) + abs(rank - 3.5)\n            score = max(0, 4 - center_distance) / 4\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if (file + rank) % 7 == 0 or abs(file - rank) <= 1:\n                score = 1.0\n        elif piece.piece_type == chess.ROOK:\n            # Rooks better on open/semi-open files and 7th/8th ranks\n            if piece.color == chess.WHITE and rank >= 6:\n                score = 0.5\n            elif piece.color == chess.BLACK and rank <= 1:\n                score = 0.5\n        \n        optimal_scores[piece.color] += score\n    \n    return optimal_scores[chess.WHITE] - optimal_scores[chess.BLACK]\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from black king to all white attacking pieces\"\n    black_king_square = board.king(chess.BLACK)\n    if black_king_square is None:\n        return 0.0\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type != chess.PAWN:\n            if board.is_attacked_by(chess.WHITE, black_king_square):\n                total_distance += chess.square_distance(square, black_king_square)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between pawns of the same color\"\n    white_pawns = []\n    black_pawns = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns.append(square)\n            else:\n                black_pawns.append(square)\n    \n    total_distance = 0\n    pair_count = 0\n    \n    for pawns in [white_pawns, black_pawns]:\n        for i in range(len(pawns)):\n            for j in range(i + 1, len(pawns)):\n                total_distance += chess.square_distance(pawns[i], pawns[j])\n                pair_count += 1\n    \n    return float(total_distance / pair_count if pair_count > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of pieces defending the king\"\n    white_king = None\n    black_king = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    \n    white_defenders = len(board.attackers(chess.WHITE, white_king)) if white_king else 0\n    black_defenders = len(board.attackers(chess.BLACK, black_king)) if black_king else 0\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in one move\"\n    check_threats = 0\n    \n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_threats += 1 if not board.turn else -1\n        board.pop()\n    \n    return check_threats\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of opponent's pieces from their own king\"\n    enemy_color = not board.turn\n    enemy_king_sq = board.king(enemy_color)\n    if enemy_king_sq is None:\n        return 0.0\n    \n    enemy_pieces = [sq for sq, piece in board.piece_map().items() \n                   if piece.color == enemy_color and piece.piece_type != chess.KING]\n    if not enemy_pieces:\n        return 0.0\n    \n    total_distance = sum(chess.square_distance(enemy_king_sq, sq) for sq in enemy_pieces)\n    return total_distance / len(enemy_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can reach the 7th/2nd rank\"\n    white_count = 0\n    black_count = 0\n    for move in board.legal_moves:\n        rank = chess.square_rank(move.to_square)\n        if board.turn and rank == 6:  # White to 7th rank\n            white_count += 1\n        elif not board.turn and rank == 1:  # Black to 2nd rank\n            black_count += 1\n    return float(white_count - black_count) if board.turn else float(black_count - white_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns weighted by pawn advancement\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_val = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += file_val * (rank + 1)\n            else:\n                black_score += file_val * (8 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weighted piece activity based on number of legal moves per piece type\"\n    weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    current_turn = board.turn\n    \n    white_activity = 0\n    black_activity = 0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = weights.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white_activity += weight\n            else:\n                black_activity += weight\n    \n    board.turn = not board.turn\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            weight = weights.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white_activity += weight\n            else:\n                black_activity += weight\n    \n    board.turn = current_turn\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares to total pieces\"\n    optimal_count = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        total_pieces += 1\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                optimal_count += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type == chess.BISHOP:\n            if len(list(board.attackers(not piece.color, square))) == 0:\n                diagonal_control = 0\n                for direction in [(1,1), (1,-1), (-1,1), (-1,-1)]:\n                    test_rank, test_file = rank, file\n                    while 0 <= test_rank + direction[0] <= 7 and 0 <= test_file + direction[1] <= 7:\n                        test_rank += direction[0]\n                        test_file += direction[1]\n                        test_square = chess.square(test_file, test_rank)\n                        if board.piece_at(test_square):\n                            break\n                        diagonal_control += 1\n                if diagonal_control >= 4:\n                    optimal_count += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type == chess.ROOK:\n            if rank == 6 and piece.color == chess.WHITE:\n                optimal_count += 1\n            elif rank == 1 and piece.color == chess.BLACK:\n                optimal_count -= 1\n    \n    return optimal_count / max(total_pieces, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from all pieces to their respective starting squares\"\n    starting_positions = {\n        (chess.WHITE, chess.ROOK): [chess.A1, chess.H1],\n        (chess.WHITE, chess.KNIGHT): [chess.B1, chess.G1],\n        (chess.WHITE, chess.BISHOP): [chess.C1, chess.F1],\n        (chess.WHITE, chess.QUEEN): [chess.D1],\n        (chess.WHITE, chess.KING): [chess.E1],\n        (chess.BLACK, chess.ROOK): [chess.A8, chess.H8],\n        (chess.BLACK, chess.KNIGHT): [chess.B8, chess.G8],\n        (chess.BLACK, chess.BISHOP): [chess.C8, chess.F8],\n        (chess.BLACK, chess.QUEEN): [chess.D8],\n        (chess.BLACK, chess.KING): [chess.E8]\n    }\n    \n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.PAWN:\n            key = (piece.color, piece.piece_type)\n            if key in starting_positions:\n                min_dist = min(chess.square_distance(square, start_sq) for start_sq in starting_positions[key])\n                total_distance += min_dist\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces that can move to squares not attacked by enemy pawns\"\n    safe_destinations = 0\n    total_destinations = 0\n    \n    enemy_pawn_attacks = set()\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color != board.turn:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                if file > 0 and rank < 7:\n                    enemy_pawn_attacks.add(chess.square(file - 1, rank + 1))\n                if file < 7 and rank < 7:\n                    enemy_pawn_attacks.add(chess.square(file + 1, rank + 1))\n            else:\n                if file > 0 and rank > 0:\n                    enemy_pawn_attacks.add(chess.square(file - 1, rank - 1))\n                if file < 7 and rank > 0:\n                    enemy_pawn_attacks.add(chess.square(file + 1, rank - 1))\n    \n    for move in board.legal_moves:\n        if board.piece_at(move.from_square).color == board.turn:\n            total_destinations += 1\n            if move.to_square not in enemy_pawn_attacks:\n                safe_destinations += 1\n    \n    return float(safe_destinations / max(total_destinations, 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to enemy pieces\"\n    count = 0\n    enemy_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            for adj_square in range(64):\n                if chess.square_distance(square, adj_square) == 1:\n                    enemy_squares.add(adj_square)\n    \n    for move in board.legal_moves:\n        if move.to_square in enemy_squares:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on back ranks versus advanced positions\"\n    piece_counts = {'back': 0, 'advanced': 0}\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        \n        if piece.color == chess.WHITE:\n            if rank <= 2:\n                piece_counts['back'] += 1\n            elif rank >= 5:\n                piece_counts['advanced'] += 1\n        else:\n            if rank >= 5:\n                piece_counts['back'] += 1\n            elif rank <= 2:\n                piece_counts['advanced'] += 1\n    \n    total = piece_counts['back'] + piece_counts['advanced']\n    if total == 0:\n        return 0.0\n    \n    return float(piece_counts['advanced']) / float(total)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of squares controlled by current player in the center 16 squares\"\n    center_squares = [chess.C3, chess.C4, chess.C5, chess.C6, chess.D3, chess.D4, chess.D5, chess.D6,\n                     chess.E3, chess.E4, chess.E5, chess.E6, chess.F3, chess.F4, chess.F5, chess.F6]\n    controlled = 0\n    for square in center_squares:\n        if board.is_attacked_by(board.turn, square):\n            controlled += 1\n    return float(controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of distances from all white pawns to the black king\"\n    black_king_sq = None\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_sq = sq\n            break\n    \n    if black_king_sq is None:\n        return 0.0\n    \n    total_distance = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n            total_distance += chess.square_distance(sq, black_king_sq)\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defended by pawns weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_score = 0\n    black_score = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        \n        defended_by_pawn = False\n        if piece.color == chess.WHITE:\n            # Check if defended by white pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square - 9)  # SW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square - 7)  # SE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.WHITE:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                white_score += piece_values.get(piece.piece_type, 0)\n        else:\n            # Check if defended by black pawns\n            pawn_defense_squares = []\n            if chess.square_file(square) > 0:\n                pawn_defense_squares.append(square + 7)  # NW\n            if chess.square_file(square) < 7:\n                pawn_defense_squares.append(square + 9)  # NE\n            \n            for def_sq in pawn_defense_squares:\n                if 0 <= def_sq < 64:\n                    defender = board.piece_at(def_sq)\n                    if defender and defender.piece_type == chess.PAWN and defender.color == chess.BLACK:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                black_score += piece_values.get(piece.piece_type, 0)\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of major pieces (queen, rook) to total pieces for material imbalance assessment\"\n    white_major = 0\n    black_major = 0\n    white_total = 0\n    black_total = 0\n    \n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                white_major += 1\n        else:\n            black_total += 1\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                black_major += 1\n    \n    white_ratio = white_major / max(white_total, 1)\n    black_ratio = black_major / max(black_total, 1)\n    \n    return white_ratio - black_ratio\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of opponent pieces that can be captured by pieces of lesser value\"\n    count = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            capturing_piece = board.piece_at(move.from_square)\n            if captured_piece and capturing_piece:\n                if piece_values[capturing_piece.piece_type] < piece_values[captured_piece.piece_type]:\n                    count += 1\n    \n    return float(count) * (1 if board.turn == chess.WHITE else -1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    piece_map = board.piece_map()\n    if not piece_map:\n        return 0.0\n    \n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_total_distance = 0\n    black_total_distance = 0\n    white_pieces = 0\n    black_pieces = 0\n    \n    for square, piece in piece_map.items():\n        min_distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            white_total_distance += min_distance\n            white_pieces += 1\n        else:\n            black_total_distance += min_distance\n            black_pieces += 1\n    \n    white_avg = white_total_distance / white_pieces if white_pieces > 0 else 0\n    black_avg = black_total_distance / black_pieces if black_pieces > 0 else 0\n    \n    return black_avg - white_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces attacking opponent's back rank\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.A8)) + len(board.attackers(chess.WHITE, chess.B8)) + len(board.attackers(chess.WHITE, chess.C8)) + len(board.attackers(chess.WHITE, chess.D8)) + len(board.attackers(chess.WHITE, chess.E8)) + len(board.attackers(chess.WHITE, chess.F8)) + len(board.attackers(chess.WHITE, chess.G8)) + len(board.attackers(chess.WHITE, chess.H8))\n    black_attacks = len(board.attackers(chess.BLACK, chess.A1)) + len(board.attackers(chess.BLACK, chess.B1)) + len(board.attackers(chess.BLACK, chess.C1)) + len(board.attackers(chess.BLACK, chess.D1)) + len(board.attackers(chess.BLACK, chess.E1)) + len(board.attackers(chess.BLACK, chess.F1)) + len(board.attackers(chess.BLACK, chess.G1)) + len(board.attackers(chess.BLACK, chess.H1))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that can move to the center four squares\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            piece = board.piece_at(move.from_square)\n            if piece:\n                value = piece_values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total_value += value\n                else:\n                    total_value -= value\n    \n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can retreat to safety when attacked\"\n    white_safe_retreats = 0\n    black_safe_retreats = 0\n    \n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            board_copy = board.copy()\n            board_copy.remove_piece_at(square)\n            retreat_squares = 0\n            \n            for target_square in chess.SQUARES:\n                if board_copy.piece_at(target_square) is None:\n                    board_copy.set_piece_at(target_square, piece)\n                    if not board_copy.is_attacked_by(not piece.color, target_square):\n                        retreat_squares += 1\n                    board_copy.remove_piece_at(target_square)\n            \n            if piece.color == chess.WHITE:\n                white_safe_retreats += retreat_squares\n            else:\n                black_safe_retreats += retreat_squares\n    \n    return float(white_safe_retreats - black_safe_retreats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture without being recaptured\"\n    safe_captures = 0\n    \n    for move in board.legal_moves:\n        if board.is_capture(move):\n            board.push(move)\n            target_square = move.to_square\n            attacker_color = not board.turn\n            \n            if not board.attackers(board.turn, target_square):\n                safe_captures += 1 if attacker_color == chess.WHITE else -1\n            \n            board.pop()\n    \n    return safe_captures\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of black pieces weighted by piece value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0\n    weighted_rank_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            rank = chess.square_rank(square)\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    return float(weighted_rank_sum / total_value) if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can capture black pieces in one move\"\n    captures = 0\n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captures += 1\n    return float(captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of active pieces to total pieces for current player\"\n    active_pieces = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            total_pieces += 1\n            has_legal_move = False\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    has_legal_move = True\n                    break\n            if has_legal_move:\n                active_pieces += 1\n    \n    return active_pieces / max(total_pieces, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending squares adjacent to own king\"\n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    \n    defenders = 0\n    king_file = chess.square_file(king_square)\n    king_rank = chess.square_rank(king_square)\n    \n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            new_file = king_file + df\n            new_rank = king_rank + dr\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adj_square = chess.square(new_file, new_rank)\n                defenders += len(board.attackers(board.turn, adj_square))\n    \n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of hanging pieces (attacked and undefended)\"\n    white_hanging = 0\n    black_hanging = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.color == chess.WHITE:\n            if board.attackers(chess.BLACK, square) and not board.attackers(chess.WHITE, square):\n                white_hanging += 1\n        else:\n            if board.attackers(chess.WHITE, square) and not board.attackers(chess.BLACK, square):\n                black_hanging += 1\n    \n    return float(white_hanging - black_hanging)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on the next move\"\n    capturing_pieces = 0\n    \n    for move in board.legal_moves:\n        if board.piece_at(move.to_square) is not None:\n            capturing_pieces += 1\n    \n    return float(capturing_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of undefended pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_undefended = 0\n    black_undefended = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        defenders = board.attackers(piece.color, square)\n        if not defenders:\n            value = piece_values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                white_undefended += value\n            else:\n                black_undefended += value\n    \n    return white_undefended - black_undefended\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces in enemy half of the board\"\n    pieces_in_enemy_half = 0\n    total_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            total_pieces += 1\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3):\n                pieces_in_enemy_half += 1\n    \n    return float(pieces_in_enemy_half / max(1, total_pieces))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can reach the 8th rank in one move\"\n    white_can_reach_8th = 0\n    black_can_reach_1st = 0\n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        piece = board.piece_at(move.from_square)\n        if piece:\n            if piece.color == chess.WHITE and to_rank == 7:\n                white_can_reach_8th += 1\n            elif piece.color == chess.BLACK and to_rank == 0:\n                black_can_reach_1st += 1\n    return float(white_can_reach_8th - black_can_reach_1st)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in the next move\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can retreat to safety when attacked\"\n    safe_retreat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        board.push(move)\n                        if not board.is_attacked_by(not board.turn, move.to_square):\n                            safe_retreat_count += 1\n                            board.pop()\n                            break\n                        board.pop()\n    return float(safe_retreat_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity measured by number of squares it can attack\"\n    total_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            attacks = len(list(board.attacks(square)))\n            if piece.color == chess.WHITE:\n                total_attacks += attacks\n            else:\n                total_attacks -= attacks\n    return float(total_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting squares for the opponent\"\n    opponent_color = not board.turn\n    starting_pieces = 0\n    \n    starting_positions = {\n        chess.WHITE: {chess.A1: chess.ROOK, chess.B1: chess.KNIGHT, chess.C1: chess.BISHOP, \n                     chess.D1: chess.QUEEN, chess.E1: chess.KING, chess.F1: chess.BISHOP, \n                     chess.G1: chess.KNIGHT, chess.H1: chess.ROOK},\n        chess.BLACK: {chess.A8: chess.ROOK, chess.B8: chess.KNIGHT, chess.C8: chess.BISHOP,\n                     chess.D8: chess.QUEEN, chess.E8: chess.KING, chess.F8: chess.BISHOP,\n                     chess.G8: chess.KNIGHT, chess.H8: chess.ROOK}\n    }\n    \n    for square, expected_piece_type in starting_positions[opponent_color].items():\n        piece = board.piece_at(square)\n        if piece and piece.color == opponent_color and piece.piece_type == expected_piece_type:\n            starting_pieces += 1\n    \n    return float(starting_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in knight mobility between white and black knights\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            mobility = 0\n            knight_moves = [(2,1), (2,-1), (-2,1), (-2,-1), (1,2), (1,-2), (-1,2), (-1,-2)]\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            for df, dr in knight_moves:\n                new_file, new_rank = file + df, rank + dr\n                if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    if target_piece is None or target_piece.color != piece.color:\n                        mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility weighted by piece value in endgame\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    total_pieces = len(board.piece_map())\n    endgame_factor = max(0, 1.0 - (total_pieces - 6) / 26.0)\n    \n    white_mobility = black_mobility = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0) * endgame_factor\n            if piece.color == chess.WHITE:\n                white_mobility += mobility_value\n            else:\n                black_mobility += mobility_value\n    \n    board.turn = not board.turn\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            mobility_value = piece_values.get(piece.piece_type, 0) * endgame_factor\n            if piece.color == chess.BLACK:\n                black_mobility += mobility_value\n            else:\n                white_mobility += mobility_value\n    board.turn = not board.turn\n    \n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between friendly pieces\"\n    friendly_squares = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            friendly_squares.append(square)\n    \n    if len(friendly_squares) < 2:\n        return 0.0\n    \n    total_distance = 0.0\n    count = 0\n    \n    for i in range(len(friendly_squares)):\n        for j in range(i + 1, len(friendly_squares)):\n            total_distance += chess.square_distance(friendly_squares[i], friendly_squares[j])\n            count += 1\n    \n    return total_distance / count if count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between knights and bishops for current position\"\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_mobility += mobility\n            else:\n                black_mobility += mobility\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond the 5th rank for the side to move\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == board.turn:\n                if piece.color == chess.WHITE and rank >= 5:\n                    count += 1\n                elif piece.color == chess.BLACK and rank <= 2:\n                    count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and penalty for blocked bishops\"\n    white_bishops = 0\n    black_bishops = 0\n    white_blocked = 0\n    black_blocked = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    white_blocked += 1\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                if mobility < 3:\n                    black_blocked += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 0.5\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 0.5\n    \n    return bishop_pair_bonus + (black_blocked - white_blocked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of files occupied by pawns weighted by pawn advancement\"\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_val = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_score += file_val * (rank + 1)\n            else:\n                black_score += file_val * (8 - rank)\n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in king activity measured by squares king can reach in two moves\"\n    def king_two_move_squares(king_square, color):\n        reachable = set()\n        for delta_file in [-1, 0, 1]:\n            for delta_rank in [-1, 0, 1]:\n                if delta_file == 0 and delta_rank == 0:\n                    continue\n                file = chess.square_file(king_square) + delta_file\n                rank = chess.square_rank(king_square) + delta_rank\n                if 0 <= file <= 7 and 0 <= rank <= 7:\n                    first_move = chess.square(file, rank)\n                    if not board.piece_at(first_move) or board.piece_at(first_move).color != color:\n                        reachable.add(first_move)\n                        for delta_file2 in [-1, 0, 1]:\n                            for delta_rank2 in [-1, 0, 1]:\n                                file2 = file + delta_file2\n                                rank2 = rank + delta_rank2\n                                if 0 <= file2 <= 7 and 0 <= rank2 <= 7:\n                                    second_move = chess.square(file2, rank2)\n                                    reachable.add(second_move)\n        return len(reachable)\n    \n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    white_reach = king_two_move_squares(white_king, chess.WHITE)\n    black_reach = king_two_move_squares(black_king, chess.BLACK)\n    \n    return float(white_reach - black_reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of legal moves available to the current player\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in piece mobility between current player and opponent\"\n    current_mobility = len(list(board.legal_moves))\n    \n    board.push(chess.Move.null())\n    try:\n        opponent_mobility = len(list(board.legal_moves))\n    except:\n        opponent_mobility = 0\n    finally:\n        board.pop()\n    \n    return float(current_mobility - opponent_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of ranks of all pieces weighted by their piece type values\"\n    weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 4}\n    white_sum = 0\n    black_sum = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        weight = weights.get(piece.piece_type, 0)\n        \n        if piece.color == chess.WHITE:\n            white_sum += rank * weight\n        else:\n            black_sum += rank * weight\n    \n    return float(white_sum - black_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can support pawn advances\"\n    white_support = 0\n    black_support = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank < 7:\n                target_square = chess.square(file, rank + 1)\n                if not board.piece_at(target_square):\n                    white_support += len(board.attackers(chess.WHITE, target_square))\n            elif piece.color == chess.BLACK and rank > 0:\n                target_square = chess.square(file, rank - 1)\n                if not board.piece_at(target_square):\n                    black_support += len(board.attackers(chess.BLACK, target_square))\n    return float(white_support - black_support)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between all pawns on the board\"\n    pawns = []\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawns.append(square)\n    \n    if len(pawns) < 2:\n        return 0.0\n    \n    total_distance = 0\n    pairs = 0\n    for i in range(len(pawns)):\n        for j in range(i + 1, len(pawns)):\n            total_distance += chess.square_distance(pawns[i], pawns[j])\n            pairs += 1\n    \n    return float(total_distance) / pairs if pairs > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on the same rank as opponent king\"\n    piece_map = board.piece_map()\n    white_king_square = black_king_square = None\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_king_rank = chess.square_rank(white_king_square)\n    black_king_rank = chess.square_rank(black_king_square)\n    \n    white_pieces_on_black_king_rank = sum(1 for sq, piece in piece_map.items() \n                                        if piece.color == chess.WHITE and chess.square_rank(sq) == black_king_rank)\n    black_pieces_on_white_king_rank = sum(1 for sq, piece in piece_map.items() \n                                        if piece.color == chess.BLACK and chess.square_rank(sq) == white_king_rank)\n    \n    return float(white_pieces_on_black_king_rank - black_pieces_on_white_king_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total Manhattan distance of all pieces from board center\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        total_distance += min_center_dist\n    \n    return total_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of doubled pawns for both sides, positive favors white\"\n    white_doubled = 0\n    black_doubled = 0\n    \n    for file in range(8):\n        white_pawns = 0\n        black_pawns = 0\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns += 1\n                else:\n                    black_pawns += 1\n        \n        if white_pawns > 1:\n            white_doubled += white_pawns - 1\n        if black_pawns > 1:\n            black_doubled += black_pawns - 1\n    \n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of defended pieces between white and black\"\n    white_defended = 0\n    black_defended = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.attackers(chess.WHITE, square):\n                white_defended += 1\n        else:\n            if board.attackers(chess.BLACK, square):\n                black_defended += 1\n    return float(white_defended - black_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count of pawns that have advanced beyond their 4th rank\"\n    advanced_pawns = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 3:\n                advanced_pawns -= 1\n    \n    return advanced_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on light vs dark squares\"\n    light_pieces = 0\n    dark_pieces = 0\n    for square, piece in board.piece_map().items():\n        if (chess.square_rank(square) + chess.square_file(square)) % 2 == 0:\n            dark_pieces += 1\n        else:\n            light_pieces += 1\n    return float(light_pieces - dark_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the 7th or 8th rank in one move\"\n    count = 0\n    for move in board.legal_moves:\n        to_rank = chess.square_rank(move.to_square)\n        piece = board.piece_at(move.from_square)\n        if piece and piece.color == chess.WHITE and to_rank >= 6:\n            count += 1\n        elif piece and piece.color == chess.BLACK and to_rank <= 1:\n            count += 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total material value of pieces that can be captured in one move\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    capturable_value = 0\n    for move in board.legal_moves:\n        if board.is_capture(move):\n            captured_piece = board.piece_at(move.to_square)\n            if captured_piece:\n                value = piece_values.get(captured_piece.piece_type, 0)\n                capturable_value += value if captured_piece.color == chess.BLACK else -value\n    \n    return float(capturable_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces controlling central four squares weighted by piece value\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_control = 0.0\n    black_control = 0.0\n    \n    for center_sq in center_squares:\n        white_attackers = board.attackers(chess.WHITE, center_sq)\n        black_attackers = board.attackers(chess.BLACK, center_sq)\n        \n        for attacker_sq in white_attackers:\n            piece = board.piece_at(attacker_sq)\n            if piece:\n                white_control += piece_values.get(piece.piece_type, 0)\n        \n        for attacker_sq in black_attackers:\n            piece = board.piece_at(attacker_sq)\n            if piece:\n                black_control += piece_values.get(piece.piece_type, 0)\n    \n    return white_control - black_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can capture on squares adjacent to enemy king\"\n    enemy_king_square = board.king(not board.turn)\n    if enemy_king_square is None:\n        return 0.0\n    \n    capture_count = 0\n    for move in board.legal_moves:\n        if move.to_square in [enemy_king_square + delta for delta in [-9, -8, -7, -1, 1, 7, 8, 9]\n                             if 0 <= enemy_king_square + delta < 64 and \n                             abs(chess.square_file(enemy_king_square + delta) - chess.square_file(enemy_king_square)) <= 1]:\n            capture_count += 1\n    return float(capture_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to opponent pawns\"\n    count = 0\n    opponent_color = not board.turn\n    \n    # Find all opponent pawn squares\n    opponent_pawns = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == opponent_color:\n            opponent_pawns.append(square)\n    \n    # Find squares adjacent to opponent pawns\n    adjacent_squares = set()\n    for pawn_square in opponent_pawns:\n        file, rank = chess.square_file(pawn_square), chess.square_rank(pawn_square)\n        for df in [-1, 0, 1]:\n            for dr in [-1, 0, 1]:\n                if df == 0 and dr == 0:\n                    continue\n                new_file, new_rank = file + df, rank + dr\n                if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                    adjacent_squares.add(chess.square(new_file, new_rank))\n    \n    # Count pieces that can move to these squares\n    for move in board.legal_moves:\n        if move.to_square in adjacent_squares:\n            count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces on light vs dark squares for current player\"\n    light_pieces = 0\n    dark_pieces = 0\n    current_color = board.turn\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == current_color:\n            if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0:\n                dark_pieces += 1\n            else:\n                light_pieces += 1\n    \n    return float(light_pieces - dark_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of doubled pawns for both sides, with penalty weighting\"\n    doubled_count = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        file_counts = [0] * 8\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                file_counts[chess.square_file(square)] += 1\n        \n        color_doubled = sum(max(0, count - 1) for count in file_counts)\n        if color == chess.WHITE:\n            doubled_count += color_doubled\n        else:\n            doubled_count -= color_doubled\n    \n    return float(doubled_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the castling squares around each king\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    white_defenders = 0\n    black_defenders = 0\n    \n    if white_king_sq:\n        for sq in [white_king_sq - 1, white_king_sq + 1, white_king_sq - 8, white_king_sq + 8]:\n            if 0 <= sq <= 63:\n                white_defenders += len(board.attackers(chess.WHITE, sq))\n    \n    if black_king_sq:\n        for sq in [black_king_sq - 1, black_king_sq + 1, black_king_sq - 8, black_king_sq + 8]:\n            if 0 <= sq <= 63:\n                black_defenders += len(board.attackers(chess.BLACK, sq))\n    \n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces on their starting files weighted by development factor\"\n    starting_files = {chess.KNIGHT: [1, 6], chess.BISHOP: [2, 5], chess.ROOK: [0, 7], chess.QUEEN: [3], chess.KING: [4]}\n    white_undeveloped = 0\n    black_undeveloped = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in starting_files:\n            file_num = chess.square_file(square)\n            if file_num in starting_files[piece.piece_type]:\n                if piece.color == chess.WHITE and chess.square_rank(square) == 0:\n                    white_undeveloped += 1\n                elif piece.color == chess.BLACK and chess.square_rank(square) == 7:\n                    black_undeveloped += 1\n    \n    return black_undeveloped - white_undeveloped\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pieces minus average rank of black pieces\"\n    white_ranks = []\n    black_ranks = []\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_ranks.append(rank)\n        else:\n            black_ranks.append(rank)\n    \n    white_avg = sum(white_ranks) / len(white_ranks) if white_ranks else 0\n    black_avg = sum(black_ranks) / len(black_ranks) if black_ranks else 0\n    \n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces defending the king (within 2 squares)\"\n    king_square = None\n    king_color = chess.WHITE if board.turn else chess.BLACK\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == king_color:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    defenders = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == king_color and piece.piece_type != chess.KING:\n            if chess.square_distance(square, king_square) <= 2:\n                defenders += 1\n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of Manhattan distances from all pieces to their respective starting squares\"\n    starting_positions = {\n        (chess.WHITE, chess.ROOK): [chess.A1, chess.H1],\n        (chess.WHITE, chess.KNIGHT): [chess.B1, chess.G1],\n        (chess.WHITE, chess.BISHOP): [chess.C1, chess.F1],\n        (chess.WHITE, chess.QUEEN): [chess.D1],\n        (chess.WHITE, chess.KING): [chess.E1],\n        (chess.BLACK, chess.ROOK): [chess.A8, chess.H8],\n        (chess.BLACK, chess.KNIGHT): [chess.B8, chess.G8],\n        (chess.BLACK, chess.BISHOP): [chess.C8, chess.F8],\n        (chess.BLACK, chess.QUEEN): [chess.D8],\n        (chess.BLACK, chess.KING): [chess.E8]\n    }\n    \n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.PAWN:\n            key = (piece.color, piece.piece_type)\n            if key in starting_positions:\n                min_dist = min(chess.square_distance(square, start_sq) for start_sq in starting_positions[key])\n                total_distance += min_dist\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Mobility difference between white and black pieces (total legal moves)\"\n    current_turn = board.turn\n    white_mobility = 0\n    black_mobility = 0\n    \n    # Count white moves\n    if current_turn == chess.WHITE:\n        white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n        if not board.is_checkmate() and not board.is_stalemate():\n            black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n    else:\n        black_mobility = len(list(board.legal_moves))\n        board.turn = chess.WHITE\n        if not board.is_checkmate() and not board.is_stalemate():\n            white_mobility = len(list(board.legal_moves))\n        board.turn = chess.BLACK\n    \n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material imbalance considering piece exchanges in current position\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = 0\n    black_material = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += value\n        else:\n            black_material += value\n    return float(white_material - black_material) / max(white_material + black_material, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance += min_center_dist\n        else:\n            total_distance -= min_center_dist\n        piece_count += 1\n    \n    if piece_count == 0:\n        return 0.0\n    return total_distance / piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank advancement of pawns relative to their starting positions\"\n    pawn_advancement = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                advancement = rank - 1\n            else:\n                advancement = 6 - rank\n            pawn_advancement += max(0, advancement)\n            pawn_count += 1\n    \n    return pawn_advancement / max(pawn_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Difference in number of pieces that can escape attack next move\"\n    white_escapes = 0\n    black_escapes = 0\n    \n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            escape_count = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    board.push(move)\n                    if not board.is_attacked_by(not piece.color, move.to_square):\n                        escape_count += 1\n                    board.pop()\n            \n            if piece.color == chess.WHITE:\n                white_escapes += escape_count\n            else:\n                black_escapes += escape_count\n    \n    return float(white_escapes - black_escapes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance between white pieces (cohesion measure)\"\n    white_pieces = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE]\n    if len(white_pieces) <= 1:\n        return 0.0\n    \n    total_distance = 0\n    pairs = 0\n    for i in range(len(white_pieces)):\n        for j in range(i + 1, len(white_pieces)):\n            total_distance += chess.square_distance(white_pieces[i], white_pieces[j])\n            pairs += 1\n    \n    return float(total_distance / pairs) if pairs > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces that can reach 7th or 8th rank in one move\"\n    count = 0\n    target_ranks = [6, 7]\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.color == chess.WHITE:\n            to_rank = chess.square_rank(move.to_square)\n            if to_rank in target_ranks:\n                count += 1\n    \n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that have advanced beyond their starting rank normalized by total pawns\"\n    white_advanced = black_advanced = 0\n    white_pawns = black_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n                if rank > 1:\n                    white_advanced += 1\n            else:\n                black_pawns += 1\n                if rank < 6:\n                    black_advanced += 1\n    \n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    \n    return (white_advanced - black_advanced) / total_pawns\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of white pawns minus average rank of black pawns\"\n    white_pawn_ranks = []\n    black_pawn_ranks = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                white_pawn_ranks.append(rank)\n            else:\n                black_pawn_ranks.append(rank)\n    \n    white_avg = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0.0\n    black_avg = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0.0\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawns that can potentially promote without immediate capture\"\n    promoting_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE and rank >= 5:\n                promotion_square = chess.square(file, 7)\n                if not board.is_attacked_by(chess.BLACK, promotion_square):\n                    promoting_pawns += 1\n            elif piece.color == chess.BLACK and rank <= 2:\n                promotion_square = chess.square(file, 0)\n                if not board.is_attacked_by(chess.WHITE, promotion_square):\n                    promoting_pawns += 1\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of hanging pieces that are attacked more times than defended\"\n    hanging = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n        \n        attackers = len(board.attackers(not piece.color, square))\n        defenders = len(board.attackers(piece.color, square))\n        \n        if attackers > defenders and attackers > 0:\n            hanging += 1\n    \n    return float(hanging)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average mobility of queen and rooks combined\"\n    mobility_sum = 0\n    piece_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            mobility = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n            \n            if piece.color == chess.WHITE:\n                mobility_sum += mobility\n            else:\n                mobility_sum -= mobility\n            piece_count += 1\n    \n    return mobility_sum / max(1, piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of queen mobility to total pieces on board\"\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    \n    queen_mobility = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            old_board = board.copy()\n            board.turn = piece.color\n            queen_moves = 0\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    queen_moves += 1\n            queen_mobility += queen_moves\n            board = old_board\n    \n    return queen_mobility / total_pieces\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of enemy pieces weighted by their value\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    enemy_color = not board.turn\n    \n    total_value = 0.0\n    weighted_rank_sum = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == enemy_color and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if enemy_color == chess.BLACK:\n                rank = 7 - rank  # Flip for black perspective\n            value = piece_values[piece.piece_type]\n            weighted_rank_sum += rank * value\n            total_value += value\n    \n    return weighted_rank_sum / total_value if total_value > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average distance of all pieces from the center of the board\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        min_center_dist = min(chess.square_distance(square, center) for center in center_squares)\n        weight = 1.0 if piece.color == chess.WHITE else -1.0\n        total_distance += weight * min_center_dist\n        piece_count += 1\n    \n    return total_distance / max(piece_count, 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of white pieces on light squares minus black pieces on dark squares\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        square_color = (chess.square_rank(square) + chess.square_file(square)) % 2\n        if piece.color == chess.WHITE and square_color == 1:\n            count += 1\n        elif piece.color == chess.BLACK and square_color == 0:\n            count -= 1\n    return float(count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pawn islands (groups of connected pawns) difference\"\n    def count_pawn_islands(color):\n        pawn_files = set()\n        for square, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN and piece.color == color:\n                pawn_files.add(chess.square_file(square))\n        \n        if not pawn_files:\n            return 0\n        \n        sorted_files = sorted(pawn_files)\n        islands = 1\n        for i in range(1, len(sorted_files)):\n            if sorted_files[i] - sorted_files[i-1] > 1:\n                islands += 1\n        \n        return islands\n    \n    white_islands = count_pawn_islands(chess.WHITE)\n    black_islands = count_pawn_islands(chess.BLACK)\n    return float(black_islands - white_islands)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity score based on open files and rank control\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            file_val = chess.square_file(square)\n            rank_val = chess.square_rank(square)\n            \n            # Check if rook is on open or semi-open file\n            file_pawns = sum(1 for sq, p in board.piece_map().items() \n                           if p.piece_type == chess.PAWN and chess.square_file(sq) == file_val)\n            \n            # Check rank control\n            rank_squares = sum(1 for sq in range(8) if chess.square_rank(sq * 8 + file_val) == rank_val)\n            controlled_rank = len([sq for sq in board.attackers(piece.color, square) if chess.square_rank(sq) == rank_val])\n            \n            activity = (8 - file_pawns) + controlled_rank * 0.5\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return white_rook_activity - black_rook_activity\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of file differences between kings and all rooks on the board\"\n    king_files = {}\n    rook_squares = []\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            king_files[piece.color] = chess.square_file(square)\n        elif piece.piece_type == chess.ROOK:\n            rook_squares.append(square)\n    \n    total_diff = 0.0\n    for rook_square in rook_squares:\n        rook_file = chess.square_file(rook_square)\n        for king_file in king_files.values():\n            total_diff += abs(rook_file - king_file)\n    \n    return total_diff\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Sum of piece values on the most active rank (rank with most piece activity)\"\n    rank_activity = [0] * 8\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n        \n        rank = chess.square_rank(square)\n        piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n        rank_activity[rank] += piece_values.get(piece.piece_type, 0)\n    \n    return float(max(rank_activity))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can reach the center four squares in one move\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_reach = 0\n    black_reach = 0\n    \n    for move in board.legal_moves:\n        if move.to_square in center_squares:\n            if board.piece_at(move.from_square).color == chess.WHITE:\n                white_reach += 1\n            else:\n                black_reach += 1\n    \n    return white_reach - black_reach\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of developed minor pieces to total minor pieces\"\n    developed = 0\n    total = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            total += 1\n            rank = chess.square_rank(square)\n            if rank > 0:\n                developed += 1\n        elif piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            total += 1\n            rank = chess.square_rank(square)\n            if rank < 7:\n                developed += 1\n    return float(developed / max(total, 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can move to squares adjacent to enemy king\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    \n    enemy_color = not board.turn\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == enemy_color:\n            enemy_king_square = square\n            break\n    \n    if enemy_king_square is None:\n        return 0.0\n    \n    king_file = chess.square_file(enemy_king_square)\n    king_rank = chess.square_rank(enemy_king_square)\n    adjacent_squares = []\n    \n    for df in [-1, 0, 1]:\n        for dr in [-1, 0, 1]:\n            if df == 0 and dr == 0:\n                continue\n            new_file = king_file + df\n            new_rank = king_rank + dr\n            if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                adjacent_squares.append(chess.square(new_file, new_rank))\n    \n    attacking_pieces = 0\n    for square in adjacent_squares:\n        if board.is_attacked_by(board.turn, square):\n            attacking_pieces += 1\n    \n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of knight moves to total legal moves\"\n    knight_moves = 0\n    total_moves = 0\n    \n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            knight_moves += 1\n        total_moves += 1\n    \n    return float(knight_moves / total_moves) if total_moves > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Average rank of all white pieces minus average rank of all black pieces\"\n    white_ranks = []\n    black_ranks = []\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            white_ranks.append(rank)\n        else:\n            black_ranks.append(rank)\n    \n    white_avg = sum(white_ranks) / len(white_ranks) if white_ranks else 0.0\n    black_avg = sum(black_ranks) / len(black_ranks) if black_ranks else 0.0\n    return white_avg - black_avg\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of black pieces on their back two ranks\"\n    black_pieces_back_ranks = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            if rank >= 6:\n                black_pieces_back_ranks += 1\n    \n    return float(black_pieces_back_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Distance from white king to the promotion square of the most advanced white pawn\"\n    white_king = None\n    most_advanced_pawn = None\n    max_rank = -1\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.WHITE:\n            white_king = square\n        elif piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n            rank = chess.square_rank(square)\n            if rank > max_rank:\n                max_rank = rank\n                most_advanced_pawn = square\n    \n    if white_king is None or most_advanced_pawn is None:\n        return 10.0\n    \n    file = chess.square_file(most_advanced_pawn)\n    promotion_square = chess.square(file, 7)\n    return chess.square_distance(white_king, promotion_square)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces positioned on optimal squares for their type\"\n    optimal_count = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        \n        if piece.piece_type == chess.KNIGHT:\n            # Knights better in center\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                optimal_count += 1 if piece.color == board.turn else -1\n        elif piece.piece_type == chess.BISHOP:\n            # Bishops better on long diagonals\n            if abs(rank - file) <= 1 or abs(rank + file - 7) <= 1:\n                optimal_count += 1 if piece.color == board.turn else -1\n        elif piece.piece_type == chess.ROOK:\n            # Rooks better on open files or 7th rank\n            pawn_on_file = False\n            for r in range(8):\n                test_square = chess.square(file, r)\n                test_piece = board.piece_at(test_square)\n                if test_piece and test_piece.piece_type == chess.PAWN:\n                    pawn_on_file = True\n                    break\n            \n            if not pawn_on_file or (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                optimal_count += 1 if piece.color == board.turn else -1\n    \n    return float(optimal_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection between pieces\"\n    coordination_score = 0\n    piece_map = board.piece_map()\n    \n    for square, piece in piece_map.items():\n        defenders = len(board.attackers(piece.color, square))\n        if defenders > 1:\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}.get(piece.piece_type, 0)\n            multiplier = 1 if piece.color == chess.WHITE else -1\n            coordination_score += multiplier * piece_value * (defenders - 1)\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of pieces that can give check in the next move\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value difference weighted by piece centralization\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    white_score = 0.0\n    black_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        \n        base_value = piece_values.get(piece.piece_type, 0)\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        # Centralization bonus (distance from center)\n        center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n        centralization_bonus = 1.0 + (3.5 - center_distance) * 0.1\n        \n        weighted_value = base_value * centralization_bonus\n        \n        if piece.color == chess.WHITE:\n            white_score += weighted_value\n        else:\n            black_score += weighted_value\n    \n    return white_score - black_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Material value of pieces that are undefended by own pieces\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    undefended_value = 0\n    for square, piece in board.piece_map().items():\n        defenders = board.attackers(piece.color, square)\n        if len(defenders) == 0:\n            value = piece_values.get(piece.piece_type, 0)\n            undefended_value += value if piece.color == chess.WHITE else -value\n    return float(undefended_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Total number of squares controlled by white pieces in black king's vicinity\"\n    black_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            black_king_square = square\n            break\n    \n    if black_king_square is None:\n        return 0.0\n    \n    king_rank = chess.square_rank(black_king_square)\n    king_file = chess.square_file(black_king_square)\n    \n    controlled_squares = 0\n    for rank in range(max(0, king_rank - 2), min(8, king_rank + 3)):\n        for file in range(max(0, king_file - 2), min(8, king_file + 3)):\n            square = chess.square(file, rank)\n            if board.is_attacked_by(chess.WHITE, square):\n                controlled_squares += 1\n    \n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Ratio of pieces on their optimal squares versus suboptimal squares\"\n    white_optimal = 0\n    black_optimal = 0\n    white_total = 0\n    black_total = 0\n    \n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        file = chess.square_file(square)\n        optimal = False\n        \n        if piece.piece_type == chess.KNIGHT:\n            if 2 <= rank <= 5 and 2 <= file <= 5:\n                optimal = True\n        elif piece.piece_type == chess.BISHOP:\n            if abs(rank - 3.5) + abs(file - 3.5) <= 3:\n                optimal = True\n        elif piece.piece_type == chess.ROOK:\n            if rank in [0, 6, 7] or file in [0, 7]:\n                optimal = True\n                \n        if piece.color == chess.WHITE:\n            white_total += 1\n            if optimal:\n                white_optimal += 1\n        else:\n            black_total += 1\n            if optimal:\n                black_optimal += 1\n                \n    white_ratio = white_optimal / max(white_total, 1)\n    black_ratio = black_optimal / max(black_total, 1)\n    return white_ratio - black_ratio\n\n"
  ]
}