{
  "used_features": [
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material balance between white and black pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # King is not valued as it's not capturable\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance by counting the value of pieces each side has on the board.\"\n    material_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_material = sum(material_value[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_material = sum(material_value[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the proportion of the board occupied by each player, highlighting spatial control.\"\n    total_squares = 64\n    white_occupied = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE])\n    black_occupied = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK])\n    result = (white_occupied - black_occupied) / total_squares\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides and returns the difference.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks to indicate control of the board.\"\n    white_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    result = white_distribution - black_distribution\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the most valuable piece remaining for each player.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.WHITE), default=0)\n    black_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.BLACK), default=0)\n    return float(white_valuable - black_valuable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the total number of squares controlled by each side, based on piece placement.\"\n    white_controlled = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece value of both sides.'\n    piece_value = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_value - black_value)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the piece activity by counting the number of pieces that can move to an open square.'\n    mobility_count = 0\n    for move in board.legal_moves:\n        mobility_count += 1\n    result = float(mobility_count)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board to assess material density.\"\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece value of both sides.'\n    piece_value = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_value - black_value)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the most valuable piece remaining for each player.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.WHITE), default=0)\n    black_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.BLACK), default=0)\n    return float(white_valuable - black_valuable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pieces to gauge control of the board.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by both colors.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    \n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both players by counting their legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of the pieces: sum of distances of all pieces to the center.\"\n    center_square = chess.E4\n    total_distance = sum(chess.square_distance(square, center_square) for square in board.piece_map())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = white_pieces_in_enemy_half - black_pieces_in_enemy_half\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces occupying the first and eighth ranks.\"\n    pieces_on_first_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 0)\n    pieces_on_eighth_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 7)\n    \n    return float(pieces_on_first_rank - pieces_on_eighth_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential threats by calculating the number of legal moves that can capture the opponent's pieces.\"\n    threat_count_white = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    threat_count_black = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(threat_count_white - threat_count_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of available legal moves for each side, indicating positional flexibility.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares under attack by each side.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player.\"\n    controlled_by_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_by_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    control_difference = controlled_by_white - controlled_by_black\n    return float(control_difference)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map())\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains (connected pawns) for both sides.\"\n    def count_pawn_chains(color):\n        chains = 0\n        for file in range(8):\n            chain = False\n            for rank in range(8):\n                square = chess.square(file, rank)\n                piece = board.piece_at(square)\n                if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                    if not chain:\n                        chains += 1\n                        chain = True\n                else:\n                    chain = False\n        return chains\n    return float(count_pawn_chains(chess.WHITE) - count_pawn_chains(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains on the board.\"\n    pawn_chains = 0\n    pawn_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    for file in range(8):\n        chain_count = 0\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if square in pawn_positions:\n                chain_count += 1\n            else:\n                if chain_count > 0:\n                    pawn_chains += 1\n                chain_count = 0\n        if chain_count > 0:\n            pawn_chains += 1\n    return float(pawn_chains)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both players by counting their legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility ratio of white to black by comparing legal moves.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = False\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the influence of each player by counting how many squares are attacked.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each color.\"\n    total_distance_white = total_distance_black = 0\n    piece_count_white = piece_count_black = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance_white += distance\n            piece_count_white += 1\n        else:\n            total_distance_black += distance\n            piece_count_black += 1\n    avg_distance_white = total_distance_white / piece_count_white if piece_count_white > 0 else 0\n    avg_distance_black = total_distance_black / piece_count_black if piece_count_black > 0 else 0\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the distance of each side's pieces to the opponent's back rank.\"\n    white_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pieces to gauge control of the board.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the percentage of pieces that are on their starting squares for both sides.\"\n    starting_positions = {\n        chess.WHITE: {chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2, chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1},\n        chess.BLACK: {chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7, chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    }\n    on_starting_sq = {\n        chess.WHITE: sum(1 for sq in starting_positions[chess.WHITE] if board.piece_at(sq) is not None),\n        chess.BLACK: sum(1 for sq in starting_positions[chess.BLACK] if board.piece_at(sq) is not None)\n    }\n    total_on_starting_squares = on_starting_sq[chess.WHITE] + on_starting_sq[chess.BLACK]\n    return float(total_on_starting_squares) / (16.0 if total_on_starting_squares else 1)  # Normalizing to maximum possible pieces\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of major pieces (rooks and queens) for each side.\"\n    white_mobility = sum(len(list(board.legal_moves))\n                        for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.WHITE and \n                        board.piece_map()[square].piece_type in [chess.ROOK, chess.QUEEN])\n    black_mobility = sum(len(list(board.legal_moves))\n                        for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.BLACK and \n                        board.piece_map()[square].piece_type in [chess.ROOK, chess.QUEEN])\n    result = white_mobility - black_mobility\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color based on piece attacks.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the central control by counting pieces in central squares (d4, d5, e4, e5).'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control_white = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    central_control_black = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_control_white - central_control_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both players by counting their legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of both kings to their respective corners.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_corner_distance = min(chess.square_distance(white_king_square, corner) for corner in [chess.A1, chess.H1, chess.A8, chess.H8])\n    black_corner_distance = min(chess.square_distance(black_king_square, corner) for corner in [chess.A1, chess.H1, chess.A8, chess.H8])\n    return float(black_corner_distance - white_corner_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player excluding occupied squares.\"\n    controlled_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None])\n    controlled_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None])\n    return float(controlled_white - controlled_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are advanced (rank 4 or higher) for each side.\"\n    white_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    black_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) <= 3)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    board.turn = not board.turn  # Switch turn for black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Revert turn\n    \n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    board.turn = not board.turn  # Switch turn for black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Revert turn\n    \n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for the player to move.\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    \n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE].add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK].add(square)\n    \n    result = len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK])\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    attacked_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    attacked_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(attacked_white - attacked_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player.\"\n    def controlled_squares(color):\n        controlled = sum(1 for square in range(64) if board.is_attacked_by(color, square))\n        return controlled\n\n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(square, piece.piece_type) for square, piece in board.piece_map().items())\n    average_distance = total_distance / len(board.piece_map()) if board.piece_map() else 0\n    return float(average_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the back rank for each side indicating readiness for action.'\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.A7 + square) and board.piece_at(chess.A7 + square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.A1 + square) and board.piece_at(chess.A1 + square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 4th rank or higher for both sides.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map().keys() \n                                if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) >= 4 and board.piece_at(sq).color == chess.WHITE)\n    black_advanced_pawns = sum(1 for sq in board.piece_map().keys() \n                                if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) >= 4 and board.piece_at(sq).color == chess.BLACK)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for the player to move.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_value += piece_values.get(piece.piece_type, 0)\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board weighted by their positions.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_weighted_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square))\n        piece_count += 1\n    \n    return total_weighted_value / (piece_count if piece_count > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces attacking the enemy king for each player, reflecting pressure on the king.\"\n    def count_attacks_king(color):\n        king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, king_square) and board.piece_at(sq).color != color)\n    \n    white_attack_count = count_attacks_king(chess.WHITE)\n    black_attack_count = count_attacks_king(chess.BLACK)\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value for both colors based on the pieces present.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value / total_value if total_value > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of the remaining pieces for both colors.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value - black_value) / (total_value + 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from their home squares.\"\n    total_distance = 0\n    piece_count = 0\n    home_squares = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8],\n    }\n    \n    for square, piece in board.piece_map().items():\n        piece_count += 1\n        home_positions = home_squares.get(piece.piece_type, [])\n        for home in home_positions:\n            total_distance += chess.square_distance(square, home)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are attacking opponent pieces.'\n    attack_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color != board.turn:\n            attackers = board.attackers(board.turn, square)\n            attack_count += len(attackers)\n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of active pieces for the current player.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = white_pieces_in_enemy_half - black_pieces_in_enemy_half\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece activity based on their mobility.'\n    activity_score = 0.0\n    for piece in board.piece_map().values():\n        mobility = len(list(board.legal_moves))  # Count all legal moves available\n        activity_score += mobility\n    return activity_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces near each king, assessing protection.\"\n    king_proximity_squares = [chess.square_file(square) + chess.square_rank(square) for square in range(chess.A1, chess.H8 + 1)]\n    \n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n\n    white_protection = sum(1 for square in king_proximity_squares if board.is_attacked_by(chess.BLACK, square))\n    black_protection = sum(1 for square in king_proximity_squares if board.is_attacked_by(chess.WHITE, square))\n    return float(white_protection - black_protection)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares under attack by each side.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for each color.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_ratio = white_minor / total_white if total_white > 0 else 0.0\n    black_ratio = black_minor / total_black if total_black > 0 else 0.0\n    return float(white_ratio - black_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced past the fourth rank, indicating aggressive positioning.\"\n    advanced_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) > 3) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) < 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available checks for both players.\"\n    checks_available = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks_available)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the ranks occupied by each player's pieces.\"\n    white_sum_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_sum_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_sum_ranks - black_sum_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the relative piece activity by counting pieces that have more than one legal move.\"\n    active_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            legal_moves = list(board.legal_moves)\n            if any(move.from_square == square for move in legal_moves):\n                active_piece_count += 1\n    return float(active_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by both players to indicate pressure.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of pieces attacking the opponent\u2019s most advanced pawn.'\n    most_advanced_pawn_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK:\n            if most_advanced_pawn_square is None or chess.square_rank(square) > chess.square_rank(most_advanced_pawn_square):\n                most_advanced_pawn_square = square\n                \n    if most_advanced_pawn_square is None:\n        return 0.0\n    \n    attacking_value = 0\n    for attacker in board.attackers(chess.WHITE, most_advanced_pawn_square):\n        attacking_value += board.piece_at(attacker).piece_type  # Use piece_type as numeric value\n    return float(attacking_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each color.\"\n    white_attacked = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacked = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacked pieces for each color.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has positioned on the 7th rank, indicating potential promotion advantage.\"\n    white_7th_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_7th_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares under attack for both sides to assess control.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides and returns the difference.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the most valuable piece remaining for each player.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.WHITE), default=0)\n    black_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.BLACK), default=0)\n    return float(white_valuable - black_valuable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by each side.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each side's pawns to the opponent's back rank, emphasizing advancement.\"\n    def pawn_distance(color):\n        total_distance = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                if color == chess.WHITE:\n                    total_distance += chess.square_rank(square)  # Distance to rank 8\n                else:\n                    total_distance += 7 - chess.square_rank(square)  # Distance to rank 1\n        return total_distance\n\n    white_distance = pawn_distance(chess.WHITE)\n    black_distance = pawn_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance by counting the total value of pieces each side has.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has in the opponent's half of the board.\"\n    white_in_enemy_half = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_half = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = float(white_in_enemy_half - black_in_enemy_half)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the average rank of pieces for both sides to evaluate their control of the board.'\n    total_white_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_black_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    white_avg_rank = total_white_rank / (len(board.piece_map()) / 2) if board.piece_map() else 0\n    black_avg_rank = total_black_rank / (len(board.piece_map()) / 2) if board.piece_map() else 0\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for the player to move.\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the disparity in development by comparing the number of developed pieces.\"\n    developed_pieces_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and (chess.square_rank(sq) >= 5))\n    developed_pieces_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and (chess.square_rank(sq) <= 2))\n    result = developed_pieces_white - developed_pieces_black\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total piece value difference weighted by the square distance from the home row.'\n    piece_map = board.piece_map()\n    total_value = 0.0\n    for square, piece in piece_map.items():\n        value = 0\n        if piece.piece_type == chess.PAWN:\n            value = 1\n        elif piece.piece_type == chess.KNIGHT:\n            value = 3\n        elif piece.piece_type == chess.BISHOP:\n            value = 3\n        elif piece.piece_type == chess.ROOK:\n            value = 5\n        elif piece.piece_type == chess.QUEEN:\n            value = 9\n        elif piece.piece_type == chess.KING:\n            value = 0  # King is invaluable in terms of material\n        distance = chess.square_rank(square)  # Distance from home row for each color\n        distance_adjusted_value = value * (8 - distance) if piece.color == chess.WHITE else value * distance\n        total_value += distance_adjusted_value if piece.color == chess.WHITE else -distance_adjusted_value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks to indicate control of the board.\"\n    white_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    result = white_distribution - black_distribution\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of bishops to pawns for each color, giving insight into piece value balance.\"\n    bishops_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    bishops_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    pawns_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    pawns_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    ratio_white = bishops_white / pawns_white if pawns_white > 0 else 0\n    ratio_black = bishops_black / pawns_black if pawns_black > 0 else 0\n    return float(ratio_white - ratio_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the average piece value for each side.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return (white_value - black_value) / (total_value if total_value > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of squares attacking pawns by both players.\"\n    white_attacks = sum(1 for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.WHITE and \n                        board.piece_map()[square].piece_type == chess.PAWN and \n                        any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    black_attacks = sum(1 for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.BLACK and \n                        board.piece_map()[square].piece_type == chess.PAWN and \n                        any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.BLACK, square)))\n    result = float(white_attacks - black_attacks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares where each side has a rook that influences the center.\"\n    rook_squares = [chess.A4, chess.B4, chess.C4, chess.D4, chess.E4, chess.F4, chess.G4, chess.H4,\n                    chess.A5, chess.B5, chess.C5, chess.D5, chess.E5, chess.F5, chess.G5, chess.H5]\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.ROOK and any(board.is_attacked_by(chess.BLACK, sq) for sq in rook_squares))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.ROOK and any(board.is_attacked_by(chess.WHITE, sq) for sq in rook_squares))\n    result = float(white_rook_control - black_rook_control)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares attacked by each side\u2019s pieces.'\n    total_attacks_white = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_attacks_black = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(total_attacks_white - total_attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece activity based on their mobility.'\n    activity_score = 0.0\n    for piece in board.piece_map().values():\n        mobility = len(list(board.legal_moves))  # Count all legal moves available\n        activity_score += mobility\n    return activity_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of square defenders for each player's king to measure safety.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_king_defense = len(board.attackers(chess.WHITE, white_king_square))\n    black_king_defense = len(board.attackers(chess.BLACK, black_king_square))\n    \n    return float(white_king_defense - black_king_defense)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all white pieces on the board.\"\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank += chess.square_rank(square)\n    return float(total_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides, focusing on non-pawn pieces.\"\n    piece_value = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece activity based on their mobility.'\n    activity_score = 0.0\n    for piece in board.piece_map().values():\n        mobility = len(list(board.legal_moves))  # Count all legal moves available\n        activity_score += mobility\n    return activity_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of squares attacking pawns by both players.\"\n    white_attacks = sum(1 for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.WHITE and \n                        board.piece_map()[square].piece_type == chess.PAWN and \n                        any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    black_attacks = sum(1 for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.BLACK and \n                        board.piece_map()[square].piece_type == chess.PAWN and \n                        any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.BLACK, square)))\n    result = float(white_attacks - black_attacks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map())\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking pieces each side has.\"\n    white_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where a single piece attacks two opponent pieces).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_pieces = [board.piece_at(move.to_square) for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)]\n                    if len(attacked_pieces) > 1:\n                        double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of direct threats (pieces that can capture without being captured) for each side.\"\n    white_threats = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None or (board.piece_at(move.to_square).color != chess.WHITE and board.is_attacked_by(chess.WHITE, move.to_square)))\n    black_threats = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None or (board.piece_at(move.to_square).color != chess.BLACK and board.is_attacked_by(chess.BLACK, move.to_square)))\n    return float(white_threats - black_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned by either color, indicating tactical opportunities.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:  # Only for the current player's pieces\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where a single piece attacks two opponent pieces).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_pieces = [board.piece_at(move.to_square) for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)]\n                    if len(attacked_pieces) > 1:\n                        double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of double attacks from pieces of each side.\"\n    def count_double_attacks(color):\n        double_attacks = 0\n        for sq, piece in board.piece_map().items():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if move.from_square == sq and board.is_attacked_by(not color, move.to_square):\n                        double_attacks += 1\n        return double_attacks\n    white_doubles = count_double_attacks(chess.WHITE)\n    black_doubles = count_double_attacks(chess.BLACK)\n    return float(white_doubles - black_doubles)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently attacking the opponent's king, illustrating direct threats.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares where each player's pieces can move, indicating mobility.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where a single piece attacks two opponent pieces).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_pieces = [board.piece_at(move.to_square) for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)]\n                    if len(attacked_pieces) > 1:\n                        double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each player has on the board, weighted by standard piece values.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the square control by summing the number of attacks made by pieces.\"\n    total_attacks = 0\n    for square in range(64):\n        total_attacks += len(board.attackers(chess.WHITE, square)) - len(board.attackers(chess.BLACK, square))\n    return float(total_attacks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where a single piece attacks two opponent pieces).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_pieces = [board.piece_at(move.to_square) for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)]\n                    if len(attacked_pieces) > 1:\n                        double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where a single piece attacks two opponent pieces).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_pieces = [board.piece_at(move.to_square) for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)]\n                    if len(attacked_pieces) > 1:\n                        double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their respective opponent's king.\"\n    def distance_to_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == color)\n        return sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_map()[square].color != color)\n\n    white_distance = distance_to_king(chess.WHITE)\n    black_distance = distance_to_king(chess.BLACK)\n    result = black_distance - white_distance\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's back rank as a measure of offensive pressure.\"\n    white_pieces_on_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_pieces_on_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n\n    result = float(white_pieces_on_back_rank - black_pieces_on_back_rank)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are currently pinned by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if board.is_attacked_by(not board.turn, target.to_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pieces to gauge control of the board.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of fork opportunities available for the player.\"\n    fork_opportunities = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if len(board.attackers(board.piece_at(move.to_square).color, move.to_square)) > 1:\n            fork_opportunities += 1\n        board.pop()\n    return float(fork_opportunities)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates mobility by considering the total number of legal moves per piece.\"\n    total_mobility = 0.0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            total_mobility += len(list(board.legal_moves))\n    return total_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns for each color on the board.\"\n    white_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by more than one piece for the player to move.\"\n    defended_count = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(board.turn, square):\n            attackers = len(board.attackers(board.turn, square))\n            if attackers > 1:\n                defended_count += 1\n    return float(defended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of fork opportunities available for the player.\"\n    fork_opportunities = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if len(board.attackers(board.piece_at(move.to_square).color, move.to_square)) > 1:\n            fork_opportunities += 1\n        board.pop()\n    return float(fork_opportunities)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned, indicating potential tactical vulnerabilities.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and len(board.attackers(board.piece_map()[square].color, square)) > 1)\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each side's pawns to the opponent's back rank, emphasizing advancement.\"\n    def pawn_distance(color):\n        total_distance = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                if color == chess.WHITE:\n                    total_distance += chess.square_rank(square)  # Distance to rank 8\n                else:\n                    total_distance += 7 - chess.square_rank(square)  # Distance to rank 1\n        return total_distance\n\n    white_distance = pawn_distance(chess.WHITE)\n    black_distance = pawn_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    white_doubled = 0\n    black_doubled = 0\n    pawn_squares = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_squares:\n                pawn_squares[file] = {chess.WHITE: 0, chess.BLACK: 0}\n            pawn_squares[file][piece.color] += 1\n\n    for counts in pawn_squares.values():\n        if counts[chess.WHITE] > 1:\n            white_doubled += counts[chess.WHITE] - 1\n        if counts[chess.BLACK] > 1:\n            black_doubled += counts[chess.BLACK] - 1\n\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank, indicating potential threats.\"\n    distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            rank_distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            distance += rank_distance if piece.color == chess.WHITE else -rank_distance\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces for both players based on standard chess piece values.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # King value can generally be ignored as it doesn't influence material balance\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces on the board, representing activity level.'\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe king squares available for both players.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) == False)\n    black_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) == False)\n    \n    return float(white_safe_squares - black_safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the overall imbalance in piece value on the board.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distances = [chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE]\n    return float(sum(distances) / len(distances)) if distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks available for the player to move.\"\n    discovered_attack_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not board.turn, move.to_square):\n                    discovered_attack_count += 1\n    return float(discovered_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of non-pawn pieces remaining for each player to assess piece strength.'\n    non_pawn_types = {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING}\n    white_non_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in non_pawn_types)\n    black_non_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in non_pawn_types)\n    return float(white_non_pawns - black_non_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety for each player by counting how many pawns protect their king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_protected = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.BLACK, square) and chess.square_distance(square, white_king_square) <= 1)\n    black_protected = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.WHITE, square) and chess.square_distance(square, black_king_square) <= 1)\n    return float(white_protected - black_protected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns on the board, which can influence strategic decisions.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces from their respective back ranks, indicating the development stage.\"\n    white_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential forks available for each player.\"\n    potential_forks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if len(board.attackers(chess.BLACK, move.to_square)) > 1:\n                        potential_forks += 1\n        else:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if len(board.attackers(chess.WHITE, move.to_square)) > 1:\n                        potential_forks += 1\n    return float(potential_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of minor pieces each side has (knights and bishops).\"\n    white_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minors - black_minors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks to indicate control of the board.\"\n    white_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    result = white_distribution - black_distribution\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting rank for each player.'\n    distance_w = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distance_b = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distance_w - distance_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares attacked by each side\u2019s pieces.'\n    total_attacks_white = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_attacks_black = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(total_attacks_white - total_attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each color.\"\n    white_doubled = sum(1 for file in range(8) if (board.piece_at(chess.parse_square(f'{chr(file + 97)}2')) and board.piece_at(chess.parse_square(f'{chr(file + 97)}3'))))\n    black_doubled = sum(1 for file in range(8) if (board.piece_at(chess.parse_square(f'{chr(file + 97)}7')) and board.piece_at(chess.parse_square(f'{chr(file + 97)}6'))))\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the relative piece activity by counting pieces that have more than one legal move.\"\n    active_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            legal_moves = list(board.legal_moves)\n            if any(move.from_square == square for move in legal_moves):\n                active_piece_count += 1\n    return float(active_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance from all pieces to the nearest enemy king.\"\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != (chess.WHITE if board.turn else chess.BLACK))\n    distance_sum = sum(chess.square_distance(square, enemy_king_square) for square in board.piece_map().keys())\n    result = float(distance_sum)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned, indicating potential tactical vulnerabilities.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and len(board.attackers(board.piece_map()[square].color, square)) > 1)\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from their respective corners, evaluating potential for endgame.\"\n    def distance_to_corner(color):\n        corner_squares = [chess.A1, chess.H1] if color == chess.WHITE else [chess.A8, chess.H8]\n        return sum(chess.square_distance(sq, corner) for sq in board.piece_map() if board.piece_at(sq).color == color for corner in corner_squares)\n\n    white_distance = distance_to_corner(chess.WHITE)\n    black_distance = distance_to_corner(chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of rooks to total pieces for each player.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    total_white = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    ratio_white = white_rooks / total_white if total_white > 0 else 0.0\n    ratio_black = black_rooks / total_black if total_black > 0 else 0.0\n    result = ratio_white - ratio_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares left unoccupied for pawns to potentially promote.\"\n    white_pawn_promotable = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawn_promotable = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawn_promotable - black_pawn_promotable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board considering their types.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # Kings are invaluable\n    }\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n        total_value += value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponents' half of the board for spatial control.\"\n    white_pieces_in_opponent_half = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are pinned by the opponent.'\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type == chess.QUEEN:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks by each player.\"\n    discovered_attacks_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            potential_moves = [move for move in board.legal_moves if board.piece_at(square) and chess.square_file(move.from_square) == chess.square_file(square)]\n            discovered_attacks_count += len(potential_moves)\n    return float(discovered_attacks_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal pawn moves available for each player.\"\n    white_pawn_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.WHITE)\n    black_pawn_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_pawn_moves - black_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces defending each player's king, adding layers of safety.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n\n    white_defenders = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and sq != white_king_square and piece.piece_type != chess.KING and board.is_attacked_by(chess.BLACK, white_king_square))\n    black_defenders = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and sq != black_king_square and piece.piece_type != chess.KING and board.is_attacked_by(chess.WHITE, black_king_square))\n\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's king, measuring potential threats.\"\n    king_square = next((s for s, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    piece_distances = [chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK)]\n    return float(sum(piece_distances) / len(piece_distances)) if piece_distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank, indicating potential threats.\"\n    distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            rank_distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            distance += rank_distance if piece.color == chess.WHITE else -rank_distance\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the value of pieces in play weighted by their distance to the center.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_value[board.piece_at(square).piece_type] / (1 + chess.square_distance(square, chess.D4)) for square in board.piece_map() if board.piece_at(square) is not None)\n    return float(total_value)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of connected pawns for each player, indicating pawn structure strength.'\n    connected_pawn_count = 0\n    for file in range(8):\n        last_pawn_rank = -1\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                if last_pawn_rank == rank - 1:  # Check if connected\n                    connected_pawn_count += 1\n                last_pawn_rank = rank\n    return float(connected_pawn_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from their respective corners, evaluating potential for endgame.\"\n    def distance_to_corner(color):\n        corner_squares = [chess.A1, chess.H1] if color == chess.WHITE else [chess.A8, chess.H8]\n        return sum(chess.square_distance(sq, corner) for sq in board.piece_map() if board.piece_at(sq).color == color for corner in corner_squares)\n\n    white_distance = distance_to_corner(chess.WHITE)\n    black_distance = distance_to_corner(chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces each player has compared to the total piece count.\"\n    total_pieces = len(board.piece_map())\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    return float(white_piece_count / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks available for the player to move.\"\n    double_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            attackers_count = len(board.attackers(piece.color, square))\n            if attackers_count > 1:  # For double attacks\n                double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of passed pawns for each color.\"\n    def passed_pawn_count(color):\n        count = 0\n        for sq, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(sq)\n                rank = chess.square_rank(sq)\n                if color == chess.WHITE and all(board.piece_at(chess.parse_square(chess.square_name(file + (i * 8)))) is None for i in range(rank + 1, 8)):\n                    count += 1\n                elif color == chess.BLACK and all(board.piece_at(chess.parse_square(chess.square_name(file + (i * 8)))) is None for i in range(0, rank)):\n                    count += 1\n        return count\n\n    return float(passed_pawn_count(chess.WHITE) - passed_pawn_count(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the back rank to assess defensiveness.\"\n    white_back_rank = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    black_back_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    white_back_rank_count = sum(1 for square in white_back_rank if board.piece_at(square) is not None)\n    black_back_rank_count = sum(1 for square in black_back_rank if board.piece_at(square) is not None)\n    return float(white_back_rank_count - black_back_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by opposing pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of the pieces present in the two halves of the board.\"\n    white_in_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_file(sq) < 4)\n    black_in_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_file(sq) < 4)\n    return float(white_in_half - black_in_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are advanced into the opponent's territory.\"\n    advanced_pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) >= 4:\n            advanced_pieces_count += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) <= 3:\n            advanced_pieces_count -= 1\n    return float(advanced_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the total number of squares available for knights, reflecting mobility.\"\n    knight_mobility = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT:\n            knight_mobility += len(list(board.legal_moves))\n        elif piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT:\n            knight_mobility -= len(list(board.legal_moves))\n    return float(knight_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks by each player.\"\n    discovered_attacks_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            potential_moves = [move for move in board.legal_moves if board.piece_at(square) and chess.square_file(move.from_square) == chess.square_file(square)]\n            discovered_attacks_count += len(potential_moves)\n    return float(discovered_attacks_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns each player has that are not blocked (pawns that can advance).\"\n    unblockable_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and \n                            ((board.piece_map()[square].color == chess.WHITE and \n                             board.piece_at(square + 8) is None) or \n                             (board.piece_map()[square].color == chess.BLACK and \n                             board.piece_at(square - 8) is None)))\n    return float(unblockable_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks to evaluate piece activity.\"\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to promotion to evaluate offensive potential.\"\n    pawn_distance_to_promotion = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn)\n    \n    result = float(pawn_distance_to_promotion)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that have advanced to the 5th rank or beyond.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         (piece.color == chess.WHITE and chess.square_rank(square) >= 4 or \n                          piece.color == chess.BLACK and chess.square_rank(square) <= 3))\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy pawns to assess pressure.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces controlled by each player.\"\n    white_controlled = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.WHITE, square))\n    black_controlled = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.BLACK, square))\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility ratio by comparing the number of legal moves for both players.'\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn back\n    return float(white_moves / (black_moves + 1e-5))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of pieces by counting available moves for each color.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch to the other player\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    result = float(white_moves - black_moves)\n    return result\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces controlled by each player's pawns.\"\n    white_controlled_squares = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and board.attackers(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and board.attackers(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of different piece types present on the board.\"\n    piece_types = set()\n    for piece in board.piece_map().values():\n        piece_types.add(piece.piece_type)\n    return float(len(piece_types))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned, indicating potential tactical vulnerabilities.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and len(board.attackers(board.piece_map()[square].color, square)) > 1)\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of the pieces present in the two halves of the board.\"\n    white_in_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_file(sq) < 4)\n    black_in_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_file(sq) < 4)\n    return float(white_in_half - black_in_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the number of squares attacked by minor pieces to assess zone control.'\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            attacked_squares.update(board.attackers(piece.color, square))\n    return float(len(attacked_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average square value of all pieces on the board.\"\n    piece_square_values = {\n        chess.PAWN: 0.5, chess.KNIGHT: 2.5, chess.BISHOP: 3.0,\n        chess.ROOK: 4.5, chess.QUEEN: 6.0, chess.KING: 7.0\n    }\n    total_value = 0\n    piece_count = 0\n    for piece in board.piece_map().values():\n        total_value += piece_square_values.get(piece.piece_type, 0)\n        piece_count += 1\n    return total_value / piece_count if piece_count > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in moves to reach the opponent's back rank.\"\n    distance_to_back_rank = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(distance_to_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on each side's third rank, indicating potential advancement.\"\n    white_third_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 2)\n    black_third_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 5)\n    result = float(white_third_rank - black_third_rank)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces protected by pawns for each player.'\n    def count_protected_by_pawns(color):\n        protected_pieces = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for pawn_offset in [-8, -7, -9]:\n                    if board.piece_at(square + pawn_offset) is not None and board.piece_at(square + pawn_offset).piece_type == chess.PAWN and board.piece_at(square + pawn_offset).color == color:\n                        protected_pieces += 1\n                        break\n        return protected_pieces\n    return float(count_protected_by_pawns(chess.WHITE) - count_protected_by_pawns(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each piece from the center of the board, promoting control.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    distance_sum = sum(chess.square_distance(square, center_square) for square in board.piece_map() for center_square in center_squares)\n    return float(distance_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting how many squares each piece can legally move to.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    \n    for square in board.piece_map():\n        piece_count += 1\n        distance = min(chess.square_distance(square, csq) for csq in center_squares)\n        total_distance += distance\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks to indicate control of the board.\"\n    white_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    result = white_distribution - black_distribution\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces in the opponent's half of the board.\"\n    opponent_half = range(0, 4) if board.turn else range(4, 8)\n    return float(sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) in opponent_half))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces from the center (d4, d5, e4, e5) and returns the difference.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_distance = sum(chess.square_distance(sq, csq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE for csq in central_squares)\n    black_distance = sum(chess.square_distance(sq, csq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK for csq in central_squares)\n    return black_distance - white_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are currently defending each player's king.\"\n    white_defenders = sum(1 for sq in board.attackers(chess.WHITE, board.king(chess.WHITE)))\n    black_defenders = sum(1 for sq in board.attackers(chess.BLACK, board.king(chess.BLACK)))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of rook connections (where rooks control the same file or rank).\"\n    rook_positions = [square for square, piece in board.piece_map().items() \n                      if piece.piece_type == chess.ROOK]\n    connection_count = sum(1 for square1 in rook_positions \n                           for square2 in rook_positions \n                           if square1 != square2 and \n                           (chess.square_file(square1) == chess.square_file(square2) or \n                            chess.square_rank(square1) == chess.square_rank(square2))\n                          )\n    return float(connection_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of forks available for each side, considering multiple attacking pieces.\"\n    white_forks = len([move for move in board.legal_moves \n                       if len(board.attackers(chess.BLACK, move.to_square)) > 1])\n    black_forks = len([move for move in board.legal_moves \n                       if len(board.attackers(chess.WHITE, move.to_square)) > 1])\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of kingside and queenside pawn structures for both players, assessing endgame potential.\"\n    white_ks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 1 and chess.square_file(square) >= 4)\n    white_qs = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 1 and chess.square_file(square) < 4)\n    black_ks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6 and chess.square_file(square) >= 4)\n    black_qs = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6 and chess.square_file(square) < 4)\n    result = float((white_ks - black_ks) + (white_qs - black_qs))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces with more than one legal move for both players.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and board.piece_at(move.from_square).piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN))\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and board.piece_at(move.from_square).piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN))\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each king to the center of the board.\"\n    white_king_square = next((square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE), None)\n    black_king_square = next((square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        white_distance = chess.square_distance(white_king_square, chess.square(4, 4))\n        black_distance = chess.square_distance(black_king_square, chess.square(4, 4))\n        return float(white_distance - black_distance)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of different piece types remaining for each player.\"\n    piece_types_white = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE}\n    piece_types_black = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK}\n\n    return float(len(piece_types_white) - len(piece_types_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for both sides.\"\n    white_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_white = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    white_ratio = white_minors / total_white if total_white > 0 else 0.0\n    black_ratio = black_minors / total_black if total_black > 0 else 0.0\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of times each player's pieces attack each other's pieces.\"\n    def attacking_moves(color):\n        attacks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == color and board.attackers(not color, move.to_square))\n        return attacks\n\n    white_attacks = attacking_moves(chess.WHITE)\n    black_attacks = attacking_moves(chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns for both players.\"\n    def is_isolated(square):\n        file = chess.square_file(square)\n        return (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None)\n\n    white_isolated = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and \n                        board.piece_at(square).piece_type == chess.PAWN and is_isolated(square)))\n    black_isolated = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.BLACK and \n                        board.piece_at(square).piece_type == chess.PAWN and is_isolated(square)))\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for White.\"\n    total_rank = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    result = total_rank / count if count > 0 else 0.0\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the presence of passed pawns for both sides, as an indicator of endgame potential.\"\n    white_passed = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE and \n                        all(board.piece_at(square) is None or board.piece_at(square).color == chess.WHITE for square in board.attacks(sq))) \n    black_passed = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK and \n                        all(board.piece_at(square) is None or board.piece_at(square).color == chess.BLACK for square in board.attacks(sq)))\n    return float(white_passed - black_passed)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has in the opponent\u2019s half of the board.\"\n    white_half = range(0, 4)\n    black_half = range(4, 8)\n    white_count = sum(1.0 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) in white_half)\n    black_count = sum(1.0 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) in black_half)\n    return white_count - black_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board, indicating safety and mobility.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4)  # Center square\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n    result = black_distance - white_distance  # Positive if White's king is closer\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of active pieces (pieces with legal moves) for each color.\"\n    white_active = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_active = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns ready to promote (on the 7th rank).'\n    promoting_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn and chess.square_rank(square) == 6)\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of semi-open files for both players.\"\n    semi_open_files = 0\n    for file in range(8):\n        white_pawn_present = any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE for rank in range(8))\n        black_pawn_present = any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK for rank in range(8))\n        if white_pawn_present and not black_pawn_present:\n            semi_open_files += 1\n        elif black_pawn_present and not white_pawn_present:\n            semi_open_files -= 1\n    return float(semi_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the seventh rank for both sides, highlighting offensive potential.\"\n    seventh_rank_white = sum(1 for square in range(48, 56) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    seventh_rank_black = sum(1 for square in range(8, 16) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece mobility based on the distance from the center.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    mobility = sum(len(list(board.legal_moves)) for square in center_squares if board.piece_at(square))\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces on the board.\"\n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n\n    white_ratio = minor_white / (major_white + 1)  # Prevent division by zero\n    black_ratio = minor_black / (major_black + 1)  # Prevent division by zero\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the number of pieces on each player\\'s back rank to assess readiness for action.'\n    white_back_rank_pieces = sum(1 for square in range(8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces around the kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_defenders = sum(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, black_king_square))\n    black_defenders = sum(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, white_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces threatening the opponent's king.\"\n    white_threats = sum(1 for square in board.attackers(chess.WHITE, chess.parse_square('e8')) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_threats = sum(1 for square in board.attackers(chess.BLACK, chess.parse_square('e1')) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's king from the opponent's back rank, indicating aggression.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance_white = 7 - chess.square_rank(black_king_square)\n    distance_black = chess.square_rank(white_king_square)\n    result = distance_white - distance_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns are on the 6th and 7th ranks, indicating promotion potential.\"\n    pawn_rank_count = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    pawn_rank_count += sum(1 for square in range(chess.A6, chess.H6 + 1) if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawn_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the piece activity by counting the number of pieces that can move to an open square.'\n    mobility_count = 0\n    for move in board.legal_moves:\n        mobility_count += 1\n    result = float(mobility_count)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the overall fitness of pawns considering their advanced positions.\"\n    advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (chess.square_rank(square) >= 4 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) <= 3))\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by more than one piece for the player to move.\"\n    defended_squares = {}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacked_square in board.attackers(not board.turn, square):\n                if attacked_square not in defended_squares:\n                    defended_squares[attacked_square] = 0\n                defended_squares[attacked_square] += 1\n\n    multi_defended_count = sum(1 for count in defended_squares.values() if count > 1)\n    return float(multi_defended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the sum of the absolute ranks of all pieces of a player to assess position advantage.'\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank += chess.square_rank(square) + 1  # +1 to make ranks 1-indexed\n    return float(total_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces each player has supported by another piece.\"\n    white_support = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and any(board.is_attacked_by(chess.WHITE, sq) for sq in board.attackers(chess.BLACK, sq)))\n    black_support = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and any(board.is_attacked_by(chess.BLACK, sq) for sq in board.attackers(chess.WHITE, sq)))\n    return float(white_support - black_support)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by pieces of each color.\"\n    white_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates piece coordination by counting pairs of pieces within one knight move of each other.'\n    count_pairs = 0\n    piece_positions = list(board.piece_map().keys())\n    for i in range(len(piece_positions)):\n        for j in range(i + 1, len(piece_positions)):\n            if chess.square_distance(piece_positions[i], piece_positions[j]) <= 3:\n                count_pairs += 1\n    return float(count_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pawns, indicating pawn power and influence.\"\n    def controlled_by_pawns(color):\n        controlled_squares = set()\n        for square in range(64):\n            if board.piece_at(square) is not None and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                if color == chess.WHITE:\n                    if square >= 8:\n                        controlled_squares.add(square - 8)\n                    if square % 8 != 0:\n                        controlled_squares.add(square - 7)\n                    if square % 8 != 7:\n                        controlled_squares.add(square - 9)\n                else:\n                    if square <= 55:\n                        controlled_squares.add(square + 8)\n                    if square % 8 != 0:\n                        controlled_squares.add(square + 9)\n                    if square % 8 != 7:\n                        controlled_squares.add(square + 7)\n\n        return len(controlled_squares)\n\n    white_controlled = controlled_by_pawns(chess.WHITE)\n    black_controlled = controlled_by_pawns(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of secured pieces from the enemy's back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if (piece.color == chess.WHITE and piece.piece_type != chess.KING) or (piece.color == chess.BLACK and piece.piece_type != chess.KING):\n            distance = chess.square_distance(square, chess.parse_square('a8' if piece.color == chess.BLACK else 'h1'))\n            total_distance += distance\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights each player has on the board.\"\n    white_knights = len([p for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.WHITE])\n    black_knights = len([p for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.BLACK])\n    return float(white_knights - black_knights)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces being attacked by more than one opposing piece.\"\n    white_doubly_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) > 1)\n    black_doubly_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) > 1)\n    return float(white_doubly_attacked - black_doubly_attacked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure for both sides by counting isolated pawns.\"\n    def count_isolated_pawns(color):\n        return sum(1 for sq, piece in board.piece_map().items() if piece.color == color and\n                   (chess.square_file(sq) == 0 or board.piece_at(sq - 1) is None) and\n                   (chess.square_file(sq) == 7 or board.piece_at(sq + 1) is None))\n    return float(count_isolated_pawns(chess.WHITE) - count_isolated_pawns(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides, focusing on non-pawn pieces.\"\n    piece_value = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces attacking the enemy king for each player, reflecting pressure on the king.\"\n    def count_attacks_king(color):\n        king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, king_square) and board.piece_at(sq).color != color)\n    \n    white_attack_count = count_attacks_king(chess.WHITE)\n    black_attack_count = count_attacks_king(chess.BLACK)\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for both players, distinguishing material strengths.\"\n    total_material = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        total_material += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    \n    return float(total_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the presence of passed pawns for each color, which can be crucial in endgames.\"\n    def is_passed_pawn(square, color):\n        own_pawn = board.piece_at(square) and board.piece_at(square).color == color\n        if not own_pawn:\n            return False\n        file = chess.square_file(square)\n        for r in range(chess.square_rank(square) + 1, 8):\n            for f in (file - 1, file, file + 1):\n                if 0 <= f < 8 and (board.piece_at(chess.square(f, r)) and board.piece_at(chess.square(f, r)).color != color):\n                    return False\n        return True\n\n    white_passed = sum(is_passed_pawn(sq, chess.WHITE) for sq in chess.SQUARES)\n    black_passed = sum(is_passed_pawn(sq, chess.BLACK) for sq in chess.SQUARES)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are hanging (unprotected and can be captured next move).\"\n    hanging_count = sum(1 for square in board.piece_map() if board.piece_at(square) and \n                        not any(board.is_attacked_by(board.piece_at(square).color, attacker_square) for attacker_square in board.attackers(\n                            chess.BLACK if board.piece_at(square).color == chess.WHITE else chess.WHITE, square)))\n    return float(hanging_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares attacked by each side\u2019s pieces.'\n    total_attacks_white = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_attacks_black = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(total_attacks_white - total_attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each color.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all white pieces on the board.\"\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank += chess.square_rank(square)\n    return float(total_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king's distance to the center of the board to assess king safety.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance_to_center_white = (chess.square_rank(white_king_square) - 3) ** 2 + (chess.square_file(white_king_square) - 3) ** 2\n    distance_to_center_black = (chess.square_rank(black_king_square) - 4) ** 2 + (chess.square_file(black_king_square) - 4) ** 2\n    return float(distance_to_center_white - distance_to_center_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity score based on the number of legal moves for all pieces.\"\n    white_mobility = sum(len(list(board.legal_moves)) if board.piece_at(sq).color == chess.WHITE else 0 for sq in board.piece_map())\n    black_mobility = sum(len(list(board.legal_moves)) if board.piece_at(sq).color == chess.BLACK else 0 for sq in board.piece_map())\n    result = white_mobility - black_mobility\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the potential advancement of the most advanced pawn for each side.'\n    white_advanced = max((chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN), default=-1)\n    black_advanced = max((7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN), default=-1)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material distribution, taking into account the value of pieces within the opponent's territory.\"\n    value_map = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    material_difference = 0.0\n    for square, piece in board.piece_map().items():\n        if (piece.color == board.turn and chess.square_rank(square) > 4) or (piece.color != board.turn and chess.square_rank(square) < 4):\n            material_difference += value_map.get(piece.piece_type, 0) * (1 if piece.color == board.turn else -1)\n    return float(material_difference)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are pinned for each color.\"\n    pinned_white = sum(1 for square in board.piece_map() \n                       if board.piece_map()[square].color == chess.WHITE and \n                       any(board.is_attacked_by(chess.BLACK, target) \n                           for target in board.attackers(chess.WHITE, square)))\n    pinned_black = sum(1 for square in board.piece_map() \n                       if board.piece_map()[square].color == chess.BLACK and \n                       any(board.is_attacked_by(chess.WHITE, target) \n                           for target in board.attackers(chess.BLACK, square)))\n    result = pinned_white - pinned_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of passive pieces for each color, which are not defending or attacking any piece.'\n    passive_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, square) for move in board.legal_moves if move.from_square == square))\n    passive_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, square) for move in board.legal_moves if move.from_square == square))\n    return float(passive_white - passive_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for each player.\"\n    backward_pawns_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and all(board.piece_at(chess.square(chess.square_file(square), rank)) is None for rank in range(chess.square_rank(square)+1, 8)))\n    backward_pawns_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and all(board.piece_at(chess.square(chess.square_file(square), rank)) is None for rank in range(0, chess.square_rank(square))))\n    result = float(backward_pawns_white - backward_pawns_black)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks the number of attacking configurations with respect to each player's pieces.\"\n    white_attacking_configs = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_attacking_configs = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_attacking_configs - black_attacking_configs)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for each color.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of threats, counting pieces attacking opponent's major pieces.\"\n    major_piece_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type in [chess.QUEEN, chess.ROOK] and board.is_attacked_by(not board.turn, square))\n    return float(major_piece_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the opponent's half of the board.\"\n    white_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                         if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                         if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = white_pieces_in_opponent_half - black_pieces_in_opponent_half\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the ratio of bishops to total pieces for each color.'\n    bishops_count = {chess.WHITE: 0, chess.BLACK: 0}\n    total_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        total_pieces[piece.color] += 1\n        if piece.piece_type == chess.BISHOP:\n            bishops_count[piece.color] += 1\n    ratio = (bishops_count[chess.WHITE] / total_pieces[chess.WHITE] if total_pieces[chess.WHITE] > 0 else 0) - \\\n            (bishops_count[chess.BLACK] / total_pieces[chess.BLACK] if total_pieces[chess.BLACK] > 0 else 0)\n    return float(ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns advanced past the opponent's 4th rank.\"\n    advanced_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n            if chess.square_rank(square) > 3:\n                advanced_pawns += 1\n        elif piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n            if chess.square_rank(square) < 4:\n                advanced_pawns += 1\n    \n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to an unprotected square on the next turn.\"\n    unprotected_squares = [square for square in chess.SQUARES if not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square)]\n    movable_pieces = sum(1 for move in board.legal_moves if move.to_square in unprotected_squares)\n    return float(movable_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can potentially fork opposing pieces.\"\n    forking_pieces_count = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(chess.BLACK, move.to_square):\n                    forking_pieces_count += 1\n    \n    return float(forking_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are within two squares of the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    close_pieces_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_distance(square, opponent_king_square) <= 2:\n            close_pieces_count += 1\n    return float(close_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = white_control - black_control\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player.\"\n    def controlled_squares(color):\n        controlled = sum(1 for square in range(64) if board.is_attacked_by(color, square))\n        return controlled\n\n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares with more than one piece to assess congestion.\"\n    congested_squares = sum(1 for square in board.piece_map() if \n                             len(board.attackers(chess.WHITE, square)) > 1 or \n                             len(board.attackers(chess.BLACK, square)) > 1)\n    result = float(congested_squares)\n    return result\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures piece coordination by counting pairs of pieces that can attack the same square.\"\n    attack_pairs = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            attack_pairs += 1\n    return float(attack_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are double attacked by both players.\"\n    double_attacked_squares = sum(1 for sq in chess.SQUARES if len(board.attackers(chess.WHITE, sq)) > 0 and len(board.attackers(chess.BLACK, sq)) > 0)\n    return float(double_attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces within the opponent's reach, indicating potential threats.\"\n    reach = sum(len(board.attackers(piece.color, square)) for square in board.piece_map() for piece in [board.piece_at(square)] if piece)\n    return float(reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the 7th rank to evaluate pressure on the opponent.\"\n    white_7th_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_7th_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = white_7th_rank - black_7th_rank\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(board.turn, square):\n            # Check if the piece is pinned\n            if len(board.attackers(not board.turn, square)) > 0:\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece mobility by calculating the average number of legal moves per piece.\"\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    piece_count = len(board.piece_map())\n    return total_moves / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by each player's pieces in the central area of the board (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_central_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_central_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_central_count - black_central_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting rank for each player.'\n    distance_w = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distance_b = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distance_w - distance_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces obstructing each player's king mobility, indicating safety.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n\n    white_obstructed = sum(1 for move in board.legal_moves if move.from_square == white_king_square and board.piece_at(move.to_square) is not None)\n    black_obstructed = sum(1 for move in board.legal_moves if move.from_square == black_king_square and board.piece_at(move.to_square) is not None)\n\n    result = float(black_obstructed - white_obstructed)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total value of pieces in the center of the board for both players.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for sq in central_squares:\n        piece = board.piece_at(sq)\n        if piece is not None:\n            value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    \n    return float(value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank to indicate offensive positioning.\"\n    def average_distance(color):\n        total_distance = 0\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                distance = chess.square_distance(square, 0 if color == chess.BLACK else 56)\n                total_distance += distance\n                count += 1\n        return total_distance / count if count > 0 else 0\n    \n    white_avg_distance = average_distance(chess.WHITE)\n    black_avg_distance = average_distance(chess.BLACK)\n    result = white_avg_distance - black_avg_distance\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the first two ranks for both players.\"\n    white_ranks = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) < 2)\n    black_ranks = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) > 5)\n    return float(white_ranks - black_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color based on piece attacks.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of pawns for each color.\"\n    white_pawn_value = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN]) * 1\n    black_pawn_value = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN]) * 1\n    return float(white_pawn_value - black_pawn_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on the 7th rank for both sides.\"\n    white_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    black_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    return float(white_rooks_on_seventh - black_rooks_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of potential discovered attacks for each player, indicating tactical opportunities.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not piece.color, move.to_square):\n                    discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks both sides can make next.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    result = float(white_checks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each player has on the board, weighted by standard piece values.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of material value over the board.\"\n    value_distribution = sum(piece.piece_type for piece in board.piece_map().values())\n    return float(value_distribution)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces of each type on the board.\"\n    piece_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for piece in board.piece_map().values():\n        piece_count[piece.piece_type] += 1\n    return float(piece_count[chess.QUEEN] * 9 + piece_count[chess.ROOK] * 5 + \n                 piece_count[chess.BISHOP] * 3 + piece_count[chess.KNIGHT] * 3 + \n                 piece_count[chess.PAWN] * 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of pieces available to each player and returns the ratio.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return white_value / (black_value + 1e-10)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares around the king that are either occupied or attacked.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING)\n    unsafe_squares = sum(1 for sq in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, sq) or board.piece_at(sq) is not None)\n    return float(unsafe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of backward pawns for each color, indicating vulnerabilities.'\n    backward_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and (piece.color == chess.WHITE and \n                (board.piece_at(sq + 8) is None or\n                (board.piece_at(sq + 8) and chess.square_rank(sq + 8) < chess.square_rank(sq)))):\n                backward_pawns += 1\n            elif piece.color == chess.BLACK and (piece.color == chess.BLACK and \n                (board.piece_at(sq - 8) is None or\n                (board.piece_at(sq - 8) and chess.square_rank(sq - 8) > chess.square_rank(sq)))):\n                backward_pawns -= 1\n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of minor pieces (knights + bishops) remaining for both sides.\"\n    white_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return white_minor_count - black_minor_count\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered check possibilities for both sides.\"\n    discovered_checks = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == sq:\n                    board.push(move)\n                    if board.is_check():\n                        discovered_checks += 1\n                    board.pop()\n    return float(discovered_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures control of the center by counting the pawns on d4, d5, e4, e5 squares.\"\n    center_control = 0\n    for square in [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                center_control += 1\n            else:\n                center_control -= 1\n    return float(center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the opponent's half of the board for aggression evaluation.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value_white = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    total_value_black = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(total_value_white - total_value_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the total number of pawns on the 4th rank.\"\n    white_pawns_on_4th = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 3)\n    black_pawns_on_4th = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 4)\n    return float(white_pawns_on_4th - black_pawns_on_4th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned to the king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces not currently defending any squares.\"\n    non_defending_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(piece.color, square))\n    return float(non_defending_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces attacked by both players as a measure of activity.'\n    white_attacked_count = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacked_count = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacked_count - black_attacked_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center (e4 and e5).\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        distance_white = chess.square_distance(white_king_square, chess.E4)\n        distance_black = chess.square_distance(black_king_square, chess.E5)\n        return float(distance_white - distance_black)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of isolated pawns for both players.\"\n    result = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if not board.is_attacked_by(piece.color, square):\n                if (board.piece_at(square + 1) is None and board.piece_at(square - 1) is None): \n                    result += 1.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = white_control - black_control\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of backward pawns for both players.\"\n    backward_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and board.piece_at(square + 8) is None and (square % 8 != 7):\n                backward_pawns += 1\n            elif piece.color == chess.BLACK and board.piece_at(square - 8) is None and (square % 8 != 0):\n                backward_pawns += 1\n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns passed for both sides, indicating potential for promotion.\"\n    white_passed_pawns = 0\n    black_passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, square + i) for i in range(1, 9) if chess.square_file(square) + i < 8):\n                white_passed_pawns += 1\n            elif piece.color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, square - i) for i in range(1, 9) if chess.square_file(square) - i >= 0):\n                black_passed_pawns += 1\n    return float(white_passed_pawns - black_passed_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player's pieces.\"\n    white_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE))\n    black_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of pieces to their respective home ranks.\"\n    white_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of double attacks from pieces of each side.\"\n    def count_double_attacks(color):\n        double_attacks = 0\n        for sq, piece in board.piece_map().items():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if move.from_square == sq and board.is_attacked_by(not color, move.to_square):\n                        double_attacks += 1\n        return double_attacks\n    white_doubles = count_double_attacks(chess.WHITE)\n    black_doubles = count_double_attacks(chess.BLACK)\n    return float(white_doubles - black_doubles)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available squares for all pieces, giving an idea of piece mobility.\"\n    mobility_count = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(mobility_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the square control by summing the number of attacks made by pieces.\"\n    total_attacks = 0\n    for square in range(64):\n        total_attacks += len(board.attackers(chess.WHITE, square)) - len(board.attackers(chess.BLACK, square))\n    return float(total_attacks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(square, piece.piece_type) for square, piece in board.piece_map().items())\n    average_distance = total_distance / len(board.piece_map()) if board.piece_map() else 0\n    return float(average_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the positional advantage by calculating the number of pieces on the seventh rank.\"\n    seventh_rank_count = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 6 and board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE) \\\n                       - sum(1 for square in chess.SQUARES if chess.square_rank(square) == 1 and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n                       \n    return float(seventh_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from their respective king's squares.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_distance = sum(chess.square_distance(square, white_king_square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_distance = sum(chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces that each side has.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    ratio_white = white_minor / (white_major + 1)  # Adding 1 to avoid division by zero\n    ratio_black = black_minor / (black_major + 1)  # Adding 1 to avoid division by zero\n    return float(ratio_white - ratio_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity score based on the number of legal moves for all pieces.\"\n    white_mobility = sum(len(list(board.legal_moves)) if board.piece_at(sq).color == chess.WHITE else 0 for sq in board.piece_map())\n    black_mobility = sum(len(list(board.legal_moves)) if board.piece_at(sq).color == chess.BLACK else 0 for sq in board.piece_map())\n    result = white_mobility - black_mobility\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board weighted by their positions.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_weighted_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square))\n        piece_count += 1\n    \n    return total_weighted_value / (piece_count if piece_count > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces around the kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_defenders = sum(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, black_king_square))\n    black_defenders = sum(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, white_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) by each side.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective kings, indicating possible vulnerability.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distances = sum(chess.square_distance(square, white_king_square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distances -= sum(chess.square_distance(square, black_king_square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distances)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the center of the board, reflecting overall control.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, chess.parse_square('d4')) + chess.square_distance(square, chess.parse_square('e4'))\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for each player, indicating potential advancement.\"\n    white_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for each player.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the 2nd and 7th ranks for each player.\"\n    back_rank_white = sum(1 for square in range(16, 24) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility ratio by comparing the number of legal moves for both players.'\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn back\n    return float(white_moves / (black_moves + 1e-5))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility ratio by comparing the number of legal moves for both players.'\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn back\n    return float(white_moves / (black_moves + 1e-5))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by both players' pieces to assess control.\"\n    white_attacked_squares = len(set(square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE for square in board.attacks(move.to_square)))\n    black_attacked_squares = len(set(square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK for square in board.attacks(move.to_square)))\n    return float(white_attacked_squares - black_attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each side excluding occupied squares.\"\n    controlled_squares_white = {square for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None}\n    controlled_squares_black = {square for square in range(64) if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None}\n    \n    return float(len(controlled_squares_white) - len(controlled_squares_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the central pawn structure by counting pawns on central files.\"\n    central_pawns = sum(1 for square in [chess.D4, chess.E4, chess.D5, chess.E5] if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(central_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the average rank of pieces for both sides to evaluate their control of the board.'\n    total_white_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_black_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    white_avg_rank = total_white_rank / (len(board.piece_map()) / 2) if board.piece_map() else 0\n    black_avg_rank = total_black_rank / (len(board.piece_map()) / 2) if board.piece_map() else 0\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts how many squares are under attack by pawns for the player to move.'\n    pawn_attack_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            # Check diagonal attacks\n            if file > 0 and rank < 7 and board.is_attacked_by(not board.turn, chess.parse_square(chess.square_name(square - 9))):\n                pawn_attack_squares += 1\n            if file < 7 and rank < 7 and board.is_attacked_by(not board.turn, chess.parse_square(chess.square_name(square - 7))):\n                pawn_attack_squares += 1\n\n    return float(pawn_attack_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the back rank.\"\n    back_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    white_back_rank = sum(1 for square in back_rank if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in back_rank if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total threats posed by each player by counting how many opponent pieces are attacked.\"\n    white_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    result = white_threats - black_threats\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces located on the opponent's third rank for offensive pressure.\"\n    pieces_third_rank_white = sum(1 for square in board.piece_map() \n                                     if chess.square_rank(square) == 5 and \n                                     board.piece_at(square).color == chess.WHITE)\n    pieces_third_rank_black = sum(1 for square in board.piece_map() \n                                     if chess.square_rank(square) == 2 and \n                                     board.piece_at(square).color == chess.BLACK)\n    return float(pieces_third_rank_white - pieces_third_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by all pieces of the player to move, indicating board control.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece mobility by calculating the sum of legal moves available for each piece type.\"\n    mobility_score = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average position value of each player's pieces.\"\n    piece_values = [0, 0]  # Index 0 for White, Index 1 for Black\n    for square, piece in board.piece_map().items():\n        if piece:\n            position_value = chess.square_file(square) + chess.square_rank(square)  # Simplified value based on position \n            piece_values[0 if piece.color == chess.WHITE else 1] += position_value\n    return float(piece_values[0] - piece_values[1])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has attacking the opponent's king.\"\n    def attacking_king_count(color):\n        king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].color == color and board.piece_map()[sq].piece_type == chess.KING)\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, king_square))\n\n    white_attacks = attacking_king_count(chess.WHITE)\n    black_attacks = attacking_king_count(chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the ratio of pieces currently attacking the opponent\\'s pieces to those that are defended.'\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    defended_pieces = sum(1 for square in board.piece_map() if len(board.attackers(chess.WHITE, square)) > 0 or len(board.attackers(chess.BLACK, square)) > 0)\n    return float(attacking_pieces) / (defended_pieces + 1e-10)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall position imbalance based on pawn structure.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discovered checks available to both players.\"\n    discovered_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            discovered_checks += 1\n        board.pop()\n    return float(discovered_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pieces of each player.\"\n    def controlled_squares(color):\n        controlled = set()\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                controlled.update(board.attackers(color, square))\n        return len(controlled)\n    \n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of moves leading to potential forks (where one piece threatens two).\"\n    fork_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            potential_moves = board.legal_moves\n            for move in potential_moves:\n                if move.from_square == square:\n                    # Simulate the move\n                    board.push(move)\n                    if len(board.attackers(not board.turn, move.to_square)) > 1:\n                        fork_count += 1\n                    board.pop()\n    return float(fork_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are within one square of the opponent's king.\"\n    threat_pieces = 0\n    king_square = chess.KING if board.turn else chess.KING + 6\n    king_pos = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            if chess.square_distance(square, king_pos) == 1:\n                threat_pieces += 1\n    return float(threat_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens) for each side.\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    \n    white_ratio = minor_pieces_white / (major_pieces_white + 1e-10)\n    black_ratio = minor_pieces_black / (major_pieces_black + 1e-10)\n    \n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the average piece value for each side.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return (white_value - black_value) / (total_value if total_value > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between the two players, focusing on connected pawns.\"\n    connected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) == piece:\n                connected_pawns += 1\n            if file < 7 and board.piece_at(chess.square(file + 1, chess.square_rank(square))) == piece:\n                connected_pawns += 1\n    return float(connected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the enemy king for all pieces of the side to move.\"\n    player_color = chess.WHITE if board.turn else chess.BLACK\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != player_color)\n    distance_sum = sum(chess.square_distance(square, enemy_king_square) for square in board.piece_map() if board.piece_map()[square].color == player_color)\n    result = distance_sum / len(board.piece_map()) if len(board.piece_map()) > 0 else 0\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential passed pawns for each player.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            for enemy_file in range(max(0, file - 1), min(7, file + 2)):\n                if board.piece_at(chess.square(enemy_file, rank + 1)) and \\\n                   board.piece_at(chess.square(enemy_file, rank + 1)).color != piece.color:\n                    is_passed = False\n                    break\n            passed_pawn_count += 1 if piece.color == chess.WHITE and is_passed else -1 if piece.color == chess.BLACK and is_passed else 0\n    return float(passed_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that can move immediately (legal moves).\"\n    total_legal_moves = len(list(board.legal_moves))\n    return float(total_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares attacked by each side\u2019s pieces.'\n    total_attacks_white = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_attacks_black = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(total_attacks_white - total_attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average material value of pieces in each player's back rank.\"\n    white_back_rank_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) == 0)\n    black_back_rank_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) == 7)\n    return float(white_back_rank_value - black_back_rank_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of both kings to their respective corners.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_corner_distance = min(chess.square_distance(white_king_square, corner) for corner in [chess.A1, chess.H1, chess.A8, chess.H8])\n    black_corner_distance = min(chess.square_distance(black_king_square, corner) for corner in [chess.A1, chess.H1, chess.A8, chess.H8])\n    return float(black_corner_distance - white_corner_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity between bishops and knights for both players.\"\n    white_knights = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.BISHOP)\n    result = (white_bishops - black_bishops) - (white_knights - black_knights)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the position by counting the number of pieces that are controlling key squares in enemy territory.\"\n    control_count = sum(1 for square in chess.SQUARES if chess.square_rank(square) > 4 and board.is_attacked_by(chess.WHITE, square)) \\\n                  - sum(1 for square in chess.SQUARES if chess.square_rank(square) < 4 and board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe king squares available for both players.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) == False)\n    black_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) == False)\n    \n    return float(white_safe_squares - black_safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares occupied by strong pieces (Q, R) vs weak pieces (P, N).\"\n    strong_count = 0\n    weak_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            if piece.piece_type in (chess.QUEEN, chess.ROOK):\n                strong_count += 1\n            elif piece.piece_type in (chess.PAWN, chess.KNIGHT):\n                weak_count += 1\n    return float(strong_count - weak_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of double threats made by both sides, illustrating offensive capabilities.\"\n    double_threats = 0.0\n    for square in board.piece_map():\n        if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) > 1:\n            double_threats += 1.0\n    return double_threats\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pawns on the 7th rank for both sides, indicating potential promotion.\"\n    seventh_rank_pawns_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    seventh_rank_pawns_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(seventh_rank_pawns_white - seventh_rank_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces from their king to assess support.\"\n    white_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE)\n    black_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK)\n    \n    white_distance = sum(chess.square_distance(white_king_square, sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_distance(black_king_square, sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to a central square (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and any(board.is_attacked_by(board.turn, sq) for sq in central_squares))\n    result = float(control_count)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average position rank of all the pieces on the board for each color.\"\n    def piece_rank_value():\n        total_rank = 0\n        piece_count = 0\n        for square, piece in board.piece_map().items():\n            total_rank += chess.square_rank(square) + 1  # rank is 0-7, we use 1-8\n            piece_count += 1\n        return total_rank / piece_count if piece_count else 0\n\n    white_average_rank = piece_rank_value()\n    return float(white_average_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of non-pawn pieces attacking opponent's pawns, indicating pressure on pawn structure.\"\n    white_piece_attacking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and \n                                       any(board.is_attacked_by(chess.BLACK, pawn_square) \n                                       for pawn_square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]))\n    black_piece_attacking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and \n                                       any(board.is_attacked_by(chess.WHITE, pawn_square) \n                                       for pawn_square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]))\n    return float(white_piece_attacking_pawns - black_piece_attacking_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces directly opposing each other on the same file.\"\n    opposing_pairs = 0\n    for file in range(8):\n        white_piece = None\n        black_piece = None\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece:\n                if piece.color == chess.WHITE:\n                    white_piece = piece\n                else:\n                    black_piece = piece\n        if white_piece and black_piece:\n            opposing_pairs += 1\n    return float(opposing_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within two squares of each player's king, indicating tactical presence.\"\n    white_king = next(sq for sq in board.piece_map() \n                      if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king = next(sq for sq in board.piece_map() \n                      if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    white_near_king = sum(1 for sq in board.piece_map() \n                          if chess.square_distance(white_king, sq) <= 2 and \n                          board.piece_at(sq).color == chess.WHITE)\n    black_near_king = sum(1 for sq in board.piece_map() \n                          if chess.square_distance(black_king, sq) <= 2 and \n                          board.piece_at(sq).color == chess.BLACK)\n    result = white_near_king - black_near_king\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distance of each player\u2019s pieces from the opponent\u2019s king to assess pressure.'\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK)\n    white_distances = sum(chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distances = sum(chess.square_distance(square, white_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_distances - black_distances)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players, penalizing structural weaknesses.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_files:\n                pawn_files[file] = 0\n            pawn_files[file] += 1\n    \n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the flexibility of pieces by counting the number of possible moves for each piece type.\"\n    flexibility_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            flexibility_score += len(list(board.legal_moves))\n    return float(flexibility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns advanced for each side.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) > 4)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) < 3)\n    \n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for the player to move.\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of non-pawn pieces attacking opponent's pawns, indicating pressure on pawn structure.\"\n    white_piece_attacking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and \n                                       any(board.is_attacked_by(chess.BLACK, pawn_square) \n                                       for pawn_square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]))\n    black_piece_attacking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and \n                                       any(board.is_attacked_by(chess.WHITE, pawn_square) \n                                       for pawn_square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]))\n    return float(white_piece_attacking_pawns - black_piece_attacking_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces that each side has.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    ratio_white = white_minor / (white_major + 1)  # Adding 1 to avoid division by zero\n    ratio_black = black_minor / (black_major + 1)  # Adding 1 to avoid division by zero\n    return float(ratio_white - ratio_black)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the material balance adjusted for piece positioning.'\n    piece_positions = {\n        chess.KNIGHT: (3, 2),\n        chess.BISHOP: (3, 2),\n        chess.ROOK: (5, 1),\n        chess.QUEEN: (9, 0)\n    }\n    \n    positional_value_white = sum(piece_positions.get(piece.piece_type, (0, 0))[0] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    positional_value_black = sum(piece_positions.get(piece.piece_type, (0, 0))[1] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(positional_value_white - positional_value_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of the remaining pieces for both colors.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value - black_value) / (total_value + 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the longest distance of pieces from their respective kings, indicating vulnerability.\"\n    max_distance_white = max([chess.square_distance(board.king(chess.WHITE), square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE], default=0)\n    max_distance_black = max([chess.square_distance(board.king(chess.BLACK), square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK], default=0)\n    return float(max_distance_white - max_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pawns on the board, giving insight into pawn structure.\"\n    pawn_value = 1.0\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            total_value += pawn_value if piece.color == chess.WHITE else -pawn_value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of backward pawns for each color, indicating potential weaknesses in pawn structure.'\n    backward_pawns_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and \n                                board.piece_map()[sq].color == chess.WHITE and \n                                chess.square_rank(sq) < 7 and (board.piece_at(sq + 8) is None))\n    backward_pawns_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and \n                                board.piece_map()[sq].color == chess.BLACK and \n                                chess.square_rank(sq) > 0 and (board.piece_at(sq - 8) is None))\n    return float(backward_pawns_white - backward_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to their promotion rank for both players.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently pinned to their own king.'\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                # Check if this piece is pinned by the opponent's line piece\n                for attacker in board.attackers(not piece.color, square):\n                    if board.piece_at(attacker).piece_type in (chess.ROOK, chess.QUEEN):\n                        if (piece.color == chess.WHITE and square < attacker) or (piece.color == chess.BLACK and square > attacker):\n                            pinned_pieces += 1\n                            break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value difference between both sides excluding pawns.\"\n    piece_values = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pawns from their starting rank, highlighting pawn progress.\"\n    pawn_distance_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_distance_sum) / pawn_count if pawn_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total square control by counting how many squares are attacked by each player's pieces.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in range(64))\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in range(64))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attackers on the opponent's pieces.\"\n    attacker_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color != board.turn)\n    return float(attacker_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of backward pawns for both players.\"\n    backward_pawns = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            if (board.turn and chess.square_rank(square) < 5) or (not board.turn and chess.square_rank(square) > 2):\n                backward_pawns += 1\n    return float(backward_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total absolute value of pieces for both players.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by both colors.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    \n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the total number of squares attacked by each player\u2019s knights, indicating knight activity.'\n    knight_attack_squares_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT and board.is_attacked_by(chess.BLACK, square))\n    knight_attack_squares_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT and board.is_attacked_by(chess.WHITE, square))\n    return float(knight_attack_squares_white - knight_attack_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Assesses the knight mobility for both sides, counting possible knight moves.'\n    white_knight_moves = sum(len(list(board.legal_moves)) for square in chess.SQUARES \n                              if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.KNIGHT \n                              and board.piece_at(square).color == chess.WHITE)\n    black_knight_moves = sum(len(list(board.legal_moves)) for square in chess.SQUARES \n                              if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.KNIGHT \n                              and board.piece_at(square).color == chess.BLACK)\n    result = float(white_knight_moves - black_knight_moves)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each side.\"\n    white_controlled_squares = set()\n    black_controlled_squares = set()\n\n    for move in board.legal_moves:\n        if move.from_square in white_controlled_squares:\n            white_controlled_squares.add(move.to_square)\n        else:\n            black_controlled_squares.add(move.to_square)\n    \n    return float(len(white_controlled_squares) - len(black_controlled_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the distance of pieces to the opponent\\'s back rank.'\n    distance_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            distance_score += distance\n    return float(distance_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the endgame compared to the total number of pieces on the board.\"\n    piece_count = len(board.piece_map())\n    endgame_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KING, chess.PAWN])\n    return float(endgame_pieces / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential pawn promotions on the board.\"\n    promotions = 0.0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotions += 1\n    return promotions\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces of each color from the opponent's king.\"\n    def average_distance(color):\n        opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color != color and board.piece_map()[square].piece_type == chess.KING)\n        total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == color)\n        piece_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == color)\n        return total_distance / piece_count if piece_count > 0 else 0\n\n    white_distance = average_distance(chess.WHITE)\n    black_distance = average_distance(chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to attack the opponent's pawns.\"\n    attacking_pawn_moves = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE for move in board.legal_moves if move.to_square in board.attackers(chess.BLACK, sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    attacking_pawn_moves += sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK for move in board.legal_moves if move.to_square in board.attackers(chess.WHITE, sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(attacking_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    opponent_back_rank = 0 if board.turn else 7\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            total_distance += chess.square_rank(square) - opponent_back_rank\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal captures available in the current position.\"\n    captures_white = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    captures_black = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    return float(captures_white - captures_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(board.is_attacked_by(chess.WHITE, sq) for sq in center_squares)\n    control_black = sum(board.is_attacked_by(chess.BLACK, sq) for sq in center_squares)\n    return float(control_white - control_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the pawn structure by counting isolated pawns to evaluate weakness.'\n    isolated_pawn_count = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) == None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) == None):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on the 7th rank for both sides.\"\n    white_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    black_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    return float(white_rooks_on_seventh - black_rooks_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces in terms of piece activity, based on their mobility.\"\n    piece_activity_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                             chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    activity_value = 0\n    for piece in board.piece_map().values():\n        mobility = len(list(board.legal_moves))\n        activity_value += piece_activity_values[piece.piece_type] * mobility if piece.color == chess.WHITE else -piece_activity_values[piece.piece_type] * mobility\n    return float(activity_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces in play within the opponent's half.\"\n    white_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) < 4)\n    black_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) > 3)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board weighted by their positions.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_weighted_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square))\n        piece_count += 1\n    \n    return total_weighted_value / (piece_count if piece_count > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates piece imbalance by considering the positional advantage of each piece.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    value_sum = 0\n    for piece in board.piece_map().values():\n        value_sum += piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return float(value_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides, focusing on non-pawn pieces.\"\n    piece_value = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control based on pieces in central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    result = float(white_control - black_control)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece types of each color on the board.\"\n    white_types = len(set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE))\n    black_types = len(set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK))\n    return float(white_types - black_types)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling lines or diagonals (ranks, files, and diagonals).\"\n    def count_controlled_lines(color):\n        control_count = 0\n        for square in board.piece_map():\n            if board.piece_at(square).color == color:\n                if board.is_attacked_by(color, square):\n                    control_count += 1\n        return control_count\n    return float(count_controlled_lines(chess.WHITE) - count_controlled_lines(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of pawns and indicates a pawn structure advantage.\"\n    pawn_value = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(pawn_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for both players.\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n\n    ratio_white = minor_pieces_white / major_pieces_white if major_pieces_white > 0 else 0\n    ratio_black = minor_pieces_black / major_pieces_black if major_pieces_black > 0 else 0\n    return float(ratio_white - ratio_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both sides.\"\n    white_doubled = sum(1 for f in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(f, sq)) and board.piece_at(chess.square(f, sq)).color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for f in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(f, sq)) and board.piece_at(chess.square(f, sq)).color == chess.BLACK]) > 1)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece types between players to reflect material variety.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of all pieces in the central four squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_value = sum(board.piece_at(sq).piece_type for sq in central_squares if board.piece_at(sq) is not None)\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces located on the last two ranks, indicating an active position.\"\n    active_piece_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and (chess.square_rank(square) == 6 or chess.square_rank(square) == 7 if piece.color == chess.WHITE else chess.square_rank(square) == 1 or chess.square_rank(square) == 0):\n            active_piece_value += piece.piece_type\n    return float(active_piece_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and not board.piece_at(square - 1) or \n                file < 7 and not board.piece_at(square + 1)):\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    result = float(isolated_pawns)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity between bishops and knights for both players.\"\n    white_knights = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.BISHOP)\n    result = (white_bishops - black_bishops) - (white_knights - black_knights)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawn majority on one side of the board.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    result = white_pawns - black_pawns\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from the nearest opponent's piece.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        opponent_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n        nearest_distance = min(chess.square_distance(square, opp_square) for opp_square in board.piece_map().keys() if board.piece_map()[opp_square].color == opponent_color)\n        total_distance += nearest_distance\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the ratio of knights to all pieces for each color to evaluate piece diversity.'\n    white_knights = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.KNIGHT)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    return (white_knights / total_pieces) - (black_knights / total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting pieces protecting each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_protectors = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_distance(square, white_king_square) <= 2)\n    black_protectors = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_distance(square, black_king_square) <= 2)\n    return float(white_protectors - black_protectors)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Assesses the potential safety of the kings by counting the number of escape squares.'\n    escape_squares_w = sum(1 for sq in board.attacks(chess.KING if board.turn else chess.BLACK) if chess.square_file(sq) in range(8) and chess.square_rank(sq) in range(8))\n    escape_squares_b = sum(1 for sq in board.attacks(chess.KING if not board.turn else chess.WHITE) if chess.square_file(sq) in range(8) and chess.square_rank(sq) in range(8))\n    return float(escape_squares_w - escape_squares_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops).\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_pieces / (minor_pieces + 1))  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for both colors to assess pawn structure.\"\n    backward_pawns_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and board.piece_at(square + 8) is None) or (piece.color == chess.BLACK and board.piece_at(square - 8) is None):\n                backward_pawns_count += 1\n    return float(backward_pawns_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures that are isolated from other pawns.\"\n    isolated_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                continue\n            isolated_pawn_count += 1\n    return float(isolated_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the vulnerability of respective kings based on piece proximity.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n\n    white_proximity = sum(chess.square_distance(white_king_square, square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    black_proximity = sum(chess.square_distance(black_king_square, square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n\n    return float(black_proximity - white_proximity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for both sides.\"\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of opponent pieces that are unprotected.\"\n    unprotected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            if not board.attackers(board.turn, square):\n                unprotected_count += 1\n    return float(unprotected_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for each player.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the opponent's king.\"\n    pinned_pieces = 0\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            if board.is_attacked_by(not board.turn, square) and board.attackers(not board.turn, opponent_king_square):\n                pinned_pieces += 1\n\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn structures for both sides, helping to identify positional weaknesses.\"\n    white_pawn_structure = sum(board.piece_at(sq) is not None and board.piece_at(sq).piece_type == chess.PAWN for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_pawn_structure = sum(board.piece_at(sq) is not None and board.piece_at(sq).piece_type == chess.PAWN for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    result = float(white_pawn_structure - black_pawn_structure)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the depth of the player's piece formation towards the opponent's back rank.\"\n    formation_depth = sum(8 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    result = float(formation_depth)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for both colors, which may indicate vulnerabilities.\"\n    unprotected_count = 0.0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE:\n            if not any(board.is_attacked_by(chess.BLACK, attacked_square) for attacked_square in board.attackers(chess.WHITE, square)):\n                unprotected_count += 1.0\n        else:\n            if not any(board.is_attacked_by(chess.WHITE, attacked_square) for attacked_square in board.attackers(chess.BLACK, square)):\n                unprotected_count -= 1.0\n    return unprotected_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the opponent's half of the board.\"\n    white_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                         if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                         if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = white_pieces_in_opponent_half - black_pieces_in_opponent_half\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces attacking squares occupied by enemy pieces.'\n    attack_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            for attacker in board.attackers(piece.color, square):\n                if board.is_attacked_by(not piece.color, square):\n                    attack_count += 1\n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of defenders for each piece on the board.'\n    defenders = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the balance of piece types in terms of value and positional strength.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3.5, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(board.piece_map()[sq].piece_type, 0) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_value = sum(piece_values.get(board.piece_map()[sq].piece_type, 0) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    return float(white_value - black_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within three squares of the kings.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    nearby_pieces = sum(1 for piece_square in board.piece_map() if (chess.square_distance(white_king_square, piece_square) <= 3 or chess.square_distance(black_king_square, piece_square) <= 3))\n    return float(nearby_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces in the back rank for both players.\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the overall imbalance in minor pieces between both sides.'\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    \n    result = float((white_knights - black_knights) + (white_bishops - black_bishops))\n    return result\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of rook connections (open files) available for each player to evaluate piece coordination.'\n    white_rook_files = {chess.square_file(square) for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == chess.WHITE and piece.piece_type == chess.ROOK}\n    black_rook_files = {chess.square_file(square) for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == chess.BLACK and piece.piece_type == chess.ROOK}\n    result = float(len(white_rook_files) - len(black_rook_files))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are placed on the 3rd rank or higher for both sides.\"\n    active_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) > 1)\n    return float(active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces on the board, indicating position strength.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        piece_count += 1\n    return float(total_rank / piece_count if piece_count > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the degree of piece development (pieces moved off the back row).\"\n    developed_white = sum(1 for square in range(8, 16) \n                          if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    developed_black = sum(1 for square in range(48, 56) \n                          if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(developed_white - developed_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe squares available for each king.\"\n    white_safe_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None)\n    black_safe_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None)\n    return float(white_safe_squares - black_safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pinned pieces for both sides, reflecting tactical weaknesses.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            # Check if any piece is a king; if so, the piece is pinned.\n            if any(board.piece_at(king) and board.piece_at(king).piece_type == chess.KING for king in attackers):\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of squares where pieces are expected to develop in the opening phase.'\n    development_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if chess.square_rank(square) == 0:\n                development_squares += 1\n        elif piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if chess.square_rank(square) == 7:\n                development_squares += 1\n    return float(development_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks available for both players.\"\n    discovered_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    new_board = board.copy()\n                    new_board.push(move)\n                    for target_square in chess.SQUARES:\n                        if new_board.is_attacked_by(not board.turn, target_square):\n                            discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the presence of major pieces (Queen, Rooks) for both sides.\"\n    white_major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    black_major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    return float(white_major_pieces_count - black_major_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are advanced to or beyond the fifth rank to assess pawn structure.\"\n    white_advanced_pawns = sum(1 for square in range(chess.A4, chess.H5) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_advanced_pawns = sum(1 for square in range(chess.A4, chess.H5) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board weighted by their positions.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_weighted_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square))\n        piece_count += 1\n    \n    return total_weighted_value / (piece_count if piece_count > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains (connected pawns) for both sides.\"\n    def count_pawn_chains(color):\n        chains = 0\n        for file in range(8):\n            chain = False\n            for rank in range(8):\n                square = chess.square(file, rank)\n                piece = board.piece_at(square)\n                if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                    if not chain:\n                        chains += 1\n                        chain = True\n                else:\n                    chain = False\n        return chains\n    return float(count_pawn_chains(chess.WHITE) - count_pawn_chains(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discoveries (pieces that can move away to reveal an attack).\"\n    discovery_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    board.push(move)\n                    # Check if after move there is an attack\n                    if board.is_attacked_by(not board.turn, move.to_square):\n                        discovery_count += 1\n                    board.pop()\n    return float(discovery_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures how many pieces are actively protecting each other.'\n    result = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            for target_square in board.attackers(piece.color, square):\n                if board.is_attacked_by(piece.color, target_square):\n                    result += 1.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns for each color.\"\n    white_isolated = sum(1 for sq, piece in board.piece_map().items() \n                          if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and \n                          not (board.is_attacked_by(chess.BLACK, sq - 1) or board.is_attacked_by(chess.BLACK, sq + 1)))\n    black_isolated = sum(1 for sq, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and \n                         not (board.is_attacked_by(chess.WHITE, sq - 1) or board.is_attacked_by(chess.WHITE, sq + 1)))\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player, emphasizing spatial control.\"\n    white_control = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to total squares on the board, assessing overall control.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares / 64) if controlled_squares > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe king squares available for both players.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) == False)\n    black_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) == False)\n    \n    return float(white_safe_squares - black_safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces from their respective home ranks.\"\n    distance_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_score += chess.square_rank(square)  # Closer to home is better\n        else:\n            distance_score -= chess.square_rank(square)  # Closer to home is worse\n    return float(distance_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns on the board for both sides.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_neighbors = [(square - 1, square + 1)]\n            if all(board.piece_at(s) is None for s in file_neighbors[0]):\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has that are actively participating in the attack.\"\n    attacking_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == board.turn)\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are positioned on the seventh rank.\"\n    white_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seventh_rank - black_seventh_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal captures available in the current position.\"\n    captures_white = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    captures_black = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    return float(captures_white - captures_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the total number of squares around the king that are attacked.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING)\n    attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, sq))\n    result = float(attacked_squares)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for each player, indicating potential advancement.\"\n    white_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for both sides.\"\n    white_passed = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and is_passed_pawn(board, square))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and is_passed_pawn(board, square))\n    return float(white_passed - black_passed)\n\ndef is_passed_pawn(board, square):\n    \"\"\" Helper function to check if a pawn is passed \"\"\"\n    piece = board.piece_at(square)\n    if piece.piece_type != chess.PAWN:\n        return False\n    if piece.color == chess.WHITE:\n        return all(board.piece_at(chess.square_file(square) + 8 * r) is None for r in range(1, 8) for file in range(chess.square_file(square)))\n    else: # BLACK\n        return all(board.piece_at(chess.square_file(square) - 8 * r) is None for r in range(1, 8) for file in range(chess.square_file(square)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board using standard piece values.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    value = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map())\n    return float(value)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total distance of each player\\'s pawns to the promotion rank.'\n    total_distance = 0\n    if board.turn:  # White's turn\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                total_distance += (chess.square_rank(square) - 7)\n    else:  # Black's turn\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                total_distance += (6 - chess.square_rank(square))\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total distance of each player\\'s pawns to the promotion rank.'\n    total_distance = 0\n    if board.turn:  # White's turn\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                total_distance += (chess.square_rank(square) - 7)\n    else:  # Black's turn\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                total_distance += (6 - chess.square_rank(square))\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from their promotion ranks for both players.\"\n    white_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of the remaining pieces for both colors.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value - black_value) / (total_value + 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the structural integrity of each player's pawn structure.\"\n    white_pawns = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE]\n    black_pawns = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK]\n    white_pawn_structure = sum(1 for pawn in white_pawns if board.piece_at(pawn - 8) is None)\n    black_pawn_structure = sum(1 for pawn in black_pawns if board.piece_at(pawn + 8) is None)\n    return float(white_pawn_structure - black_pawn_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece value of all pieces that are currently being attacked.\"\n    attacking_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if board.is_attacked_by(chess.BLACK, sq)) \\\n                      - sum(piece.piece_type for sq, piece in board.piece_map().items() if board.is_attacked_by(chess.WHITE, sq))\n    return float(attacking_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are within two squares of the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    close_pieces_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_distance(square, opponent_king_square) <= 2:\n            close_pieces_count += 1\n    return float(close_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures distribution of pieces on the eighth rank, indicating readiness for promotion.\"\n    eighth_rank_count = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) is not None)\n    return float(eighth_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pieces for both sides.\"\n    white_squares = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE]\n    black_squares = [sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK]\n    white_avg_rank = sum(chess.square_rank(sq) for sq in white_squares) / (len(white_squares) or 1)\n    black_avg_rank = sum(chess.square_rank(sq) for sq in black_squares) / (len(black_squares) or 1)\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces of each color in the opponent\u2019s half of the board.'\n    white_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pawns to the promotion rank for both colors, showing potential for advancement.\"\n    white_pawn_distances = [7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN]\n    black_pawn_distances = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN]\n    avg_distance_white = sum(white_pawn_distances) / len(white_pawn_distances) if white_pawn_distances else 0\n    avg_distance_black = sum(black_pawn_distances) / len(black_pawn_distances) if black_pawn_distances else 0\n    return avg_distance_white - avg_distance_black\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective best squares.\"\n    distance = 0\n    for sq, piece in board.piece_map().items():\n        best_pos = piece.piece_type - 1  # Simplified logic for where each type of piece wants to go\n        distance += chess.square_distance(sq, best_pos)\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by all pieces of the player to move, indicating board control.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces in terms of unblocked pieces with legal moves.\"\n    mobility_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            mobility_count += len(list(board.legal_moves))\n    return float(mobility_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player by counting legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the edge of the board for both colors, indicating possible mobility.\"\n    edge_pieces_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and (chess.square_file(sq) == 0 or chess.square_file(sq) == 7))\n    edge_pieces_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and (chess.square_file(sq) == 0 or chess.square_file(sq) == 7))\n    return float(edge_pieces_white - edge_pieces_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the difference in pawn structure between white and black.'\n    white_pawn_structure = len([square for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.PAWN \n                                 and board.piece_at(square).color == chess.WHITE \n                                 and chess.square_rank(square) >= 4])\n    black_pawn_structure = len([square for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.PAWN \n                                 and board.piece_at(square).color == chess.BLACK \n                                 and chess.square_rank(square) >= 4])\n    return float(white_pawn_structure - black_pawn_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the most advanced pawn from the opponent's back rank.\"\n    white_advanced_pawn = max((7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE), default=0)\n    black_advanced_pawn = max((chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK), default=0)\n    result = white_advanced_pawn - black_advanced_pawn\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks given by both players based on total piece activity.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to total squares on the board, assessing overall control.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares / 64) if controlled_squares > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each color around their respective kings.\"\n    white_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n    black_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    white_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for both colors to assess pawn structure.\"\n    backward_pawns_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and board.piece_at(square + 8) is None) or (piece.color == chess.BLACK and board.piece_at(square - 8) is None):\n                backward_pawns_count += 1\n    return float(backward_pawns_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures overall piece safety by summing the safety of each piece.\"\n    piece_safety = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(chess.WHITE if piece.color == chess.WHITE else chess.BLACK, square)\n        piece_safety += (4 - len(attackers)) if piece.color == chess.WHITE else -(4 - len(attackers))\n    return float(piece_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall material value of pieces on the board for both sides.\"\n    material_value = sum(piece.piece_type for piece in board.piece_map().values())\n    return float(material_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the endgame versus the total number of pieces.\"\n    total_pieces = len(board.piece_map())\n    endgame_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KING, chess.PAWN})\n    return float(endgame_pieces) / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each player has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of opponent pieces that are unprotected.\"\n    unprotected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            if not board.attackers(board.turn, square):\n                unprotected_count += 1\n    return float(unprotected_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for promotion by counting pawns on the 7th rank.\"\n    white_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players, penalizing structural weaknesses.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_files:\n                pawn_files[file] = 0\n            pawn_files[file] += 1\n    \n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by each side.\"\n    white_attacked = len(board.attackers(chess.WHITE, chess.A1)) + \\\n                     len(board.attackers(chess.WHITE, chess.A2)) + \\\n                     len(board.attackers(chess.WHITE, chess.A3)) + \\\n                     len(board.attackers(chess.WHITE, chess.A4)) + \\\n                     len(board.attackers(chess.WHITE, chess.A5)) + \\\n                     len(board.attackers(chess.WHITE, chess.A6)) + \\\n                     len(board.attackers(chess.WHITE, chess.A7)) + \\\n                     len(board.attackers(chess.WHITE, chess.A8))\n                     \n    black_attacked = len(board.attackers(chess.BLACK, chess.A1)) + \\\n                     len(board.attackers(chess.BLACK, chess.A2)) + \\\n                     len(board.attackers(chess.BLACK, chess.A3)) + \\\n                     len(board.attackers(chess.BLACK, chess.A4)) + \\\n                     len(board.attackers(chess.BLACK, chess.A5)) + \\\n                     len(board.attackers(chess.BLACK, chess.A6)) + \\\n                     len(board.attackers(chess.BLACK, chess.A7)) + \\\n                     len(board.attackers(chess.BLACK, chess.A8))\n                     \n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each color.\"\n    total_distance_white = total_distance_black = 0\n    piece_count_white = piece_count_black = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance_white += distance\n            piece_count_white += 1\n        else:\n            total_distance_black += distance\n            piece_count_black += 1\n    avg_distance_white = total_distance_white / piece_count_white if piece_count_white > 0 else 0\n    avg_distance_black = total_distance_black / piece_count_black if piece_count_black > 0 else 0\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of minor pieces to the total number of pieces for each player.\"\n    total_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    \n    ratio_white = minor_white / total_white_pieces if total_white_pieces > 0 else 0.0\n    ratio_black = minor_black / total_black_pieces if total_black_pieces > 0 else 0.0\n    result = ratio_white - ratio_black\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides, focusing on non-pawn pieces.\"\n    piece_value = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pawns to the promotion rank for both colors, showing potential for advancement.\"\n    white_pawn_distances = [7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN]\n    black_pawn_distances = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN]\n    avg_distance_white = sum(white_pawn_distances) / len(white_pawn_distances) if white_pawn_distances else 0\n    avg_distance_black = sum(black_pawn_distances) / len(black_pawn_distances) if black_pawn_distances else 0\n    return avg_distance_white - avg_distance_black\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total pairs of pawns on adjacent files for both sides.\"\n    white_pawn_files = {chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN}\n    black_pawn_files = {chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN}\n    \n    white_pairs = sum(1 for f in white_pawn_files if f + 1 in white_pawn_files or f - 1 in white_pawn_files)\n    black_pairs = sum(1 for f in black_pawn_files if f + 1 in black_pawn_files or f - 1 in black_pawn_files)\n    \n    return float(white_pairs - black_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the concentration of pieces within a 3x3 area around the kings.'\n    white_king_square = next(sq for sq in board.piece_map() \n                              if board.piece_at(sq).color == chess.WHITE and \n                              board.piece_at(sq).piece_type == chess.KING\n                             )\n    black_king_square = next(sq for sq in board.piece_map() \n                              if board.piece_at(sq).color == chess.BLACK and \n                              board.piece_at(sq).piece_type == chess.KING\n                             )\n    white_neighbors = sum(1 for square in chess.SQUARES \n                          if chess.square_distance(square, white_king_square) <= 2 and \n                          board.piece_at(square) is not None and \n                          board.piece_at(square).color == chess.WHITE\n                         )\n    black_neighbors = sum(1 for square in chess.SQUARES \n                          if chess.square_distance(square, black_king_square) <= 2 and \n                          board.piece_at(square) is not None and \n                          board.piece_at(square).color == chess.BLACK\n                         )\n    return float(white_neighbors - black_neighbors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each side to assess pawn structure.\"\n    def count_connected_pawns(color):\n        connected_count = 0\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        for pawn in pawns:\n            if (board.piece_at(pawn - 1) and board.piece_at(pawn - 1).color == color) or (board.piece_at(pawn + 1) and board.piece_at(pawn + 1).color == color):\n                connected_count += 1\n        return connected_count\n    \n    connected_white = count_connected_pawns(chess.WHITE)\n    connected_black = count_connected_pawns(chess.BLACK)\n    return float(connected_white - connected_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacked pieces by the opponent.\"\n    attacked_pieces_count = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(not board.turn, square):\n            attacked_pieces_count += 1\n    return float(attacked_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered checks for both colors.\"\n    discovered_checks = 0\n    \n    for square in board.piece_map():\n        if board.piece_at(square).color == board.turn:\n            for move in board.legal_moves:\n                if board.is_check() or board.is_checkmate():\n                    continue\n                temp_board = board.copy()\n                temp_board.push(move)\n                if temp_board.is_check() and board.piece_at(square).piece_type in (chess.ROOK, chess.QUEEN, chess.BISHOP):\n                    discovered_checks += 1\n    \n    return float(discovered_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between the two players by counting potential legal captures.\"\n    white_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each player's pieces.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the piece safety rating for each color based on potential attacks.'\n    safety_score = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        attacks = len(board.attacks(square))\n        if piece.color == chess.WHITE:\n            safety_score[chess.WHITE] += (6 - attacks)\n        else:\n            safety_score[chess.BLACK] += (6 - attacks)\n    return float(safety_score[chess.WHITE] - safety_score[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks by counting the number of open files available.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    result = float(open_files)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the potential advancement of the most advanced pawn for each side.'\n    white_advanced = max((chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN), default=-1)\n    black_advanced = max((7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN), default=-1)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total material value considering piece type and its position on the board.\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of unprotected pieces for each side.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board, indicating safety and mobility.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4)  # Center square\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n    result = black_distance - white_distance  # Positive if White's king is closer\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the center of the board.\"\n    center_distance = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance_to_center = min(chess.square_distance(square, csq) for csq in center_squares)\n        center_distance += distance_to_center\n    return float(center_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawns' advancement by calculating how many pawns are on the 6th and 7th ranks.\"\n    advancing_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 1):\n                advancing_pawns += 1\n    return float(advancing_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains for each side.\"\n    white_chains = 0\n    black_chains = 0\n    \n    def count_pawn_chain(start_square):\n        chain_length = 0\n        for sq in range(start_square, 64):\n            piece = board.piece_at(sq)\n            if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                chain_length += 1\n            else:\n                break\n        return chain_length\n\n    for file in range(8):\n        chain_found = False\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                if board.piece_at(square).color == chess.WHITE:\n                    if not chain_found:\n                        white_chains += 1\n                        chain_found = True\n                else:\n                    chain_found = False\n    return float(white_chains - black_chains)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can be immediately promoted.\"\n    promotable_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotable_pawns += 1\n    return float(promotable_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank, indicating potential promotion threats.\"\n    white_pawns_on_seventh = sum(1 for square in board.piece_map() if \n                                   board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_seventh = sum(1 for square in board.piece_map() if \n                                   board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_seventh - black_pawns_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() \n                                 if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square, piece in board.piece_map().items() if piece.color == board.turn)\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    result = total_distance / (piece_count if piece_count > 0 else 1)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance from each piece to the opposite king.\"\n    king_white = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    king_black = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    total_distance = sum(chess.square_distance(sq, king_black) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    total_distance += sum(chess.square_distance(sq, king_white) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    total_pieces = len(board.piece_map().keys())\n    return total_distance / max(1, total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's king, measuring potential threats.\"\n    king_square = next((s for s, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    piece_distances = [chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK)]\n    return float(sum(piece_distances) / len(piece_distances)) if piece_distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    board.turn = not board.turn  # Switch turn for black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Revert turn\n    \n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for both colors to assess pawn structure.\"\n    backward_pawns_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and board.piece_at(square + 8) is None) or (piece.color == chess.BLACK and board.piece_at(square - 8) is None):\n                backward_pawns_count += 1\n    return float(backward_pawns_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for piece development by counting piece types that can move.\"\n    mobile_pieces = sum(1 for move in board.legal_moves)\n    return float(mobile_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average position value of all pieces, weighted by their types.\"\n    piece_values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    total_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square))\n    num_pieces = len(board.piece_map())\n    return total_value / num_pieces if num_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of connected pawns for both sides.\"\n    def count_connected_pawns(color):\n        connected = 0\n        pawns = [sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        for sq in pawns:\n            if sq - 1 in pawns or sq + 1 in pawns:\n                connected += 1\n        return connected\n\n    return float(count_connected_pawns(chess.WHITE) - count_connected_pawns(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_distance += min(chess.square_distance(square, cs) for cs in center_squares)\n        piece_count += 1\n    \n    result = total_distance / piece_count if piece_count > 0 else 0.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponents' back rank to identify potential threats.\"\n    distance_sum = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if board.turn == chess.WHITE else chess.square_rank(square)\n            distance_sum += distance\n    return distance_sum\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on distance from home squares.\"\n    activity_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        activity_score += distance if piece.color == chess.WHITE else -distance\n    \n    return activity_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by both colors.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    \n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponents' half of the board for spatial control.\"\n    white_pieces_in_opponent_half = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens).\"\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(minor_count / (major_count + 1))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pawns in front of the kings.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.KING)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.KING)\n    white_pawns_in_front = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > chess.square_rank(white_king_square))\n    black_pawns_in_front = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < chess.square_rank(black_king_square))\n    return float(white_pawns_in_front - black_pawns_in_front)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total count of potential passed pawns for both players.\"\n    white_passed_pawns = 0\n    black_passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n            if not any(board.is_attacked_by(chess.BLACK, chess.parse_square(chess.square_name(file + 8))) for file in range(chess.square_file(square) - 1, chess.square_file(square) + 2)):\n                white_passed_pawns += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n            if not any(board.is_attacked_by(chess.WHITE, chess.parse_square(chess.square_name(file + 8))) for file in range(chess.square_file(square) - 1, chess.square_file(square) + 2)):\n                black_passed_pawns += 1\n    return float(white_passed_pawns - black_passed_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for checkmate in the next few moves based on piece positions.\"\n    potential_checkmate = 0\n    if board.is_check():\n        potential_checkmate += 1\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            potential_checkmate += 1\n        board.pop()\n    return float(potential_checkmate)\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns reaching the 6th rank for white and the 3rd rank for black.'\n    white_pawn_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) == 5)\n    black_pawn_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) == 2)\n    return float(white_pawn_rank - black_pawn_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of pieces that are centralized (on ranks 3, 4, 5).'\n    material_value = 0\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5, chess.C4, chess.C5, chess.F4, chess.F5]\n    piece_values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0  # King's value is conceptually unique\n    }\n\n    for square in central_squares:\n        if board.piece_at(square):\n            piece = board.piece_at(square)\n            material_value += piece_values[piece.piece_type] if piece is not None else 0\n\n    return float(material_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential pawn structures by counting connected pawns.\"\n    connected_pawn_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.piece_type == chess.PAWN:\n            if board.piece_at(square + 1) and board.piece_at(square + 1).piece_type == chess.PAWN and board.piece_at(square + 1).color == piece.color:\n                connected_pawn_count += 1\n            if board.piece_at(square - 1) and board.piece_at(square - 1).piece_type == chess.PAWN and board.piece_at(square - 1).color == piece.color:\n                connected_pawn_count += 1\n    return float(connected_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of squares controlled by each side based on piece placement.'\n    white_controlled_squares = set()\n    black_controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square:\n                if piece.color == chess.WHITE:\n                    white_controlled_squares.add(move.to_square)\n                else:\n                    black_controlled_squares.add(move.to_square)\n    return float(len(white_controlled_squares) - len(black_controlled_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of all pawns on the board, with higher ranks indicating advancement.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    if not pawns:\n        return 0.0\n    avg_rank = sum(chess.square_rank(sq) for sq in pawns) / len(pawns)\n    return float(avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are within two squares of the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    close_pieces_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_distance(square, opponent_king_square) <= 2:\n            close_pieces_count += 1\n    return float(close_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each player based on piece influence.'\n    controlled_white = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE))\n    controlled_black = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK))\n    return float(controlled_white - controlled_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each side has advanced past the 4th rank.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_advanced_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n\n    return float(white_advanced_value - black_advanced_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the back rank for both sides.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting rank for each player.'\n    distance_w = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distance_b = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distance_w - distance_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the balance of material by counting how many pieces are on the board relative to pawns.'\n    piece_count = len(board.piece_map())\n    pawn_count = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN)\n    return float(piece_count - pawn_count) / max(piece_count, 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures mobility by counting the maximum number of possible moves for any single piece.'\n    max_moves = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            piece_moves = len(list(board.legal_moves))  # Count all legal moves of that piece\n            if piece_moves > max_moves:\n                max_moves = piece_moves\n    result = float(max_moves)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has connected on the same rank.\"\n    connected_white = sum(1 for rank in range(8) if any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE for file in range(8)))\n    connected_black = sum(1 for rank in range(8) if any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK for file in range(8)))\n    result = connected_white - connected_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece values between the two sides.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by each side, indicating potential tactical opportunities.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = float(white_attacks - black_attacks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the average distance of pawns to the promotion rank.'\n    total_distance = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_count += 1\n            total_distance += (7 - chess.square_rank(square))  # Distance to promotion rank (rank 8)\n    return total_distance / pawn_count if pawn_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of square files controlled by each color's rooks.\"\n    white_files_controlled = set()\n    black_files_controlled = set()\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            controlled_file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_files_controlled.add(controlled_file)\n            else:\n                black_files_controlled.add(controlled_file)\n    controlled_difference = len(white_files_controlled) - len(black_files_controlled)\n    return float(controlled_difference)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all white pieces on the board.\"\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank += chess.square_rank(square)\n    return float(total_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of legal moves available for the player to move.'\n    return float(len(list(board.legal_moves)))  # Number of legal moves\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of the active pieces to the total pieces for both sides.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    \n    if total_pieces == 0:\n        return 0.0\n    \n    return float(active_pieces / total_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the central control based on pieces occupying or controlling central squares.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq) or board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq) or board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = float(white_control - black_control)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces to their respective kings.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance_sum = {chess.WHITE: 0, chess.BLACK: 0}\n    piece_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece:\n            if piece.color == chess.WHITE:\n                distance_sum[chess.WHITE] += chess.square_distance(square, white_king_square)\n                piece_count[chess.WHITE] += 1\n            else:\n                distance_sum[chess.BLACK] += chess.square_distance(square, black_king_square)\n                piece_count[chess.BLACK] += 1\n    avg_distance_white = distance_sum[chess.WHITE] / (piece_count[chess.WHITE] + 1e-9)\n    avg_distance_black = distance_sum[chess.BLACK] / (piece_count[chess.BLACK] + 1e-9)\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king's distance to the center of the board to assess king safety.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance_to_center_white = (chess.square_rank(white_king_square) - 3) ** 2 + (chess.square_file(white_king_square) - 3) ** 2\n    distance_to_center_black = (chess.square_rank(black_king_square) - 4) ** 2 + (chess.square_file(black_king_square) - 4) ** 2\n    return float(distance_to_center_white - distance_to_center_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value for mobile pieces only.\"\n    mobile_value = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        mobile_value += piece.piece_type if piece.color == board.turn else -piece.piece_type\n    return float(mobile_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each player has on the board, weighted by standard piece values.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance to the opponent's back rank for each side.\"\n    white_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.KING), None)\n    black_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.KING), None)\n    white_distance = (7 - chess.square_rank(white_king_square)) if white_king_square is not None else float('inf')\n    black_distance = (chess.square_rank(black_king_square)) if black_king_square is not None else float('inf')\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within three squares of the kings.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    nearby_pieces = sum(1 for piece_square in board.piece_map() if (chess.square_distance(white_king_square, piece_square) <= 3 or chess.square_distance(black_king_square, piece_square) <= 3))\n    return float(nearby_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of opposing pieces controlled by two squares next to the kings for safety assessment.\"\n    king_squares = [next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None),\n                    next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)]\n    opposing_piece_count = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color != board.piece_at(king_squares[0]).color and chess.square_distance(sq, king_squares[0]) <= 1)\n    return float(opposing_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawn moves that could be played by each side.\"\n    pawn_move_count = 0\n    for square, piece in board.piece_map().items():\n        if piece and piece.piece_type == chess.PAWN:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    pawn_move_count += 1\n    return float(pawn_move_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank for each color.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distribution of pieces across files, reflecting control of the center.'\n    file_control = [0] * 8\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            file_control[chess.square_file(square)] += 1 if piece.color == chess.WHITE else -1\n    return float(max(file_control) - min(file_control))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    board.turn = not board.turn  # Switch turn for black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Revert turn\n    \n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pawns, indicating pawn power and influence.\"\n    def controlled_by_pawns(color):\n        controlled_squares = set()\n        for square in range(64):\n            if board.piece_at(square) is not None and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                if color == chess.WHITE:\n                    if square >= 8:\n                        controlled_squares.add(square - 8)\n                    if square % 8 != 0:\n                        controlled_squares.add(square - 7)\n                    if square % 8 != 7:\n                        controlled_squares.add(square - 9)\n                else:\n                    if square <= 55:\n                        controlled_squares.add(square + 8)\n                    if square % 8 != 0:\n                        controlled_squares.add(square + 9)\n                    if square % 8 != 7:\n                        controlled_squares.add(square + 7)\n\n        return len(controlled_squares)\n\n    white_controlled = controlled_by_pawns(chess.WHITE)\n    black_controlled = controlled_by_pawns(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of doubled pawns for each side.'\n    def doubled_pawns(color):\n        files = set()\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if file in files:\n                    count += 1\n                files.add(file)\n        return count\n\n    result = float(doubled_pawns(chess.WHITE) - doubled_pawns(chess.BLACK))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the position of kings relative to pawns on the board.\"\n    white_king_pos = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_pos = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(chess.square_distance(white_king_pos, black_king_pos) - (white_pawns - black_pawns))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates material ratio between white and black pieces.\"\n    white_material = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return (white_material / (black_material + 1)) if black_material > 0 else float('inf')\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces out of their starting positions, indicating development.'\n    development = 0\n    initial_positions = {\n        chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.KNIGHT: [chess.B1, chess.G1, chess.B8, chess.G8],\n        chess.BISHOP: [chess.C1, chess.F1, chess.C8, chess.F8],\n        chess.ROOK: [chess.A1, chess.H1, chess.A8, chess.H8],\n        chess.QUEEN: [chess.D1, chess.D8],\n        chess.KING: [chess.E1, chess.E8]\n    }\n    \n    for square, piece in board.piece_map().items():\n        if square not in initial_positions.get(piece.piece_type, []):\n            development += 1\n    return float(development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces around the kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_defenders = sum(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, black_king_square))\n    black_defenders = sum(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, white_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's advanced pawns.\"\n    attacking_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            # Check if this piece is attacking any opponent's advanced pawn\n            for target in board.piece_map():\n                target_piece = board.piece_at(target)\n                if target_piece and target_piece.color != piece.color and target_piece.piece_type == chess.PAWN:\n                    if (piece.color == chess.WHITE and chess.square_rank(target) == 6) or \\\n                       (piece.color == chess.BLACK and chess.square_rank(target) == 1):\n                        if board.is_attacked_by(piece.color, target):\n                            attacking_count += 1\n    return float(attacking_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces poised for promotion (pawns on 7th rank).\"\n    promotion_candidates = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    return float(promotion_candidates)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in value between the most valuable piece of each side.\"\n    white_max_value = 0\n    black_max_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n\n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_max_value = max(white_max_value, piece_values[piece.piece_type])\n        else:\n            black_max_value = max(black_max_value, piece_values[piece.piece_type])\n    \n    return float(white_max_value - black_max_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on the 7th rank for both sides.\"\n    white_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    black_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    return float(white_rooks_on_seventh - black_rooks_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board, assessing their mobility and safety.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    distance_from_center = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('e5'))\n    return float(distance_from_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the average piece value for each side.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return (white_value - black_value) / (total_value if total_value > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for each player and returns the difference.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            for rank in range(chess.square_rank(square) + 1, 8):\n                if board.piece_at(chess.square(chess.square_file(square), rank)) and board.piece_at(chess.square(chess.square_file(square), rank)).color == chess.BLACK:\n                    return False\n        else:\n            for rank in range(chess.square_rank(square)):\n                if board.piece_at(chess.square(chess.square_file(square), rank)) and board.piece_at(chess.square(chess.square_file(square), rank)).color == chess.WHITE:\n                    return False\n        return True\n    \n    white_passed = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and is_passed_pawn(sq, chess.WHITE))\n    black_passed = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and is_passed_pawn(sq, chess.BLACK))\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares the king can move to that are not attacked.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    safe_moves = len([square for square in board.legal_moves if square.to_square != king_square and not board.is_attacked_by(not board.turn, square.to_square)])\n    return float(safe_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of isolated pawns for both sides, impacting pawn structure.\"\n    def count_isolated_pawns(color):\n        isolated_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                if (square % 8 == 0 or not board.piece_at(square - 1) or board.piece_at(square - 1).color != color) and \\\n                   (square % 8 == 7 or not board.piece_at(square + 1) or board.piece_at(square + 1).color != color):\n                    isolated_count += 1\n        return isolated_count\n    \n    white_isolated = count_isolated_pawns(chess.WHITE)\n    black_isolated = count_isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces in the opponent's half of the board for aggression evaluation.\"\n    white_value = 0\n    black_value = 0\n    \n    for square, piece in board.piece_map().items():\n        piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}[piece.piece_type]\n        if piece.color == chess.WHITE and chess.square_rank(square) > 3:\n            white_value += piece_value\n        elif piece.color == chess.BLACK and chess.square_rank(square) < 4:\n            black_value += piece_value\n            \n    return float(white_value - black_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of available checks by both players.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses piece positioning by averaging the ranks and files of all pieces.\"\n    position_sum = 0\n    total_pieces = 0\n    for square in range(0, 64):\n        piece = board.piece_at(square)\n        if piece is not None:\n            position_sum += (chess.square_rank(square) + chess.square_file(square))\n            total_pieces += 1\n    return position_sum / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance of pieces from their respective kings.\"\n    max_distance = 0\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_distance(square, king_square)\n            max_distance = max(max_distance, distance)\n\n    return float(max_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces from their respective kings to indicate safety.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king, square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE) / (len(board.piece_map()) // 2)\n    black_dist = sum(chess.square_distance(black_king, square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK) / (len(board.piece_map()) // 2)\n\n    return float(white_dist - black_dist)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking pawns of the opponent.\"\n    white_attacks_on_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and any(board.is_attacked_by(chess.WHITE, chess.parse_square(sq)) for sq in ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']))\n    black_attacks_on_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and any(board.is_attacked_by(chess.BLACK, chess.parse_square(sq)) for sq in ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']))\n    return float(white_attacks_on_pawns - black_attacks_on_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knights to bishops on the board for each player, indicating piece balance.\"\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT and piece.color == board.turn)\n    bishop_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == board.turn)\n    return float(knight_count / (bishop_count + 1))  # Added 1 to prevent division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of Pawns each player has advanced past the 4th rank.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces on the board, indicating position strength.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        piece_count += 1\n    return float(total_rank / piece_count if piece_count > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each color.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the control of central squares (d4, d5, e4, e5) based on occupying pieces.'\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    white_control = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_control = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pawns each player has relative to total pieces.'\n    white_pawn_count = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN)\n    total_piece_count = len(board.piece_map())\n    if total_piece_count == 0:\n        return 0.0\n    return (white_pawn_count - black_pawn_count) / total_piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) each side has.\"\n    minor_white = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_white - minor_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats each player has by counting the pieces that are attacking and defending key squares (like the opponent's pieces).\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, tgt_square) for tgt_square in board.attackers(chess.BLACK, square)))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, tgt_square) for tgt_square in board.attackers(chess.WHITE, square)))\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the percentage of pawns advanced beyond the third rank, indicating pawn structure.\"\n    white_advanced = sum(1 for square in board.piece_map() \n                         if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 2)\n    black_advanced = sum(1 for square in board.piece_map() \n                         if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 5)\n    total_pawns = white_advanced + black_advanced\n    return float((white_advanced - black_advanced) / total_pawns) if total_pawns > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the position by calculating the total value of pieces under attack.\"\n    under_attack_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            under_attack_value += piece.piece_type  # You can assign values here, e.g., using a dictionary\n    return float(under_attack_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board weighted by their positions.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_weighted_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square))\n        piece_count += 1\n    \n    return total_weighted_value / (piece_count if piece_count > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total potential for pawn structure weaknesses (isolated, doubled pawns).\"\n    isolated_pawns = 0\n    doubled_pawns = 0\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and \n                                                   board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and \n                                                   board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and \n                                                   board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and \n                                                   board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        if white_pawns > 1:\n            doubled_pawns += (white_pawns - 1)\n        if black_pawns > 1:\n            doubled_pawns += (black_pawns - 1)\n        if (white_pawns == 1 and (file == 0 or board.piece_at(chess.square(file-1, 0)) is None) and \n            (file == 7 or board.piece_at(chess.square(file+1, 0)) is None)):\n            isolated_pawns += 1\n        if (black_pawns == 1 and (file == 0 or board.piece_at(chess.square(file-1, 7)) is None) and \n            (file == 7 or board.piece_at(chess.square(file+1, 7)) is None)):\n            isolated_pawns += 1\n    return float(isolated_pawns - doubled_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pawns for each player.\"\n    def average_pawn_rank(color):\n        pawns = [chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        return sum(pawns) / (len(pawns) + 1)  # Prevent division by zero\n\n    white_avg_rank = average_pawn_rank(chess.WHITE)\n    black_avg_rank = average_pawn_rank(chess.BLACK)\n    result = white_avg_rank - black_avg_rank\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's back rank.\"\n    total_distance = 0\n    total_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # How many ranks away from black's back rank (row 0)\n            total_pieces += 1\n    return total_distance / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distance of each player\u2019s king from its back rank, penalizing for being too far away.'\n    king_white_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    king_black_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance_to_back_rank_white = chess.square_rank(king_white_square)\n    distance_to_back_rank_black = 7 - chess.square_rank(king_black_square)\n    return float(distance_to_back_rank_white - distance_to_back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of all pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces to each king, indicating threats and potential for checkmate.\"\n    distance_to_king = []\n    king_square = board.king(chess.WHITE) if board.turn == chess.WHITE else board.king(chess.BLACK)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            distance_to_king.append(chess.square_distance(square, king_square))\n    return float(sum(distance_to_king) / (len(distance_to_king) if distance_to_king else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of piece pairs that can attack each other.\"\n    pairs = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            attackers = board.attackers(board.piece_at(square).color, square)\n            pairs += len(attackers)\n    return float(pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    return float(active_pieces) / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for each player, indicating potential advancement.\"\n    white_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the symmetry of pieces on both sides for potential attacking chances.\"\n    symmetry_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        mirrored_square = chess.square(7 - chess.square_file(square), chess.square_rank(square))\n        if piece and board.piece_at(mirrored_square) is not None:\n            symmetry_score += 1\n    return float(symmetry_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks occupied by each player's pawns.\"\n    white_pawn_ranks = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawn_ranks = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n\n    return float(white_pawn_ranks - black_pawn_ranks)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the average distance of pawns to the promotion rank.'\n    total_distance = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_count += 1\n            total_distance += (7 - chess.square_rank(square))  # Distance to promotion rank (rank 8)\n    return total_distance / pawn_count if pawn_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawn distance to promotion for each pawn to evaluate offensive potential.\"\n    total_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces occupying the first and eighth ranks.\"\n    pieces_on_first_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 0)\n    pieces_on_eighth_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 7)\n    \n    return float(pieces_on_first_rank - pieces_on_eighth_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting how many squares around the king are attacked.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    safety_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(king_square, square) == 1)\n    return float(safety_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the stability of the king position based on the number of squares its surrounded by.\"\n    white_king_squares = sum(1 for square in board.attackers(chess.WHITE, chess.parse_square('e1')))\n    black_king_squares = sum(1 for square in board.attackers(chess.BLACK, chess.parse_square('e8')))\n    return float(white_king_squares - black_king_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the interaction of pieces by counting the number of pieces defending their own.\"\n    defending_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(defending_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of passed pawns for both colors.'\n    white_passed_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and not board.is_attacked_by(chess.BLACK, square))\n    black_passed_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and not board.is_attacked_by(chess.WHITE, square))\n    result = float(white_passed_pawns - black_passed_pawns)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the strength of pawn structure by assessing the number of connected pawns.\"\n    connected_pawns = 0\n    for file in range(8):\n        last_pawn = -1\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if last_pawn == -1 or last_pawn == rank - 1:\n                    connected_pawns += 1\n                last_pawn = rank\n    return float(connected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the back rank for each side to assess king safety.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square))\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square))\n    result = white_back_rank - black_back_rank\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player, considering the influence of pieces.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking opponent's central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_attackers = sum(board.is_attacked_by(chess.WHITE, sq) for sq in central_squares)\n    black_attackers = sum(board.is_attacked_by(chess.BLACK, sq) for sq in central_squares)\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    return float(active_pieces) / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the opponent's half of the board for aggression evaluation.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value_white = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    total_value_black = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(total_value_white - total_value_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can be moved in one turn for each side and returns the difference.\"\n    white_moves = len(list(board.legal_moves)) * (1 if board.turn else 0)\n    black_moves = len(list(board.legal_moves)) * (1 if not board.turn else 0)\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of double attacks possible on both players' less valuable pieces.\"\n    def count_double_attacks(color):\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color:\n                attackers = board.attackers(not color, square)\n                if len(attackers) > 1:\n                    count += 1\n        return count\n\n    white_double_attacks = count_double_attacks(chess.WHITE)\n    black_double_attacks = count_double_attacks(chess.BLACK)\n    return float(white_double_attacks - black_double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their opponent's king.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.piece_map()[sq].piece_type == chess.KING)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.piece_map()[sq].piece_type == chess.KING)\n    white_distance = sum(chess.square_distance(sq, black_king_square) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_distance = sum(chess.square_distance(sq, white_king_square) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    white_piece_count = len([sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE])\n    black_piece_count = len([sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK])\n    \n    return float((white_distance / (white_piece_count or 1)) - (black_distance / (black_piece_count or 1)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces to the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    total_distance = 0\n    for sq in board.piece_map():\n        total_distance += min(chess.square_distance(sq, center_sq) for center_sq in center_squares)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety index based on pawn coverage around kings.\"\n    white_king_safety = sum(1 for square in [chess.parse_square('g1'), chess.parse_square('f1'), chess.parse_square('g2'), chess.parse_square('f2')] \n                             if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_king_safety = sum(1 for square in [chess.parse_square('g8'), chess.parse_square('f8'), chess.parse_square('g7'), chess.parse_square('f7')]\n                             if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_king_safety - black_king_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of captured pieces (from the perspective of the current player).\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    captured_value = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            captured_value += piece_values[piece.piece_type]\n    return float(captured_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the region of the board each king controls (defined by the squares around them).\"\n    def king_control(sq):\n        king_squares = [sq + 1, sq - 1, sq + 8, sq - 8, sq + 7, sq - 7, sq + 9, sq - 9]\n        return sum(1 for ksq in king_squares if ksq in chess.SQUARES and board.is_attacked_by(board.piece_at(sq).color, ksq))\n\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    return float(king_control(white_king_square) - king_control(black_king_square))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each color.\"\n    total_distance_white = total_distance_black = 0\n    piece_count_white = piece_count_black = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance_white += distance\n            piece_count_white += 1\n        else:\n            total_distance_black += distance\n            piece_count_black += 1\n    avg_distance_white = total_distance_white / piece_count_white if piece_count_white > 0 else 0\n    avg_distance_black = total_distance_black / piece_count_black if piece_count_black > 0 else 0\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across the board, assessing how concentrated they are.\"\n    piece_distribution = {chess.WHITE: 0, chess.BLACK: 0}\n    for sq in range(64):\n        piece = board.piece_at(sq)\n        if piece:\n            piece_distribution[piece.color] += 1 / (1 + chess.square_distance(sq, chess.parse_square('e4')))\n    return float(piece_distribution[chess.WHITE] - piece_distribution[chess.BLACK])\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the King for both sides by counting the number of pieces defending it.\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    white_defense = len(board.attackers(chess.WHITE, white_king_sq))\n    black_defense = len(board.attackers(chess.BLACK, black_king_sq))\n    return float(white_defense - black_defense)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the defending pieces each player's pawns have, indicating their solidity.\"\n    white_defended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and any(board.is_attacked_by(chess.BLACK, square + offset) for offset in (-1, 1) if 0 <= square + offset <= 63))\n    black_defended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and any(board.is_attacked_by(chess.WHITE, square + offset) for offset in (-1, 1) if 0 <= square + offset <= 63))\n    return float(white_defended - black_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential outposts for knights in the opponent's territory.\"\n    knight_outpost_squares = [\n        chess.E5, chess.D5, chess.C6,\n        chess.E4, chess.D4, chess.C3,\n        chess.B3\n    ]\n    outpost_count = sum(1 for square in knight_outpost_squares if board.is_attacked_by(board.turn, square))\n    return float(outpost_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains for each side.\"\n    white_chains = 0\n    black_chains = 0\n    \n    def count_pawn_chain(start_square):\n        chain_length = 0\n        for sq in range(start_square, 64):\n            piece = board.piece_at(sq)\n            if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                chain_length += 1\n            else:\n                break\n        return chain_length\n\n    for file in range(8):\n        chain_found = False\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                if board.piece_at(square).color == chess.WHITE:\n                    if not chain_found:\n                        white_chains += 1\n                        chain_found = True\n                else:\n                    chain_found = False\n    return float(white_chains - black_chains)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king, indicating threats.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    black_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned, indicating potential tactical vulnerabilities.\"\n    pinned_count = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pieces attacking versus pieces defending for both sides.\"\n    attacking_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    defending_white = sum(1 for square in board.piece_map() if board.attackers(chess.WHITE, square))\n    attacking_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    defending_black = sum(1 for square in board.piece_map() if board.attackers(chess.BLACK, square))\n    white_ratio = attacking_white / (defending_white + 1)  # Avoid division by zero\n    black_ratio = attacking_black / (defending_black + 1)  # Avoid division by zero\n    return float(white_ratio - black_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns on the 7th rank, indicating potential promotion and resulting positional strength.'\n    seventh_rank_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    return float(seventh_rank_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between both sides by comparing isolated and doubled pawns.\"\n    white_isolated = 0\n    black_isolated = 0\n    white_doubled = 0\n    black_doubled = 0\n\n    def analyze_pawns():\n        for file in range(8):\n            white_pawn = board.piece_at(chess.square(file, 1))\n            black_pawn = board.piece_at(chess.square(file, 6))\n            if (white_pawn and white_pawn.piece_type == chess.PAWN):\n                if (file > 0 and not board.piece_at(chess.square(file - 1, 1))) and (file < 7 and not board.piece_at(chess.square(file + 1, 1))):\n                    nonlocal white_isolated\n                    white_isolated += 1\n                elif (file < 7 and board.piece_at(chess.square(file + 1, 1)) and board.piece_at(chess.square(file + 1, 1)).piece_type == chess.PAWN):\n                    nonlocal white_doubled\n                    white_doubled += 1\n\n            if (black_pawn and black_pawn.piece_type == chess.PAWN):\n                if (file > 0 and not board.piece_at(chess.square(file - 1, 6))) and (file < 7 and not board.piece_at(chess.square(file + 1, 6))):\n                    nonlocal black_isolated\n                    black_isolated += 1\n                elif (file < 7 and board.piece_at(chess.square(file + 1, 6)) and board.piece_at(chess.square(file + 1, 6)).piece_type == chess.PAWN):\n                    nonlocal black_doubled\n                    black_doubled += 1\n    analyze_pawns()\n    return float(white_isolated - black_isolated + (white_doubled - black_doubled))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players, penalizing structural weaknesses.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_files:\n                pawn_files[file] = 0\n            pawn_files[file] += 1\n    \n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each king from the center, reflecting king safety.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    king_distance = 0\n    for square in [board.king(chess.WHITE), board.king(chess.BLACK)]:\n        if square is not None:\n            for center in center_squares:\n                king_distance += chess.square_distance(square, center)\n    return float(king_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece distance to the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    for square in board.piece_map():\n        total_distance += chess.square_distance(square, opponent_king_square)\n    return total_distance / len(board.piece_map()) if board.piece_map() else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the center of the board (central squares).\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_sum = sum(chess.square_distance(square, center_square) for square in board.piece_map() for center_square in center_squares)\n    result = float(distance_sum)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to promotion to evaluate offensive potential.\"\n    pawn_distance_to_promotion = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn)\n    \n    result = float(pawn_distance_to_promotion)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of attempted checks by each side in the current position.'\n    white_checks = sum(1 for move in board.legal_moves \n                       if board.is_check() and board.is_attacked_by(chess.BLACK, move.to_square))\n    black_checks = sum(1 for move in board.legal_moves \n                       if board.is_check() and board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total pawn structure (isolated, doubled, and passed pawns).\"\n    white_pawns = {sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN}\n    black_pawns = {sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN}\n    \n    def pawn_structure(pawns):\n        isolated = sum(1 for sq in pawns if (board.piece_at(sq).color == chess.WHITE and (sq - 1) not in pawns and (sq + 1) not in pawns))\n        doubled = sum(1 for file in range(8) if any(sq for sq in pawns if chess.square_file(sq) == file) > 1)\n        return float(isolated - doubled)\n    \n    return pawn_structure(white_pawns) - pawn_structure(black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distances = [chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE]\n    return float(sum(distances) / len(distances)) if distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the distance of pieces from the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    \n    def distance_from_center(square):\n        return min(chess.square_distance(square, cs) for cs in center_squares)\n    \n    white_activity = sum(distance_from_center(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_activity = sum(distance_from_center(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    \n    return float(black_activity - white_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces attacking the enemy king for each player, reflecting pressure on the king.\"\n    def count_attacks_king(color):\n        king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, king_square) and board.piece_at(sq).color != color)\n    \n    white_attack_count = count_attacks_king(chess.WHITE)\n    black_attack_count = count_attacks_king(chess.BLACK)\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square and black_king_square:\n        white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.E5)\n        black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.E5)\n        return float(black_distance - white_distance)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety for each player by counting how many pawns protect their king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_protected = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.BLACK, square) and chess.square_distance(square, white_king_square) <= 1)\n    black_protected = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.WHITE, square) and chess.square_distance(square, black_king_square) <= 1)\n    return float(white_protected - black_protected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Estimates the board's open files by counting rook placements on open files.\"\n    open_file_count = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average distance of all pieces from their respective kings to assess safety.\"\n    pieces = board.piece_map()\n    king_square = next(sq for sq,(piece) in pieces.items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    distances = [chess.square_distance(sq, king_square) for sq, piece in pieces.items() if piece.color == board.turn]\n    result = sum(distances) / len(distances) if distances else 0.0\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of open files available for rooks and queens of both colors.\"\n    open_files_white = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE for rank in range(8)))\n    open_files_black = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK for rank in range(8)))\n    return float(open_files_white - open_files_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility based on attacks and legal moves available.\"\n    mobility_balance = len(list(board.legal_moves))\n    for square, piece in board.piece_map().items():\n        mobility_balance += len(board.attackers(piece.color, square)) * (-1 if piece.color == chess.WHITE else 1)\n    \n    return float(mobility_balance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting ranks.'\n    distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance += chess.square_rank(square)  # Distance for white pieces\n        else:\n            distance += 7 - chess.square_rank(square)  # Distance for black pieces\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares occupied by pawns.'\n    occupied_squares = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(occupied_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the most valuable piece remaining for each player.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.WHITE), default=0)\n    black_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.BLACK), default=0)\n    return float(white_valuable - black_valuable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces controlling key squares (d4, d5, e4, e5).\"\n    key_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_value = 0\n    for square in key_squares:\n        for piece in board.attackers(chess.WHITE, square):\n            control_value += board.piece_at(piece).piece_type\n        for piece in board.attackers(chess.BLACK, square):\n            control_value -= board.piece_at(piece).piece_type\n    return float(control_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces for each player's third rank.\"\n    white_third_rank_density = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and 16 <= square <= 23)\n    black_third_rank_density = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and 24 <= square <= 31)\n    return float(white_third_rank_density - black_third_rank_density)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides and returns the difference.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the average piece value for each side.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return (white_value - black_value) / (total_value if total_value > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 7th and 2nd ranks.\"\n    white_seventh = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_second = sum(1 for sq in range(8, 16) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = white_seventh - black_second\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by both sides to reflect control over the board.\"\n    white_attacks = len([square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square)])\n    black_attacks = len([square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square)])\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value between each player's most advanced pieces.\"\n    white_advanced_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced_value - black_advanced_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces remaining for each player to indicate material strength.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_pieces - black_pieces)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be developed to active positions.\"\n    active_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_file(square) in [1, 2, 5, 6] or chess.square_rank(square) in [0, 1, 6, 7])):\n            active_pieces += 1\n        elif piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_file(square) in [1, 2, 5, 6] or chess.square_rank(square) in [0, 1, 6, 7])):\n            active_pieces -= 1\n    return float(active_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the distance of each side\u2019s pieces to the opponent\u2019s back rank.'\n    distance_white = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    distance_black = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(distance_white - distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each color.\"\n    total_distance_white = total_distance_black = 0\n    piece_count_white = piece_count_black = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance_white += distance\n            piece_count_white += 1\n        else:\n            total_distance_black += distance\n            piece_count_black += 1\n    avg_distance_white = total_distance_white / piece_count_white if piece_count_white > 0 else 0\n    avg_distance_black = total_distance_black / piece_count_black if piece_count_black > 0 else 0\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value for mobile pieces only.\"\n    mobile_value = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        mobile_value += piece.piece_type if piece.color == board.turn else -piece.piece_type\n    return float(mobile_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of piece pairs in close proximity (Manhattan distance = 1).\"\n    close_pairs = 0\n    squares = list(board.piece_map().keys())\n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            if chess.square_distance(squares[i], squares[j]) == 1:\n                close_pairs += 1\n    return float(close_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's king, indicating the offensive potential.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board for both players, indicating endgame prospects.\"\n    pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total piece value difference weighted by the square distance from the home row.'\n    piece_map = board.piece_map()\n    total_value = 0.0\n    for square, piece in piece_map.items():\n        value = 0\n        if piece.piece_type == chess.PAWN:\n            value = 1\n        elif piece.piece_type == chess.KNIGHT:\n            value = 3\n        elif piece.piece_type == chess.BISHOP:\n            value = 3\n        elif piece.piece_type == chess.ROOK:\n            value = 5\n        elif piece.piece_type == chess.QUEEN:\n            value = 9\n        elif piece.piece_type == chess.KING:\n            value = 0  # King is invaluable in terms of material\n        distance = chess.square_rank(square)  # Distance from home row for each color\n        distance_adjusted_value = value * (8 - distance) if piece.color == chess.WHITE else value * distance\n        total_value += distance_adjusted_value if piece.color == chess.WHITE else -distance_adjusted_value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center by counting the number of pieces controlling central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces from their opponent's back rank, indicating pressure on the opponent.\"\n    white_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on both players' kings' proximity to the center.\"\n    white_king_square = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE][0]\n    black_king_square = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK][0]\n    center_distance = (chess.square_distance(white_king_square, chess.parse_square('e4')) + \n                       chess.square_distance(black_king_square, chess.parse_square('e4')))\n    return float(center_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces to the opponent's king.\"\n    white_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE)\n    black_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK)\n    \n    white_distances = [chess.square_distance(sq, black_king_square) for sq, p in board.piece_map().items() if p.color == chess.WHITE]\n    black_distances = [chess.square_distance(sq, white_king_square) for sq, p in board.piece_map().items() if p.color == chess.BLACK]\n    \n    avg_white_distance = sum(white_distances) / len(white_distances) if white_distances else 0.0\n    avg_black_distance = sum(black_distances) / len(black_distances) if black_distances else 0.0\n    \n    return avg_white_distance - avg_black_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the average rank of all pawns on the board to assess their advancement.\"\n    pawn_ranks = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_ranks.append(chess.square_rank(square))\n    if not pawn_ranks:\n        return 0.0\n    return float(sum(pawn_ranks) / len(pawn_ranks))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are unprotected for each side.\"\n    def value_of_unprotected_pieces(color):\n        unprotected_value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and not board.is_attacked_by(not color, square):\n                unprotected_value += piece.piece_type\n        return unprotected_value\n    \n    return float(value_of_unprotected_pieces(chess.WHITE) - value_of_unprotected_pieces(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of pieces attacking the opponent\u2019s most advanced pawn.'\n    most_advanced_pawn_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK:\n            if most_advanced_pawn_square is None or chess.square_rank(square) > chess.square_rank(most_advanced_pawn_square):\n                most_advanced_pawn_square = square\n                \n    if most_advanced_pawn_square is None:\n        return 0.0\n    \n    attacking_value = 0\n    for attacker in board.attackers(chess.WHITE, most_advanced_pawn_square):\n        attacking_value += board.piece_at(attacker).piece_type  # Use piece_type as numeric value\n    return float(attacking_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pieces for each player as a measure of their position.\"\n    white_average_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE) / max(sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE), 1)\n    black_average_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK) / max(sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK), 1)\n    return white_average_rank - black_average_rank\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks to indicate control of the board.\"\n    white_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    result = white_distribution - black_distribution\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the nearest opponent's piece for all pieces of the current side.\"\n    distances = []\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            nearest_distance = min(chess.square_distance(square, opp_square) for opp_square in board.piece_map() if board.piece_at(opp_square).color != piece.color)\n            distances.append(nearest_distance)\n    return float(sum(distances)) / max(1, len(distances))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for each player.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of pieces currently defending each king to evaluate safety.\"\n    white_defenders = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from their home squares.\"\n    total_distance = 0\n    piece_count = 0\n    home_squares = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8],\n    }\n    \n    for square, piece in board.piece_map().items():\n        piece_count += 1\n        home_positions = home_squares.get(piece.piece_type, [])\n        for home in home_positions:\n            total_distance += chess.square_distance(square, home)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player and gives a score based on that.\"\n    controlled_white = sum(1 for move in board.legal_moves if move.from_square == chess.WHITE)\n    controlled_black = sum(1 for move in board.legal_moves if move.from_square == chess.BLACK)\n    return float(controlled_white - controlled_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks available for each player, indicating tactical opportunities.\"\n    white_discovered = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_discovered = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_discovered - black_discovered)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the piece safety rating for each color based on potential attacks.'\n    safety_score = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        attacks = len(board.attacks(square))\n        if piece.color == chess.WHITE:\n            safety_score[chess.WHITE] += (6 - attacks)\n        else:\n            safety_score[chess.BLACK] += (6 - attacks)\n    return float(safety_score[chess.WHITE] - safety_score[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the piece activity by counting pieces on active files (central and kingside files).'\n    active_files = [2, 3, 4, 5]  # Central and kingside files (c, d, e, f)\n    white_activity = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_file(sq) in active_files)\n    black_activity = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_file(sq) in active_files)\n    result = white_activity - black_activity\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of bishops to knights for both players, assessing piece coordination and control.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each player using their respective pieces' positions.\"\n    white_control = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type != chess.KING)\n    black_control = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type != chess.KING)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within two squares of each player's king, indicating tactical presence.\"\n    white_king = next(sq for sq in board.piece_map() \n                      if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king = next(sq for sq in board.piece_map() \n                      if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    white_near_king = sum(1 for sq in board.piece_map() \n                          if chess.square_distance(white_king, sq) <= 2 and \n                          board.piece_at(sq).color == chess.WHITE)\n    black_near_king = sum(1 for sq in board.piece_map() \n                          if chess.square_distance(black_king, sq) <= 2 and \n                          board.piece_at(sq).color == chess.BLACK)\n    result = white_near_king - black_near_king\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces supported by their own pawns.\"\n    supported_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only check pieces of the current turn's color\n            pawns_attacking = board.attackers(piece.color, square)\n            if any(board.piece_at(pawn) and board.piece_at(pawn).piece_type == chess.PAWN for pawn in pawns_attacking):\n                supported_pieces += 1\n    return float(supported_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    for sq in board.piece_map():\n        piece_count += 1\n        total_distance += chess.square_distance(sq, chess.parse_square('e4'))  # Center square\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the total distance of all pieces from their side of the board.\"\n    total_distance = sum(chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square) \n                         for square, piece in board.piece_map().items())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available to both players.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn else 0\n    legal_moves_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(legal_moves_white - legal_moves_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides, focusing on non-pawn pieces.\"\n    piece_value = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting rank for each player.'\n    distance_w = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distance_b = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distance_w - distance_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of pieces on the board to determine material quality.\"\n    value_mapping = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(value_mapping[piece.piece_type] for piece in board.piece_map().values())\n    return total_value / max(1, len(board.piece_map()))  # avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of the remaining pieces for both colors.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value - black_value) / (total_value + 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total value of pieces in controlled squares for the player to move.'\n    controlled_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_value += piece.piece_type\n    return controlled_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces directly attacking the opponent's pieces.\"\n    attacking_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacking_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of underdeveloped pieces for both sides, indicating potential for future mobility.\"\n    white_underdeveloped = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_rank(square) < 2 or chess.square_rank(square) > 5)))\n    black_underdeveloped = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_rank(square) < 2 or chess.square_rank(square) > 5)))\n    return float(white_underdeveloped - black_underdeveloped)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of all pieces on the board, weighted more for pieces in opponent half.'\n    material_score = 0.0\n    for square, piece in board.piece_map().items():\n        value = 1 if piece.piece_type == chess.PAWN else 3 if piece.piece_type in [chess.KNIGHT, chess.BISHOP] else 5 if piece.piece_type == chess.ROOK else 9 if piece.piece_type == chess.QUEEN else 0\n        if (piece.color == chess.WHITE and chess.square_rank(square) > 4) or (piece.color == chess.BLACK and chess.square_rank(square) < 4):\n            value *= 1.2\n        material_score += value if piece.color == chess.WHITE else -value\n    return material_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    return float(active_pieces) / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are attacking the opponent's king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attackers_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to the total pieces for both players.\"\n    total_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN])\n    total_pieces = len(board.piece_map())\n    return float(total_pawns / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each side by counting the number of legal captures available.\"\n    white_captures = sum(1 for move in board.legal_moves if move.to_square in [m.to_square for m in board.legal_moves if board.piece_at(m.to_square) and board.piece_at(m.to_square).color == chess.BLACK])\n    black_captures = sum(1 for move in board.legal_moves if move.to_square in [m.to_square for m in board.legal_moves if board.piece_at(m.to_square) and board.piece_at(m.to_square).color == chess.WHITE])\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the corners of the board by each player.\"\n    corner_squares = [chess.A1, chess.A8, chess.H1, chess.H8]\n    white_corners = sum(1 for square in corner_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_corners = sum(1 for square in corner_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(white_corners - black_corners)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distance to the opponent\u2019s king for all pieces.'\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each side, highlighting influence on the board.\"\n    controlled_squares_white = len([square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square)])\n    controlled_squares_black = len([square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_squares_white - controlled_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are aligned on the same file, indicating potential vertical control.\"\n    file_control = [0] * 8\n    for square in board.piece_map():\n        file_index = chess.square_file(square)\n        file_control[file_index] += 1\n    return float(max(file_control))  # Return maximum pieces on the same file.\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the overall piece activity by calculating the total of all pieces\u2019 legal moves.'\n    total_activity = 0\n    for piece in board.piece_map().values():\n        total_activity += len(list(board.legal_moves))\n    return float(total_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each player, weighted by their distance to the opponent's back rank.\"\n    control_weight = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            control_weight += 1 / (chess.square_rank(square) + 1)  # Closer to back rank gives higher weight\n        elif piece.color == chess.BLACK:\n            control_weight -= 1 / (8 - chess.square_rank(square))  # Closer to back rank gives lower weight\n        piece_count += 1\n    \n    result = control_weight / piece_count if piece_count > 0 else 0.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in play, indicating dynamics in the position.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players, penalizing structural weaknesses.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_files:\n                pawn_files[file] = 0\n            pawn_files[file] += 1\n    \n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total center control defined as the number of pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    center_square = chess.parse_square('e4')\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, center_square)\n        piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in moves to reach the opponent's back rank.\"\n    distance_to_back_rank = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(distance_to_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of open files for both players, assessing control of the board.'\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawn structures on the 4th and 5th ranks for both players to assess potential mobility.\"\n    white_pawn_structure = sum(1 for sq in range(32, 48) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawn_structure = sum(1 for sq in range(16, 32) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    result = white_pawn_structure - black_pawn_structure\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their initial squares for each side.\"\n    def total_distance(color):\n        distance = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                initial_position = piece.piece_type * 8 + (chess.square_rank(square) if color == chess.WHITE else 7 - chess.square_rank(square))\n                distance += chess.square_distance(square, initial_position)\n        return distance\n\n    white_distance = total_distance(chess.WHITE)\n    black_distance = total_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of double attacks from pieces of each side.\"\n    def count_double_attacks(color):\n        double_attacks = 0\n        for sq, piece in board.piece_map().items():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if move.from_square == sq and board.is_attacked_by(not color, move.to_square):\n                        double_attacks += 1\n        return double_attacks\n    white_doubles = count_double_attacks(chess.WHITE)\n    black_doubles = count_double_attacks(chess.BLACK)\n    return float(white_doubles - black_doubles)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the total distance of all pieces from their side of the board.\"\n    total_distance = sum(chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square) \n                         for square, piece in board.piece_map().items())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the fourth rank, indicating advanced position.\"\n    white_on_fourth = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 3])\n    black_on_fourth = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 3])\n    return float(white_on_fourth - black_on_fourth)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total value of all pieces supported by other pieces on the board.\"\n    value = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.WHITE, sq)\n            within_support_distance = sum(p.piece_type for p in (board.piece_map()[attacker] for attacker in attackers) if p.color == chess.WHITE)\n            value += within_support_distance * (1 if piece.color == chess.WHITE else -1)\n    return value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the impact of a piece's position by evaluating its rank and file control.\"\n    piece_control_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            piece_control_value += (chess.square_rank(square) + 1)  # Higher rank is better\n        else:\n            piece_control_value -= (chess.square_rank(square) + 1)\n    return piece_control_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces to the opponent's king.\"\n    white_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE)\n    black_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK)\n    \n    white_distances = [chess.square_distance(sq, black_king_square) for sq, p in board.piece_map().items() if p.color == chess.WHITE]\n    black_distances = [chess.square_distance(sq, white_king_square) for sq, p in board.piece_map().items() if p.color == chess.BLACK]\n    \n    avg_white_distance = sum(white_distances) / len(white_distances) if white_distances else 0.0\n    avg_black_distance = sum(black_distances) / len(black_distances) if black_distances else 0.0\n    \n    return avg_white_distance - avg_black_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety index based on pawn coverage around kings.\"\n    white_king_safety = sum(1 for square in [chess.parse_square('g1'), chess.parse_square('f1'), chess.parse_square('g2'), chess.parse_square('f2')] \n                             if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_king_safety = sum(1 for square in [chess.parse_square('g8'), chess.parse_square('f8'), chess.parse_square('g7'), chess.parse_square('f7')]\n                             if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_king_safety - black_king_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces each side has on the center four squares for spatial control.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_pieces = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_pieces = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_pieces - black_center_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces on the board, representing activity level.'\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in [chess.ROOK, chess.QUEEN]:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each color, reflecting overall board control and influence.\"\n    white_controlled = sum([1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_controlled = sum([1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    control_ratio = (white_controlled - black_controlled) / (white_controlled + black_controlled + 1)  # Adding 1 to avoid division by zero\n    return float(control_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece distance from the opponent's back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            target_rank = 7 if piece.color == chess.WHITE else 0\n            total_distance += chess.square_rank(square) - target_rank\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average rank of each player's pieces.\"\n    def average_rank(color):\n        pieces = [board.piece_at(square) for square in board.piece_map() if board.piece_map()[square].color == color]\n        if not pieces:\n            return 0.0\n        return sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == color) / len(pieces)\n\n    return float(average_rank(chess.WHITE) - average_rank(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of active squares (squares that can be reached by pieces) for each color.\"\n    white_active_squares = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_active_squares = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_active_squares - black_active_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of connecting pawns to analyze pawn structure.'\n    connected_pawn_count = 0\n    for file in range(8):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                left_square = chess.square(file - 1, rank) if file > 0 else None\n                right_square = chess.square(file + 1, rank) if file < 7 else None\n                if (left_square is not None and board.piece_at(left_square) and board.piece_at(left_square).piece_type == chess.PAWN) or \\\n                   (right_square is not None and board.piece_at(right_square) and board.piece_at(right_square).piece_type == chess.PAWN):\n                    connected_pawn_count += 1\n    return float(connected_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces attacking the same square for both sides, highlighting tactical conflicts.\"\n    attack_counts = {chess.WHITE: {}, chess.BLACK: {}}\n    \n    for square in range(64):\n        for attacker in board.attackers(chess.WHITE, square):\n            if square not in attack_counts[chess.WHITE]:\n                attack_counts[chess.WHITE][square] = 0\n            attack_counts[chess.WHITE][square] += 1\n            \n        for attacker in board.attackers(chess.BLACK, square):\n            if square not in attack_counts[chess.BLACK]:\n                attack_counts[chess.BLACK][square] = 0\n            attack_counts[chess.BLACK][square] += 1\n            \n    return float(sum(attack_counts[chess.WHITE].values()) - sum(attack_counts[chess.BLACK].values()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the back rank for both sides.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of rooks actively controlling open files for both colors, indicating potential for attack.\"\n    white_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == chess.WHITE \n                      and not any(board.piece_at(k) for k in board.piece_map() if chess.square_file(k) == chess.square_file(square) and chess.square_rank(k) > chess.square_rank(square)))\n    black_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == chess.BLACK \n                      and not any(board.piece_at(k) for k in board.piece_map() if chess.square_file(k) == chess.square_file(square) and chess.square_rank(k) < chess.square_rank(square)))\n    return float(white_rooks - black_rooks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all kings from their respective corners.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.A1)\n    black_distance = chess.square_distance(black_king_square, chess.H8)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total pairs of pawns on adjacent files for both sides.\"\n    white_pawn_files = {chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN}\n    black_pawn_files = {chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN}\n    \n    white_pairs = sum(1 for f in white_pawn_files if f + 1 in white_pawn_files or f - 1 in white_pawn_files)\n    black_pairs = sum(1 for f in black_pawn_files if f + 1 in black_pawn_files or f - 1 in black_pawn_files)\n    \n    return float(white_pairs - black_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (Queens and Rooks) for both players.\"\n    white_major_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    black_major_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    return float(white_major_piece_count - black_major_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of escape squares available for each king.\"\n    white_king = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    white_escape_squares = sum(1 for move in board.legal_moves if chess.square_distance(white_king, move.to_square) == 1)\n    black_escape_squares = sum(1 for move in board.legal_moves if chess.square_distance(black_king, move.to_square) == 1)\n    return float(white_escape_squares - black_escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count the number of isolated pawns for each player.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if (file_index > 0 and not board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + chr(ord(chess.square_name(square)[-1]) - 1))) or\n                file_index < 7 and not board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + chr(ord(chess.square_name(square)[-1]) + 1)))):\n                isolated_pawns += 1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average mobility of pieces for both players.\"\n    white_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces supporting each player's pawns.\"\n    white_support = 0.0\n    black_support = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_support += len(list(board.attackers(chess.WHITE, square)))\n            else:\n                black_support += len(list(board.attackers(chess.BLACK, square)))\n    return white_support - black_support\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has beyond the 7th rank, indicating advancement.\"\n    white_pieces_advanced = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 6)\n    black_pieces_advanced = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 1)\n    return float(white_pieces_advanced - black_pieces_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total piece value difference weighted by the square distance from the home row.'\n    piece_map = board.piece_map()\n    total_value = 0.0\n    for square, piece in piece_map.items():\n        value = 0\n        if piece.piece_type == chess.PAWN:\n            value = 1\n        elif piece.piece_type == chess.KNIGHT:\n            value = 3\n        elif piece.piece_type == chess.BISHOP:\n            value = 3\n        elif piece.piece_type == chess.ROOK:\n            value = 5\n        elif piece.piece_type == chess.QUEEN:\n            value = 9\n        elif piece.piece_type == chess.KING:\n            value = 0  # King is invaluable in terms of material\n        distance = chess.square_rank(square)  # Distance from home row for each color\n        distance_adjusted_value = value * (8 - distance) if piece.color == chess.WHITE else value * distance\n        total_value += distance_adjusted_value if piece.color == chess.WHITE else -distance_adjusted_value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides separately and returns the ratio of White to Black value.\"\n    white_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return white_value / (black_value + 1e-5)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking each player's king, indicating threats.\"\n    attackers_white = len(board.attackers(chess.WHITE, board.king(chess.WHITE)))\n    attackers_black = len(board.attackers(chess.BLACK, board.king(chess.BLACK)))\n    return float(attackers_white - attackers_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces to the enemy's king.\"\n    white_king_square = next(s for s in board.piece_map() if board.piece_at(s).piece_type == chess.KING and board.piece_at(s).color == chess.WHITE)\n    black_king_square = next(s for s in board.piece_map() if board.piece_at(s).piece_type == chess.KING and board.piece_at(s).color == chess.BLACK)\n    average_distance_white = sum(chess.square_distance(s, black_king_square) for s in board.piece_map() if board.piece_at(s).color == chess.WHITE) / (len(board.piece_map()) // 2)\n    average_distance_black = sum(chess.square_distance(s, white_king_square) for s in board.piece_map() if board.piece_at(s).color == chess.BLACK) / (len(board.piece_map()) // 2)\n    return float(average_distance_white - average_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of unprotected pieces for both players, signaling weakness.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    result = white_unprotected - black_unprotected\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board, providing a sense of material density.\"\n    return float(len(board.piece_map()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value for mobile pieces only.\"\n    mobile_value = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        mobile_value += piece.piece_type if piece.color == board.turn else -piece.piece_type\n    return float(mobile_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces that are on their original squares, indicating a lack of development.\"\n    original_square_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if (piece.piece_type == chess.PAWN and (square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2] if piece.color == chess.WHITE else\n                                                       square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7])):\n                original_square_count += 1\n            elif (piece.piece_type in [chess.ROOK, chess.KNIGHT, chess.BISHOP] and (square in [chess.A1, chess.H1] if piece.color == chess.WHITE else\n                                                                                    square in [chess.A8, chess.H8])):\n                original_square_count += 1\n            elif (piece.piece_type == chess.QUEEN and (square in [chess.D1] if piece.color == chess.WHITE else square in [chess.D8])):\n                original_square_count += 1\n            elif (piece.piece_type == chess.KING and (square in [chess.E1] if piece.color == chess.WHITE else square in [chess.E8])):\n                original_square_count += 1\n    return float(original_square_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of the closest knight to the opposing king.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    knights = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT]\n    if knights:\n        closest_distance = min(chess.square_distance(sq, black_king_square) for sq in knights)\n        return float(closest_distance)\n    return float(10)  # Arbitrary high value if no knights are present\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players based on piece types.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the king by counting the number of legal moves available to it.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    legal_king_moves = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(legal_king_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in central pawn control between players.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_pawns = sum(1 for sq in central_squares if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_central_pawns = sum(1 for sq in central_squares if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_central_pawns - black_central_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the concentration of pieces within a 3x3 area around the kings.'\n    white_king_square = next(sq for sq in board.piece_map() \n                              if board.piece_at(sq).color == chess.WHITE and \n                              board.piece_at(sq).piece_type == chess.KING\n                             )\n    black_king_square = next(sq for sq in board.piece_map() \n                              if board.piece_at(sq).color == chess.BLACK and \n                              board.piece_at(sq).piece_type == chess.KING\n                             )\n    white_neighbors = sum(1 for square in chess.SQUARES \n                          if chess.square_distance(square, white_king_square) <= 2 and \n                          board.piece_at(square) is not None and \n                          board.piece_at(square).color == chess.WHITE\n                         )\n    black_neighbors = sum(1 for square in chess.SQUARES \n                          if chess.square_distance(square, black_king_square) <= 2 and \n                          board.piece_at(square) is not None and \n                          board.piece_at(square).color == chess.BLACK\n                         )\n    return float(white_neighbors - black_neighbors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of minor pieces to the total number of pieces for each player.\"\n    total_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    \n    ratio_white = minor_white / total_white_pieces if total_white_pieces > 0 else 0.0\n    ratio_black = minor_black / total_black_pieces if total_black_pieces > 0 else 0.0\n    result = ratio_white - ratio_black\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of each player's king by counting the number of defenders.\"\n    def count_defenders(king_square, color):\n        return sum(1 for square in chess.SQUARES if board.is_attacked_by(color, king_square) and\n                   board.piece_at(square) and board.piece_at(square).color == color)\n\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    return float(count_defenders(white_king_square, chess.WHITE) - count_defenders(black_king_square, chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of times each player has attacking pieces aimed at each other's kings.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and (square in board.attacks(board.king(chess.BLACK))))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and (square in board.attacks(board.king(chess.WHITE))))\n    return float(white_attacks - black_attacks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are vulnerable to capture (attacked and undefended).\"\n    vulnerable_count = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and \n                           board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square))\n    return float(vulnerable_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all rooks from their starting positions for each player.\"\n    def rook_distance(color):\n        return sum(chess.square_distance(square, chess.parse_square('a1' if color == chess.WHITE else 'a8')) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.ROOK)\n    \n    white_distance = rook_distance(chess.WHITE)\n    black_distance = rook_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for Black and the 2nd rank for White.\"\n    rank_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_rank(square) == 1:\n                rank_counts[chess.WHITE] += 1\n            elif piece.color == chess.BLACK and chess.square_rank(square) == 6:\n                rank_counts[chess.BLACK] += 1\n    return float(rank_counts[chess.WHITE] - rank_counts[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility based on attacks and legal moves available.\"\n    mobility_balance = len(list(board.legal_moves))\n    for square, piece in board.piece_map().items():\n        mobility_balance += len(board.attackers(piece.color, square)) * (-1 if piece.color == chess.WHITE else 1)\n    \n    return float(mobility_balance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on unsupported pieces.\"\n    white_activity = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, attacker) for attacker in board.attackers(chess.BLACK, square)))\n    black_activity = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, attacker) for attacker in board.attackers(chess.WHITE, square)))\n    result = float(white_activity - black_activity)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective kings to assess piece coordination.'\n    def average_distance_to_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.KING)\n        total_distance = sum(chess.square_distance(king_square, square) for square in board.piece_map() if board.piece_at(square).color == color)\n        piece_count = sum(1 for piece in board.piece_map().values() if piece.color == color)\n        return total_distance / piece_count if piece_count > 0 else 0\n\n    white_avg_distance = average_distance_to_king(chess.WHITE)\n    black_avg_distance = average_distance_to_king(chess.BLACK)\n    return float(white_avg_distance - black_avg_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks the number of defended squares around the opponent's king, indicating security.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() \n                                 if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    return float(defended_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from their respective king's squares.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_distance = sum(chess.square_distance(square, white_king_square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_distance = sum(chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pins for each side based on current piece positions.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            # Check if there's a potential to pin this piece\n            for attacking_square in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacking_square):\n                    pinned_pieces += 1\n                    break\n    result = pinned_pieces\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control over the center (squares d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the pawn structure value: doubled pawns, isolated pawns, and passed pawns.'\n    def pawn_structure_value(color):\n        value = 0\n        pawns = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == color]\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if file in files:\n                files[file].append(pawn)\n            else:\n                files[file] = [pawn]\n        for file, pawns in files.items():\n            # Doubling\n            if len(pawns) > 1:\n                value -= 1  # Penalize doubled pawns\n            # Isolated\n            if file > 0 and (file - 1 not in files or len(files[file - 1]) == 0) and (file + 1 not in files or len(files[file + 1]) == 0):\n                value -= 1  # Penalize isolated pawns\n        return value\n\n    result = float(pawn_structure_value(chess.WHITE) - pawn_structure_value(chess.BLACK))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the total distance of all pieces from their starting squares to capture development.\"\n    piece_initial_positions = {\n        chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.ROOK: [chess.A1, chess.H1],\n        chess.KNIGHT: [chess.B1, chess.G1],\n        chess.BISHOP: [chess.C1, chess.F1],\n        chess.QUEEN: [chess.D1],\n        chess.KING: [chess.E1],\n    }\n    white_distance_sum = sum(chess.square_distance(square, initial) for square, piece in board.piece_map().items() if piece.color == chess.WHITE for initial in piece_initial_positions.get(piece.piece_type, []))\n    black_distance_sum = sum(chess.square_distance(square, initial) for square, piece in board.piece_map().items() if piece.color == chess.BLACK for initial in piece_initial_positions.get(piece.piece_type, []))\n    return float(white_distance_sum - black_distance_sum)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have control over central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value for both colors based on the pieces present.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value / total_value if total_value > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of doubled pawns for both sides, affecting pawn structure.\"\n    def count_doubled_pawns(color):\n        ranks = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                ranks[chess.square_rank(square)] += 1\n        return sum(max(0, count - 1) for count in ranks)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the eighth and first ranks.\"\n    major_rank_count = 0\n    for square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8,\n                   chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]:\n        piece = board.piece_at(square)\n        if piece:\n            major_rank_count += 1\n    return float(major_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of passed pawns for each player.\"\n    def count_passed_pawns(color):\n        passed_pawn_count = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                if (color == chess.WHITE and all(board.piece_at(chess.square(file, rank)) is None for file in range(chess.square_file(square) + 1, 8))) or \\\n                   (color == chess.BLACK and all(board.piece_at(chess.square(file, rank)) is None for file in range(0, chess.square_file(square)))):\n                    passed_pawn_count += 1\n        return passed_pawn_count\n\n    return float(count_passed_pawns(chess.WHITE) - count_passed_pawns(chess.BLACK)) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pawns from their starting ranks, assessing advancement.\"\n    white_pawn_advancement = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN)\n    black_pawn_advancement = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(white_pawn_advancement - black_pawn_advancement)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of all pieces that can be captured immediately.\"\n    material_value = 0\n    for move in board.legal_moves:\n        target_piece = board.piece_at(move.to_square)\n        if target_piece:\n            material_value += target_piece.piece_type\n    return float(material_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by each player's pieces.\"\n    controlled_squares_white = set()\n    controlled_squares_black = set()\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            controlled_squares_white.update(board.attacks(sq))\n        else:\n            controlled_squares_black.update(board.attacks(sq))\n    return float(len(controlled_squares_white) - len(controlled_squares_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses central pawn structure by counting the difference in central pawns for both players.\"\n    central_pawns_white = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    central_pawns_black = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(central_pawns_white - central_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are attacked by the most active piece from each player.\"\n    highest_attack_pieces_white = max([len(board.attackers(chess.WHITE, sq)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE], default=0)\n    highest_attack_pieces_black = max([len(board.attackers(chess.BLACK, sq)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK], default=0)\n    result = highest_attack_pieces_white - highest_attack_pieces_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting how many squares around the king are attacked.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    safety_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(king_square, square) == 1)\n    return float(safety_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of pawns on the 7th rank for both sides.\"\n    pawns_on_seventh = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    pawns_on_second = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(pawns_on_seventh - pawns_on_second)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by both sides.\"\n    attack_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        for attack_square in board.attackers(piece.color, square):\n            attack_count[piece.color] += 1\n    return float(attack_count[chess.WHITE] - attack_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the fifth rank or higher, indicating advanced pawn structure.\"\n    advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks to evaluate piece activity.\"\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential future threats by counting pieces that can attack the opponent's king.\"\n    threats_to_king = len([1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is not None])\n    return float(threats_to_king)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the level of king safety based on available escape squares.\"\n    escape_squares = 0\n    king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn]\n    if not king_square:\n        return float(-1)\n    for move in board.legal_moves:\n        if move.to_square in board.attackers(not board.turn, king_square[0]):\n            escape_squares -= 1\n        else:\n            escape_squares += 1\n    return float(escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces positioned on central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE) - \\\n                     sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by both players' knights.\"\n    knight_count = sum(1 for square, piece in board.piece_map().items() \n                       if piece.piece_type == chess.KNIGHT\n                      )\n    return float(knight_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawn chains for each side.\"\n    def count_pawn_chains(color):\n        pawn_chains = 0\n        for file in range(8):\n            chain_active = False\n            for rank in range(8):\n                square = chess.square(file, rank)\n                if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                    if not chain_active:\n                        pawn_chains += 1\n                        chain_active = True\n                else:\n                    chain_active = False\n        return pawn_chains\n    return float(count_pawn_chains(chess.WHITE) - count_pawn_chains(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attack squares for all pieces, reflecting strategic position strength.\"\n    total_attacks = sum(len(board.attackers(attacker.color, square)) for square, attacker in board.piece_map().items())\n    return float(total_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacked squares by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each side has in the opponent's territory (ranks 6-8 for White, ranks 1-3 for Black).\"\n    white_territory_count = 0\n    black_territory_count = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 6:\n            white_territory_count += 1\n        elif piece.color == chess.BLACK and rank <= 2:\n            black_territory_count += 1\n    return float(white_territory_count - black_territory_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces safely positioned away from threats.'\n    safe_pieces = 0\n    for square, piece in board.piece_map().items():\n        if all(not board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, square)):\n            safe_pieces += 1\n    return float(safe_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns from the promotion rank to evaluate their activity.\"\n    pawn_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece development advantage by counting undeveloped pieces.\"\n    undeveloped_white = sum(1 for square in [chess.B1, chess.C1, chess.G1, chess.H1] if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    undeveloped_black = sum(1 for square in [chess.B8, chess.C8, chess.G8, chess.H8] if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(undeveloped_black - undeveloped_white)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares where a piece of the current player is attacking.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    attacking_squares = sum(1 for square in range(64) if board.is_attacked_by(color, square))\n    return float(attacking_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the queenside (a-d files) versus the kingside (e-h files).\"\n    queenside_count = sum(1 for sq in board.piece_map() if chess.square_file(sq) < 4)\n    kingside_count = sum(1 for sq in board.piece_map() if chess.square_file(sq) >= 4)\n    return float(queenside_count - kingside_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of defenders to attackers for each player's pieces on the board.\"\n    white_defenders = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    white_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    black_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    result = (white_defenders / (white_attackers + 1e-7)) - (black_defenders / (black_attackers + 1e-7))\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are unprotected (not attacked by any opposing pieces).\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece activity based on the number of potential attacks by each color.\"\n    white_activity = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_activity = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns across the ranks, assessing pawn structure.\"\n    pawn_distribution = [0] * 8\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_distribution[chess.square_rank(square)] += 1\n    return float(max(pawn_distribution) - min(pawn_distribution))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that have potential to attack the enemy king.\"\n    result = 0.0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:  # Only consider the current player's pieces\n            result += len(board.attackers(not board.turn, chess.KING))  # Count potential attackers on the enemy king\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of defenders to attackers for each player's pieces on the board.\"\n    white_defenders = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    white_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    black_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    result = (white_defenders / (white_attackers + 1e-7)) - (black_defenders / (black_attackers + 1e-7))\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each side's pawns to the promotion rank.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the total value of pieces that are currently under attack.\"\n    threatened_value = 0.0\n    pieces = board.piece_map()\n    \n    for square, piece in pieces.items():\n        if board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n            threatened_value += piece.piece_type\n\n    return threatened_value\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the disparity in development by comparing the number of developed pieces.\"\n    developed_pieces_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and (chess.square_rank(sq) >= 5))\n    developed_pieces_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and (chess.square_rank(sq) <= 2))\n    result = developed_pieces_white - developed_pieces_black\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of defenders to attackers for each player's pieces on the board.\"\n    white_defenders = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    white_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    black_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    result = (white_defenders / (white_attackers + 1e-7)) - (black_defenders / (black_attackers + 1e-7))\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the difference in material value, emphasizing the value of major pieces.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return white_value - black_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the development of minor pieces, evaluating knights and bishops.\"\n    white_development = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_development = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    result = white_development - black_development\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in value between the most valuable piece of each side.\"\n    white_max_value = 0\n    black_max_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n\n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_max_value = max(white_max_value, piece_values[piece.piece_type])\n        else:\n            black_max_value = max(black_max_value, piece_values[piece.piece_type])\n    \n    return float(white_max_value - black_max_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average position rank of all the pieces on the board for each color.\"\n    def piece_rank_value():\n        total_rank = 0\n        piece_count = 0\n        for square, piece in board.piece_map().items():\n            total_rank += chess.square_rank(square) + 1  # rank is 0-7, we use 1-8\n            piece_count += 1\n        return total_rank / piece_count if piece_count else 0\n\n    white_average_rank = piece_rank_value()\n    return float(white_average_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility ratio by comparing the number of legal moves for both players.'\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn back\n    return float(white_moves / (black_moves + 1e-5))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of attacking pieces for both players, highlighting their ability to threaten.'\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides and returns the difference.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces over the board based on rank positions.\"\n    white_distribution = [0] * 8\n    black_distribution = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_distribution[chess.square_rank(square)] += 1\n        else:\n            black_distribution[chess.square_rank(square)] += 1\n            \n    white_avg = sum(rank * count for rank, count in enumerate(white_distribution)) / sum(white_distribution) if sum(white_distribution) > 0 else 0\n    black_avg = sum(rank * count for rank, count in enumerate(black_distribution)) / sum(black_distribution) if sum(black_distribution) > 0 else 0\n    \n    return float(white_avg - black_avg)\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of duplicated pieces for each color, indicating potential overcrowding.\"\n    def duplicated_count(color):\n        count = 0\n        piece_types = {}\n        for sq in board.piece_map():\n            piece = board.piece_at(sq)\n            if piece.color == color:\n                piece_types[piece.piece_type] = piece_types.get(piece.piece_type, 0) + 1\n        return sum(max(0, count - 1) for count in piece_types.values())\n\n    white_duplicates = duplicated_count(chess.WHITE)\n    black_duplicates = duplicated_count(chess.BLACK)\n    return float(white_duplicates - black_duplicates)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts how many pieces are controlling key squares on the board (C3, C6, F3, F6) as a mobility indicator.'\n    key_squares = [chess.C3, chess.C6, chess.F3, chess.F6]\n    control_count = sum(1 for square in key_squares for piece in board.piece_map().values() if board.is_attacked_by(piece.color, square))\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each piece from the opponent's king, indicating pressure.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    total_distance = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, black_king_square)\n        elif piece.color == chess.BLACK:\n            total_distance -= chess.square_distance(square, white_king_square)\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of Pawns each player has advanced past the 4th rank.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n"
  ]
}