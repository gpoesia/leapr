{
  "used_features": [
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate hole area ratio: fraction of ink-area that surrounds enclosed background (holes). 8 has two holes, 0 has one, 5 typically none'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    # robust thresholding as above\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr)\n    ink = ink.astype(np.bool_)\n    if h == 0 or w == 0:\n        return 0.0\n    # flood-fill to find background connected to borders\n    bg = np.zeros_like(ink, dtype=bool)\n    stack = []\n    # push border background pixels\n    for c in range(w):\n        if not ink[0, c]:\n            stack.append((0, c))\n            bg[0, c] = True\n        if not ink[h - 1, c]:\n            stack.append((h - 1, c))\n            bg[h - 1, c] = True\n    for r in range(h):\n        if not ink[r, 0]:\n            stack.append((r, 0))\n            bg[r, 0] = True\n        if not ink[r, w - 1]:\n            stack.append((r, w - 1))\n            bg[r, w - 1] = True\n    # 4-connected flood fill\n    while stack:\n        r, c = stack.pop()\n        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            rr, cc = r + dr, c + dc\n            if 0 <= rr < h and 0 <= cc < w and (not bg[rr, cc]) and (not ink[rr, cc]):\n                bg[rr, cc] = True\n                stack.append((rr, cc))\n    holes = (~ink) & (~bg)\n    hole_area = float(np.count_nonzero(holes))\n    ink_area = float(np.count_nonzero(ink))\n    if ink_area <= 0:\n        return 0.0\n    return float(hole_area) / ink_area\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in top-right quadrant to bottom-left quadrant (helps detect 7-like top-right strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    tr = np.sum(ink[0:h//2, w//2:w])\n    bl = np.sum(ink[h//2:h, 0:w//2])\n    return float((tr + 1e-6) / (bl + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient: detects prevalence of horizontal bars vs round edges'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    if gray.size == 0:\n        return 1.0\n    try:\n        gy, gx = np.gradient(gray)  # gy: d/drow (vertical), gx: d/dcol (horizontal)\n    except Exception:\n        return 1.0\n    mean_abs_gx = float(np.mean(np.abs(gx)))\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    return float(mean_abs_gx / (mean_abs_gy + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical separation between two largest enclosed hole centroids normalized by image height (0 if fewer than 2 holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # exterior fill\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal = (~ink) & (~exterior)\n    visited = np.zeros_like(internal, dtype=bool)\n    centroids = []\n    for i in range(h):\n        for j in range(w):\n            if internal[i, j] and not visited[i, j]:\n                # BFS\n                q = deque()\n                q.append((i, j))\n                visited[i, j] = True\n                pts = [(i, j)]\n                while q:\n                    ci, cj = q.popleft()\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and internal[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            pts.append((ni, nj))\n                            q.append((ni, nj))\n                pts = np.array(pts)\n                centroids.append((float(np.mean(pts[:,0])), float(np.mean(pts[:,1])), pts.shape[0]))\n    if len(centroids) < 2:\n        return 0.0\n    # sort by area desc and take two largest\n    centroids.sort(key=lambda x: x[2], reverse=True)\n    y1 = centroids[0][0]\n    y2 = centroids[1][0]\n    return float(abs(y1 - y2) / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal gradient energy (sum|dI/dy| / (sum|dI/dx| + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    vert_energy = np.sum(np.abs(gy))\n    horz_energy = np.sum(np.abs(gx))\n    return float(vert_energy / (horz_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-quarter horizontal edge strength: average absolute horizontal gradient magnitude in top 25% of image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = gray[:top_h, :]\n    # horizontal gradient: difference along columns\n    horiz_grad = np.abs(np.diff(top_region, axis=1))\n    # average normalized by intensity range\n    denom = max(1.0, float(np.ptp(gray)))\n    score = float(horiz_grad.mean()) / denom\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the top third of the image (detects prominent top bars like in 7 or 9)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        top = gray[:max(1, h//3), :]\n        gy, gx = np.gradient(top)\n        horiz_edges = np.abs(gx)\n        return float(np.mean(horiz_edges))\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical transitions per column (measures stroke complexity like loops vs single strokes)'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    # transitions per column: count changes along rows\n    diffs = np.abs(np.diff(fg.astype(int), axis=0))\n    transitions_per_col = np.sum(diffs, axis=0)  # number of changes per column\n    avg_trans = np.mean(transitions_per_col) / max(1.0, float(h))\n    return float(avg_trans)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left vs right ink balance: normalized difference in ink pixel counts'\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # adaptive binarization: determine if ink is darker\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    left = float(np.count_nonzero(fg[:, :w//2]))\n    right = float(np.count_nonzero(fg[:, w//2:]))\n    denom = left + right + 1e-6\n    return float((left - right) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of total enclosed hole area to ink area (how big holes are relative to ink)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # Flood fill exterior background\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal_bg = (~ink) & (~exterior)\n    hole_area = float(np.sum(internal_bg))\n    ink_area = float(np.sum(ink))\n    if ink_area <= 0.0:\n        return 0.0\n    return float(hole_area / ink_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate of number of holes (background components inside bounding box) using 4-connectivity; returns integer as float'\n    import numpy as np\n    from collections import deque\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = (gray_n < thr) if np.mean(gray_n) > 0.5 else (gray_n > thr)\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(np.min(ys)), int(np.max(ys))\n    x0, x1 = int(np.min(xs)), int(np.max(xs))\n    sub = fg[y0:y1+1, x0:x1+1]\n    # background mask inside bounding box\n    bg = (~sub).astype(np.uint8)\n    H, W = bg.shape\n    visited = np.zeros_like(bg, dtype=bool)\n    holes = 0\n    for i in range(H):\n        for j in range(W):\n            if bg[i, j] == 1 and not visited[i, j]:\n                # BFS\n                q = deque([(i, j)])\n                visited[i, j] = True\n                touches_border = False\n                while q:\n                    y, x = q.popleft()\n                    if y == 0 or x == 0 or y == H-1 or x == W-1:\n                        touches_border = True\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = y+dy, x+dx\n                        if 0 <= ny < H and 0 <= nx < W and not visited[ny, nx] and bg[ny, nx] == 1:\n                            visited[ny, nx] = True\n                            q.append((ny, nx))\n                if not touches_border:\n                    holes += 1\n    return float(holes)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of holes (closed loops) in the foreground by counting background components not touching the border'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # Simple adaptive binarization: foreground assumed darker than mean\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    # If too much ink, invert assumption\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    bg = ~ink\n    visited = np.zeros(bg.shape, dtype=bool)\n    holes = 0\n    # flood fill background components; count those not touching border\n    for r in range(h):\n        for c in range(w):\n            if not bg[r, c] or visited[r, c]:\n                continue\n            # start flood fill\n            stack = [(r, c)]\n            visited[r, c] = True\n            touches_border = False\n            while stack:\n                y, x = stack.pop()\n                if y == 0 or x == 0 or y == h - 1 or x == w - 1:\n                    touches_border = True\n                # explore 8-neighbors\n                for dy in (-1, 0, 1):\n                    for dx in (-1, 0, 1):\n                        ny, nx = y + dy, x + dx\n                        if ny < 0 or ny >= h or nx < 0 or nx >= w:\n                            continue\n                        if not visited[ny, nx] and bg[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n            if not touches_border:\n                holes += 1\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of horizontal gradient energy in the upper half of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.size == 0:\n        return 0.0\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    gy, gx = np.gradient(gray.astype(np.float32))\n    abs_gx = np.abs(gx)\n    h = gray.shape[0]\n    mid = max(1, h // 2)\n    upper_energy = np.sum(abs_gx[:mid, :])\n    total_energy = np.sum(abs_gx) + 1e-9\n    return float(upper_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between a central small region and its surrounding annulus (helps detect holes/loops)'\n    # Robust grayscale conversion\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    # define radii\n    r = max(1, min(h, w) // 12)\n    cy, cx = h // 2, w // 2\n    yy, xx = np.ogrid[:h, :w]\n    dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n    center_mask = dist <= r\n    annulus_mask = (dist > r) & (dist <= 2 * r)\n    # compute means; if annulus empty, fallback to surrounding square\n    center_mean = float(np.mean(gray[center_mask])) if np.any(center_mask) else 0.0\n    if np.any(annulus_mask):\n        annulus_mean = float(np.mean(gray[annulus_mask]))\n    else:\n        pad = max(1, r)\n        y0, y1 = max(0, cy - 2 * pad), min(h, cy + 2 * pad)\n        x0, x1 = max(0, cx - 2 * pad), min(w, cx + 2 * pad)\n        ring = gray[y0:y1, x0:x1].copy()\n        annulus_mean = float(np.mean(ring)) if ring.size else center_mean\n    # For typical images ink is darker (lower values); a hole gives annulus darker than center\n    return float(annulus_mean - center_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight bounding box around the ink (1 is square, >1 is tall like 1, <1 is wide like 7)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 1.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 1.0\n        bh = float(ys.max() - ys.min() + 1)\n        bw = float(xs.max() - xs.min() + 1)\n        if bw <= 0:\n            return 1.0\n        return float(bh / bw)\n    except Exception:\n        return 1.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical position (0..1) of hole centroids; 0 if no hole (0=top,1=bottom)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        centroids = []\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumy = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumy += y\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > 0:\n                        centroids.append((sumy / area))\n        if len(centroids) == 0:\n            return 0.0\n        avg_y = float(np.mean(centroids))\n        return float(avg_y / max(1.0, h))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of ink runs in the vertical center column: counts separated vertical ink components along middle column'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 3 or w < 1:\n        return 0.0\n    thresh = np.mean(gray)\n    bin_img = (gray < thresh).astype(np.uint8)\n    if np.sum(bin_img) < 1:\n        bin_img = (gray > thresh).astype(np.uint8)\n        if np.sum(bin_img) < 1:\n            return 0.0\n    col = bin_img[:, w // 2]\n    # count runs of ones\n    diff = np.diff(np.concatenate(([0], col, [0])))\n    starts = np.sum(diff == 1)\n    return float(starts)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of columns that contain a vertical ink run covering at least 60% of image height (indicates strong vertical strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    count = 0\n    minrun = max(1, int(0.6 * h))\n    for c in range(w):\n        col = ink[:, c].astype(int)\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= minrun):\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical ink span in upper half to vertical span in lower half (helps separate top-loop digits like 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    if ink.sum() == 0:\n        return 0.0\n    mid = h // 2\n    upper = ink[:mid, :]\n    lower = ink[mid:, :]\n    def vert_span(arr):\n        cols = np.any(arr, axis=0)\n        if not cols.any():\n            return 0.0\n        ys = np.any(arr, axis=1)\n        if not ys.any():\n            return 0.0\n        return float(ys.nonzero()[0].max() - ys.nonzero()[0].min() + 1)\n    upper_span = vert_span(upper)\n    lower_span = vert_span(lower)\n    if lower_span == 0.0:\n        return float(upper_span)\n    return float(upper_span / (lower_span + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge strength to horizontal edge strength (vertical/horizontal)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    gx, gy = np.gradient(gray)\n    # gx = d/dy (vertical), gy = d/dx (horizontal) depending on numpy's ordering\n    vert = float(np.abs(gx).sum())\n    hor = float(np.abs(gy).sum())\n    return float(vert / (hor + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink pixels located in the top quarter of the image (top density ratio)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink_mask_candidate = gray < thresh\n    if np.count_nonzero(ink_mask_candidate) > (h * w / 2):\n        ink = (~ink_mask_candidate).astype(float)\n    else:\n        ink = ink_mask_candidate.astype(float)\n    top_rows = max(1, h // 4)\n    top_ink = np.sum(ink[:top_rows, :])\n    total_ink = np.sum(ink)\n    if total_ink == 0:\n        return 0.0\n    return float(top_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of radial distances of foreground pixels from centroid (normalized) \u2014 \"0\" tends to have larger circular spread'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.0\n    cx, cy = np.mean(xs), np.mean(ys)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = np.std(dists)\n    # normalize by image diagonal\n    diag = np.sqrt(w * w + h * h)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of horizontal transitions along the central row (captures number of stroke segments)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    # threshold\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.int32)\n    row_idx = h//2\n    if row_idx < 0 or row_idx >= h:\n        return 0.0\n    row = ink[row_idx, :]\n    if row.size < 2:\n        return 0.0\n    transitions = np.sum(np.abs(np.diff(row)))\n    # normalize by width\n    return float(transitions / (w - 1 + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the top third of the image (detects prominent top bars like in 7 or 9)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        top = gray[:max(1, h//3), :]\n        gy, gx = np.gradient(top)\n        horiz_edges = np.abs(gx)\n        return float(np.mean(horiz_edges))\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink density in the top half and bottom half (top_density - bottom_density) / overall_density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    top = ink[0:h//2, :]\n    bottom = ink[h//2:h, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    total = top_count + bottom_count\n    if total <= 0.0:\n        return 0.0\n    return float((top_count - bottom_count) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized distance from top to the first ink row (top gap / image height)'\n    import numpy as np\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    rows = np.where(mask.any(axis=1))[0]\n    if rows.size == 0:\n        return 1.0\n    top_row = rows.min()\n    return float(top_row / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient restricted to the right half (captures right-side curvature)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        # smooth-ish by simple local mean to reduce noise\n        # compute gradients\n        gx, gy = np.gradient(gray.astype(float))\n        right_gx = gx[:, w//2:]\n        right_gy = gy[:, w//2:]\n        mag_x = np.mean(np.abs(right_gx)) if right_gx.size > 0 else 0.0\n        mag_y = np.mean(np.abs(right_gy)) if right_gy.size > 0 else 0.0\n        if mag_y == 0:\n            return float(mag_x)\n        return float(mag_x) / float(mag_y)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical position (0..1) of hole centroids; 0 if no hole (0=top,1=bottom)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        centroids = []\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumy = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumy += y\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > 0:\n                        centroids.append((sumy / area))\n        if len(centroids) == 0:\n            return 0.0\n        avg_y = float(np.mean(centroids))\n        return float(avg_y / max(1.0, h))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative area of the largest inner hole to the bounding box area (useful: 9 often has one large loop, 8 has two moderate loops)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 0.0\n        y0, y1 = ys.min(), ys.max()\n        x0, x1 = xs.min(), xs.max()\n        sub = ~fg[y0:y1+1, x0:x1+1]\n        H, W = sub.shape\n        if H <= 0 or W <= 0:\n            return 0.0\n        visited = np.zeros_like(sub, dtype=np.bool_)\n        from collections import deque\n        q = deque()\n        for i in range(H):\n            for j in (0, W-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        for j in range(W):\n            for i in (0, H-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        while q:\n            y, x = q.popleft()\n            for dy in (-1, 0, 1):\n                for dx in (-1, 0, 1):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n        # find hole components and record largest\n        largest = 0\n        for i in range(H):\n            for j in range(W):\n                if sub[i, j] and not visited[i, j]:\n                    # new hole\n                    size = 0\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        size += 1\n                        for dy in (-1, 0, 1):\n                            for dx in (-1, 0, 1):\n                                ny, nx = y+dy, x+dx\n                                if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n                    if size > largest:\n                        largest = size\n        bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1)) + 1e-8\n        return float(largest / bbox_area)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical ink span in upper half to vertical span in lower half (helps separate top-loop digits like 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    if ink.sum() == 0:\n        return 0.0\n    mid = h // 2\n    upper = ink[:mid, :]\n    lower = ink[mid:, :]\n    def vert_span(arr):\n        cols = np.any(arr, axis=0)\n        if not cols.any():\n            return 0.0\n        ys = np.any(arr, axis=1)\n        if not ys.any():\n            return 0.0\n        return float(ys.nonzero()[0].max() - ys.nonzero()[0].min() + 1)\n    upper_span = vert_span(upper)\n    lower_span = vert_span(lower)\n    if lower_span == 0.0:\n        return float(upper_span)\n    return float(upper_span / (lower_span + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of 8-connected ink components normalized by total pixels (higher if disjoint pieces exist)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thresh = (float(np.min(gray)) + float(np.max(gray))) / 2.0\n    ink = (gray < thresh)\n    visited = np.zeros_like(ink, dtype=bool)\n    comps = 0\n    stack = []\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j] and not visited[i, j]:\n                comps += 1\n                # flood fill (8-connected)\n                stack.append((i, j))\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if (0 <= ny < h) and (0 <= nx < w) and not visited[ny, nx] and ink[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n    return float(comps / (h * w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of ink runs in the vertical center column: counts separated vertical ink components along middle column'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 3 or w < 1:\n        return 0.0\n    thresh = np.mean(gray)\n    bin_img = (gray < thresh).astype(np.uint8)\n    if np.sum(bin_img) < 1:\n        bin_img = (gray > thresh).astype(np.uint8)\n        if np.sum(bin_img) < 1:\n            return 0.0\n    col = bin_img[:, w // 2]\n    # count runs of ones\n    diff = np.diff(np.concatenate(([0], col, [0])))\n    starts = np.sum(diff == 1)\n    return float(starts)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference of radial spread between lower-half and upper-half foreground pixels normalized by overall radial std'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    ys, xs = np.where(fg)\n    if xs.size == 0:\n        return 0.0\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    upper_mask = ys < cy\n    lower_mask = ~upper_mask\n    if np.count_nonzero(upper_mask) < 2 or np.count_nonzero(lower_mask) < 2:\n        return 0.0\n    upper_std = float(np.std(dists[upper_mask]))\n    lower_std = float(np.std(dists[lower_mask]))\n    overall_std = float(np.std(dists)) + 1e-6\n    return float((lower_std - upper_std) / overall_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical edge strength (gx) in the center-right quadrant (detects vertical right strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = gray.min(), gray.max()\n    norm = (gray - mn) / (mx - mn + 1e-9)\n    gy, gx = np.gradient(norm)\n    r0, c0 = h//4, w//2\n    region = gx[r0:3*h//4, c0:w]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(np.abs(region)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in the top third vs bottom third (top_third / (bottom_third+eps)); 5s often have heavier bottom third'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(int)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(int)\n    t = max(1, h // 3)\n    top = np.sum(ink[:t, :])\n    bottom = np.sum(ink[-t:, :])\n    return float(top) / (float(bottom) + 1e-6)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of topologically enclosed background regions (holes) in the ink strokes'\n    import numpy as np\n    # Convert to grayscale\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # Heuristic threshold and ensure ink is the minority\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    fg = fg.astype(np.uint8)\n    bg = 1 - fg\n    visited = np.zeros_like(bg, dtype=bool)\n    holes = 0\n    # 4-neighbor flood fill for background components\n    for r in range(h):\n        for c in range(w):\n            if bg[r, c] and not visited[r, c]:\n                stack = [(r, c)]\n                visited[r, c] = True\n                touches_border = (r == 0 or c == 0 or r == h-1 or c == w-1)\n                while stack:\n                    rr, cc = stack.pop()\n                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n                        nr, nc = rr+dr, cc+dc\n                        if 0 <= nr < h and 0 <= nc < w and not visited[nr, nc] and bg[nr, nc]:\n                            visited[nr, nc] = True\n                            stack.append((nr, nc))\n                            if nr == 0 or nc == 0 or nr == h-1 or nc == w-1:\n                                touches_border = True\n                if not touches_border:\n                    holes += 1\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-center loop density: fraction of ink located in the lower central third of the image (useful to detect closed loops at the bottom like in 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    mask = mask.astype(np.uint8)\n    ink_total = mask.sum()\n    if ink_total == 0:\n        return 0.0\n    r0 = (2 * h) // 3\n    c0 = w // 4\n    c1 = 3 * w // 4\n    bottom_center = mask[r0:h, c0:c1]\n    return float(bottom_center.sum() / (ink_total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of enclosed white regions (holes) inside the ink strokes'\n    import numpy as np\n    h, w = image.shape[:2]\n    # convert to grayscale float\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # simple adaptive threshold\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    # if too many pixels are classified as ink, invert assumption\n    if np.mean(ink) > 0.75:\n        ink = ~ink\n    # mark background pixels reachable from image border\n    visited = np.zeros((h, w), dtype=bool)\n    stack = []\n    # push border background pixels\n    for i in range(h):\n        for j in (0, w - 1):\n            if not ink[i, j] and not visited[i, j]:\n                visited[i, j] = True\n                stack.append((i, j))\n    for j in range(w):\n        for i in (0, h - 1):\n            if not ink[i, j] and not visited[i, j]:\n                visited[i, j] = True\n                stack.append((i, j))\n    while stack:\n        i, j = stack.pop()\n        for di in (-1, 0, 1):\n            ni = i + di\n            if ni < 0 or ni >= h:\n                continue\n            for dj in (-1, 0, 1):\n                nj = j + dj\n                if nj < 0 or nj >= w:\n                    continue\n                if not ink[ni, nj] and not visited[ni, nj]:\n                    visited[ni, nj] = True\n                    stack.append((ni, nj))\n    # holes are background pixels not reachable from border\n    holes = (~visited) & (~ink)\n    # count connected components among holes\n    visited_holes = np.zeros_like(holes, dtype=bool)\n    hole_count = 0\n    for i in range(h):\n        for j in range(w):\n            if holes[i, j] and not visited_holes[i, j]:\n                hole_count += 1\n                stack = [(i, j)]\n                visited_holes[i, j] = True\n                while stack:\n                    x, y = stack.pop()\n                    for di in (-1, 0, 1):\n                        nx = x + di\n                        if nx < 0 or nx >= h:\n                            continue\n                        for dj in (-1, 0, 1):\n                            ny = y + dj\n                            if ny < 0 or ny >= w:\n                                continue\n                            if holes[nx, ny] and not visited_holes[nx, ny]:\n                                visited_holes[nx, ny] = True\n                                stack.append((nx, ny))\n    return float(hole_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per central row (center 3 rows)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink_mask_candidate = gray < thresh\n    if np.count_nonzero(ink_mask_candidate) > (h * w / 2):\n        ink = (~ink_mask_candidate).astype(int)\n    else:\n        ink = ink_mask_candidate.astype(int)\n    center = h // 2\n    rows = [max(0, center - 1), center, min(h - 1, center + 1)]\n    transitions = []\n    for r in rows:\n        row = ink[r, :]\n        # transitions count: number of times adjacent pixels differ\n        trans = int(np.sum(np.abs(row[1:] - row[:-1])))\n        transitions.append(trans)\n    return float(np.mean(transitions))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized directional diagonal bias: (energy along / diagonal - energy along \\\\ diagonal) / total diagonal energy'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    # gradients\n    gy, gx = np.gradient(gray.astype(float))\n    diag1 = np.abs(gx + gy)  # one diagonal direction\n    diag2 = np.abs(gx - gy)  # other diagonal direction\n    s1 = diag1.sum()\n    s2 = diag2.sum()\n    denom = s1 + s2 + 1e-9\n    return float((s1 - s2) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of holes (closed loops) in the foreground by counting background components not touching the border'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # Simple adaptive binarization: foreground assumed darker than mean\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    # If too much ink, invert assumption\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    bg = ~ink\n    visited = np.zeros(bg.shape, dtype=bool)\n    holes = 0\n    # flood fill background components; count those not touching border\n    for r in range(h):\n        for c in range(w):\n            if not bg[r, c] or visited[r, c]:\n                continue\n            # start flood fill\n            stack = [(r, c)]\n            visited[r, c] = True\n            touches_border = False\n            while stack:\n                y, x = stack.pop()\n                if y == 0 or x == 0 or y == h - 1 or x == w - 1:\n                    touches_border = True\n                # explore 8-neighbors\n                for dy in (-1, 0, 1):\n                    for dx in (-1, 0, 1):\n                        ny, nx = y + dy, x + dx\n                        if ny < 0 or ny >= h or nx < 0 or nx >= w:\n                            continue\n                        if not visited[ny, nx] and bg[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n            if not touches_border:\n                holes += 1\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of vertical gradient energy that lies in the right half (captures vertical components concentrated on the right as in 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gx, gy = np.gradient(gray)\n    vert_energy = np.abs(gy)\n    total_energy = np.sum(vert_energy) + 1e-8\n    right_energy = np.sum(vert_energy[:, w//2:])\n    return float(right_energy) / float(total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal edge strength in the central horizontal band (captures mid crossbar presence)'\n    import numpy as np\n    # convert to grayscale float\n    if image is None:\n        return 0.0\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    if h < 3 or w < 3:\n        return 0.0\n    # central band\n    r0, r1 = h // 3, (2 * h) // 3\n    band = gray[r0:r1, :]\n    # horizontal edges ~ gradient along columns (diff across columns)\n    gx = np.abs(np.diff(band, axis=1))\n    # normalize by band area and global dynamic range\n    denom = (np.ptp(gray) + 1e-6) * band.size\n    return float(np.sum(gx) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of hole pixels located in the upper half of the image (0 if no holes)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr\n    background = ~ink\n    # Flood-fill external background\n    ext = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); ext[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); ext[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not ext[y, 0]:\n            dq.append((y, 0)); ext[y, 0] = True\n        if background[y, w - 1] and not ext[y, w - 1]:\n            dq.append((y, w - 1)); ext[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        if y > 0 and background[y - 1, x] and not ext[y - 1, x]:\n            ext[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not ext[y + 1, x]:\n            ext[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not ext[y, x - 1]:\n            ext[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not ext[y, x + 1]:\n            ext[y, x + 1] = True; dq.append((y, x + 1))\n    holes = background & (~ext)\n    total_hole = np.count_nonzero(holes)\n    if total_hole == 0:\n        return 0.0\n    upper = holes[:h // 2, :]\n    upper_count = np.count_nonzero(upper)\n    return float(upper_count) / float(total_hole)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean binary ink presence in a narrow horizontal band around the image midline (detects middle crossbar like in \"4\")'\n    import numpy as np\n    h, w = image.shape[:2]\n    # convert to grayscale\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # robust binarization (assume ink differs from median)\n    thr = np.mean(gray)\n    mask = gray < thr\n    prop = mask.mean()\n    if prop > 0.9 or prop < 0.01:\n        mask = gray > thr\n    # choose a narrow band around middle (10% of height)\n    band_h = max(1, h // 10)\n    start = max(0, h // 2 - band_h // 2)\n    band = mask[start:start + band_h, :]\n    return float(band.mean())\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient (vertical strokes produce higher horizontal gradient)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mean_abs_gx = float(np.mean(np.abs(gx)))\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    return float((mean_abs_gx + 1e-9) / (mean_abs_gy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-quarter horizontal edge strength: average absolute horizontal gradient magnitude in top 25% of image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = gray[:top_h, :]\n    # horizontal gradient: difference along columns\n    horiz_grad = np.abs(np.diff(top_region, axis=1))\n    # average normalized by intensity range\n    denom = max(1.0, float(np.ptp(gray)))\n    score = float(horiz_grad.mean()) / denom\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of vertical gradient energy located in the right half of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute vertical gradient\n    gy, gx = np.gradient(gray)\n    energy = np.abs(gy)\n    left_energy = energy[:, :w // 2].sum()\n    right_energy = energy[:, w // 2:].sum()\n    total = left_energy + right_energy + 1e-9\n    return float(right_energy / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical ink run (indicates strong vertical strokes like \"1\")'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv or h == 0 or w == 0:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    count = 0\n    for col in range(w):\n        colarr = ink[:, col].astype(int)\n        maxrun = 0\n        cur = 0\n        for v in colarr:\n            if v:\n                cur += 1\n                if cur > maxrun:\n                    maxrun = cur\n            else:\n                cur = 0\n        if maxrun >= max(1, int(0.4 * h)):\n            count += 1\n    return float(count / max(1.0, float(w)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a top horizontal stroke: proportion of ink in the top 20% rows'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_count = float(np.count_nonzero(ink[:top_rows, :]))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized strength of a continuous horizontal stroke in the top 25% rows (detects top bar of \"7\")'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    top_rows = max(1, h // 4)\n    # for each top row compute fraction of columns that are foreground; take the maximum\n    row_sums = np.sum(fg[:top_rows, :], axis=1).astype(float)\n    max_frac = np.max(row_sums) / float(w)\n    # Also scale by how many top rows have above-median fill\n    median_row = np.median(row_sums)\n    high_rows = np.count_nonzero(row_sums > median_row)\n    score = max_frac * (high_rows / float(top_rows))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength in the bottom quarter compared to full image (captures bottom bars)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    if arr.size == 0:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    horiz_edge = np.abs(gx)\n    bottom_start = max(0, (3*h)//4)\n    bottom = horiz_edge[bottom_start:, :]\n    bottom_mean = float(np.mean(bottom)) if bottom.size > 0 else 0.0\n    full_mean = float(np.mean(horiz_edge)) if horiz_edge.size > 0 else 1.0\n    return float(bottom_mean / (full_mean + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal shift of centroid between top and bottom halves (captures diagonal/leaning strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    thresh = (mn + mx) / 2.0\n    ink = gray < thresh if gray.mean() > thresh else gray > thresh\n    h, w = ink.shape\n    top = ink[:h//2, :]\n    bot = ink[h//2:, :]\n    def centroid_x(arr):\n        coords = np.argwhere(arr)\n        if coords.size == 0:\n            return w / 2.0\n        return float(coords[:, 1].mean())\n    cx_top = centroid_x(top)\n    cx_bot = centroid_x(bot) + 0.0\n    # return signed shift normalized by width\n    return float((cx_top - cx_bot) / (w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position of the strongest horizontal stroke (row index of max horizontal edge energy)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    # horizontal strokes create strong vertical gradients (change across rows) -> use |gy|\n    row_energy = np.sum(np.abs(gy), axis=1)\n    if np.all(row_energy == 0):\n        return 0.0\n    max_row = int(np.argmax(row_energy))\n    # normalized distance from center (0=center, 1=top or bottom edge)\n    center = (h - 1) / 2.0\n    norm = abs(max_row - center) / (center + 1e-8)\n    # invert so lower values mean it's centered\n    return float(1.0 - norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Solidity-like measure: area of largest connected ink component divided by its bounding-box area (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    t = (np.percentile(gray, 30) + np.percentile(gray, 70)) / 2.0\n    lower_mean = gray[gray <= t].mean() if np.any(gray <= t) else t\n    upper_mean = gray[gray > t].mean() if np.any(gray > t) else t\n    if lower_mean < upper_mean:\n        ink = (gray <= t)\n    else:\n        ink = (gray >= t)\n    ink = ink.astype(np.uint8)\n    visited = np.zeros_like(ink, dtype=bool)\n    largest_area = 0\n    largest_bbox_area = 1\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j] and not visited[i, j]:\n                area = 0\n                minr, maxr = i, i\n                minc, maxc = j, j\n                stack = [(i, j)]\n                visited[i, j] = True\n                while stack:\n                    r, c = stack.pop()\n                    area += 1\n                    if r < minr: minr = r\n                    if r > maxr: maxr = r\n                    if c < minc: minc = c\n                    if c > maxc: maxc = c\n                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)):\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < h and 0 <= nc < w and ink[nr, nc] and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            stack.append((nr, nc))\n                bbox_area = max(1, (maxr - minr + 1) * (maxc - minc + 1))\n                if area > largest_area:\n                    largest_area = area\n                    largest_bbox_area = bbox_area\n    if largest_area == 0:\n        return 0.0\n    return float(largest_area) / float(largest_bbox_area)\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference of radial spread between lower-half and upper-half foreground pixels normalized by overall radial std'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    ys, xs = np.where(fg)\n    if xs.size == 0:\n        return 0.0\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    upper_mask = ys < cy\n    lower_mask = ~upper_mask\n    if np.count_nonzero(upper_mask) < 2 or np.count_nonzero(lower_mask) < 2:\n        return 0.0\n    upper_std = float(np.std(dists[upper_mask]))\n    lower_std = float(np.std(dists[lower_mask]))\n    overall_std = float(np.std(dists)) + 1e-6\n    return float((lower_std - upper_std) / overall_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom horizontal gradient strength: mean absolute horizontal gradient in bottom strip (detect bottom bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    gy, gx = np.gradient(gray.astype(np.float64))\n    horiz_abs = np.abs(gx)\n    bottom_h = max(1, h // 5)\n    region = horiz_abs[h - bottom_h:, :]\n    fg_region = fg[h - bottom_h:, :]\n    # weight by foreground presence to emphasize strokes\n    weighted = region * (fg_region.astype(np.float64))\n    mean_val = weighted.mean() if weighted.size else 0.0\n    return float(mean_val)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the top third of the image (detects prominent top bars like in 7 or 9)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        top = gray[:max(1, h//3), :]\n        gy, gx = np.gradient(top)\n        horiz_edges = np.abs(gx)\n        return float(np.mean(horiz_edges))\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized topmost ink row: fraction of image height to the first row containing ink (0=top,1=bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    thresh = (np.mean(border) + np.mean(gray)) / 2.0\n    ink = (gray < thresh) if (np.mean(border) > np.mean(gray)) else (gray > thresh)\n    rows = np.any(ink, axis=1)\n    if not np.any(rows):\n        return 1.0\n    first = int(np.argmax(rows))\n    return float(first / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized x-coordinate of the ink centroid relative to image center (centroid_x - 0.5)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.float64)\n    total = ink.sum()\n    if total <= 1e-9:\n        return 0.0\n    cols = np.arange(w)\n    cx = (ink.sum(axis=0) * cols).sum() / (total + 1e-9)\n    # normalized relative to center: range approx [-0.5,0.5]\n    return float((cx / max(1, w - 1)) - 0.5)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum relative background gap width in the top third (captures top concavities/openings)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.uint8)\n    if np.count_nonzero(ink) == 0:\n        return 1.0\n    top = max(1, h // 3)\n    max_gap_rel = 0.0\n    for i in range(top):\n        row = ink[i, :]\n        if np.any(row):\n            left = np.argmax(row > 0)\n            # find rightmost ink: search from right\n            rev = row[::-1]\n            right = w - 1 - np.argmax(rev > 0)\n            gap = max(0, right - left + 1 - int(np.sum(row[left:right+1] > 0)))\n            # alternatively, compute largest sequence of zeros between left and right\n            if right > left:\n                seg = row[left:right+1] == 0\n                # find longest run of True in seg\n                max_run = 0\n                run = 0\n                for v in seg:\n                    if v:\n                        run += 1\n                    else:\n                        if run > max_run: max_run = run\n                        run = 0\n                if run > max_run: max_run = run\n                gap_width = max_run\n            else:\n                gap_width = 0\n            rel = float(gap_width) / float(w)\n            if rel > max_gap_rel:\n                max_gap_rel = rel\n    return float(max_gap_rel)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean ink density in the lower-left quadrant (captures loops or low-left strokes like 6)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    m, med = np.mean(gray), np.median(gray)\n    thresh = (m + med) / 2.0\n    mask = (gray < thresh) if (m < med) else (gray > thresh)\n    h, w = gray.shape[:2]\n    r0, r1 = h//2, h\n    c0, c1 = 0, w//2\n    region = mask[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(region))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom third of the image (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        bottom = np.count_nonzero(ink[(2*h)//3 : , :])\n        return float(bottom) / float(total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of left-third columns that contain any ink (indicates presence of a left vertical stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    left_w = max(1, w // 3)\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    left_block = ink[:, :left_w]\n    if left_block.size == 0:\n        return 0.0\n    cols_with_ink = np.sum(np.any(left_block, axis=0))\n    return float(cols_with_ink / left_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative bias of ink between upper-right and upper-left quadrants: (UR - UL) / (UR + UL + eps) in upper half'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh)\n    h, w = ink.shape\n    mid_r = h // 2\n    mid_c = w // 2\n    upper = ink[0:mid_r, :]\n    ul = np.count_nonzero(upper[:, 0:mid_c])\n    ur = np.count_nonzero(upper[:, mid_c:w])\n    val = (float(ur) - float(ul)) / (float(ur) + float(ul) + 1e-9)\n    return float(val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink density in the top half and bottom half (top_density - bottom_density) / overall_density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    top = ink[0:h//2, :]\n    bottom = ink[h//2:h, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    total = top_count + bottom_count\n    if total <= 0.0:\n        return 0.0\n    return float((top_count - bottom_count) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical ink run (indicates strong vertical strokes like \"1\")'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv or h == 0 or w == 0:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    count = 0\n    for col in range(w):\n        colarr = ink[:, col].astype(int)\n        maxrun = 0\n        cur = 0\n        for v in colarr:\n            if v:\n                cur += 1\n                if cur > maxrun:\n                    maxrun = cur\n            else:\n                cur = 0\n        if maxrun >= max(1, int(0.4 * h)):\n            count += 1\n    return float(count / max(1.0, float(w)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-quarter vs lower-quarter ink imbalance: (upper_quarter - lower_quarter) / (total + eps), range [-1,1]'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    h, w = gray.shape\n    m = _np.mean(gray)\n    ink = (gray < m).astype(_np.float32)\n    q = max(1, h // 4)\n    upper = float(ink[:q, :].sum())\n    lower = float(ink[-q:, :].sum())\n    total = float(ink.sum()) + 1e-6\n    imbalance = float((upper - lower) / total)\n    return imbalance\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink contained in bottom-left quadrant (useful to detect 6-like fills)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx <= mn:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    br = h // 2\n    bc = w // 2\n    bottom_left = float(norm[br:, :bc].sum())\n    total = float(norm.sum())\n    if total <= 1e-8:\n        return 0.0\n    return float(bottom_left / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of horizontal transitions along the central row (captures number of stroke segments)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    # threshold\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.int32)\n    row_idx = h//2\n    if row_idx < 0 or row_idx >= h:\n        return 0.0\n    row = ink[row_idx, :]\n    if row.size < 2:\n        return 0.0\n    transitions = np.sum(np.abs(np.diff(row)))\n    # normalize by width\n    return float(transitions / (w - 1 + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal edges in the upper third: mean horizontal gradient in top band divided by global gradient'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    # horizontal gradient (differences along columns)\n    hg = np.abs(np.diff(gray, axis=1))\n    # average in upper third\n    top_rows = max(1, h // 3)\n    top_hg = hg[:top_rows, :]\n    mean_top = top_hg.mean() if top_hg.size else 0.0\n    mean_all = hg.mean() if hg.size else 0.0\n    denom = mean_all + 1e-8\n    return float(mean_top / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the top third of the image (detects prominent top bars like in 7 or 9)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        top = gray[:max(1, h//3), :]\n        gy, gx = np.gradient(top)\n        horiz_edges = np.abs(gx)\n        return float(np.mean(horiz_edges))\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate hole area ratio: fraction of ink-area that surrounds enclosed background (holes). 8 has two holes, 0 has one, 5 typically none'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    # robust thresholding as above\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr)\n    ink = ink.astype(np.bool_)\n    if h == 0 or w == 0:\n        return 0.0\n    # flood-fill to find background connected to borders\n    bg = np.zeros_like(ink, dtype=bool)\n    stack = []\n    # push border background pixels\n    for c in range(w):\n        if not ink[0, c]:\n            stack.append((0, c))\n            bg[0, c] = True\n        if not ink[h - 1, c]:\n            stack.append((h - 1, c))\n            bg[h - 1, c] = True\n    for r in range(h):\n        if not ink[r, 0]:\n            stack.append((r, 0))\n            bg[r, 0] = True\n        if not ink[r, w - 1]:\n            stack.append((r, w - 1))\n            bg[r, w - 1] = True\n    # 4-connected flood fill\n    while stack:\n        r, c = stack.pop()\n        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            rr, cc = r + dr, c + dc\n            if 0 <= rr < h and 0 <= cc < w and (not bg[rr, cc]) and (not ink[rr, cc]):\n                bg[rr, cc] = True\n                stack.append((rr, cc))\n    holes = (~ink) & (~bg)\n    hole_area = float(np.count_nonzero(holes))\n    ink_area = float(np.count_nonzero(ink))\n    if ink_area <= 0:\n        return 0.0\n    return float(hole_area) / ink_area\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a top horizontal stroke: proportion of ink in the top 20% rows'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_count = float(np.count_nonzero(ink[:top_rows, :]))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Angle (radians) of the principal axis from PCA of ink coordinates (range approx -pi/2..pi/2)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if ys.size < 2:\n        return 0.0\n    coords = np.vstack((xs.astype(float), ys.astype(float)))\n    cov = np.cov(coords)\n    # principal eigenvector\n    evals, evecs = np.linalg.eigh(cov + 1e-8 * np.eye(2))\n    principal = evecs[:, np.argmax(evals)]\n    angle = np.arctan2(principal[1], principal[0])\n    return float(angle)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal vs anti-diagonal gradient energy: sum|gx+gy| / (sum|gx-gy| + eps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag = np.sum(np.abs(gx + gy))\n    antidiag = np.sum(np.abs(gx - gy))\n    eps = 1e-6\n    return float(diag / (antidiag + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge strength to horizontal edge strength (vertical/horizontal)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    gx, gy = np.gradient(gray)\n    # gx = d/dy (vertical), gy = d/dx (horizontal) depending on numpy's ordering\n    vert = float(np.abs(gx).sum())\n    hor = float(np.abs(gy).sum())\n    return float(vert / (hor + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of columns that contain a vertical ink run covering at least 60% of image height (indicates strong vertical strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    count = 0\n    minrun = max(1, int(0.6 * h))\n    for c in range(w):\n        col = ink[:, c].astype(int)\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= minrun):\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of the rightmost ink column index per row (normalized by width) - boundary variation of right side'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    meanv = gray.mean()\n    stdv = gray.std() if gray.std() > 1e-9 else 1.0\n    fg = (np.abs(gray - meanv) > 0.5 * stdv)\n    rightmost = []\n    for r in range(h):\n        cols = np.nonzero(fg[r, :])[0]\n        if cols.size:\n            rightmost.append(float(cols.max()))\n    if len(rightmost) < 2:\n        return 0.0\n    s = float(np.std(np.array(rightmost)))\n    return float(s / float(max(1.0, w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain no ink (indicates stroke breaks or disjoint strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    if h == 0:\n        return 0.0\n    empty_rows = np.sum(np.all(ink == 0, axis=1))\n    return float(empty_rows / (h + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength difference between left and right in the top third (detects whether the top bar is centered or biased)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 3)\n    Gx, Gy = np.gradient(gray)\n    horiz_edge = np.abs(Gx)  # horizontal edges respond to horizontal intensity changes\n    left_energy = np.sum(horiz_edge[0:top_h, :w//2])\n    right_energy = np.sum(horiz_edge[0:top_h, w//2:])\n    denom = left_energy + right_energy + 1e-8\n    return float(right_energy - left_energy) / float(denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left vs right ink balance: normalized difference in ink pixel counts'\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # adaptive binarization: determine if ink is darker\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    left = float(np.count_nonzero(fg[:, :w//2]))\n    right = float(np.count_nonzero(fg[:, w//2:]))\n    denom = left + right + 1e-6\n    return float((left - right) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient to horizontal gradient in the top-right quadrant (vertical/horizontal)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    r0, c0 = 0, w // 2\n    r1, c1 = max(1, h // 2), w\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mean_abs_gx = np.mean(np.abs(gx)) + 1e-9\n    mean_abs_gy = np.mean(np.abs(gy))\n    return float(mean_abs_gy / mean_abs_gx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge (absolute y-gradient) strength in the bottom third normalized by total gradient energy (detects strong bottom bars vs top bars)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.abs(gy)\n    bottom = mag[max(0, 2*h//3):, :]\n    bottom_energy = float(np.mean(bottom)) if bottom.size else 0.0\n    total_energy = float(np.mean(np.sqrt(gx*gx + gy*gy))) + 1e-12\n    return float(bottom_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength in top third vs bottom third (mean abs horizontal gradient top / bottom)'\n    import numpy as np\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute horizontal gradient magnitude\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    top_third = abs_gx[:max(1, h//3), :]\n    bottom_third = abs_gx[max(1, 2*h//3):, :]\n    top_mean = float(np.mean(top_third)) if top_third.size > 0 else 0.0\n    bottom_mean = float(np.mean(bottom_third)) if bottom_third.size > 0 else 1e-9\n    return float(top_mean / (bottom_mean + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge energy in the upper half vs lower half (upper_energy / (lower_energy + eps))'\n    eps = 1e-9\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    # horizontal gradient magnitude (differences along columns)\n    grad_h = np.abs(np.diff(norm, axis=1))\n    mid = h // 2\n    upper_energy = grad_h[:mid, :].sum()\n    lower_energy = grad_h[mid:, :].sum()\n    return float(upper_energy / (lower_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical ink span in upper half to vertical span in lower half (helps separate top-loop digits like 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    if ink.sum() == 0:\n        return 0.0\n    mid = h // 2\n    upper = ink[:mid, :]\n    lower = ink[mid:, :]\n    def vert_span(arr):\n        cols = np.any(arr, axis=0)\n        if not cols.any():\n            return 0.0\n        ys = np.any(arr, axis=1)\n        if not ys.any():\n            return 0.0\n        return float(ys.nonzero()[0].max() - ys.nonzero()[0].min() + 1)\n    upper_span = vert_span(upper)\n    lower_span = vert_span(lower)\n    if lower_span == 0.0:\n        return float(upper_span)\n    return float(upper_span / (lower_span + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated fraction of enclosed hole pixels (background not connected to border) relative to image area'\n    import numpy as np\n    from collections import deque\n    eps = 1e-9\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gmin, gmax = gray.min(), gray.max()\n    denom = (gmax - gmin) + eps\n    norm = (gray - gmin) / denom\n    low_count = int(np.count_nonzero(norm < 0.5))\n    high_count = h * w - low_count\n    if low_count <= high_count:\n        ink = norm < 0.5\n    else:\n        ink = norm >= 0.5\n    background = ~ink\n    # flood fill background from borders to find reachable background\n    reachable = np.zeros_like(background, dtype=bool)\n    q = deque()\n    # push border background pixels\n    # top and bottom rows\n    top = np.where(background[0, :])[0]\n    for c in top:\n        q.append((0, int(c)))\n        reachable[0, int(c)] = True\n    bottom = np.where(background[h - 1, :])[0]\n    for c in bottom:\n        if not reachable[h - 1, int(c)]:\n            q.append((h - 1, int(c)))\n            reachable[h - 1, int(c)] = True\n    # left and right columns\n    left = np.where(background[:, 0])[0]\n    for r in left:\n        if not reachable[int(r), 0]:\n            q.append((int(r), 0))\n            reachable[int(r), 0] = True\n    right = np.where(background[:, w - 1])[0]\n    for r in right:\n        if not reachable[int(r), w - 1]:\n            q.append((int(r), w - 1))\n            reachable[int(r), w - 1] = True\n    # neighbors offsets 4-connected (sufficient)\n    while q:\n        r, c = q.popleft()\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w and not reachable[nr, nc] and background[nr, nc]:\n                reachable[nr, nc] = True\n                q.append((nr, nc))\n    # hole pixels are background but not reachable\n    hole_pixels = np.count_nonzero(background & (~reachable))\n    return float(hole_pixels / (h * w + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness circularity: 4*pi*area / (perimeter^2) approximated from pixel neighbors (higher for round shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    fg = fg.astype(np.uint8)\n    area = np.count_nonzero(fg)\n    if area == 0:\n        return 0.0\n    # perimeter approx: foreground pixels that have at least one background neighbor (4-neigh)\n    pad = np.pad(fg, pad_width=1, mode='constant', constant_values=0)\n    perim = 0\n    for r in range(1, h+1):\n        for c in range(1, w+1):\n            if pad[r, c]:\n                if not (pad[r-1, c] and pad[r+1, c] and pad[r, c-1] and pad[r, c+1]):\n                    perim += 1\n    perim = float(max(perim, 1))\n    compact = 4.0 * np.pi * float(area) / (perim * perim)\n    return float(compact)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in the top 20% of rows to total ink pixels (top-edge density)'\n    import numpy as np\n    eps = 1e-8\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # normalize to 0..1\n    mn, mx = float(gray.min()), float(gray.max())\n    rng = mx - mn + eps\n    norm = (gray - mn) / rng\n    # decide ink polarity: assume ink is the minority intensity side\n    if np.mean(norm) > 0.5:\n        ink = norm < 0.5\n    else:\n        ink = norm > 0.5\n    total_ink = np.count_nonzero(ink)\n    if total_ink == 0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_region = ink[:top_rows, :]\n    return float(np.count_nonzero(top_region) / (total_ink + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink density in the top half and bottom half (top_density - bottom_density) / overall_density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    top = ink[0:h//2, :]\n    bottom = ink[h//2:h, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    total = top_count + bottom_count\n    if total <= 0.0:\n        return 0.0\n    return float((top_count - bottom_count) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of hole pixels located in the upper half of the image (0 if no holes)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr\n    background = ~ink\n    # Flood-fill external background\n    ext = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); ext[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); ext[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not ext[y, 0]:\n            dq.append((y, 0)); ext[y, 0] = True\n        if background[y, w - 1] and not ext[y, w - 1]:\n            dq.append((y, w - 1)); ext[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        if y > 0 and background[y - 1, x] and not ext[y - 1, x]:\n            ext[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not ext[y + 1, x]:\n            ext[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not ext[y, x - 1]:\n            ext[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not ext[y, x + 1]:\n            ext[y, x + 1] = True; dq.append((y, x + 1))\n    holes = background & (~ext)\n    total_hole = np.count_nonzero(holes)\n    if total_hole == 0:\n        return 0.0\n    upper = holes[:h // 2, :]\n    upper_count = np.count_nonzero(upper)\n    return float(upper_count) / float(total_hole)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical gradient magnitude (average absolute d/dy) normalized by intensity range'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    minv = float(np.min(gray))\n    maxv = float(np.max(gray))\n    if maxv > minv:\n        gray = (gray - minv) / (maxv - minv)\n    else:\n        gray = gray * 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.abs(gy)\n    return float(np.mean(mag))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of enclosed holes (connected background regions fully surrounded by ink), returns integer as float'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        # initialize from borders\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j))\n                    ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j))\n                    ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        # count enclosed connected components\n        visited = np.zeros_like(enclosed, dtype=bool)\n        holes = 0\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    holes += 1\n                    # flood fill\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n        return float(holes)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated hole count inside ink strokes (counts background components not touching image border)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    mx = gray.max()\n    scale = 255.0 if mx > 1.5 else 1.0\n    if gray.mean() > scale * 0.5:\n        thr = np.percentile(gray, 30)\n        ink = (gray < thr)\n    else:\n        thr = np.percentile(gray, 70)\n        ink = (gray > thr)\n    # background mask\n    bg = ~ink\n    visited = np.zeros((h, w), dtype=np.uint8)\n    holes = 0\n    # flood-fill background components\n    for i in range(h):\n        for j in range(w):\n            if bg[i, j] and not visited[i, j]:\n                stack = [(i, j)]\n                visited[i, j] = 1\n                touches_border = False\n                while stack:\n                    y, x = stack.pop()\n                    if y == 0 or y == h-1 or x == 0 or x == w-1:\n                        touches_border = True\n                    # iterate neighbors 8-neighborhood\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if (0 <= ny < h) and (0 <= nx < w) and (not visited[ny, nx]) and bg[ny, nx]:\n                                visited[ny, nx] = 1\n                                stack.append((ny, nx))\n                if not touches_border:\n                    holes += 1\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical position (normalized) of the largest interior hole centroid, -1 if no hole'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # determine foreground\n    p40 = np.percentile(gray, 40)\n    p60 = np.percentile(gray, 60)\n    dark = (gray < p40)\n    light = (gray > p60)\n    if dark.sum() > 0 and (dark.sum() <= max(1, light.sum())):\n        fg = dark\n    elif light.sum() > 0:\n        fg = light\n    else:\n        fg = (gray < np.mean(gray))\n    bg = (~fg).astype(np.uint8)\n    visited = np.zeros_like(bg, dtype=bool)\n    holes = []\n    # flood fill background components\n    for y in range(h):\n        for x in range(w):\n            if bg[y, x] and not visited[y, x]:\n                # BFS\n                stack = [(y, x)]\n                visited[y, x] = True\n                coords = []\n                touches_border = False\n                while stack:\n                    cy, cx = stack.pop()\n                    coords.append((cy, cx))\n                    if cy == 0 or cy == h-1 or cx == 0 or cx == w-1:\n                        touches_border = True\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny = cy + dy\n                            nx = cx + dx\n                            if 0 <= ny < h and 0 <= nx < w and not visited[ny, nx] and bg[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n                if not touches_border:\n                    ys = [c[0] for c in coords]\n                    xs = [c[1] for c in coords]\n                    holes.append((len(coords), np.mean(ys), np.mean(xs)))\n    if len(holes) == 0:\n        return -1.0\n    # pick largest hole\n    holes.sort(reverse=True, key=lambda t: t[0])\n    _, yc, _ = holes[0]\n    return float(yc / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of background holes that are centered in the lower half of the bounding box (float int)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    meanv = float(np.mean(gray))\n    if meanv > (mn + mx) / 2.0:\n        fg = (gray < meanv)\n    else:\n        fg = (gray > meanv)\n    fg = fg.astype(np.uint8)\n    coords = np.argwhere(fg)\n    if coords.size == 0:\n        return 0.0\n    r0, c0 = coords.min(axis=0)\n    r1, c1 = coords.max(axis=0)\n    sub = fg[r0:r1+1, c0:c1+1]\n    # background mask inside bbox\n    bg = (sub == 0).astype(np.uint8)\n    H, W = bg.shape\n    visited = np.zeros_like(bg, dtype=np.uint8)\n    holes_lower = 0\n    # 4-connectivity neighbors\n    for i in range(H):\n        for j in range(W):\n            if bg[i, j] and not visited[i, j]:\n                # flood fill\n                stack = [(i, j)]\n                visited[i, j] = 1\n                touches_border = False\n                sum_r = 0\n                count = 0\n                while stack:\n                    y, x = stack.pop()\n                    sum_r += y\n                    count += 1\n                    if y == 0 or x == 0 or y == H - 1 or x == W - 1:\n                        touches_border = True\n                    # neighbors\n                    if y > 0 and bg[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = 1\n                        stack.append((y - 1, x))\n                    if y < H - 1 and bg[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = 1\n                        stack.append((y + 1, x))\n                    if x > 0 and bg[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = 1\n                        stack.append((y, x - 1))\n                    if x < W - 1 and bg[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = 1\n                        stack.append((y, x + 1))\n                # if component does NOT touch bbox border -> it's a hole\n                if not touches_border and count > 0:\n                    centroid_r = float(sum_r) / float(count)\n                    # if centroid lies in lower half of the bbox region\n                    if centroid_r >= H / 2.0:\n                        holes_lower += 1\n    return float(holes_lower)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical to horizontal gradient magnitudes calculated on the right half'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2).astype(float)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    right = slice(w//2, w)\n    abs_vert = np.abs(gy[:, right])\n    abs_horz = np.abs(gx[:, right])\n    mean_vert = float(np.mean(abs_vert)) if abs_vert.size else 0.0\n    mean_horz = float(np.mean(abs_horz)) if abs_horz.size else 0.0\n    eps = 1e-9\n    return float(mean_vert / (mean_horz + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous horizontal ink run in the top quarter of the image, normalized by width'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    thr = np.percentile(gray, 50.0)\n    ink = (gray < thr).astype(np.uint8)\n    if np.sum(ink) == 0:\n        ink = (gray > thr).astype(np.uint8)\n        if np.sum(ink) == 0:\n            return 0.0\n    top_band = ink[:max(1, h // 4), :]\n    max_run = 0\n    # For each row compute longest consecutive ones\n    for row in top_band:\n        # compute run lengths by diff trick\n        padded = np.concatenate(([0], row, [0]))\n        changes = np.diff(padded)\n        starts = np.nonzero(changes == 1)[0]\n        ends = np.nonzero(changes == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(int(np.max(runs)), max_run)\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the top-right quadrant (upper-right density ratio)'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    thresh = np.mean(norm)\n    ink = (norm < thresh).astype(np.float32)\n    if np.mean(ink) < 1e-3:\n        ink = 1.0 - ink\n    mid_h, mid_w = h // 2, w // 2\n    top_right = ink[0:mid_h, mid_w:w]\n    total = ink.sum()\n    if total <= 0:\n        return 0.0\n    return float(top_right.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top contour variability: std dev of topmost ink row per column normalized by image height (higher -> more peaks/valleys)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 45)\n    mask = gray < thr if np.mean(gray) < thr else gray > thr\n    top_idx = np.full(w, h, dtype=int)\n    for col in range(w):\n        col_vals = mask[:, col]\n        nz = np.nonzero(col_vals)[0]\n        if nz.size:\n            top_idx[col] = nz[0]\n    valid = top_idx < h\n    if valid.sum() == 0:\n        return 0.0\n    std = float(np.std(top_idx[valid]))\n    return std / max(1.0, h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical position (0..1) of hole centroids; 0 if no hole (0=top,1=bottom)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        centroids = []\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumy = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumy += y\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > 0:\n                        centroids.append((sumy / area))\n        if len(centroids) == 0:\n            return 0.0\n        avg_y = float(np.mean(centroids))\n        return float(avg_y / max(1.0, h))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    '180-degree rotational symmetry score: normalized correlation between image and its 180-degree rotation'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # normalize\n    g = gray.astype(float)\n    g = (g - g.mean())\n    rot = np.rot90(g, 2)\n    num = np.sum(g * rot)\n    denom = np.sqrt(np.sum(g * g) * np.sum(rot * rot)) + 1e-12\n    return float(num / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical ink run (indicates strong vertical strokes like \"1\")'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv or h == 0 or w == 0:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    count = 0\n    for col in range(w):\n        colarr = ink[:, col].astype(int)\n        maxrun = 0\n        cur = 0\n        for v in colarr:\n            if v:\n                cur += 1\n                if cur > maxrun:\n                    maxrun = cur\n            else:\n                cur = 0\n        if maxrun >= max(1, int(0.4 * h)):\n            count += 1\n    return float(count / max(1.0, float(w)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of ink runs (background->ink transitions) per column in the central vertical third (captures vertical fragmentation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 1:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    thresh = 0.5 * (mn + mx)\n    p = float(np.mean(gray < thresh))\n    ink = (gray < thresh) if p <= 0.5 else (gray > thresh)\n    c0, c1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    if c1 <= c0:\n        cols = ink\n    else:\n        cols = ink[:, c0:c1]\n    # compute transitions per column\n    diffs = np.diff(cols.astype(int), axis=0)\n    runs_per_col = np.sum(diffs == 1, axis=0)  # count background->ink transitions\n    if runs_per_col.size == 0:\n        return 0.0\n    avg_runs = np.mean(runs_per_col)\n    return float(avg_runs / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal vs anti-diagonal gradient energy: sum|gx+gy| / (sum|gx-gy| + eps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag = np.sum(np.abs(gx + gy))\n    antidiag = np.sum(np.abs(gx - gy))\n    eps = 1e-6\n    return float(diag / (antidiag + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between NW-SE and NE-SW diagonal gradient energy (positive -> NW-SE dominant)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients\n    gy, gx = np.gradient(gray)\n    diag1 = gx + gy  # NW-SE\n    diag2 = gx - gy  # NE-SW\n    e1 = np.sum(np.abs(diag1))\n    e2 = np.sum(np.abs(diag2))\n    tot = e1 + e2 + 1e-6\n    return float((e1 - e2) / tot)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal edge strength in the top quarter (captures a top bar)'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # gradients\n    gy, gx = np.gradient(gray)\n    edge = np.hypot(gx, gy)\n    top_region = edge[:max(1, h//4), :]\n    total = edge.sum() + 1e-9\n    return float(top_region.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal transitions per row (captures horizontal stroke complexity)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn + 1e-8\n    norm = (gray - mn) / rng\n    stroke_darker = np.mean(norm) < 0.5\n    mask = (norm < 0.5) if stroke_darker else (norm > 0.5)\n    # compute row-wise transitions\n    diffs = np.abs(np.diff(mask.astype(np.int8), axis=1))\n    transitions_per_row = np.sum(diffs, axis=1)  # length h\n    avg_trans = float(np.mean(transitions_per_row) / (w + 1e-8))\n    return avg_trans\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom horizontal gradient strength: mean absolute horizontal gradient in bottom strip (detect bottom bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    gy, gx = np.gradient(gray.astype(np.float64))\n    horiz_abs = np.abs(gx)\n    bottom_h = max(1, h // 5)\n    region = horiz_abs[h - bottom_h:, :]\n    fg_region = fg[h - bottom_h:, :]\n    # weight by foreground presence to emphasize strokes\n    weighted = region * (fg_region.astype(np.float64))\n    mean_val = weighted.mean() if weighted.size else 0.0\n    return float(mean_val)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative ink mass in the lower central region (bottom half & central 60% width) compared to total ink'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    vals = gray.ravel()\n    lowp, highp = np.percentile(vals, 10), np.percentile(vals, 90)\n    thresh = (lowp + highp) / 2.0\n    binary = gray < thresh\n    if np.count_nonzero(binary) == 0:\n        binary = gray > thresh\n    total = float(np.count_nonzero(binary))\n    if total == 0.0:\n        return 0.0\n    left = int(w * 0.2)\n    right = int(w * 0.8)\n    bottom_mask = np.zeros_like(binary, dtype=bool)\n    bottom_mask[h//2:, left:right] = True\n    bottom_count = float(np.count_nonzero(binary & bottom_mask))\n    return bottom_count / total\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink density in the top half and bottom half (top_density - bottom_density) / overall_density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    top = ink[0:h//2, :]\n    bottom = ink[h//2:h, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    total = top_count + bottom_count\n    if total <= 0.0:\n        return 0.0\n    return float((top_count - bottom_count) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the right half divided by left half (detects right-side lobes like 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)  # gy: d/drow (vertical change -> horizontal edges), gx: d/dcol (vertical edges)\n    horiz_edge = np.abs(gy)\n    mid = w // 2\n    left_energy = np.mean(horiz_edge[:, :mid]) if mid > 0 else 0.0\n    right_energy = np.mean(horiz_edge[:, mid:]) if w - mid > 0 else 0.0\n    denom = left_energy + 1e-9\n    return float(right_energy / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient restricted to the right half (captures right-side curvature)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        # smooth-ish by simple local mean to reduce noise\n        # compute gradients\n        gx, gy = np.gradient(gray.astype(float))\n        right_gx = gx[:, w//2:]\n        right_gy = gy[:, w//2:]\n        mag_x = np.mean(np.abs(right_gx)) if right_gx.size > 0 else 0.0\n        mag_y = np.mean(np.abs(right_gy)) if right_gy.size > 0 else 0.0\n        if mag_y == 0:\n            return float(mag_x)\n        return float(mag_x) / float(mag_y)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-quarter horizontal edge strength: average absolute horizontal gradient magnitude in top 25% of image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = gray[:top_h, :]\n    # horizontal gradient: difference along columns\n    horiz_grad = np.abs(np.diff(top_region, axis=1))\n    # average normalized by intensity range\n    denom = max(1.0, float(np.ptp(gray)))\n    score = float(horiz_grad.mean()) / denom\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical gradient energy in the right half vs whole image (higher means stronger vertical strokes on the right side)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if image.ndim == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        # vertical gradients\n        vg = np.abs(np.diff(gray, axis=0))\n        total_vg = np.mean(vg) if vg.size>0 else 0.0\n        right_vg = np.mean(vg[:, w//2:]) if vg[:, w//2:].size>0 else 0.0\n        eps = 1e-6\n        return float(right_vg / (total_vg + eps))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative right-half horizontal edge strength: mean abs horizontal gradient in right half divided by global edge strength'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w <= 1:\n        return 0.0\n    gx = np.abs(np.diff(gray, axis=1))\n    total_mean = float(np.mean(gx)) + 1e-9\n    right_gx = gx[:, w // 2 - 1:] if (w // 2 - 1) >= 0 else gx\n    right_mean = float(np.mean(right_gx))\n    return float(right_mean / total_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom third of the image (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        bottom = np.count_nonzero(ink[(2*h)//3 : , :])\n        return float(bottom) / float(total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical gradient energy concentrated in the central vertical third (distinguishes centered vertical strokes like 1)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        gy, gx = np.gradient(gray)\n        vert = np.abs(gy)\n        h, w = gray.shape\n        c0, c1 = w//3, 2*w//3\n        center_vert = np.sum(vert[:, c0:c1])\n        total = np.sum(vert) + 1e-8\n        return float(center_vert / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-bar strength: mean absolute horizontal gradient in the top quarter divided by overall mean horizontal gradient'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(np.float32))\n    abs_gx = np.abs(gx)\n    top_h = max(1, h // 4)\n    mean_top = float(np.mean(abs_gx[:top_h, :]))\n    mean_all = float(np.mean(abs_gx)) + 1e-9\n    return float(mean_top / mean_all)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength difference between left and right in the top third (detects whether the top bar is centered or biased)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 3)\n    Gx, Gy = np.gradient(gray)\n    horiz_edge = np.abs(Gx)  # horizontal edges respond to horizontal intensity changes\n    left_energy = np.sum(horiz_edge[0:top_h, :w//2])\n    right_energy = np.sum(horiz_edge[0:top_h, w//2:])\n    denom = left_energy + right_energy + 1e-8\n    return float(right_energy - left_energy) / float(denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal coverage fraction within the top third (max row ink count in top third divided by width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top = gray[: max(1, h // 3), :]\n    thresh = np.mean(gray)\n    dark_count = np.count_nonzero(gray < thresh)\n    bright_count = np.count_nonzero(gray > thresh)\n    ink_top = (top < thresh) if dark_count < bright_count else (top > thresh)\n    if ink_top.size == 0:\n        return 0.0\n    row_counts = np.sum(ink_top, axis=1)\n    max_row = float(np.max(row_counts)) if row_counts.size > 0 else 0.0\n    return float(max_row / w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient restricted to the right half (captures right-side curvature)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        # smooth-ish by simple local mean to reduce noise\n        # compute gradients\n        gx, gy = np.gradient(gray.astype(float))\n        right_gx = gx[:, w//2:]\n        right_gy = gy[:, w//2:]\n        mag_x = np.mean(np.abs(right_gx)) if right_gx.size > 0 else 0.0\n        mag_y = np.mean(np.abs(right_gy)) if right_gy.size > 0 else 0.0\n        if mag_y == 0:\n            return float(mag_x)\n        return float(mag_x) / float(mag_y)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center ring contrast: difference between average ring intensity and center disk intensity (positive if center is background hole)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    r = max(1, int(min(h, w) / 6.0))\n    yy, xx = np.ogrid[0:h, 0:w]\n    dist = np.sqrt((yy - cy)**2 + (xx - cx)**2)\n    center_mask = dist <= r\n    ring_mask = (dist > r) & (dist <= 2*r)\n    if np.sum(center_mask) == 0 or np.sum(ring_mask) == 0:\n        return 0.0\n    center_mean = float(np.mean(gray[center_mask]))\n    ring_mean = float(np.mean(gray[ring_mask]))\n    # use border to determine polarity: if border is lighter than mean then ink is dark; then hole means center is bright\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    # if border is light, background is large values; so a hole has center mean close to border_mean and ring mean is ink (low)\n    polarity = 1.0 if border_mean > np.mean(gray) else -1.0\n    contrast = polarity * (center_mean - ring_mean)\n    # normalize by global intensity range\n    denom = (np.max(gray) - np.min(gray)) + 1e-9\n    return float(contrast / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fractional size of the largest internal hole (background region not touching border) relative to image area'\n    import numpy as np\n    eps = 1e-9\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    below = np.count_nonzero(gray < thresh)\n    above = np.count_nonzero(gray > thresh)\n    if below <= above:\n        ink = (gray < thresh)\n    else:\n        ink = (gray > thresh)\n    bg = ~ink\n    visited = np.zeros_like(bg, dtype=bool)\n    max_hole = 0\n    # flood fill background components\n    for r in range(h):\n        for c in range(w):\n            if not bg[r, c] or visited[r, c]:\n                continue\n            # new component\n            stack = [(r, c)]\n            visited[r, c] = True\n            comp_size = 0\n            touches_border = False\n            while stack:\n                y, x = stack.pop()\n                comp_size += 1\n                if y == 0 or x == 0 or y == h-1 or x == w-1:\n                    touches_border = True\n                # explore 4-neighbors for speed\n                for ny, nx in ((y-1, x), (y+1, x), (y, x-1), (y, x+1)):\n                    if 0 <= ny < h and 0 <= nx < w and (not visited[ny, nx]) and bg[ny, nx]:\n                        visited[ny, nx] = True\n                        stack.append((ny, nx))\n            if not touches_border:\n                if comp_size > max_hole:\n                    max_hole = comp_size\n    return float(max_hole / (h * w + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) pixels in the right-middle region vs left-middle region (close to 1 => more empty on right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.5\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        fg = (gray < (med - delta)).astype(int)\n    else:\n        fg = (gray > (med + delta)).astype(int)\n    y0, y1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    mid_x0, mid_x1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    band = fg[y0:y1, mid_x0:mid_x1]\n    if band.size == 0:\n        return 0.5\n    mid = band.shape[1] // 2\n    left_band = band[:, :mid]\n    right_band = band[:, mid:]\n    left_bg = float((left_band == 0).sum())\n    right_bg = float((right_band == 0).sum())\n    total = left_bg + right_bg\n    if total == 0:\n        return 0.5\n    return float(right_bg / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of enclosed white regions (holes) inside the ink strokes'\n    import numpy as np\n    h, w = image.shape[:2]\n    # convert to grayscale float\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # simple adaptive threshold\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    # if too many pixels are classified as ink, invert assumption\n    if np.mean(ink) > 0.75:\n        ink = ~ink\n    # mark background pixels reachable from image border\n    visited = np.zeros((h, w), dtype=bool)\n    stack = []\n    # push border background pixels\n    for i in range(h):\n        for j in (0, w - 1):\n            if not ink[i, j] and not visited[i, j]:\n                visited[i, j] = True\n                stack.append((i, j))\n    for j in range(w):\n        for i in (0, h - 1):\n            if not ink[i, j] and not visited[i, j]:\n                visited[i, j] = True\n                stack.append((i, j))\n    while stack:\n        i, j = stack.pop()\n        for di in (-1, 0, 1):\n            ni = i + di\n            if ni < 0 or ni >= h:\n                continue\n            for dj in (-1, 0, 1):\n                nj = j + dj\n                if nj < 0 or nj >= w:\n                    continue\n                if not ink[ni, nj] and not visited[ni, nj]:\n                    visited[ni, nj] = True\n                    stack.append((ni, nj))\n    # holes are background pixels not reachable from border\n    holes = (~visited) & (~ink)\n    # count connected components among holes\n    visited_holes = np.zeros_like(holes, dtype=bool)\n    hole_count = 0\n    for i in range(h):\n        for j in range(w):\n            if holes[i, j] and not visited_holes[i, j]:\n                hole_count += 1\n                stack = [(i, j)]\n                visited_holes[i, j] = True\n                while stack:\n                    x, y = stack.pop()\n                    for di in (-1, 0, 1):\n                        nx = x + di\n                        if nx < 0 or nx >= h:\n                            continue\n                        for dj in (-1, 0, 1):\n                            ny = y + dj\n                            if ny < 0 or ny >= w:\n                                continue\n                            if holes[nx, ny] and not visited_holes[nx, ny]:\n                                visited_holes[nx, ny] = True\n                                stack.append((nx, ny))\n    return float(hole_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean projection of the local gradient onto the top-right-to-bottom-left diagonal (alignment score)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray)\n    # unit vector for TR->BL direction in (x,y) coordinates: (-1,1)/sqrt(2)\n    ux, uy = -1.0 / np.sqrt(2.0), 1.0 / np.sqrt(2.0)\n    proj = gx * ux + gy * uy\n    mag = np.hypot(gx, gy)\n    # normalized projection magnitude per pixel\n    norm_proj = np.abs(proj) / (mag + 1e-9)\n    # mask out very small gradients\n    mask = mag > (np.percentile(mag, 30) * 0.2 + 1e-9)\n    if mask.sum() == 0:\n        return 0.0\n    result = float(np.mean(norm_proj[mask]))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative top-left vs top-right horizontal edge strength: mean |horizontal gradient| in top-left divided by top-right'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    med = np.median(gray)\n    # compute gradients on gray\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    horiz = np.abs(gx)\n    midx = w // 2\n    top = slice(0, max(1, h // 4))  # top quarter\n    left_strength = np.mean(horiz[top, :midx]) if np.any(~np.isnan(horiz[top, :midx])) else 0.0\n    right_strength = np.mean(horiz[top, midx:w]) if np.any(~np.isnan(horiz[top, midx:w])) else 0.0\n    if right_strength < 1e-9:\n        return float(left_strength)\n    return float(left_strength / right_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength in the bottom quarter compared to full image (captures bottom bars)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    if arr.size == 0:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    horiz_edge = np.abs(gx)\n    bottom_start = max(0, (3*h)//4)\n    bottom = horiz_edge[bottom_start:, :]\n    bottom_mean = float(np.mean(bottom)) if bottom.size > 0 else 0.0\n    full_mean = float(np.mean(horiz_edge)) if horiz_edge.size > 0 else 1.0\n    return float(bottom_mean / (full_mean + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of horizontal-gradient sign changes down columns within the right quarter (captures alternating curvature)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    c0 = max(0, 3 * w // 4)\n    band = gray[:, c0:w]\n    if band.size == 0:\n        return 0.0\n    # horizontal gradient (difference along x)\n    hgrad = np.diff(band, axis=1)\n    # sign of gradient per row\n    s = np.sign(hgrad)\n    # count sign changes vertically per column position (ignore zeros by replacing with previous non-zero sign)\n    # propagate last non-zero sign downwards to avoid zero noise\n    s_proc = s.copy()\n    for col in range(s_proc.shape[1]):\n        last = 0\n        for row in range(s_proc.shape[0]):\n            if s_proc[row, col] == 0:\n                s_proc[row, col] = last\n            else:\n                last = s_proc[row, col]\n    sign_changes = np.sum(np.abs(np.diff(s_proc, axis=0)) > 0)\n    # normalize by possible maximum changes = (h-1)*(width of band)\n    denom = float(max(1, (h - 1) * s_proc.shape[1]))\n    return float(sign_changes / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized diagonal (45\u00b0) edge energy: diagonal magnitude / total edge energy (captures slanted strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    # diagonal projection (45\u00b0)\n    diag = (gx + gy) / np.sqrt(2.0)\n    diag_energy = np.sum(np.abs(diag))\n    total_energy = np.sum(np.abs(gx)) + np.sum(np.abs(gy))\n    return float(diag_energy / (total_energy + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Right-to-left ink density ratio (sum of ink on right half divided by left half, >1 means more ink on right)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    left_sum = float(np.count_nonzero(ink[:, :w//2]))\n    right_sum = float(np.count_nonzero(ink[:, w//2:]))\n    if left_sum + right_sum == 0:\n        return 1.0\n    ratio = right_sum / (left_sum + 1e-8)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a middle horizontal bar: mean absolute horizontal gradient in central band normalized by overall gradient'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3:\n        return 0.0\n    gx, gy = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    # central band - middle 20% of rows\n    start = max(0, h//2 - max(1, h//10))\n    end = min(h, h//2 + max(1, h//10))\n    band_mean = float(np.mean(abs_gx[start:end, :]))\n    total_mean = float(np.mean(abs_gx) + 1e-9)\n    return band_mean / total_mean\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of ink bounding box: height divided by width (robust to empty images)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(gray.min()), float(gray.max())\n    rng = mx - mn + eps\n    norm = (gray - mn) / rng\n    ink = norm < 0.5 if np.mean(norm) > 0.5 else norm > 0.5\n    ys, xs = np.where(ink)\n    if ys.size == 0:\n        return 0.0\n    h_bbox = ys.max() - ys.min() + 1\n    w_bbox = xs.max() - xs.min() + 1\n    return float((h_bbox + eps) / (w_bbox + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal run length of ink in the top 20% of rows, normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n    dark = gray < p40\n    light = gray > p60\n    dcount = np.count_nonzero(dark)\n    lcount = np.count_nonzero(light)\n    if dcount == 0 and lcount == 0:\n        thr = np.mean(gray)\n        dark = gray < thr\n        dcount = np.count_nonzero(dark)\n        if dcount == 0:\n            return 0.0\n    mask = dark if (0 < dcount <= max(lcount, 1)) else light\n    top_k = max(1, h // 5)\n    top_region = mask[:top_k, :]\n    max_run = 0\n    for r in range(top_region.shape[0]):\n        row = top_region[r, :].astype(int)\n        if row.sum() == 0:\n            continue\n        # compute runs by difference trick\n        padded = np.concatenate([[0], row, [0]])\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, runs.max())\n    return float(max_run / max(1, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-region mean intensity minus global mean (positive when center is lighter -> possible loop/hole)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    global_mean = float(np.mean(gray))\n    ch0, cw0 = max(1, h // 6), max(1, w // 6)\n    cy0, cx0 = h // 2 - ch0, w // 2 - cw0\n    cy1, cx1 = h // 2 + ch0 + 1, w // 2 + cw0 + 1\n    cy0, cx0 = max(0, cy0), max(0, cx0)\n    cy1, cx1 = min(h, cy1), min(w, cx1)\n    center = gray[cy0:cy1, cx0:cx1]\n    if center.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    return float(center_mean - global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink width at mid-height to ink width in upper third (helps detect tails that narrow midline)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mu, s = np.mean(gray), np.std(gray)\n    thr = mu + 0.2*s\n    fg = (gray > thr) if np.count_nonzero(gray > thr) < np.count_nonzero(gray < thr) else (gray < (mu - 0.2*s))\n    fg = fg if np.count_nonzero(fg) > 0 else (gray < np.percentile(gray,50))\n    def row_width(row):\n        cols = np.where(fg[row,:])[0]\n        if cols.size == 0:\n            return 0\n        return cols.max() - cols.min() + 1\n    mid = h // 2\n    up = max(0, h // 4)\n    mid_w = row_width(mid)\n    up_w = row_width(up)\n    if up_w == 0:\n        return float(mid_w)\n    return float(mid_w / (up_w + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels contained in the largest connected component (1.0 if only one component or all ink in one piece)'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    h, w = gray.shape\n    m = _np.mean(gray)\n    ink = (gray < m).astype(_np.uint8)\n    total = int(ink.sum())\n    if total == 0:\n        return 0.0\n    visited = _np.zeros_like(ink, dtype=_np.uint8)\n    max_size = 0\n    for y in range(h):\n        for x in range(w):\n            if ink[y, x] and not visited[y, x]:\n                size = 0\n                stack = [(y, x)]\n                visited[y, x] = 1\n                while stack:\n                    cy, cx = stack.pop()\n                    size += 1\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = cy + dy, cx + dx\n                            if 0 <= ny < h and 0 <= nx < w:\n                                if ink[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = 1\n                                    stack.append((ny, nx))\n                if size > max_size:\n                    max_size = size\n    frac = float(max_size / float(total))\n    return frac\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of total edge energy located in a small circular region near the lower-right (detects 9 lower loop)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    total = float(np.sum(grad)) + 1e-9\n    # circle centered toward lower-right\n    cy, cx = int(3 * h / 4), int(3 * w / 4)\n    r = max(1, min(h, w) // 8)\n    yy, xx = np.ogrid[:h, :w]\n    mask = (yy - cy) ** 2 + (xx - cx) ** 2 <= r * r\n    region_sum = float(np.sum(grad[mask]))\n    return float(region_sum) / total\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of total ink pixels that lie in the central horizontal band (40%-60% height) to detect a mid crossbar'\n    import numpy as np\n    # grayscale conversion and normalization\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    h, w = gray.shape[:2]\n    # binarize assuming darker ink\n    thresh = 0.5\n    ink = gray < thresh\n    if np.count_nonzero(ink) == 0:\n        ink = gray > thresh\n    total_ink = float(np.count_nonzero(ink))\n    if total_ink == 0.0:\n        return 0.0\n    top = int(0.40 * h)\n    bottom = int(0.60 * h)\n    central_band = ink[top:bottom, :]\n    return float(np.count_nonzero(central_band) / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal stroke energy: ratio of main-diagonal difference energy to anti-diagonal (helps detect diagonally-slanted strokes like in 4 or 7)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    L = max(1, min(h, w))\n    # sample main diagonal and anti-diagonal\n    idx = np.arange(L)\n    main_diag = gray[idx, idx]\n    anti_diag = gray[idx, w - 1 - idx]\n    e_main = np.sum(np.abs(np.diff(main_diag)))\n    e_anti = np.sum(np.abs(np.diff(anti_diag)))\n    # return normalized ratio (main over anti) with eps\n    eps = 1e-6\n    return float((e_main + eps) / (e_anti + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) pixels in the right-middle region vs left-middle region (close to 1 => more empty on right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.5\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        fg = (gray < (med - delta)).astype(int)\n    else:\n        fg = (gray > (med + delta)).astype(int)\n    y0, y1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    mid_x0, mid_x1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    band = fg[y0:y1, mid_x0:mid_x1]\n    if band.size == 0:\n        return 0.5\n    mid = band.shape[1] // 2\n    left_band = band[:, :mid]\n    right_band = band[:, mid:]\n    left_bg = float((left_band == 0).sum())\n    right_bg = float((right_band == 0).sum())\n    total = left_bg + right_bg\n    if total == 0:\n        return 0.5\n    return float(right_bg / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry score: average absolute column difference between left and flipped right'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    # compare left half to flipped right half\n    mid = w // 2\n    left = norm[:, :mid]\n    right = norm[:, w - mid:]\n    right_flipped = right[:, ::-1]\n    # resize if they mismatch due to odd width\n    if left.shape[1] != right_flipped.shape[1]:\n        minc = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minc]\n        right_flipped = right_flipped[:, :minc]\n    score = np.mean(np.abs(left - right_flipped))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal edges in the upper third: mean horizontal gradient in top band divided by global gradient'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    # horizontal gradient (differences along columns)\n    hg = np.abs(np.diff(gray, axis=1))\n    # average in upper third\n    top_rows = max(1, h // 3)\n    top_hg = hg[:top_rows, :]\n    mean_top = top_hg.mean() if top_hg.size else 0.0\n    mean_all = hg.mean() if hg.size else 0.0\n    denom = mean_all + 1e-8\n    return float(mean_top / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous vertical ink run in the right third of the image, normalized by image height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 50)\n    ink_dark = np.mean(gray.flatten()[:max(1, int(0.05*h*w))]) < np.mean(gray.flatten()[-max(1, int(0.05*h*w)):])\n    if ink_dark:\n        ink = gray < thresh\n    else:\n        ink = gray > thresh\n    start_col = max(0, 2*w // 3)\n    region = ink[:, start_col:w]\n    # compute longest vertical run per column, take max\n    longest = 0\n    for c in range(region.shape[1]):\n        col = region[:, c]\n        cur = 0\n        maxc = 0\n        for v in col:\n            if v:\n                cur += 1\n                if cur > maxc: maxc = cur\n            else:\n                cur = 0\n        if maxc > longest: longest = maxc\n    return float(longest / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ink perimeter (boundary pixels) divided by ink area (higher -> finer/thinner or more complex contours)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(np.uint8)\n    # boundary pixels: ink pixel with at least one 4-neighbor background\n    neighbor_sum = np.zeros_like(ink, dtype=np.int32)\n    neighbor_sum[1:, :] += ink[:-1, :]\n    neighbor_sum[:-1, :] += ink[1:, :]\n    neighbor_sum[:, 1:] += ink[:, :-1]\n    neighbor_sum[:, :-1] += ink[:, 1:]\n    boundary = (ink == 1) & (neighbor_sum < 4)\n    perimeter = float(np.sum(boundary))\n    area = float(np.sum(ink))\n    if area <= 0.0:\n        return 0.0\n    return float(perimeter / area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal position of the rightmost ink pixel (0.0 left .. 1.0 right)'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    bin_img = (gray < thr).astype(np.uint8)\n    # If more than half are foreground, invert to make ink the minority\n    if bin_img.sum() > (h * w) / 2:\n        bin_img = 1 - bin_img\n    ys, xs = np.where(bin_img)\n    if xs.size == 0:\n        return 0.0\n    rightmost = float(xs.max()) / float(max(w - 1, 1))\n    return float(rightmost)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient in upper half to that in lower half (indicates horizontal stroke concentration up/down)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    h = gray.shape[0]\n    upper = abs_gx[:h//2, :]\n    lower = abs_gx[h//2:, :]\n    mu_upper = float(np.mean(upper)) if upper.size else 0.0\n    mu_lower = float(np.mean(lower)) if lower.size else 0.0\n    if mu_lower == 0.0:\n        return float(mu_upper)\n    return float(mu_upper / mu_lower)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative energy of main-diagonal (\\\\) gradients vs anti-diagonal (/) gradients (captures slanted strokes direction)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    # compute diagonal differences\n    if min(gray.shape) < 2:\n        return 0.0\n    dl = gray[:-1, :-1] - gray[1:, 1:]\n    dr = gray[:-1, 1:] - gray[1:, :-1]\n    edl = np.mean(np.abs(dl))\n    edr = np.mean(np.abs(dr))\n    denom = (edl + edr + 1e-9)\n    return float((edl - edr) / denom)  # range roughly [-1,1]\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of transitions (background<->ink) along the central horizontal row; open shapes produce different counts than closed loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    center_row = h // 2\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink_row = (gray[center_row, :] < thr).astype(int)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink_row = (gray[center_row, :] > thr).astype(int)\n    if w <= 1:\n        return 0.0\n    transitions = int(np.sum(np.abs(np.diff(ink_row))))\n    # transitions is the number of boundaries; return transitions/2 as number of segments, but keep raw as float\n    return float(transitions)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of gradient (edge) energy in lower half to upper half (captures lower loops vs top strokes)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    top = grad[:h//2, :]\n    bot = grad[h//2:, :]\n    top_sum = float(np.sum(top))\n    bot_sum = float(np.sum(bot))\n    return float(bot_sum) / (top_sum + 1e-9)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous horizontal ink run in the middle band (40%-60% height) normalized by image width (detects crossbar typical of 4)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    h, w = arr.shape[:2]\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    thresh = (p10 + p90) / 2.0\n    ink = (gray < thresh) if p90 > p10 else (gray > thresh)\n    top = max(0, int(h * 0.4))\n    bottom = min(h, int(h * 0.6))\n    region = ink[top:bottom, :]\n    max_run = 0\n    for row in region:\n        if row.size == 0:\n            continue\n        r = np.concatenate(([0], row.astype(int), [0]))\n        dif = np.diff(r)\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size:\n            runs = ends - starts\n            max_run = max(max_run, int(runs.max()))\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in mean absolute vertical gradient between right and left thirds, normalized by total gradient energy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        return 0.0\n    left_end = w // 3\n    right_start = 2 * w // 3\n    left_energy = np.abs(gy[:, :left_end]).mean() if left_end > 0 else 0.0\n    right_energy = np.abs(gy[:, right_start:]).mean() if right_start < w else 0.0\n    total = (np.abs(gx).mean() + np.abs(gy).mean()) + 1e-9\n    return float((right_energy - left_energy) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute diagonal (top-right to bottom-left) gradient energy inside the top-right quadrant'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    # quadrant bounds (top-right)\n    r0, r1 = 0, max(1, h // 2)\n    c0, c1 = max(0, w // 2), w\n    sub = gray[r0:r1, c0:c1]\n    if sub.size == 0:\n        return 0.0\n    gy, gx = np.gradient(sub)\n    # projection onto diagonal vector (1,-1) normalized\n    proj = (gx - gy) / np.sqrt(2.0)\n    return float(np.mean(np.abs(proj)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative area of the largest inner hole to the bounding box area (useful: 9 often has one large loop, 8 has two moderate loops)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 0.0\n        y0, y1 = ys.min(), ys.max()\n        x0, x1 = xs.min(), xs.max()\n        sub = ~fg[y0:y1+1, x0:x1+1]\n        H, W = sub.shape\n        if H <= 0 or W <= 0:\n            return 0.0\n        visited = np.zeros_like(sub, dtype=np.bool_)\n        from collections import deque\n        q = deque()\n        for i in range(H):\n            for j in (0, W-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        for j in range(W):\n            for i in (0, H-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        while q:\n            y, x = q.popleft()\n            for dy in (-1, 0, 1):\n                for dx in (-1, 0, 1):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n        # find hole components and record largest\n        largest = 0\n        for i in range(H):\n            for j in range(W):\n                if sub[i, j] and not visited[i, j]:\n                    # new hole\n                    size = 0\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        size += 1\n                        for dy in (-1, 0, 1):\n                            for dx in (-1, 0, 1):\n                                ny, nx = y+dy, x+dx\n                                if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n                    if size > largest:\n                        largest = size\n        bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1)) + 1e-8\n        return float(largest / bbox_area)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of holes whose centroids fall in the upper half of the image (normalized by image height)'\n    import numpy as np\n    from collections import deque\n    eps = 1e-6\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    th = float(np.mean(gray))\n    cand = gray < th\n    ink = cand.astype(bool) if np.count_nonzero(cand) <= (h * w) / 2 else (gray >= th).astype(bool)\n    background = ~ink\n    visited = np.zeros_like(background, dtype=bool)\n    q = deque()\n    for r in range(h):\n        for c in (0, w - 1):\n            if background[r, c] and not visited[r, c]:\n                visited[r, c] = True\n                q.append((r, c))\n    for c in range(w):\n        for r in (0, h - 1):\n            if background[r, c] and not visited[r, c]:\n                visited[r, c] = True\n                q.append((r, c))\n    while q:\n        r, c = q.popleft()\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            rr, cc = r + dr, c + dc\n            if 0 <= rr < h and 0 <= cc < w and background[rr, cc] and not visited[rr, cc]:\n                visited[rr, cc] = True\n                q.append((rr, cc))\n    holes_mask = background & ~visited\n    visited_hole = np.zeros_like(holes_mask, dtype=bool)\n    upper_holes = 0\n    for r in range(h):\n        for c in range(w):\n            if holes_mask[r, c] and not visited_hole[r, c]:\n                dq = deque()\n                dq.append((r, c))\n                visited_hole[r, c] = True\n                sum_r = 0\n                cnt = 0\n                while dq:\n                    rr, cc = dq.popleft()\n                    sum_r += rr\n                    cnt += 1\n                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n                        r2, c2 = rr + dr, cc + dc\n                        if 0 <= r2 < h and 0 <= c2 < w and holes_mask[r2, c2] and not visited_hole[r2, c2]:\n                            visited_hole[r2, c2] = True\n                            dq.append((r2, c2))\n                if cnt > 0:\n                    centroid_r = sum_r / float(cnt)\n                    if centroid_r < h / 2.0:\n                        upper_holes += 1\n    return float(upper_holes / (1.0 + 0.0))  # return raw count as float\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink counts in upper-left and upper-right quadrants ((UL-UR)/(UL+UR+eps))'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    mid_r = h // 2\n    mid_c = w // 2\n    ul = np.count_nonzero(fg[0:mid_r, 0:mid_c])\n    ur = np.count_nonzero(fg[0:mid_r, mid_c:w])\n    return float((ul - ur) / (ul + ur + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of separate vertical ink runs in the right third (counts separated vertical components along right side)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    col_start = (2*w)//3\n    region = gray[:, col_start:w]\n    if region.size == 0:\n        return 0.0\n    thresh = float(np.mean(region))\n    low = int(np.count_nonzero(region < thresh))\n    high = int(np.count_nonzero(region > thresh))\n    if low < high:\n        ink = (region < thresh).astype(np.uint8)\n    else:\n        ink = (region > thresh).astype(np.uint8)\n    # collapse to a single column by OR-ing columns to find vertical runs\n    collapsed = np.any(ink, axis=1).astype(np.uint8)\n    runs = 0\n    prev = 0\n    for val in collapsed:\n        if val and not prev:\n            runs += 1\n        prev = val\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized topmost ink row: fraction of image height to the first row containing ink (0=top,1=bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    thresh = (np.mean(border) + np.mean(gray)) / 2.0\n    ink = (gray < thresh) if (np.mean(border) > np.mean(gray)) else (gray > thresh)\n    rows = np.any(ink, axis=1)\n    if not np.any(rows):\n        return 1.0\n    first = int(np.argmax(rows))\n    return float(first / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom third of the image (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        bottom = np.count_nonzero(ink[(2*h)//3 : , :])\n        return float(bottom) / float(total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of radial variance of ink pixels in the lower half to the upper half with respect to the ink centroid'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mx = float(np.max(gray)) if np.max(gray) != 0 else 1.0\n    gray = gray / mx\n    thresh = np.mean(gray)\n    ink_mask = (gray < thresh).astype(np.uint8)\n    coords = np.argwhere(ink_mask)\n    if coords.shape[0] == 0:\n        return 0.0\n    ys = coords[:, 0].astype(float)\n    xs = coords[:, 1].astype(float)\n    centroid_y = ys.mean()\n    centroid_x = xs.mean()\n    # distances for lower and upper ink pixels\n    lower_idx = ys >= centroid_y\n    upper_idx = ys < centroid_y\n    if lower_idx.sum() == 0 or upper_idx.sum() == 0:\n        return 0.0\n    lower_d2 = ((ys[lower_idx] - centroid_y) ** 2 + (xs[lower_idx] - centroid_x) ** 2)\n    upper_d2 = ((ys[upper_idx] - centroid_y) ** 2 + (xs[upper_idx] - centroid_x) ** 2)\n    lower_var = lower_d2.var() if lower_d2.size > 1 else 0.0\n    upper_var = upper_d2.var() if upper_d2.size > 1 else 0.0\n    return float(lower_var / (upper_var + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground density in top half versus bottom half (top_density / (bottom_density + eps))'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = gray_n < thr if np.mean(gray_n) > 0.5 else gray_n > thr\n    top = fg[:h // 2, :]\n    bottom = fg[h // 2:, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    eps = 1e-6\n    return float(top_count / (bottom_count + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal gradient energy in the top third (indicates strong top horizontal stroke)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gx = np.abs(np.gradient(gray, axis=1))\n    total_energy = gx.sum() + 1e-9\n    top_energy = gx[0:max(1,h//3), :].sum()\n    return float(top_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bias of ink between upper-right and lower-left quadrants normalized by ink area (positive -> more upper-right ink)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv, maxv = float(np.min(gray)), float(np.max(gray))\n    scaled = (gray - minv) / (maxv - minv + 1e-8)\n    t = float(np.mean(scaled))\n    dark = scaled <= t\n    bright = scaled >= t\n    fore = dark if dark.sum() <= bright.sum() else bright\n    if fore.sum() == 0:\n        return 0.0\n    r_mid = h // 2\n    c_mid = w // 2\n    upper_right = fore[:r_mid, c_mid:].sum()\n    lower_left = fore[r_mid:, :c_mid].sum()\n    return float((upper_right - lower_left) / (fore.sum() + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical separation between two largest enclosed hole centroids normalized by image height (0 if fewer than 2 holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # exterior fill\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal = (~ink) & (~exterior)\n    visited = np.zeros_like(internal, dtype=bool)\n    centroids = []\n    for i in range(h):\n        for j in range(w):\n            if internal[i, j] and not visited[i, j]:\n                # BFS\n                q = deque()\n                q.append((i, j))\n                visited[i, j] = True\n                pts = [(i, j)]\n                while q:\n                    ci, cj = q.popleft()\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and internal[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            pts.append((ni, nj))\n                            q.append((ni, nj))\n                pts = np.array(pts)\n                centroids.append((float(np.mean(pts[:,0])), float(np.mean(pts[:,1])), pts.shape[0]))\n    if len(centroids) < 2:\n        return 0.0\n    # sort by area desc and take two largest\n    centroids.sort(key=lambda x: x[2], reverse=True)\n    y1 = centroids[0][0]\n    y2 = centroids[1][0]\n    return float(abs(y1 - y2) / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative dominance of 45-degree diagonal gradient energy (sum|dx+dy| / (sum|dx+dy|+sum|dx-dy|))'\n    import numpy as np\n    eps = 1e-9\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    diag1 = np.abs(gx + gy)\n    diag2 = np.abs(gx - gy)\n    s1 = np.sum(diag1)\n    s2 = np.sum(diag2)\n    return float(s1 / (s1 + s2 + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized x-coordinate of the ink centroid relative to image center (centroid_x - 0.5)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.float64)\n    total = ink.sum()\n    if total <= 1e-9:\n        return 0.0\n    cols = np.arange(w)\n    cx = (ink.sum(axis=0) * cols).sum() / (total + 1e-9)\n    # normalized relative to center: range approx [-0.5,0.5]\n    return float((cx / max(1, w - 1)) - 0.5)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference of vertical gradient energy between left third and right third ((L-R)/(L+R))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    venergy = np.abs(gy)\n    left = venergy[:, :max(1, w // 3)].sum()\n    right = venergy[:, max(1, 2 * w // 3):].sum()\n    return float((left - right) / (left + right + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal centroid difference between top third and bottom third normalized by width (detects twisting)'\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    g = (gray - mn) / (mx - mn)\n    mask = (g < 0.5 if np.sum(g < 0.5) <= np.sum(g > 0.5) else g > 0.5).astype(np.uint8)\n    h, w = mask.shape\n    if h < 3 or w == 0:\n        return 0.0\n    t_end = max(1, h // 3)\n    b_start = h - t_end\n    top = mask[:t_end, :]\n    bot = mask[b_start:, :]\n    def centroid_x(m):\n        ink = np.sum(m)\n        if ink == 0:\n            return w / 2.0\n        xs = np.arange(w).reshape((1, w))\n        return float(np.sum(xs * m)) / float(ink)\n    cx_top = centroid_x(top)\n    cx_bot = centroid_x(bot)\n    return float(abs(cx_top - cx_bot)) / float(max(1, w-1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Length of longest horizontal stroke in the middle third (useful to detect the cross-bar of a \"4\"), normalized by width'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    thr = np.percentile(gray, 50.0)\n    ink = (gray < thr).astype(np.uint8)\n    if np.sum(ink) == 0:\n        ink = (gray > thr).astype(np.uint8)\n        if np.sum(ink) == 0:\n            return 0.0\n    r0 = h // 3\n    r1 = max(r0 + 1, (2 * h) // 3)\n    middle = ink[r0:r1, :]\n    max_run = 0\n    for row in middle:\n        padded = np.concatenate(([0], row, [0]))\n        changes = np.diff(padded)\n        starts = np.nonzero(changes == 1)[0]\n        ends = np.nonzero(changes == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(int(np.max(runs)), max_run)\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center ring contrast: difference between average ring intensity and center disk intensity (positive if center is background hole)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    r = max(1, int(min(h, w) / 6.0))\n    yy, xx = np.ogrid[0:h, 0:w]\n    dist = np.sqrt((yy - cy)**2 + (xx - cx)**2)\n    center_mask = dist <= r\n    ring_mask = (dist > r) & (dist <= 2*r)\n    if np.sum(center_mask) == 0 or np.sum(ring_mask) == 0:\n        return 0.0\n    center_mean = float(np.mean(gray[center_mask]))\n    ring_mean = float(np.mean(gray[ring_mask]))\n    # use border to determine polarity: if border is lighter than mean then ink is dark; then hole means center is bright\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    # if border is light, background is large values; so a hole has center mean close to border_mean and ring mean is ink (low)\n    polarity = 1.0 if border_mean > np.mean(gray) else -1.0\n    contrast = polarity * (center_mean - ring_mean)\n    # normalize by global intensity range\n    denom = (np.max(gray) - np.min(gray)) + 1e-9\n    return float(contrast / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left vs right ink balance: normalized difference in ink pixel counts'\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # adaptive binarization: determine if ink is darker\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    left = float(np.count_nonzero(fg[:, :w//2]))\n    right = float(np.count_nonzero(fg[:, w//2:]))\n    denom = left + right + 1e-6\n    return float((left - right) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of enclosed holes in the ink (counts connected background components that do not touch the image border)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-8)\n    bw = max(1, min(h, w) // 10)\n    border = np.concatenate([g[:bw, :].ravel(), g[-bw:, :].ravel(), g[:, :bw].ravel(), g[:, -bw:].ravel()])\n    thresh = (float(np.mean(border)) + float(np.mean(g))) / 2.0 if border.size else 0.5\n    ink = g < thresh if np.mean(border) > np.mean(g) else g > thresh\n    bg = ~ink\n    visited = np.zeros_like(bg, dtype=bool)\n    holes = 0\n    # BFS to find connected components in bg\n    for r in range(h):\n        for c in range(w):\n            if not bg[r, c] or visited[r, c]:\n                continue\n            # new component\n            stack = [(r, c)]\n            visited[r, c] = True\n            touches_border = (r == 0 or c == 0 or r == h - 1 or c == w - 1)\n            while stack:\n                rr, cc = stack.pop()\n                for dr in (-1, 0, 1):\n                    for dc in (-1, 0, 1):\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = rr + dr, cc + dc\n                        if nr < 0 or nc < 0 or nr >= h or nc >= w:\n                            continue\n                        if not bg[nr, nc] or visited[nr, nc]:\n                            continue\n                        visited[nr, nc] = True\n                        if nr == 0 or nc == 0 or nr == h - 1 or nc == w - 1:\n                            touches_border = True\n                        stack.append((nr, nc))\n            if not touches_border:\n                holes += 1\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate Euler number: number of ink connected components minus number of holes (helps detect closed 9 loop)'\n    import numpy as np\n    # grayscale and normalization\n    if len(image.shape) == 3:\n        g = image.mean(axis=2).astype(np.float32)\n    else:\n        g = image.astype(np.float32)\n    mx = g.max() if g.size else 1.0\n    if mx > 1.0:\n        g = g / mx\n    med = np.median(g) if g.size else 0.0\n    ink = (g < 0.5) if med > 0.5 else (g > 0.5)\n    h, w = ink.shape\n    # simple 4-connected flood fill for ink components\n    seen = np.zeros_like(ink, dtype=bool)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if ink[y, x] and not seen[y, x]:\n                comps += 1\n                # stack flood\n                stack = [(y, x)]\n                seen[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = cy+dy, cx+dx\n                        if 0 <= ny < h and 0 <= nx < w and ink[ny, nx] and not seen[ny, nx]:\n                            seen[ny, nx] = True\n                            stack.append((ny, nx))\n    # count background components that are holes (background components not touching border)\n    bg = ~ink\n    seen_bg = np.zeros_like(bg, dtype=bool)\n    holes = 0\n    for y in range(h):\n        for x in range(w):\n            if bg[y, x] and not seen_bg[y, x]:\n                stack = [(y, x)]\n                seen_bg[y, x] = True\n                touches_border = False\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy == 0 or cy == h-1 or cx == 0 or cx == w-1:\n                        touches_border = True\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = cy+dy, cx+dx\n                        if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not seen_bg[ny, nx]:\n                            seen_bg[ny, nx] = True\n                            stack.append((ny, nx))\n                if not touches_border:\n                    holes += 1\n    euler = comps - holes\n    return float(euler)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in number of holes in the upper half vs lower half (upper - lower)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.mean(ink) > 0.75:\n        ink = ~ink\n    # compute reachable background from borders\n    visited = np.zeros((h, w), dtype=bool)\n    stack = []\n    for i in range(h):\n        for j in (0, w - 1):\n            if not ink[i, j] and not visited[i, j]:\n                visited[i, j] = True\n                stack.append((i, j))\n    for j in range(w):\n        for i in (0, h - 1):\n            if not ink[i, j] and not visited[i, j]:\n                visited[i, j] = True\n                stack.append((i, j))\n    while stack:\n        i, j = stack.pop()\n        for di in (-1, 0, 1):\n            ni = i + di\n            if ni < 0 or ni >= h:\n                continue\n            for dj in (-1, 0, 1):\n                nj = j + dj\n                if nj < 0 or nj >= w:\n                    continue\n                if not ink[ni, nj] and not visited[ni, nj]:\n                    visited[ni, nj] = True\n                    stack.append((ni, nj))\n    holes = (~visited) & (~ink)\n    # count hole components separately in upper and lower halves\n    visited_holes = np.zeros_like(holes, dtype=bool)\n    upper_count = 0\n    lower_count = 0\n    for i in range(h):\n        for j in range(w):\n            if holes[i, j] and not visited_holes[i, j]:\n                # flood fill this hole component\n                comp_stack = [(i, j)]\n                visited_holes[i, j] = True\n                ys = [i]\n                while comp_stack:\n                    x, y = comp_stack.pop()\n                    for di in (-1, 0, 1):\n                        nx = x + di\n                        if nx < 0 or nx >= h:\n                            continue\n                        for dj in (-1, 0, 1):\n                            ny = y + dj\n                            if ny < 0 or ny >= w:\n                                continue\n                            if holes[nx, ny] and not visited_holes[nx, ny]:\n                                visited_holes[nx, ny] = True\n                                comp_stack.append((nx, ny))\n                                ys.append(nx)\n                # assign component to half by majority of pixels' rows\n                mean_row = np.mean(ys)\n                if mean_row < h / 2.0:\n                    upper_count += 1\n                else:\n                    lower_count += 1\n    return float(upper_count - lower_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Elongation ratio from PCA (largest eigenvalue / smallest eigenvalue) of foreground coordinates; high for thin digits like \"1\"'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    coords = np.argwhere(ink).astype(float)\n    if coords.shape[0] < 3:\n        return 0.0\n    # compute covariance of (x,y) where we use columns as x, rows as y\n    ys = coords[:, 0]\n    xs = coords[:, 1]\n    X = np.column_stack((xs - np.mean(xs), ys - np.mean(ys)))\n    cov = np.cov(X, rowvar=False)\n    # ensure 2x2\n    if cov.shape != (2,2):\n        return 0.0\n    eig = np.linalg.eigvals(cov)\n    eig = np.real(eig)\n    eig = np.sort(eig)\n    eps = 1e-9\n    ratio = (float(eig[-1]) + eps) / (float(eig[0]) + eps)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal offset of the largest hole centroid from image center (0..0.5 normalized)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        best_area = 0\n        best_cx = None\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumx = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumx += x\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > best_area:\n                        best_area = area\n                        best_cx = (sumx / area)\n        if best_cx is None:\n            return 0.0\n        center = (w - 1) / 2.0\n        return float(abs(best_cx - center) / max(1.0, w))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected ink components (after simple threshold) as a float'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) - 0.25 * np.std(gray)\n    mask = (gray < thr).astype(np.uint8)\n    if mask.sum() == 0:\n        return 0.0\n    visited = np.zeros_like(mask, dtype=bool)\n    comp_count = 0\n    # stack-based flood fill\n    for i in range(h):\n        for j in range(w):\n            if mask[i, j] and not visited[i, j]:\n                comp_count += 1\n                stack = [(i, j)]\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if 0 <= ny < h and 0 <= nx < w and not visited[ny, nx] and mask[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n    return float(comp_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center of mass of ink normalized to [0,1] (0 top, 1 bottom): 5 tends to have lower center than 0/8'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.5\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(float)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(float)\n    ink_sum = np.sum(ink)\n    if ink_sum <= 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    com_y = float(np.sum(rows * np.sum(ink, axis=1).reshape(h, 1)) / np.sum(ink))\n    # normalize to 0..1\n    return float(com_y / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-left quadrant to bottom-right quadrant (high for strokes in TL, low for BR-heavy shapes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    mid_r, mid_c = h // 2, w // 2\n    tl = ink[0:mid_r, 0:mid_c]\n    br = ink[mid_r:h, mid_c:w]\n    tl_count = float(np.count_nonzero(tl))\n    br_count = float(np.count_nonzero(br))\n    # return ratio TL / (BR + 1) to avoid division by zero; scaled to reasonable magnitude\n    return float(tl_count / (br_count + 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of area of the second-largest hole to the largest hole (0 if fewer than 2 holes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    t = np.mean(gray)\n    mask1 = gray < t\n    mask2 = gray > t\n    ink = mask1 if np.count_nonzero(mask1) <= np.count_nonzero(mask2) else mask2\n    if np.count_nonzero(ink) == 0:\n        thr = np.percentile(gray, 40)\n        ink = gray < thr\n    visited = np.zeros((h, w), dtype=bool)\n    hole_areas = []\n    for r in range(h):\n        for c in range(w):\n            if visited[r, c] or ink[r, c]:\n                visited[r, c] = visited[r, c] or ink[r, c]\n                continue\n            stack = [(r, c)]\n            visited[r, c] = True\n            touches_border = False\n            area = 0\n            while stack:\n                y, x = stack.pop()\n                area += 1\n                if y == 0 or y == h-1 or x == 0 or x == w-1:\n                    touches_border = True\n                for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < h and 0 <= nx < w and (not visited[ny, nx]) and (not ink[ny, nx]):\n                        visited[ny, nx] = True\n                        stack.append((ny, nx))\n            if not touches_border:\n                hole_areas.append(area)\n    if len(hole_areas) < 2:\n        return 0.0\n    hole_areas.sort(reverse=True)\n    largest, second = hole_areas[0], hole_areas[1]\n    return float(second / largest) if largest > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in ink fraction between the upper-right and upper-left quadrants (UR - UL) normalized by total ink'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thresh = (float(np.min(gray)) + float(np.max(gray))) / 2.0\n    ink = (gray < thresh)\n    mid_h = h // 2\n    mid_w = w // 2\n    UR = np.sum(ink[:mid_h, mid_w:])\n    UL = np.sum(ink[:mid_h, :mid_w])\n    total = np.sum(ink)\n    if total == 0:\n        return 0.0\n    return float((UR - UL) / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns in the center region (middle 50% rows, center 50% cols) that are open (background) at the top 15% of that center region'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy().astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    thresh = (np.min(gray) + np.max(gray)) / 2.0\n    ink = gray < thresh\n    # define center box\n    r0, r1 = h//4, 3*h//4\n    c0, c1 = w//4, 3*w//4\n    center = ink[r0:r1, c0:c1]\n    ch, cw = center.shape\n    if ch == 0 or cw == 0:\n        return 0.0\n    top_rows = max(1, int(np.ceil(0.15 * ch)))\n    top_region = center[:top_rows, :]\n    # for each column check if many pixels are background (open)\n    col_open_fraction = np.mean(~top_region, axis=0)  # fraction of background per column\n    return float(np.mean(col_open_fraction))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical position (0..1) of hole centroids; 0 if no hole (0=top,1=bottom)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        centroids = []\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumy = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumy += y\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > 0:\n                        centroids.append((sumy / area))\n        if len(centroids) == 0:\n            return 0.0\n        avg_y = float(np.mean(centroids))\n        return float(avg_y / max(1.0, h))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the bottom-left quadrant (helps detect heavy lower-left strokes)'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Robust binarization: prefer darker-than-median as ink, but adapt if inverted\n    thr = float(np.percentile(gray, 50))\n    mask_dark = gray < thr\n    ink_ratio = float(mask_dark.mean())\n    if ink_ratio > 0.6 or ink_ratio < 0.01:\n        # try alternate threshold near mean\n        thr2 = float(np.mean(gray))\n        mask_dark = gray < thr2\n        ink_ratio = float(mask_dark.mean())\n    mask = mask_dark if ink_ratio <= 0.6 else (~mask_dark)\n    mask = mask.astype(bool)\n    if mask.sum() == 0:\n        return 0.0\n    bl = mask[h//2:, :w//2]\n    return float(bl.sum() / (mask.sum() + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Angle of principal component of ink pixels relative to vertical (0..1 where 1 ~= 90 degrees)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    rng = np.max(gray) - np.min(gray)\n    thr = np.mean(gray) - 0.15 * (rng if rng > 0 else 1.0)\n    ink = gray < thr\n    if np.count_nonzero(ink) < 4:\n        ink = gray > thr\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    # center coords\n    pts = coords.astype(float)\n    pts -= pts.mean(axis=0)\n    cov = np.cov(pts, rowvar=False)\n    # eigen decomposition (2x2)\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n    except Exception:\n        return 0.0\n    # principal eigenvector corresponds to largest eigenvalue\n    idx = np.argmax(vals)\n    vx, vy = vecs[:, idx]\n    # vector points in (row, col) coordinates; angle relative to vertical axis:\n    # vertical axis is (1,0) in row,col space. Compute angle between (vx,vy) and vertical.\n    dot = vx * 1.0 + vy * 0.0\n    mag = max(1e-9, np.hypot(vx, vy))\n    cos_theta = np.clip(dot / mag, -1.0, 1.0)\n    angle_rad = np.arccos(cos_theta)  # 0 = aligned with vertical, pi/2 = horizontal\n    angle_deg = angle_rad * (180.0 / np.pi)\n    return float(angle_deg / 90.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom horizontal gradient strength: mean absolute horizontal gradient in bottom strip (detect bottom bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    gy, gx = np.gradient(gray.astype(np.float64))\n    horiz_abs = np.abs(gx)\n    bottom_h = max(1, h // 5)\n    region = horiz_abs[h - bottom_h:, :]\n    fg_region = fg[h - bottom_h:, :]\n    # weight by foreground presence to emphasize strokes\n    weighted = region * (fg_region.astype(np.float64))\n    mean_val = weighted.mean() if weighted.size else 0.0\n    return float(mean_val)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical ink run (indicates strong vertical strokes like \"1\")'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv or h == 0 or w == 0:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    count = 0\n    for col in range(w):\n        colarr = ink[:, col].astype(int)\n        maxrun = 0\n        cur = 0\n        for v in colarr:\n            if v:\n                cur += 1\n                if cur > maxrun:\n                    maxrun = cur\n            else:\n                cur = 0\n        if maxrun >= max(1, int(0.4 * h)):\n            count += 1\n    return float(count / max(1.0, float(w)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the upper-right quadrant (helps detect 7 which often has ink in top-right)'\n    try:\n        import numpy as np\n        # grayscale conversion\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        if gray.size == 0:\n            return 0.0\n        # normalize to ~0-1\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        # estimate background polarity from corners\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        # region: upper-right quadrant\n        ur = fg[:h//2, w//2:]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(ur) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight bounding box around the ink (1 is square, >1 is tall like 1, <1 is wide like 7)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 1.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 1.0\n        bh = float(ys.max() - ys.min() + 1)\n        bw = float(xs.max() - xs.min() + 1)\n        if bw <= 0:\n            return 1.0\n        return float(bh / bw)\n    except Exception:\n        return 1.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the top-right quadrant (upper-right density ratio)'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    thresh = np.mean(norm)\n    ink = (norm < thresh).astype(np.float32)\n    if np.mean(ink) < 1e-3:\n        ink = 1.0 - ink\n    mid_h, mid_w = h // 2, w // 2\n    top_right = ink[0:mid_h, mid_w:w]\n    total = ink.sum()\n    if total <= 0:\n        return 0.0\n    return float(top_right.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical position (normalized) of the largest interior hole centroid, -1 if no hole'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # determine foreground\n    p40 = np.percentile(gray, 40)\n    p60 = np.percentile(gray, 60)\n    dark = (gray < p40)\n    light = (gray > p60)\n    if dark.sum() > 0 and (dark.sum() <= max(1, light.sum())):\n        fg = dark\n    elif light.sum() > 0:\n        fg = light\n    else:\n        fg = (gray < np.mean(gray))\n    bg = (~fg).astype(np.uint8)\n    visited = np.zeros_like(bg, dtype=bool)\n    holes = []\n    # flood fill background components\n    for y in range(h):\n        for x in range(w):\n            if bg[y, x] and not visited[y, x]:\n                # BFS\n                stack = [(y, x)]\n                visited[y, x] = True\n                coords = []\n                touches_border = False\n                while stack:\n                    cy, cx = stack.pop()\n                    coords.append((cy, cx))\n                    if cy == 0 or cy == h-1 or cx == 0 or cx == w-1:\n                        touches_border = True\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny = cy + dy\n                            nx = cx + dx\n                            if 0 <= ny < h and 0 <= nx < w and not visited[ny, nx] and bg[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n                if not touches_border:\n                    ys = [c[0] for c in coords]\n                    xs = [c[1] for c in coords]\n                    holes.append((len(coords), np.mean(ys), np.mean(xs)))\n    if len(holes) == 0:\n        return -1.0\n    # pick largest hole\n    holes.sort(reverse=True, key=lambda t: t[0])\n    _, yc, _ = holes[0]\n    return float(yc / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude in the bottom third of the image normalized by overall average gradient (edgeiness at bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        g = (gray - mn) / (mx - mn)\n    else:\n        g = np.zeros_like(gray, dtype=float)\n    gx, gy = np.gradient(g)\n    mag = np.sqrt(gx * gx + gy * gy)\n    r0 = (2 * h) // 3\n    bottom_mag = mag[r0:h, :]\n    overall_mean = float(np.mean(mag)) + 1e-9\n    return float(np.mean(bottom_mag) / overall_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top margin: row index of first ink pixel divided by image height (0 top, 1 bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gm = np.mean(gray)\n    corner = np.mean(gray[:max(1,h//10), :max(1,w//10)])\n    ink = gray < gm if corner > gm else gray > gm\n    ink = np.asarray(ink, dtype=bool)\n    ys = np.nonzero(ink)[0]\n    if ys.size == 0:\n        return 1.0\n    top_row = int(np.min(ys))\n    return float(top_row / max(1, h-1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of the ink normalized by image width (negative = left, positive = right)'\n    if image is None:\n        return 0.0\n    # Convert to grayscale if needed\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float64)\n    # Robust binarization: determine whether ink is darker or lighter\n    flat = gray.flatten()\n    thr = np.percentile(flat, 50)\n    low_mean = np.mean(flat[:max(1, len(flat)//10)])\n    high_mean = np.mean(flat[-max(1, len(flat)//10):])\n    if low_mean < high_mean:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    ink = ink.astype(np.uint8)\n    total = ink.sum()\n    if total == 0:\n        return 0.0\n    cols = np.arange(w)\n    col_sum = ink.sum(axis=0)\n    centroid_x = (col_sum * cols).sum() / total\n    # normalize to [-0.5, 0.5] then return (centered) positive means right\n    norm = (centroid_x - (w - 1) / 2.0) / float(w)\n    return float(norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of enclosed holes (loops) in the digit stroke (9 and 8 tend to have loops)'\n    try:\n        import numpy as np\n        # grayscale + normalize\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        # bounding box around foreground\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 0.0\n        y0, y1 = ys.min(), ys.max()\n        x0, x1 = xs.min(), xs.max()\n        sub = ~fg[y0:y1+1, x0:x1+1]  # background inside bbox\n        # flood fill the background component that touches the border to exclude outer background\n        H, W = sub.shape\n        visited = np.zeros_like(sub, dtype=np.bool_)\n        from collections import deque\n        q = deque()\n        for i in range(H):\n            for j in (0, W-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        for j in range(W):\n            for i in (0, H-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        while q:\n            y, x = q.popleft()\n            for dy in (-1, 0, 1):\n                for dx in (-1, 0, 1):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n        # now count remaining background components (holes)\n        holes = 0\n        for i in range(H):\n            for j in range(W):\n                if sub[i, j] and not visited[i, j]:\n                    # new hole\n                    holes += 1\n                    # mark component\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        for dy in (-1, 0, 1):\n                            for dx in (-1, 0, 1):\n                                ny, nx = y+dy, x+dx\n                                if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n        return float(holes)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'If multiple holes detected, return normalized vertical separation between the two largest hole centroids; otherwise 0'\n    if len(image.shape) == 3:\n        gray = image.mean(axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    bg = np.median(border) if border.size > 0 else np.median(gray)\n    rng = float(gray.max() - gray.min()) if gray.size else 0.0\n    tol = max(rng * 0.10, 1e-6)\n    if bg > gray.mean():\n        fg = gray < (bg - tol)\n    else:\n        fg = gray > (bg + tol)\n    fg = fg.astype(bool)\n    if not fg.any():\n        return 0.0\n    rows = np.any(fg, axis=1); cols = np.any(fg, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n    sub = fg[rmin:rmax + 1, cmin:cmax + 1]\n    bh, bw = sub.shape\n    back = (~sub).astype(np.uint8)\n    visited = np.zeros_like(back, dtype=np.uint8)\n    holes = []\n    for i in range(bh):\n        for j in range(bw):\n            if back[i, j] and not visited[i, j]:\n                stack = [(i, j)]\n                visited[i, j] = 1\n                touches_border = False\n                comp = []\n                while stack:\n                    y, x = stack.pop()\n                    comp.append((y, x))\n                    if y == 0 or x == 0 or y == bh - 1 or x == bw - 1:\n                        touches_border = True\n                    for dy, dx in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                        ny, nx = y + dy, x + dx\n                        if 0 <= ny < bh and 0 <= nx < bw and back[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = 1\n                            stack.append((ny, nx))\n                if not touches_border:\n                    ys = [p[0] for p in comp]\n                    xs = [p[1] for p in comp]\n                    holes.append({'area': len(comp), 'cy': float(np.mean(ys)), 'cx': float(np.mean(xs))})\n    if len(holes) < 2:\n        return 0.0\n    holes_sorted = sorted(holes, key=lambda x: x['area'], reverse=True)\n    h1, h2 = holes_sorted[0], holes_sorted[1]\n    vert_sep = abs(h1['cy'] - h2['cy'])\n    norm = float(max(1.0, bh - 1))\n    return float(vert_sep / norm)\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-center loop density: fraction of ink located in the lower central third of the image (useful to detect closed loops at the bottom like in 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    mask = mask.astype(np.uint8)\n    ink_total = mask.sum()\n    if ink_total == 0:\n        return 0.0\n    r0 = (2 * h) // 3\n    c0 = w // 4\n    c1 = 3 * w // 4\n    bottom_center = mask[r0:h, c0:c1]\n    return float(bottom_center.sum() / (ink_total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Local diagonal (down-right) stroke strength in the top-right quadrant (detects 4-like diagonal)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    if arr.size == 0:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    # choose a small top-right window\n    r0, r1 = 0, max(1, h//2)\n    c0, c1 = max(0, w//2), min(w, max(1, 3*w//4))\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mag = np.sqrt(gx*gx + gy*gy) + 1e-12\n    angle = np.arctan2(gy, gx)  # -pi..pi\n    # target diagonal down-right is -pi/4 (~ -0.785)\n    target = -0.7853981633974483\n    # weight by magnitude and compute similarity via Gaussian\n    diff = angle - target\n    # wrap to [-pi, pi]\n    diff = (diff + np.pi) % (2*np.pi) - np.pi\n    sim = np.exp(- (diff**2) / (0.6 + 0.5))  # moderate width\n    score = np.sum(sim * mag) / (np.sum(mag) + 1e-12)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate of number of enclosed holes (connected white regions fully surrounded by ink)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    thresh = (mn + mx) / 2.0\n    ink = (gray < thresh) if gray.mean() > thresh else (gray > thresh)\n    h, w = ink.shape\n    # background mask: True for background pixels (not ink)\n    background = ~ink\n    # flood fill from borders to find exterior background\n    visited = np.zeros_like(background, dtype=bool)\n    stack = []\n    # push border background pixels\n    ys = [0, h-1]\n    xs = [0, w-1]\n    for x in range(w):\n        if background[0, x] and not visited[0, x]:\n            stack.append((0, x))\n            visited[0, x] = True\n        if background[h-1, x] and not visited[h-1, x]:\n            stack.append((h-1, x))\n            visited[h-1, x] = True\n    for y in range(h):\n        if background[y, 0] and not visited[y, 0]:\n            stack.append((y, 0))\n            visited[y, 0] = True\n        if background[y, w-1] and not visited[y, w-1]:\n            stack.append((y, w-1))\n            visited[y, w-1] = True\n    while stack:\n        y, x = stack.pop()\n        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n            ny, nx = y+dy, x+dx\n            if 0 <= ny < h and 0 <= nx < w and background[ny, nx] and not visited[ny, nx]:\n                visited[ny, nx] = True\n                stack.append((ny, nx))\n    # any background pixel not visited is an enclosed hole; count connected components of those\n    holes_mask = background & (~visited)\n    seen = np.zeros_like(holes_mask, dtype=bool)\n    hole_count = 0\n    for y in range(h):\n        for x in range(w):\n            if holes_mask[y, x] and not seen[y, x]:\n                # flood fill this hole\n                hole_count += 1\n                stack = [(y, x)]\n                seen[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = cy+dy, cx+dx\n                        if 0 <= ny < h and 0 <= nx < w and holes_mask[ny, nx] and not seen[ny, nx]:\n                            seen[ny, nx] = True\n                            stack.append((ny, nx))\n    return float(hole_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside a small central circular region (higher for digits with centered hole like 0)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    r = max(1, min(h, w) // 6)\n    ys = np.arange(h)[:, None]\n    xs = np.arange(w)[None, :]\n    mask = ((ys - cy) ** 2 + (xs - cx) ** 2) <= (r ** 2)\n    bg = ~fg\n    region = bg & mask\n    denom = float(np.count_nonzero(mask)) + 1e-6\n    return float(np.count_nonzero(region) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized topmost ink row: fraction of image height to the first row containing ink (0=top,1=bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    thresh = (np.mean(border) + np.mean(gray)) / 2.0\n    ink = (gray < thresh) if (np.mean(border) > np.mean(gray)) else (gray > thresh)\n    rows = np.any(ink, axis=1)\n    if not np.any(rows):\n        return 1.0\n    first = int(np.argmax(rows))\n    return float(first / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized x-component of vector from global centroid to top-quarter centroid (tail direction score)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    meanv = float(np.mean(gray))\n    if meanv > (mn + mx) / 2.0:\n        fg = (gray < meanv)\n    else:\n        fg = (gray > meanv)\n    coords = np.argwhere(fg)\n    if coords.size == 0:\n        return 0.0\n    # overall centroid (x,y)\n    overall = np.array([coords[:, 1].mean(), coords[:, 0].mean()], dtype=float)\n    # top quarter region\n    top_lim = max(1, h // 4)\n    top_coords = coords[coords[:, 0] < top_lim]\n    if top_coords.shape[0] < 3:\n        # if not enough top pixels, try upper-middle quarter\n        top_coords = coords[(coords[:, 0] >= h//4) & (coords[:, 0] < h//2)]\n        if top_coords.shape[0] < 3:\n            return 0.0\n    top_centroid = np.array([top_coords[:, 1].mean(), top_coords[:, 0].mean()], dtype=float)\n    vec = top_centroid - overall\n    norm = np.sqrt(vec[0] * vec[0] + vec[1] * vec[1]) + 1e-8\n    # return normalized x component in range [-1,1]\n    return float(vec[0] / norm)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal stroke orientation (degrees) computed from ink pixel PCA; positive ~ down-right diagonal (useful for distinguishing 7)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    if gray.size == 0:\n        return 0.0\n    thr = (np.nanmin(gray) + np.nanmax(gray)) / 2.0\n    dark_count = np.count_nonzero(gray < thr)\n    ink = (gray < thr) if dark_count < gray.size / 2 else (gray > thr)\n    coords = np.column_stack(np.nonzero(ink))\n    if coords.shape[0] < 2:\n        return 0.0\n    # coords: rows, cols -> convert to x,y coordinates where x=col, y=row\n    pts = np.column_stack((coords[:, 1].astype(float), coords[:, 0].astype(float)))\n    mean = pts.mean(axis=0)\n    ptsc = pts - mean\n    cov = np.cov(ptsc.T)\n    # eigen decomposition\n    try:\n        eigvals, eigvecs = np.linalg.eigh(cov)\n    except Exception:\n        return 0.0\n    principal = eigvecs[:, np.argmax(eigvals)]\n    angle_rad = np.arctan2(principal[1], principal[0])\n    angle_deg = float(np.degrees(angle_rad))\n    return angle_deg\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical stroke (long contiguous ink run)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    fg_i = fg.astype(np.uint8)\n    long_columns = 0\n    min_len = max(2, int(h * 0.35))\n    for col in range(w):\n        col_arr = fg_i[:, col]\n        if col_arr.sum() == 0:\n            continue\n        # run length calculation\n        padded = np.concatenate(([0], col_arr, [0]))\n        dif = np.diff(padded)\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size and ends.size:\n            max_run = int(np.max(ends - starts))\n        else:\n            max_run = 0\n        if max_run >= min_len:\n            long_columns += 1\n    return float(long_columns / (w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge energy concentrated in the middle third of the image (captures mid horizontal cross in 4)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    horiz_energy = np.abs(gy)\n    r0, r1 = h // 3, (2 * h) // 3\n    mid_energy = np.sum(horiz_energy[r0:r1, :])\n    total_energy = np.sum(horiz_energy) + 1e-9\n    return float(mid_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-vs-ring brightness contrast: positive if center region is brighter than its surrounding ring (suggests a closed loop/hole)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    # define center box and a slightly larger ring box\n    ch0, ch1 = h // 3, 2 * h // 3\n    cw0, cw1 = w // 3, 2 * w // 3\n    center = gray[ch0:ch1, cw0:cw1]\n    ring_outer = gray[h//4:3*h//4, w//4:3*w//4]\n    # ring region excluding center\n    if ring_outer.size == 0 or center.size == 0:\n        return 0.0\n    ring_mask = np.ones_like(ring_outer, dtype=bool)\n    inner_y0 = ch0 - (h//4)\n    inner_x0 = cw0 - (w//4)\n    inner_y1 = inner_y0 + center.shape[0]\n    inner_x1 = inner_x0 + center.shape[1]\n    # ensure indices safe\n    inner_y0 = max(0, inner_y0); inner_x0 = max(0, inner_x0)\n    inner_y1 = min(ring_outer.shape[0], inner_y1); inner_x1 = min(ring_outer.shape[1], inner_x1)\n    if inner_y1 > inner_y0 and inner_x1 > inner_x0:\n        ring_mask[inner_y0:inner_y1, inner_x0:inner_x1] = False\n    ring_pixels = ring_outer[ring_mask]\n    center_mean = float(np.mean(center)) if center.size > 0 else 0.0\n    ring_mean = float(np.mean(ring_pixels)) if ring_pixels.size > 0 else center_mean\n    overall = float(np.mean(gray)) + 1e-8\n    # positive when center is brighter (i.e., potential hole background inside ink)\n    return float((center_mean - ring_mean) / overall)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of runs (transitions) along the central column (how many separate vertical strokes cross the center area)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    if mx - mn > 1e-8:\n        gray_norm = (gray - mn) / (mx - mn)\n    else:\n        gray_norm = gray - mn\n    thr = gray_norm.mean()\n    fg = (gray_norm < thr) if thr > 0.5 else (gray_norm > thr)\n    h, w = fg.shape\n    c = w // 2\n    col = fg[:, c].astype(int)\n    runs = 0\n    in_run = False\n    for v in col:\n        if v and not in_run:\n            runs += 1\n            in_run = True\n        elif not v:\n            in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of columns that contain a vertical ink run covering at least 60% of image height (indicates strong vertical strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    count = 0\n    minrun = max(1, int(0.6 * h))\n    for c in range(w):\n        col = ink[:, c].astype(int)\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= minrun):\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of vertical gradient energy that lies in the right half (captures vertical components concentrated on the right as in 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gx, gy = np.gradient(gray)\n    vert_energy = np.abs(gy)\n    total_energy = np.sum(vert_energy) + 1e-8\n    right_energy = np.sum(vert_energy[:, w//2:])\n    return float(right_energy) / float(total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight ink bounding box (1.0 ~ square); distinguishes tall strokes from round loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = gray < thr\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = gray > thr\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n    bbox_h = max_r - min_r + 1\n    bbox_w = max_c - min_c + 1\n    if bbox_w <= 0:\n        return float(bbox_h)\n    return float(bbox_h) / float(bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-left quadrant to bottom-right quadrant (high for strokes in TL, low for BR-heavy shapes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    mid_r, mid_c = h // 2, w // 2\n    tl = ink[0:mid_r, 0:mid_c]\n    br = ink[mid_r:h, mid_c:w]\n    tl_count = float(np.count_nonzero(tl))\n    br_count = float(np.count_nonzero(br))\n    # return ratio TL / (BR + 1) to avoid division by zero; scaled to reasonable magnitude\n    return float(tl_count / (br_count + 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical edge strength (gx) in the center-right quadrant (detects vertical right strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = gray.min(), gray.max()\n    norm = (gray - mn) / (mx - mn + 1e-9)\n    gy, gx = np.gradient(norm)\n    r0, c0 = h//4, w//2\n    region = gx[r0:3*h//4, c0:w]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(np.abs(region)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink mass in the top-right quadrant to the total ink in the top half (right bias in top area)'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = mn + 0.5 * (mx - mn)\n    top_half = gray[:h // 2, :]\n    if top_half.size == 0:\n        return 0.0\n    tr = top_half[:, w // 2:]\n    ink_top = (top_half > thr).astype(float)\n    ink_tr = (tr > thr).astype(float)\n    sum_top = float(np.sum(ink_top))\n    sum_tr = float(np.sum(ink_tr))\n    eps = 1e-9\n    return float(sum_tr / (sum_top + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous horizontal ink run in the bottom 20% rows normalized by image width (bottom-stroke indicator)'\n    import numpy as np\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img.astype(float)\n    med = np.median(gray)\n    prop = float(np.mean(gray < med))\n    thr = np.percentile(gray, 20) if prop > 0.5 else med\n    bw = (gray < thr).astype(np.uint8)\n    if bw.sum() == 0:\n        bw = (gray > thr).astype(np.uint8)\n    bottom_rows = max(1, int(np.ceil(0.20 * h)))\n    region = bw[-bottom_rows:, :]\n    max_run = 0\n    for r in region:\n        if r.sum() == 0:\n            continue\n        diff = np.diff(np.concatenate(([0], r, [0])))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if len(starts) and len(ends):\n            runs = (ends - starts)\n            max_run = max(max_run, runs.max())\n    return float(max_run / max(1, w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal gradient energy (sum|dI/dy| / (sum|dI/dx| + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    vert_energy = np.sum(np.abs(gy))\n    horz_energy = np.sum(np.abs(gx))\n    return float(vert_energy / (horz_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized average horizontal gradient magnitude in the top 25% rows (detects top bars)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top = gray[:top_h, :]\n    _, gx_top = np.gradient(top.astype(float))\n    top_energy = np.mean(np.abs(gx_top))\n    # normalize by whole-image horizontal gradient\n    _, gx_all = np.gradient(gray.astype(float))\n    norm = np.mean(np.abs(gx_all)) + 1e-9\n    return float(top_energy / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink above vs below the main diagonal (positive => more above)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    dark_count = np.count_nonzero(gray < thresh)\n    bright_count = np.count_nonzero(gray > thresh)\n    ink = (gray < thresh) if dark_count < bright_count else (gray > thresh)\n    rows = np.arange(h)[:, None]\n    cols = np.arange(w)[None, :]\n    # Above main diagonal: col > row*(w/h) approximate diagonal mapping if non-square\n    # Map row index to corresponding column index along diagonal scaled by aspect ratio\n    diag_cols = (cols.shape[1] - 1) * (rows / max(1, h - 1))\n    above = cols > diag_cols\n    below = cols < diag_cols\n    ink_above = np.count_nonzero(np.logical_and(ink, above))\n    ink_below = np.count_nonzero(np.logical_and(ink, below))\n    total = ink_above + ink_below\n    if total == 0:\n        return 0.0\n    return float((ink_above - ink_below) / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical to horizontal gradient magnitudes calculated on the right half'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2).astype(float)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    right = slice(w//2, w)\n    abs_vert = np.abs(gy[:, right])\n    abs_horz = np.abs(gx[:, right])\n    mean_vert = float(np.mean(abs_vert)) if abs_vert.size else 0.0\n    mean_horz = float(np.mean(abs_horz)) if abs_horz.size else 0.0\n    eps = 1e-9\n    return float(mean_vert / (mean_horz + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between upper-right and upper-left ink mass: (UR-UL)/(UR+UL+eps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.size == 0:\n        return 0.0\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    thr = np.mean(gray) - 0.25 * (np.std(gray) + 1e-9)\n    ink = (gray < thr).astype(np.float32)\n    h, w = ink.shape\n    mid_h = max(1, h // 2)\n    mid_w = max(1, w // 2)\n    upper = ink[:mid_h, :]\n    UL = np.sum(upper[:, :mid_w])\n    UR = np.sum(upper[:, mid_w:])\n    eps = 1e-9\n    return float((UR - UL) / (UR + UL + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical position (normalized) of the largest interior hole centroid, -1 if no hole'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # determine foreground\n    p40 = np.percentile(gray, 40)\n    p60 = np.percentile(gray, 60)\n    dark = (gray < p40)\n    light = (gray > p60)\n    if dark.sum() > 0 and (dark.sum() <= max(1, light.sum())):\n        fg = dark\n    elif light.sum() > 0:\n        fg = light\n    else:\n        fg = (gray < np.mean(gray))\n    bg = (~fg).astype(np.uint8)\n    visited = np.zeros_like(bg, dtype=bool)\n    holes = []\n    # flood fill background components\n    for y in range(h):\n        for x in range(w):\n            if bg[y, x] and not visited[y, x]:\n                # BFS\n                stack = [(y, x)]\n                visited[y, x] = True\n                coords = []\n                touches_border = False\n                while stack:\n                    cy, cx = stack.pop()\n                    coords.append((cy, cx))\n                    if cy == 0 or cy == h-1 or cx == 0 or cx == w-1:\n                        touches_border = True\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny = cy + dy\n                            nx = cx + dx\n                            if 0 <= ny < h and 0 <= nx < w and not visited[ny, nx] and bg[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n                if not touches_border:\n                    ys = [c[0] for c in coords]\n                    xs = [c[1] for c in coords]\n                    holes.append((len(coords), np.mean(ys), np.mean(xs)))\n    if len(holes) == 0:\n        return -1.0\n    # pick largest hole\n    holes.sort(reverse=True, key=lambda t: t[0])\n    _, yc, _ = holes[0]\n    return float(yc / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink in the upper-right quadrant (high values indicate right-side top ink concentration typical of 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = (gray < thr)\n    total = np.count_nonzero(ink)\n    if total == 0:\n        return 0.0\n    ur = np.count_nonzero(ink[0:h//2, w//2:w])\n    return float(ur) / float(total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute diagonal difference (shift (1,1)) to mean absolute vertical gradient (detects diagonal strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-12)\n    # diagonal difference (down-right)\n    diag = np.abs(g - np.roll(np.roll(g, -1, axis=0), -1, axis=1))\n    # avoid wrap-around influence by zeroing last row and column\n    diag[-1, :] = 0\n    diag[:, -1] = 0\n    gy = np.abs(np.gradient(g, axis=0))\n    diab = float(np.mean(np.abs(diag)))\n    vertb = float(np.mean(np.abs(gy))) + 1e-12\n    return float(diab / vertb)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of radial distances of foreground pixels from centroid (normalized) \u2014 \"0\" tends to have larger circular spread'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.0\n    cx, cy = np.mean(xs), np.mean(ys)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = np.std(dists)\n    # normalize by image diagonal\n    diag = np.sqrt(w * w + h * h)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical gradient energy concentrated in the left third of the image (left vertical energy / total energy)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    # compute gradients (dy, dx)\n    try:\n        dy, dx = np.gradient(gray)\n    except Exception:\n        dy = np.zeros_like(gray)\n        dx = np.zeros_like(gray)\n    total_energy = np.sum(np.abs(dy)) + eps\n    left_w = max(1, w // 3)\n    left_energy = np.sum(np.abs(dy[:, :left_w]))\n    return float(left_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-left ink density: ink fraction contained in the upper-left quadrant'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        thr = np.percentile(gray, 85)\n        ink = (gray < thr).astype(np.uint8)\n        total = float(np.sum(ink))\n        if total <= 0:\n            return 0.0\n        ul = float(np.sum(ink[:h//2, :w//2]))\n        return ul / (total + 1e-12)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean absolute horizontal gradient in the top third minus middle third (positive -> top horizontal stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    # compute horizontal gradient\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    top = abs_gx[:max(1, h//3), :].mean() if h>0 else 0.0\n    mid = abs_gx[h//3:2*h//3, :].mean() if h>1 else 0.0\n    denom = (top + mid + 1e-8)\n    return float((top - mid) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum relative background gap width in the top third (captures top concavities/openings)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.uint8)\n    if np.count_nonzero(ink) == 0:\n        return 1.0\n    top = max(1, h // 3)\n    max_gap_rel = 0.0\n    for i in range(top):\n        row = ink[i, :]\n        if np.any(row):\n            left = np.argmax(row > 0)\n            # find rightmost ink: search from right\n            rev = row[::-1]\n            right = w - 1 - np.argmax(rev > 0)\n            gap = max(0, right - left + 1 - int(np.sum(row[left:right+1] > 0)))\n            # alternatively, compute largest sequence of zeros between left and right\n            if right > left:\n                seg = row[left:right+1] == 0\n                # find longest run of True in seg\n                max_run = 0\n                run = 0\n                for v in seg:\n                    if v:\n                        run += 1\n                    else:\n                        if run > max_run: max_run = run\n                        run = 0\n                if run > max_run: max_run = run\n                gap_width = max_run\n            else:\n                gap_width = 0\n            rel = float(gap_width) / float(w)\n            if rel > max_gap_rel:\n                max_gap_rel = rel\n    return float(max_gap_rel)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of gradient vectors whose angle is near +45 degrees (diagonal orientation), useful for detecting diagonal strokes like in 7'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    ang = np.arctan2(gy, gx)  # range (-pi, pi)\n    # target +45 degrees = pi/4\n    target = np.pi / 4.0\n    diff = np.abs(((ang - target + np.pi) % (2*np.pi)) - np.pi)\n    mask = diff <= (np.pi / 12.0)  # +/-15 degrees\n    total = ang.size\n    return float(np.count_nonzero(mask)) / float(total + 1e-8)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average ink density in a narrow vertical band between hole centroids (3-pixel wide). If no holes, use center column.'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gmax = gray.max()\n    if gmax > 1.5:\n        gray = gray / gmax\n    thresh = float(np.mean(gray))\n    dark_frac = float(np.mean(gray < thresh))\n    if 0.01 < dark_frac < 0.99:\n        ink = (gray < thresh) if dark_frac < 0.5 else (gray > thresh)\n    else:\n        ink = gray < thresh\n    bg = ~ink\n    h, w = gray.shape\n    visited = np.zeros_like(bg, dtype=bool)\n    neighbors = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n    holes = []\n    for r in range(h):\n        for c in range(w):\n            if visited[r, c] or not bg[r, c]:\n                continue\n            stack = [(r, c)]\n            visited[r, c] = True\n            touches_border = False\n            area = 0\n            sum_c = 0.0\n            while stack:\n                rr, cc = stack.pop()\n                area += 1\n                sum_c += cc\n                if rr == 0 or rr == h-1 or cc == 0 or cc == w-1:\n                    touches_border = True\n                for dr, dc in neighbors:\n                    nr, nc = rr + dr, cc + dc\n                    if 0 <= nr < h and 0 <= nc < w and (not visited[nr, nc]) and bg[nr, nc]:\n                        visited[nr, nc] = True\n                        stack.append((nr, nc))\n            if not touches_border and area > 0:\n                holes.append((area, sum_c/area))\n    if len(holes) >= 2:\n        # choose mid-column between two largest holes\n        holes.sort(reverse=True, key=lambda x: x[0])\n        x1 = holes[0][1]\n        x2 = holes[1][1]\n        center_col = int(round((x1 + x2) / 2.0))\n    elif len(holes) == 1:\n        center_col = int(round(holes[0][1]))\n    else:\n        center_col = w // 2\n    half_width = max(1, w // 100, 1)  # small band\n    c0 = max(0, center_col - half_width)\n    c1 = min(w, center_col + half_width + 1)\n    band = ink[:, c0:c1]\n    density = float(np.count_nonzero(band)) / float(band.size) if band.size > 0 else 0.0\n    return float(density)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of per-row ink density normalized by the mean row density (higher => more vertical sparsity)'\n    if image is None:\n        return 0.0\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float64)\n    flat = gray.flatten()\n    thr = np.percentile(flat, 50)\n    low_mean = np.mean(flat[:max(1, len(flat)//10)])\n    high_mean = np.mean(flat[-max(1, len(flat)//10):])\n    if low_mean < high_mean:\n        ink = (gray < thr).astype(np.uint8)\n    else:\n        ink = (gray > thr).astype(np.uint8)\n    row_counts = ink.sum(axis=1).astype(np.float64)\n    mean_row = row_counts.mean() + 1e-9\n    std_row = row_counts.std()\n    return float(std_row / mean_row)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between NW-SE and NE-SW diagonal gradient energy (positive -> NW-SE dominant)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients\n    gy, gx = np.gradient(gray)\n    diag1 = gx + gy  # NW-SE\n    diag2 = gx - gy  # NE-SW\n    e1 = np.sum(np.abs(diag1))\n    e2 = np.sum(np.abs(diag2))\n    tot = e1 + e2 + 1e-6\n    return float((e1 - e2) / tot)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of the bottom contour (rows of lowest ink pixel per column) normalized to image aspect (positive = downward to right)'\n    import numpy as np\n    try:\n        h, w = image.shape[:2]\n        if h < 2 or w < 2:\n            return 0.0\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n        midpoint = (gray.max() + gray.min()) / 2.0\n        if np.mean(gray) > midpoint:\n            ink = gray < p40\n        else:\n            ink = gray > p60\n        bottom_rows = np.full(w, np.nan, dtype=float)\n        for c in range(w):\n            col = ink[:, c]\n            ys = np.where(col)[0]\n            if ys.size:\n                bottom_rows[c] = float(ys.max())\n        valid = ~np.isnan(bottom_rows)\n        if valid.sum() < 2:\n            return 0.0\n        xs = np.arange(w)[valid].astype(float)\n        ys = bottom_rows[valid]\n        # linear fit ys = m*xs + b\n        try:\n            m, b = np.polyfit(xs, ys, 1)\n        except Exception:\n            return 0.0\n        # normalize slope by image aspect: convert rows/col to fraction of height per width: (m * w) / h\n        slope_norm = float(m * (w / float(max(1, h))))\n        return slope_norm\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Signed vertical offset between ink centroid and background-inside-bbox centroid (normalized by height)'\n    import numpy as np\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        if h == 0 or w == 0:\n            return 0.0\n        thresh = (np.min(gray) + np.max(gray)) / 2.0\n        ink_candidate = gray < thresh\n        ink_mask = ink_candidate if np.sum(ink_candidate) <= (h*w/2) else ~ink_candidate\n        if not np.any(ink_mask):\n            return 0.0\n        ys, xs = np.nonzero(ink_mask)\n        y_mean_ink = float(np.mean(ys))\n        x_min, x_max = np.min(xs), np.max(xs)\n        y_min, y_max = np.min(ys), np.max(ys)\n        # bounding box\n        bb = (slice(y_min, y_max+1), slice(x_min, x_max+1))\n        inner_bg = ~ink_mask[bb]\n        if not np.any(inner_bg):\n            return 0.0\n        bys, bxs = np.nonzero(inner_bg)\n        y_mean_hole = float(np.mean(bys)) + y_min\n        # signed: positive means ink centroid below hole centroid\n        return float((y_mean_ink - y_mean_hole) / float(h))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along a horizontal line at 75% height normalized by width (captures bottom stroke crossings)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    row = min(h-1, max(0, int(h*0.75)))\n    line = gray[row, :]\n    thr = float(np.median(line))\n    mask = line < thr\n    # if inverted or degenerate, adjust threshold\n    if mask.mean() > 0.6 or mask.mean() < 0.01:\n        thr = float(np.mean(line))\n        mask = line < thr\n    # count transitions 0->1 or 1->0\n    trans = np.count_nonzero(mask[1:] != mask[:-1])\n    return float(trans / (w + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized strength of a continuous horizontal stroke in the top 25% rows (detects top bar of \"7\")'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    top_rows = max(1, h // 4)\n    # for each top row compute fraction of columns that are foreground; take the maximum\n    row_sums = np.sum(fg[:top_rows, :], axis=1).astype(float)\n    max_frac = np.max(row_sums) / float(w)\n    # Also scale by how many top rows have above-median fill\n    median_row = np.median(row_sums)\n    high_rows = np.count_nonzero(row_sums > median_row)\n    score = max_frac * (high_rows / float(top_rows))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of foreground point cloud (linear regression slope of y vs x), positive indicates down-right dominant strokes'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    maxv = float(np.max(gray)) if np.max(gray) != 0 else 1.0\n    gray = gray / maxv\n    p_low = np.percentile(gray, 40)\n    p_high = np.percentile(gray, 60)\n    fg = ((gray < p_low) if np.mean(gray) <= np.median(gray) else (gray > p_high)).astype(np.uint8)\n    ys, xs = np.nonzero(fg)\n    if xs.size < 2:\n        return 0.0\n    xs = xs.astype(float)\n    ys = ys.astype(float)\n    xm = xs.mean()\n    ym = ys.mean()\n    varx = np.sum((xs - xm) ** 2)\n    if varx == 0:\n        return 0.0\n    cov = np.sum((xs - xm) * (ys - ym))\n    slope = cov / varx\n    # normalize roughly by aspect ratio (height/width) to keep values comparable\n    h, w = gray.shape\n    norm = (h / (w + 1e-9))\n    return float(slope * norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal-edge energy concentrated in the top 20% rows (higher if a top bar exists)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.hypot(gx, gy)\n    # angle in degrees (-180..180)\n    ang = np.degrees(np.arctan2(gy, gx))\n    # horizontal-edge means edge normal vertical -> angle near 90 or -90? We target edges that run horizontally,\n    # i.e., gradient pointing up or down (angle around 90/-90). But we want edges corresponding to horizontal strokes,\n    # so detect angles near +/-90 degrees (abs(abs(angle)-90) small). We'll call these horizontal-edge responses.\n    horiz_mask = (np.abs(np.abs(ang) - 90) <= 25)\n    top_h = max(1, h // 5)\n    top_mask = np.zeros_like(horiz_mask, dtype=bool)\n    top_mask[:top_h, :] = True\n    horiz_total = mag[horiz_mask].sum()\n    if horiz_total <= 0:\n        return 0.0\n    top_horiz = mag[np.logical_and(horiz_mask, top_mask)].sum()\n    return float(top_horiz / horiz_total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean vertical-edge magnitude on right half to left half (right/left vertical edge ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    left = slice(0, w // 2)\n    right = slice(w // 2, w)\n    left_mean = np.mean(np.abs(gx[:, left])) + 1e-9\n    right_mean = np.mean(np.abs(gx[:, right])) + 1e-9\n    return float(right_mean / left_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient (detects horizontal bars) in the top 15% of image rows'\n    import numpy as _np\n    if image is None:\n        return 0.0\n    try:\n        h, w = image.shape[:2]\n        if h == 0 or w == 0:\n            return 0.0\n        if image.ndim == 3:\n            gray = _np.mean(image, axis=2).astype(_np.float64)\n        else:\n            gray = image.astype(_np.float64)\n        mn, mx = gray.min(), gray.max()\n        denom = (mx - mn) if (mx - mn) != 0 else 1.0\n        gray = (gray - mn) / denom\n        top_h = max(1, int(max(1, 0.15 * h)))\n        region = gray[:top_h, :]\n        # vertical gradient (change along rows) highlights horizontal edges\n        gy, _ = _np.gradient(region, axis=0), _np.gradient(region, axis=1)\n        mag = _np.abs(gy)\n        # normalize by global mean gradient to be robust\n        global_gy, _ = _np.gradient(gray, axis=0), _np.gradient(gray, axis=1)\n        global_mean = _np.mean(_np.abs(global_gy)) + 1e-9\n        return float(_np.mean(mag) / global_mean)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between fraction of ink in the lower third and the middle third (lower_density - middle_density)'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Binarize by choosing the polarity where ink is minority\n    meanv = gray.mean()\n    m1 = gray < meanv\n    m2 = gray > meanv\n    ink = m1 if np.count_nonzero(m1) <= np.count_nonzero(m2) else m2\n    total = float(np.count_nonzero(ink))\n    if total == 0:\n        return 0.0\n    lower = ink[2*h//3:h, :].sum() / total\n    middle = ink[h//3:2*h//3, :].sum() / total\n    return float(lower - middle)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'X-coordinate (normalized 0..1) of centroid of any enclosed hole (background component not touching border). Returns -1.0 if no holes'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return -1.0\n    img = np.asarray(image)\n    if img.size == 0:\n        return -1.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = np.mean(border) if border.size else np.mean(gray)\n    thresh = (border_mean + np.mean(gray)) / 2.0\n    fg = gray < thresh if border_mean > np.mean(gray) else gray > thresh\n    bg = ~fg\n    visited = np.zeros_like(bg, dtype=bool)\n    hole_centroids_x = []\n    for y in range(h):\n        for x in range(w):\n            if not bg[y, x] or visited[y, x]:\n                continue\n            # BFS flood fill\n            q = deque()\n            q.append((y, x))\n            visited[y, x] = True\n            coords = []\n            touches_border = False\n            while q:\n                yy, xx = q.popleft()\n                coords.append((yy, xx))\n                if yy == 0 or yy == h-1 or xx == 0 or xx == w-1:\n                    touches_border = True\n                # 4-connectivity\n                for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                    ny, nx = yy+dy, xx+dx\n                    if 0 <= ny < h and 0 <= nx < w and (not visited[ny, nx]) and bg[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n            if not touches_border:\n                coords = np.array(coords)\n                if coords.size:\n                    cx = coords[:,1].mean()\n                    hole_centroids_x.append(cx / max(1, w-1))\n    if not hole_centroids_x:\n        return -1.0\n    return float(np.mean(hole_centroids_x))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of significant horizontal projection peaks (rows with strong ink) normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.array(image, dtype=float)\n    if gray.ndim == 3:\n        gray = np.mean(gray, axis=2)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn + 1e-9\n    gray = (gray - mn) / rng\n    h, w = gray.shape\n    thresh = np.mean(gray)\n    fg1 = gray < thresh\n    fg2 = gray > thresh\n    fg = fg1 if np.count_nonzero(fg1) <= np.count_nonzero(fg2) else fg2\n    row_sums = fg.sum(axis=1).astype(float)\n    if row_sums.size == 0 or row_sums.max() == 0:\n        return 0.0\n    # normalized projection\n    rs = row_sums / (row_sums.max() + 1e-9)\n    # count local maxima above 30% of peak\n    peaks = 0\n    for i in range(1, len(rs) - 1):\n        if rs[i] > rs[i-1] and rs[i] >= rs[i+1] and rs[i] > 0.3:\n            peaks += 1\n    return float(peaks / max(1, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a horizontal stroke around the vertical center (center band density / overall ink density)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    med = np.median(gray)\n    b1 = gray < med\n    b2 = gray > med\n    ink = b1 if np.count_nonzero(b1) <= np.count_nonzero(b2) else b2\n    if np.count_nonzero(ink) == 0:\n        ink = gray < np.mean(gray)\n    band_half = max(1, h // 10)\n    mid = h // 2\n    top = max(0, mid - band_half)\n    bottom = min(h, mid + band_half + 1)\n    band = ink[top:bottom, :]\n    overall = np.count_nonzero(ink)\n    band_count = np.count_nonzero(band)\n    if overall == 0:\n        return 0.0\n    return float((band_count / (bottom - top) / w) / (overall / (h * w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry score: average absolute column difference between left and flipped right'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    # compare left half to flipped right half\n    mid = w // 2\n    left = norm[:, :mid]\n    right = norm[:, w - mid:]\n    right_flipped = right[:, ::-1]\n    # resize if they mismatch due to odd width\n    if left.shape[1] != right_flipped.shape[1]:\n        minc = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minc]\n        right_flipped = right_flipped[:, :minc]\n    score = np.mean(np.abs(left - right_flipped))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous horizontal ink run length normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    mask_lo = gray < th\n    mask_hi = gray > th\n    mask = mask_lo if np.count_nonzero(mask_lo) <= np.count_nonzero(mask_hi) else mask_hi\n    max_run = 0\n    for r in range(h):\n        row = mask[r]\n        # fast run length scan\n        run = 0\n        # iterate over booleans\n        for val in row:\n            if val:\n                run += 1\n            else:\n                if run > max_run:\n                    max_run = run\n                run = 0\n        if run > max_run:\n            max_run = run\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the right half divided by left half (detects right-side lobes like 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)  # gy: d/drow (vertical change -> horizontal edges), gx: d/dcol (vertical edges)\n    horiz_edge = np.abs(gy)\n    mid = w // 2\n    left_energy = np.mean(horiz_edge[:, :mid]) if mid > 0 else 0.0\n    right_energy = np.mean(horiz_edge[:, mid:]) if w - mid > 0 else 0.0\n    denom = left_energy + 1e-9\n    return float(right_energy / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink mass above the main diagonal to ink mass below it (main diagonal from top-left to bottom-right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.float32)\n    # Compute normalized coordinates and compare c_norm > r_norm -> above diagonal (toward upper-right)\n    rows = np.arange(h).reshape(h, 1).astype(np.float32) / (h - 1 if h > 1 else 1)\n    cols = np.arange(w).reshape(1, w).astype(np.float32) / (w - 1 if w > 1 else 1)\n    mask_above = cols > rows\n    mass_above = np.sum(ink[mask_above])\n    mass_below = np.sum(ink[~mask_above])\n    return float(mass_above / (mass_below + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized strength of a continuous horizontal stroke in the top 25% rows (detects top bar of \"7\")'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    top_rows = max(1, h // 4)\n    # for each top row compute fraction of columns that are foreground; take the maximum\n    row_sums = np.sum(fg[:top_rows, :], axis=1).astype(float)\n    max_frac = np.max(row_sums) / float(w)\n    # Also scale by how many top rows have above-median fill\n    median_row = np.median(row_sums)\n    high_rows = np.count_nonzero(row_sums > median_row)\n    score = max_frac * (high_rows / float(top_rows))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal component strength: ratio of largest to smallest eigenvalue of foreground coordinate covariance (>=1.0)'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = (gray_n < thr) if np.mean(gray_n) > 0.5 else (gray_n > thr)\n    ys, xs = np.where(fg)\n    if xs.size < 2:\n        return 1.0\n    coords = np.vstack([xs.astype(float), ys.astype(float)])\n    coords -= np.mean(coords, axis=1, keepdims=True)\n    cov = np.cov(coords)\n    # numerical stability\n    try:\n        vals = np.linalg.eigvalsh(cov)\n        vals = np.clip(vals, 1e-12, None)\n        ratio = float(vals[-1] / vals[0])\n    except Exception:\n        ratio = 1.0\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass (y coordinate of ink centroid divided by height) \u2014 >0.5 means ink bottom-heavy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    ys, xs = np.nonzero(ink)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(cy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the right half divided by left half (detects right-side lobes like 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)  # gy: d/drow (vertical change -> horizontal edges), gx: d/dcol (vertical edges)\n    horiz_edge = np.abs(gy)\n    mid = w // 2\n    left_energy = np.mean(horiz_edge[:, :mid]) if mid > 0 else 0.0\n    right_energy = np.mean(horiz_edge[:, mid:]) if w - mid > 0 else 0.0\n    denom = left_energy + 1e-9\n    return float(right_energy / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink located in the bottom-right quadrant (captures right-side tails like in 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        g = image.mean(axis=2).astype(np.float32)\n    else:\n        g = image.astype(np.float32)\n    mx = g.max() if g.size else 1.0\n    if mx > 1.0:\n        g = g / mx\n    med = np.median(g) if g.size else 0.0\n    ink = (g < 0.5) if med > 0.5 else (g > 0.5)\n    h, w = g.shape\n    br = np.zeros_like(ink)\n    br[h//2:, w//2:] = True\n    total = np.count_nonzero(ink)\n    if total == 0:\n        return 0.0\n    br_count = np.count_nonzero(ink & br)\n    return float(br_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between top-right and top-left ink counts (positive when top-right dominates, negative if top-left dominates)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        gmin, gmax = float(np.min(gray)), float(np.max(gray))\n        grayn = (gray - gmin) / (gmax - gmin + 1e-9)\n        mask = grayn < np.mean(grayn)\n        h, w = mask.shape\n        top = slice(0, max(1, h//3))\n        mid = w//2\n        tr = np.count_nonzero(mask[top, mid:w])\n        tl = np.count_nonzero(mask[top, 0:mid])\n        denom = tr + tl + 1e-9\n        return float((tr - tl) / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient orientation entropy: lower entropy -> dominant stroke direction (e.g., 7 has low entropy)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    mask = mag > (np.percentile(mag, 50) * 0.1 + 1e-12)\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # range -pi..pi\n    # histogram and entropy\n    bins = 16\n    hist, _ = np.histogram(angles, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (hist.sum() + 1e-12)\n    p_nonzero = p[p > 0]\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero + 1e-12))\n    # normalize by max entropy\n    max_ent = np.log(bins)\n    return float(entropy / (max_ent + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute top vs bottom ink imbalance (fractional difference between top and bottom halves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) - 0.05 * np.std(gray)\n    mask = gray < thr\n    top = np.sum(mask[:h//2, :])\n    bottom = np.sum(mask[h//2:, :])\n    denom = max(1.0, top + bottom)\n    return float(abs(top - bottom) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy to total gradient energy (higher when diagonal strokes present, e.g., \"4\")'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray.astype(float))\n    except Exception:\n        return 0.0\n    # approximate diagonal gradients by rotated components\n    g45 = (gx + gy) / np.sqrt(2.0)\n    g135 = (gx - gy) / np.sqrt(2.0)\n    diag_energy = np.sum(np.abs(g45)) + np.sum(np.abs(g135))\n    total_energy = np.sum(np.abs(gx)) + np.sum(np.abs(gy)) + 1e-9\n    return float(diag_energy / float(total_energy))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of left-third columns that contain any ink (indicates presence of a left vertical stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    left_w = max(1, w // 3)\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    left_block = ink[:, :left_w]\n    if left_block.size == 0:\n        return 0.0\n    cols_with_ink = np.sum(np.any(left_block, axis=0))\n    return float(cols_with_ink / left_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-bar strength: mean absolute horizontal gradient in the top quarter divided by overall mean horizontal gradient'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(np.float32))\n    abs_gx = np.abs(gx)\n    top_h = max(1, h // 4)\n    mean_top = float(np.mean(abs_gx[:top_h, :]))\n    mean_all = float(np.mean(abs_gx)) + 1e-9\n    return float(mean_top / mean_all)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal spread to vertical spread of ink (var_x / var_y) to indicate whether digit is wider or taller'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = float(np.percentile(gray, 40))\n    ink = (gray <= thresh).astype(np.uint8)\n    ys, xs = np.nonzero(ink)\n    if xs.size == 0:\n        return 0.0\n    var_x = float(np.var(xs))\n    var_y = float(np.var(ys))\n    if var_y < 1e-6:\n        return float(var_x / (var_y + 1e-6))\n    return float(var_x / var_y)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute 45-degree diagonal gradient to mean absolute -45-degree diagonal gradient (skewed stroke indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # compute diagonal differences\n    d1 = np.abs(gray[1:, 1:] - gray[:-1, :-1])\n    d2 = np.abs(gray[1:, :-1] - gray[:-1, 1:])\n    m1 = float(np.mean(d1)) + 1e-9\n    m2 = float(np.mean(d2)) + 1e-9\n    return float(m1 / m2)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Orientation of principal axis of ink pixels (normalized angle 0..1 where 0=horizontal, 1=vertical)'\n    try:\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        thr = np.percentile(gray, 40)\n        ink_mask = (gray < thr)\n        if np.count_nonzero(ink_mask) < 4:\n            thr = np.percentile(gray, 60)\n            ink_mask = (gray > thr)\n        ys, xs = np.where(ink_mask)\n        if xs.size < 2:\n            return 0.0\n        x = xs.astype(float)\n        y = ys.astype(float)\n        x = x - x.mean()\n        y = y - y.mean()\n        cov_xx = np.mean(x * x)\n        cov_xy = np.mean(x * y)\n        cov_yy = np.mean(y * y)\n        cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n        # eigen decomposition\n        try:\n            vals, vecs = np.linalg.eigh(cov)\n            # principal eigenvector corresponds to largest eigenvalue\n            principal = vecs[:, np.argmax(vals)]\n            angle = np.arctan2(principal[1], principal[0])  # -pi..pi\n            # convert to 0..pi/2 (orientation without direction)\n            angle = abs(angle)\n            if angle > np.pi/2:\n                angle = np.pi - angle\n            # normalize: 0 -> horizontal, 1 -> vertical\n            return float(angle / (np.pi / 2.0))\n        except Exception:\n            return 0.0\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Eccentricity proxy: ratio of principal covariance eigenvalues of ink coordinates (>=1)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(gray.min()), float(gray.max())\n    rng = mx - mn + eps\n    norm = (gray - mn) / rng\n    ink = norm < 0.5 if np.mean(norm) > 0.5 else norm > 0.5\n    ys, xs = np.where(ink)\n    if ys.size < 3:\n        return 0.0\n    coords = np.stack([xs.astype(float), ys.astype(float)], axis=0)\n    cov = np.cov(coords)\n    # numerical safety\n    trace = cov.trace() + eps\n    # eigenvalues of 2x2 symmetric matrix\n    a, b = cov[0,0], cov[0,1]\n    c = cov[1,1]\n    term = np.sqrt(max(0.0, (a - c)**2 + 4*b*b))\n    l1 = 0.5 * (a + c + term)\n    l2 = 0.5 * (a + c - term)\n    l1, l2 = max(l1, eps), max(l2, eps)\n    return float(l1 / l2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left vs right middle strip ink asymmetry: normalized difference (left - right) by total ink'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    mx = float(np.max(gray))\n    if mx > 0:\n        gray = gray / (mx + eps)\n    h, w = gray.shape[:2]\n    k = max(1, w // 8)\n    med = float(np.percentile(gray, 50))\n    corners = np.mean([gray[:k,:k].mean(), gray[:k,-k:].mean(), gray[-k:,:k].mean(), gray[-k:,-k:].mean()])\n    if corners > med:\n        ink = (gray < med).astype(np.uint8)\n    else:\n        ink = (gray > med).astype(np.uint8)\n    left_start = max(0, w // 8)\n    left_end = max(left_start + 1, w // 2)\n    right_start = min(w - 1, w // 2)\n    right_end = min(w, w * 7 // 8)\n    left_count = float(np.sum(ink[:, left_start:left_end]))\n    right_count = float(np.sum(ink[:, right_start:right_end]))\n    total = float(np.sum(ink)) + eps\n    return float((left_count - right_count) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative depth of the central valley between top and bottom density peaks in the row profile (strong valley suggests two separate loops as in \"8\")'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    g = (gray - mn) / (mx - mn + eps)\n    border = np.concatenate([g[0, :], g[-1, :], g[:, 0], g[:, -1]]) if h > 1 and w > 1 else g.flatten()\n    border_mean = float(np.mean(border)) if border.size else 1.0\n    if border_mean > 0.5:\n        ink = g < 0.5\n    else:\n        ink = g > 0.5\n    row_density = ink.sum(axis=1).astype(float) / (w + eps)\n    if h < 3 or np.max(row_density) < eps:\n        return 0.0\n    mid = h // 2\n    top_region = row_density[:mid] if mid > 1 else row_density[:1]\n    bottom_region = row_density[mid:] if mid < h - 1 else row_density[-1:]\n    top_idx = int(np.argmax(top_region)) if top_region.size > 0 else 0\n    bottom_idx = int(np.argmax(bottom_region)) + mid if bottom_region.size > 0 else h - 1\n    if bottom_idx <= top_idx + 1:\n        return 0.0\n    valley = float(np.min(row_density[top_idx:bottom_idx + 1]))\n    depth = (float(row_density[top_idx]) + float(row_density[bottom_idx]) - 2.0 * valley) / (float(np.max(row_density)) + eps)\n    return float(max(0.0, depth))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest hole area normalized by image area (holes are background components not touching the border)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    mn, mx = arr.min(), arr.max()\n    if mx <= mn:\n        return 0.0\n    gray = (arr - mn) / (mx - mn)\n    ink_is_dark = np.mean(gray) > 0.5\n    fg = (gray < 0.5) if ink_is_dark else (gray > 0.5)\n    bg = ~fg\n    h, w = bg.shape\n    visited = np.zeros_like(bg, dtype=bool)\n    max_hole = 0\n    # 4- or 8-connectivity? use 8-connectivity for robustness\n    for r in range(h):\n        for c in range(w):\n            if not bg[r, c] or visited[r, c]:\n                continue\n            # flood fill\n            stack = [(r, c)]\n            visited[r, c] = True\n            size = 0\n            touches_border = False\n            while stack:\n                y, x = stack.pop()\n                size += 1\n                if y == 0 or y == h - 1 or x == 0 or x == w - 1:\n                    touches_border = True\n                # iterate 8 neighbors\n                for dy in (-1, 0, 1):\n                    for dx in (-1, 0, 1):\n                        ny, nx = y + dy, x + dx\n                        if ny < 0 or ny >= h or nx < 0 or nx >= w:\n                            continue\n                        if not visited[ny, nx] and bg[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n            if not touches_border:\n                if size > max_hole:\n                    max_hole = size\n    area = float(h * w)\n    if area <= 0:\n        return 0.0\n    return float(max_hole / area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal edge strength in the top quarter (captures a top bar)'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # gradients\n    gy, gx = np.gradient(gray)\n    edge = np.hypot(gx, gy)\n    top_region = edge[:max(1, h//4), :]\n    total = edge.sum() + 1e-9\n    return float(top_region.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness proxy: ink area divided by (perimeter + 1). Higher means thicker/compact ink regions.'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.uint8)\n    if np.mean(ink) > 0.75:\n        ink = (~(ink.astype(bool))).astype(np.uint8)\n    area = float(np.sum(ink))\n    if area <= 0.0:\n        return 0.0\n    pad = np.pad(ink, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    neighbor_sum = (\n        pad[:-2, :-2] + pad[:-2, 1:-1] + pad[:-2, 2:] +\n        pad[1:-1, :-2] +               0  + pad[1:-1, 2:] +\n        pad[2:, :-2] + pad[2:, 1:-1] + pad[2:, 2:]\n    )\n    # a pixel is on perimeter if it has any background neighbor (neighbor_sum < 8)\n    perimeter_mask = np.logical_and(ink == 1, neighbor_sum < 8)\n    perimeter = float(np.sum(perimeter_mask))\n    compactness = area / (perimeter + 1.0)\n    return float(compactness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of empty pixels in the central vertical band (center gap ratio)'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    band_w = max(1, w // 8)\n    left = (w - band_w) // 2\n    right = left + band_w\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    thresh = np.mean(norm)\n    ink = (norm < thresh).astype(np.uint8)\n    if ink.sum() == 0:\n        ink = 1 - ink\n    band = ink[:, left:right]\n    gap_ratio = 1.0 - (band.sum() / float(band.size) if band.size > 0 else 0.0)\n    return float(gap_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel mass in the rightmost third of the image to total image mass (detects right-heavy \"3\" lobes)'\n    # handle grayscale vs RGB\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    total = np.sum(gray)\n    if total == 0:\n        return 0.0\n    c = max(1, w // 3)\n    right_mass = np.sum(gray[:, w - c:w])\n    return float(right_mass / (total + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average intensity of the central horizontal band (middle 20% of rows) normalized by overall mean \u2014 captures middle bar like in 5'\n    import numpy as np\n    eps = 1e-6\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    start = max(0, int(h * 0.4))\n    end = min(h, int(h * 0.6) + 1)\n    band = gray[start:end, :]\n    if band.size == 0:\n        return 0.0\n    return float((np.mean(band) + eps) / (np.mean(gray) + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom-right quadrant of the image'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = (gray < thr)\n    if ink.sum() > 0.6 * h * w:\n        ink = (gray > thr)\n    if ink.sum() == 0:\n        return 0.0\n    br = ink[h // 2:, w // 2:]\n    return float(np.count_nonzero(br) / max(1, np.count_nonzero(ink)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Euler number: number of connected ink components minus number of holes'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    h, w = gray.shape\n    m = _np.mean(gray)\n    ink = (gray < m).astype(_np.uint8)\n    if ink.sum() == 0:\n        return 0.0\n    visited = _np.zeros_like(ink, dtype=_np.uint8)\n    components = 0\n    for y in range(h):\n        for x in range(w):\n            if ink[y, x] and not visited[y, x]:\n                components += 1\n                stack = [(y, x)]\n                visited[y, x] = 1\n                while stack:\n                    cy, cx = stack.pop()\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = cy + dy, cx + dx\n                            if 0 <= ny < h and 0 <= nx < w:\n                                if ink[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = 1\n                                    stack.append((ny, nx))\n    # count holes using inverted components that do not touch border\n    bg = (ink == 0).astype(_np.uint8)\n    visited_bg = _np.zeros_like(bg, dtype=_np.uint8)\n    holes = 0\n    for y in range(h):\n        for x in range(w):\n            if bg[y, x] and not visited_bg[y, x]:\n                stack = [(y, x)]\n                visited_bg[y, x] = 1\n                touches_border = False\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy == 0 or cx == 0 or cy == h - 1 or cx == w - 1:\n                        touches_border = True\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = cy + dy, cx + dx\n                            if 0 <= ny < h and 0 <= nx < w:\n                                if bg[ny, nx] and not visited_bg[ny, nx]:\n                                    visited_bg[ny, nx] = 1\n                                    stack.append((ny, nx))\n                if not touches_border:\n                    holes += 1\n    euler = float(components - holes)\n    return euler\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink pixels falling inside the central 50% x 50% box (detects central loops like in 9)'\n    try:\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        p40 = np.percentile(gray, 40)\n        p60 = np.percentile(gray, 60)\n        mask_dark = gray < p40\n        mask_light = gray > p60\n        mask = mask_dark if mask_dark.sum() <= mask_light.sum() and mask_dark.sum() > 0 else (mask_light if mask_light.sum() > 0 else (gray < gray.mean()))\n        ch0, ch1 = h//4, w//4\n        center_block = mask[ch0:h-ch0, ch1:w-ch1]\n        total = float(np.count_nonzero(mask))\n        if total == 0:\n            return 0.0\n        return float(np.count_nonzero(center_block)) / total\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative bias of ink between upper-right and upper-left quadrants: (UR - UL) / (UR + UL + eps) in upper half'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh)\n    h, w = ink.shape\n    mid_r = h // 2\n    mid_c = w // 2\n    upper = ink[0:mid_r, :]\n    ul = np.count_nonzero(upper[:, 0:mid_c])\n    ur = np.count_nonzero(upper[:, mid_c:w])\n    val = (float(ur) - float(ul)) / (float(ur) + float(ul) + 1e-9)\n    return float(val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) pixels in the right-middle region vs left-middle region (close to 1 => more empty on right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.5\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        fg = (gray < (med - delta)).astype(int)\n    else:\n        fg = (gray > (med + delta)).astype(int)\n    y0, y1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    mid_x0, mid_x1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    band = fg[y0:y1, mid_x0:mid_x1]\n    if band.size == 0:\n        return 0.5\n    mid = band.shape[1] // 2\n    left_band = band[:, :mid]\n    right_band = band[:, mid:]\n    left_bg = float((left_band == 0).sum())\n    right_bg = float((right_band == 0).sum())\n    total = left_bg + right_bg\n    if total == 0:\n        return 0.5\n    return float(right_bg / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal offset of the largest hole centroid from image center (0..0.5 normalized)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        best_area = 0\n        best_cx = None\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumx = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumx += x\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > best_area:\n                        best_area = area\n                        best_cx = (sumx / area)\n        if best_cx is None:\n            return 0.0\n        center = (w - 1) / 2.0\n        return float(abs(best_cx - center) / max(1.0, w))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal run length in the top third normalized by image width (detects long top bars like in 7)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv, maxv = float(np.min(gray)), float(np.max(gray))\n    scaled = (gray - minv) / (maxv - minv + 1e-8)\n    t = float(np.mean(scaled))\n    dark = scaled <= t\n    bright = scaled >= t\n    fore = dark if dark.sum() <= bright.sum() else bright\n    top_h = max(1, h // 3)\n    max_run = 0\n    for r in range(top_h):\n        row = fore[r, :].astype(int)\n        p = np.concatenate(([0], row, [0]))\n        idx = np.where(np.diff(p) != 0)[0]\n        for i in range(0, len(idx), 2):\n            start = idx[i]\n            end = idx[i+1]\n            max_run = max(max_run, end - start)\n    return float(max_run) / float(max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy in left half to right half (left_vs_right_vertical_grad)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.0\n    dy, dx = np.gradient(gray)\n    vert = np.abs(dy)\n    left = vert[:, :w//2]\n    right = vert[:, w//2:]\n    left_energy = np.sum(left)\n    right_energy = np.sum(right)\n    if right_energy <= 1e-8:\n        return float(left_energy)\n    return float(left_energy / right_energy)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of top-quarter rows that contain multiple separate horizontal ink runs'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mn, mx = float(gray.min()), float(gray.max())\n    norm = (gray - mn) / (mx - mn + 1e-8)\n    mask = (norm < 0.5).astype(np.uint8)\n    h, w = mask.shape\n    top_rows = max(1, h // 4)\n    sub = mask[:top_rows, :]\n    rows_with_multi = 0\n    for row in sub:\n        if row.sum() == 0:\n            continue\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        runs = ends - starts\n        if runs.size >= 2 and runs.max() > 0:\n            rows_with_multi += 1\n    return float(rows_with_multi) / float(top_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in upper quarter vs lower quarter (upper_density / (lower_density + eps))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gm = np.mean(gray)\n    corner = np.mean(gray[:max(1,h//10), :max(1,w//10)])\n    ink = gray < gm if corner > gm else gray > gm\n    ink = np.asarray(ink, dtype=bool)\n    q = max(1, h // 4)\n    upper = ink[:q, :].sum() / float(max(1, q * w))\n    lower = ink[-q:, :].sum() / float(max(1, q * w))\n    return float(upper / (lower + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass offset: (y_centroid / height) - 0.5 (negative = top-biased, positive = bottom-biased)'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    h, w = gray.shape\n    m = _np.mean(gray)\n    ink_mask = (gray < m).astype(_np.float32)\n    total = float(ink_mask.sum())\n    if total <= 0.0:\n        return 0.0\n    ys = _np.arange(h).astype(_np.float32)\n    ysum = float((ink_mask * ys[:, None]).sum())\n    y_centroid = ysum / total\n    offset = float((y_centroid / float(h)) - 0.5)\n    return offset\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Local diagonal (down-right) stroke strength in the top-right quadrant (detects 4-like diagonal)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    if arr.size == 0:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    # choose a small top-right window\n    r0, r1 = 0, max(1, h//2)\n    c0, c1 = max(0, w//2), min(w, max(1, 3*w//4))\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mag = np.sqrt(gx*gx + gy*gy) + 1e-12\n    angle = np.arctan2(gy, gx)  # -pi..pi\n    # target diagonal down-right is -pi/4 (~ -0.785)\n    target = -0.7853981633974483\n    # weight by magnitude and compute similarity via Gaussian\n    diff = angle - target\n    # wrap to [-pi, pi]\n    diff = (diff + np.pi) % (2*np.pi) - np.pi\n    sim = np.exp(- (diff**2) / (0.6 + 0.5))  # moderate width\n    score = np.sum(sim * mag) / (np.sum(mag) + 1e-12)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical gradient energy concentrated in the right third (distinguishes right-side vertical strokes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    vert_energy = gy ** 2\n    total = np.sum(vert_energy)\n    third = max(1, w // 3)\n    right_energy = np.sum(vert_energy[:, w-third:])\n    eps = 1e-9\n    if total <= 0:\n        return 0.0\n    return float(right_energy / (total + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of transitions (background<->ink) along the central horizontal row; open shapes produce different counts than closed loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    center_row = h // 2\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink_row = (gray[center_row, :] < thr).astype(int)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink_row = (gray[center_row, :] > thr).astype(int)\n    if w <= 1:\n        return 0.0\n    transitions = int(np.sum(np.abs(np.diff(ink_row))))\n    # transitions is the number of boundaries; return transitions/2 as number of segments, but keep raw as float\n    return float(transitions)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground density in top half versus bottom half (top_density / (bottom_density + eps))'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = gray_n < thr if np.mean(gray_n) > 0.5 else gray_n > thr\n    top = fg[:h // 2, :]\n    bottom = fg[h // 2:, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    eps = 1e-6\n    return float(top_count / (bottom_count + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the foreground bounding box (width / height), 0.0 if no foreground found'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = gray_n < thr if np.mean(gray_n) > 0.5 else gray_n > thr\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(np.min(ys)), int(np.max(ys))\n    x0, x1 = int(np.min(xs)), int(np.max(xs))\n    bw = max(1, x1 - x0 + 1)\n    bh = max(1, y1 - y0 + 1)\n    return float(bw / bh)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of radial distances of foreground pixels from centroid (normalized) \u2014 \"0\" tends to have larger circular spread'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.0\n    cx, cy = np.mean(xs), np.mean(ys)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = np.std(dists)\n    # normalize by image diagonal\n    diag = np.sqrt(w * w + h * h)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous horizontal ink run within the top quarter center zone normalized by width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    center_w1 = max(0, w//4)\n    center_w2 = min(w, 3*w//4)\n    zone = gray[0:top_h, center_w1:center_w2]\n    if zone.size == 0:\n        return 0.0\n    thresh = float(np.mean(zone))\n    low = int(np.count_nonzero(zone < thresh))\n    high = int(np.count_nonzero(zone > thresh))\n    if low < high:\n        ink_zone = (zone < thresh).astype(np.uint8)\n    else:\n        ink_zone = (zone > thresh).astype(np.uint8)\n    # compute longest horizontal run across all rows in zone\n    longest = 0\n    for row in ink_zone:\n        # find longest run of ones in row\n        current = 0\n        maxr = 0\n        for v in row:\n            if v:\n                current += 1\n            else:\n                if current > maxr:\n                    maxr = current\n                current = 0\n        if current > maxr:\n            maxr = current\n        if maxr > longest:\n            longest = maxr\n    norm = float(longest / max(1, center_w2 - center_w1))\n    return norm\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal vs anti-diagonal gradient energy: sum|gx+gy| / (sum|gx-gy| + eps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag = np.sum(np.abs(gx + gy))\n    antidiag = np.sum(np.abs(gx - gy))\n    eps = 1e-6\n    return float(diag / (antidiag + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of transitions (background<->ink) along the central horizontal row'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    mid = h // 2\n    row = fg[mid, :].astype(int)\n    transitions = np.count_nonzero(np.diff(row) != 0)\n    return float(transitions) / float(w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude in the top-right quadrant to bottom-right quadrant (right-side curvature balance)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2 or np.all(gray == gray.flat[0]):\n        return 0.0\n    grad_row, grad_col = np.gradient(gray)\n    right = slice(w//2, w)\n    top = slice(0, h//2)\n    bottom = slice(h//2, h)\n    top_right = np.abs(grad_col[top, right])\n    bottom_right = np.abs(grad_col[bottom, right])\n    top_mean = float(np.mean(top_right)) if top_right.size > 0 else 0.0\n    bottom_mean = float(np.mean(bottom_right)) if bottom_right.size > 0 else 0.0\n    eps = 1e-6\n    return float(top_mean / (bottom_mean + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: (perimeter^2) / area for the foreground (higher means thinner/elongated strokes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    p10, p90 = np.percentile(gray, (10, 90))\n    low_mean = float(np.mean(gray[gray <= p10])) if np.any(gray <= p10) else p10\n    high_mean = float(np.mean(gray[gray >= p90])) if np.any(gray >= p90) else p90\n    median = np.median(gray)\n    if low_mean < high_mean:\n        ink = (gray <= median).astype(np.uint8)\n    else:\n        ink = (gray >= median).astype(np.uint8)\n    area = float(np.count_nonzero(ink))\n    if area <= 0:\n        return 0.0\n    # approximate perimeter: foreground pixels that touch background\n    perimeter = 0\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j]:\n                for di, dj in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                    ni, nj = i + di, j + dj\n                    if not (0 <= ni < h and 0 <= nj < w and ink[ni, nj]):\n                        perimeter += 1\n    if perimeter <= 0:\n        return 0.0\n    compactness = (perimeter * perimeter) / (area + 1e-9)\n    return float(compactness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum normalized contiguous horizontal ink run length within the top quarter of the image'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    region = gray[:top_h, :]\n    # binary threshold similar adaptive rule\n    t = region.mean()\n    ink_dark_fraction = (region < t).sum() / float(region.size) if region.size else 0.0\n    if ink_dark_fraction < 0.5:\n        bin_region = (region < t).astype(np.uint8)\n    else:\n        bin_region = (region > t).astype(np.uint8)\n    max_run = 0\n    # compute run lengths per row\n    for row in bin_region:\n        run = 0\n        row_max = 0\n        for val in row:\n            if val:\n                run += 1\n            else:\n                if run > row_max:\n                    row_max = run\n                run = 0\n        if run > row_max:\n            row_max = run\n        if row_max > max_run:\n            max_run = int(row_max)\n    # normalize\n    if w == 0:\n        return 0.0\n    return float(max_run) / float(w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink pixels located in the lower-right quadrant (captures right-bottom weight like in 3)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # simple threshold: midpoint between min and max\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    thresh = 0.5 * (mn + mx)\n    ink = gray < thresh\n    total_ink = float(np.count_nonzero(ink))\n    if total_ink < 1e-6:\n        return 0.0\n    lr_ink = np.count_nonzero(ink[h//2:, w//2:])\n    return float(lr_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink mass located in the top-right quadrant (helps detect digits with right-side strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.float64)\n    if ink.sum() <= 1e-9:\n        return 0.0\n    top = slice(0, h//2)\n    right = slice(w//2, w)\n    top_right = ink[top, right].sum()\n    return float(top_right / (ink.sum() + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal gradient strength: mean|dx-dy| / (mean|dx+dy| + eps). Emphasizes TR->BL vs TL->BR diagonals'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)  # gy = d/dy, gx = d/dx\n    a = np.mean(np.abs(gx - gy))\n    b = np.mean(np.abs(gx + gy))\n    return float(a / (b + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal edges in the upper third: mean horizontal gradient in top band divided by global gradient'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    # horizontal gradient (differences along columns)\n    hg = np.abs(np.diff(gray, axis=1))\n    # average in upper third\n    top_rows = max(1, h // 3)\n    top_hg = hg[:top_rows, :]\n    mean_top = top_hg.mean() if top_hg.size else 0.0\n    mean_all = hg.mean() if hg.size else 0.0\n    denom = mean_all + 1e-8\n    return float(mean_top / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Asymmetry between a narrow band around the main diagonal and the anti-diagonal: (main - anti) / (main + anti + eps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = np.mean(border) if border.size else np.mean(gray)\n    thresh = (border_mean + np.mean(gray)) / 2.0\n    fg = gray < thresh if border_mean > np.mean(gray) else gray > thresh\n    # create coordinate grid\n    ys = np.arange(h)[:, None]\n    xs = np.arange(w)[None, :]\n    # compute distance to main diagonal (y-x) and anti-diagonal (y-(w-1-x))\n    band_width = max(1, int(min(h, w) * 0.08))\n    main_dist = np.abs(ys - xs)\n    anti_dist = np.abs(ys - (w-1 - xs))\n    main_band = main_dist <= band_width\n    anti_band = anti_dist <= band_width\n    main_sum = float(np.count_nonzero(fg & main_band))\n    anti_sum = float(np.count_nonzero(fg & anti_band))\n    eps = 1e-6\n    return float((main_sum - anti_sum) / (main_sum + anti_sum + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of strong gradients whose orientation is near-vertical (useful to detect vertical strokes like 4)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mx = gray.max()\n    if mx > 1e-9:\n        gray = gray / float(mx)\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy) + 1e-9\n    orientations = np.arctan2(gy, gx)  # -pi..pi\n    # angle difference to vertical (pi/2) and -pi/2\n    angle_to_vert = np.minimum(np.abs(orientations - np.pi / 2), np.abs(orientations + np.pi / 2))\n    mask_strong = mag > (np.median(mag) * 0.7 + 1e-9)\n    if np.count_nonzero(mask_strong) == 0:\n        return 0.0\n    near_vert = np.sum((angle_to_vert < (np.pi / 8)) & mask_strong)\n    return float(near_vert / np.count_nonzero(mask_strong))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of horizontal transitions along the central row (captures number of stroke segments)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    # threshold\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.int32)\n    row_idx = h//2\n    if row_idx < 0 or row_idx >= h:\n        return 0.0\n    row = ink[row_idx, :]\n    if row.size < 2:\n        return 0.0\n    transitions = np.sum(np.abs(np.diff(row)))\n    # normalize by width\n    return float(transitions / (w - 1 + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a top horizontal stroke: proportion of ink in the top 20% rows'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_count = float(np.count_nonzero(ink[:top_rows, :]))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a horizontal bar near the middle: mean vertical gradient magnitude in central horizontal band normalized by global'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    vert_mag = np.abs(gy)\n    top = h // 3\n    bot = max(top + 1, (2 * h) // 3)\n    center_band = vert_mag[top:bot, :]\n    center_mean = np.mean(center_band) if center_band.size > 0 else 0.0\n    global_mean = np.mean(vert_mag) + 1e-9\n    return float(center_mean / global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Anti-diagonal asymmetry score: fraction of ink pixels that do not have a mirrored ink pixel across the anti-diagonal'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = image.mean(axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.uint8)\n    ys, xs = np.nonzero(ink)\n    total = ys.size\n    if total == 0:\n        return 0.0\n    mismatches = 0\n    # anti-diagonal mapping: (r, c) -> (w-1-c, h-1-r)\n    for r, c in zip(ys, xs):\n        mr = w - 1 - c\n        mc = h - 1 - r\n        # check bounds (mapped indices are (row, col) = (mr, mc))\n        if 0 <= mr < h and 0 <= mc < w:\n            if ink[mr, mc] == 0:\n                mismatches += 1\n        else:\n            mismatches += 1\n    return float(mismatches / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected ink runs along the central column region (average over central 3 cols); loops produce multiple runs, strokes usually one'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        flat = gray.flatten()\n        t1 = np.percentile(flat, 30)\n        t2 = np.percentile(flat, 70)\n        cand1 = gray < t1\n        cand2 = gray > t2\n        total = h * w\n        if 0 < cand1.sum() <= total // 2:\n            ink = cand1\n        elif 0 < cand2.sum() <= total // 2:\n            ink = cand2\n        else:\n            med = np.median(flat)\n            ink = gray < med\n        mid = w // 2\n        cols = list(range(max(0, mid - 1), min(w, mid + 2)))\n        run_counts = []\n        for c in cols:\n            col = ink[:, c]\n            # count runs of True\n            runs = 0\n            in_run = False\n            for val in col:\n                if val and not in_run:\n                    in_run = True\n                    runs += 1\n                elif not val:\n                    in_run = False\n            run_counts.append(runs)\n        if len(run_counts) == 0:\n            return 0.0\n        return float(np.mean(run_counts))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal gradient balance: (energy along 45deg - energy along 135deg) / total diagonal energy'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    diag45 = np.sum(np.abs(gx + gy))\n    diag135 = np.sum(np.abs(gx - gy))\n    tot = diag45 + diag135 + 1e-9\n    return float((diag45 - diag135) / tot)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative area of the largest inner hole to the bounding box area (useful: 9 often has one large loop, 8 has two moderate loops)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 0.0\n        y0, y1 = ys.min(), ys.max()\n        x0, x1 = xs.min(), xs.max()\n        sub = ~fg[y0:y1+1, x0:x1+1]\n        H, W = sub.shape\n        if H <= 0 or W <= 0:\n            return 0.0\n        visited = np.zeros_like(sub, dtype=np.bool_)\n        from collections import deque\n        q = deque()\n        for i in range(H):\n            for j in (0, W-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        for j in range(W):\n            for i in (0, H-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        while q:\n            y, x = q.popleft()\n            for dy in (-1, 0, 1):\n                for dx in (-1, 0, 1):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n        # find hole components and record largest\n        largest = 0\n        for i in range(H):\n            for j in range(W):\n                if sub[i, j] and not visited[i, j]:\n                    # new hole\n                    size = 0\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        size += 1\n                        for dy in (-1, 0, 1):\n                            for dx in (-1, 0, 1):\n                                ny, nx = y+dy, x+dx\n                                if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n                    if size > largest:\n                        largest = size\n        bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1)) + 1e-8\n        return float(largest / bbox_area)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of descending-diagonal gradient energy to ascending-diagonal gradient energy (detects \\\\ / strokes like in 2)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    # descending diagonal component ~ gx + gy, ascending ~ gx - gy\n    desc = np.abs(gx + gy)\n    asc = np.abs(gx - gy)\n    denom = np.sum(asc) + 1e-8\n    if denom == 0:\n        return 0.0\n    return float(np.sum(desc) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of horizontal ink runs across the center row (how many separated ink segments), normalized by width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    center_row = h // 2\n    thresh = np.percentile(gray, 50)\n    ink_dark = np.mean(gray.flatten()[:max(1, int(0.05*h*w))]) < np.mean(gray.flatten()[-max(1, int(0.05*h*w)):])\n    if ink_dark:\n        row = (gray[center_row, :] < thresh)\n    else:\n        row = (gray[center_row, :] > thresh)\n    # count runs of True in the row\n    runs = 0\n    inrun = False\n    for v in row:\n        if v and not inrun:\n            runs += 1\n            inrun = True\n        elif not v:\n            inrun = False\n    return float(runs / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of the largest hole centroid from image center normalized by width (positive -> hole to the right)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr  # True = ink, False = background\n    background = ~ink\n    # Flood fill external background starting from borders\n    seen = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    # push all border background pixels\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); seen[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); seen[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not seen[y, 0]:\n            dq.append((y, 0)); seen[y, 0] = True\n        if background[y, w - 1] and not seen[y, w - 1]:\n            dq.append((y, w - 1)); seen[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        # 4-neighbors\n        if y > 0 and background[y - 1, x] and not seen[y - 1, x]:\n            seen[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not seen[y + 1, x]:\n            seen[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not seen[y, x - 1]:\n            seen[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not seen[y, x + 1]:\n            seen[y, x + 1] = True; dq.append((y, x + 1))\n    # Holes are background pixels not reached by external fill\n    holes = background & (~seen)\n    hole_count = np.count_nonzero(holes)\n    if hole_count == 0:\n        return 0.0\n    ys, xs = np.where(holes)\n    cx = np.mean(xs)\n    center_x = (w - 1) / 2.0\n    return float((cx - center_x) / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant diagonal orientation ratio in the top-right quadrant (detects 7/9-style slanted strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # select top-right quadrant\n    top = gray[:h//2, w//2:]\n    if top.size == 0:\n        return 0.0\n    gy, gx = np.gradient(top.astype(float))\n    diag_pos = np.sum(np.abs(gx + gy))\n    diag_neg = np.sum(np.abs(gx - gy))\n    return float((diag_pos + 1e-9) / (diag_neg + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of connected ink components (large separate blobs) \u2014 some handwritten digits split into multiple disconnected strokes'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    visited = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    comp_count = 0\n    min_size = max(3, (h*w)//200)  # ignore tiny artifacts\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j] and not visited[i, j]:\n                size = 0\n                q = deque([(i, j)])\n                visited[i, j] = True\n                while q:\n                    ci, cj = q.popleft()\n                    size += 1\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and ink[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            q.append((ni, nj))\n                if size >= min_size:\n                    comp_count += 1\n    return float(comp_count)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the ink (y-coordinate of center of mass, 0=top, 1=bottom)'\n    import numpy as np\n    # Normalize to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Determine ink mask (assume ink is the minority of pixels)\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    if dark_mask.sum() <= (h * w) / 2:\n        ink = dark_mask\n    else:\n        ink = ~dark_mask\n    ink_count = float(ink.sum())\n    if ink_count == 0:\n        return 0.0\n    ys, xs = np.nonzero(ink)\n    centroid_y = ys.mean() / max(1.0, h - 1)\n    return float(centroid_y)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative difference in ink compactness between upper and lower halves: (compactness_upper - compactness_lower) where compactness = ink_area / boundary_count'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    med = np.median(gray); mean = np.mean(gray); thresh = 0.5*(mean+med)\n    if mean >= med:\n        ink = (gray > thresh).astype(np.int8)\n    else:\n        ink = (gray < thresh).astype(np.int8)\n    upper = ink[:h//2, :]\n    lower = ink[h//2:, :]\n    def compactness(region):\n        if region.size == 0:\n            return 0.0\n        area = np.count_nonzero(region)\n        pad = np.pad(region, 1, mode='constant', constant_values=0)\n        boundary = 0\n        for dy in (-1, 0, 1):\n            for dx in (-1, 0, 1):\n                if dx == 0 and dy == 0:\n                    continue\n                boundary += (pad[1+dy:1+dy+region.shape[0], 1+dx:1+dx+region.shape[1]] != region)\n        # boundary_count approximation: number of ink pixels that touch background\n        # compute neighbors that are background\n        neigh_sum = np.zeros_like(region, dtype=int)\n        for dy in (-1, 0, 1):\n            for dx in (-1, 0, 1):\n                if dx == 0 and dy == 0:\n                    continue\n                neigh_sum += pad[1+dy:1+dy+region.shape[0], 1+dx:1+dx+region.shape[1]]\n        boundary_count = np.sum((region == 1) & (neigh_sum < 8))\n        if boundary_count == 0:\n            return float(area)\n        return float(area) / float(boundary_count)\n    cu = compactness(upper)\n    cl = compactness(lower)\n    return float(cu - cl)\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of columns that contain a vertical ink run covering at least 60% of image height (indicates strong vertical strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    count = 0\n    minrun = max(1, int(0.6 * h))\n    for c in range(w):\n        col = ink[:, c].astype(int)\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= minrun):\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of columns that contain a vertical ink run covering at least 60% of image height (indicates strong vertical strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    count = 0\n    minrun = max(1, int(0.6 * h))\n    for c in range(w):\n        col = ink[:, c].astype(int)\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= minrun):\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside a small central circular region (higher for digits with centered hole like 0)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    r = max(1, min(h, w) // 6)\n    ys = np.arange(h)[:, None]\n    xs = np.arange(w)[None, :]\n    mask = ((ys - cy) ** 2 + (xs - cx) ** 2) <= (r ** 2)\n    bg = ~fg\n    region = bg & mask\n    denom = float(np.count_nonzero(mask)) + 1e-6\n    return float(np.count_nonzero(region) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative right-half horizontal edge strength: mean abs horizontal gradient in right half divided by global edge strength'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w <= 1:\n        return 0.0\n    gx = np.abs(np.diff(gray, axis=1))\n    total_mean = float(np.mean(gx)) + 1e-9\n    right_gx = gx[:, w // 2 - 1:] if (w // 2 - 1) >= 0 else gx\n    right_mean = float(np.mean(right_gx))\n    return float(right_mean / total_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal offset of the largest hole centroid from image center (0..0.5 normalized)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        best_area = 0\n        best_cx = None\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumx = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumx += x\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > best_area:\n                        best_area = area\n                        best_cx = (sumx / area)\n        if best_cx is None:\n            return 0.0\n        center = (w - 1) / 2.0\n        return float(abs(best_cx - center) / max(1.0, w))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) pixels in the right-middle region vs left-middle region (close to 1 => more empty on right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.5\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        fg = (gray < (med - delta)).astype(int)\n    else:\n        fg = (gray > (med + delta)).astype(int)\n    y0, y1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    mid_x0, mid_x1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    band = fg[y0:y1, mid_x0:mid_x1]\n    if band.size == 0:\n        return 0.5\n    mid = band.shape[1] // 2\n    left_band = band[:, :mid]\n    right_band = band[:, mid:]\n    left_bg = float((left_band == 0).sum())\n    right_bg = float((right_band == 0).sum())\n    total = left_bg + right_bg\n    if total == 0:\n        return 0.5\n    return float(right_bg / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal edge strength in the top band (captures a top bar) as top_horizontal / total_horizontal'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if h < 2:\n            return 0.0\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        gy, gx = np.gradient(gray)\n        horiz = np.abs(gx)\n        top_band = horiz[:max(1, h//4), :]\n        total = np.sum(horiz)\n        top_sum = np.sum(top_band)\n        if total <= 0:\n            return 0.0\n        return float(top_sum / (total + 1e-12))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset: normalized x-centroid of ink minus 0.5 (negative = left bias, positive = right bias)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    bin_img = (gray < thresh).astype(np.float32)\n    if np.sum(bin_img) < 1:\n        bin_img = (gray > thresh).astype(np.float32)\n        if np.sum(bin_img) < 1:\n            return 0.0\n    cols = np.arange(w, dtype=float)\n    x_centroid = np.sum(np.sum(bin_img, axis=0) * cols) / (np.sum(bin_img) + 1e-8)\n    return float((x_centroid / max(1.0, w)) - 0.5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal gradient strength in the right half: mean|dx| / (mean|dy| + eps) on right half'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    dy, dx = np.gradient(gray)\n    right_dx = np.abs(dx[:, w//2:])\n    right_dy = np.abs(dy[:, w//2:])\n    mean_dx = float(np.mean(right_dx))\n    mean_dy = float(np.mean(right_dy))\n    result = float(mean_dx / (mean_dy + 1e-9))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized average absolute column difference between left and flipped right halves'\n    # Convert to grayscale safely\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # split columns\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w][:, ::-1]  # flipped right part to align with left\n    # if mismatch in sizes (odd width), pad smaller one\n    if left.shape[1] != right.shape[1]:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    # compute normalized L1 difference\n    denom = np.maximum(1.0, np.mean(np.abs(left)) + 1e-6)\n    score = np.mean(np.abs(left - right)) / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of horizontal gradient energy in the upper half of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.size == 0:\n        return 0.0\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    gy, gx = np.gradient(gray.astype(np.float32))\n    abs_gx = np.abs(gx)\n    h = gray.shape[0]\n    mid = max(1, h // 2)\n    upper_energy = np.sum(abs_gx[:mid, :])\n    total_energy = np.sum(abs_gx) + 1e-9\n    return float(upper_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute diagonal (top-right to bottom-left) gradient energy inside the top-right quadrant'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    # quadrant bounds (top-right)\n    r0, r1 = 0, max(1, h // 2)\n    c0, c1 = max(0, w // 2), w\n    sub = gray[r0:r1, c0:c1]\n    if sub.size == 0:\n        return 0.0\n    gy, gx = np.gradient(sub)\n    # projection onto diagonal vector (1,-1) normalized\n    proj = (gx - gy) / np.sqrt(2.0)\n    return float(np.mean(np.abs(proj)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient (horizontal edge strength) in the bottom third of the image'\n    # handle grayscale/RGB and normalize to [0,1]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = gray.min(), gray.max()\n    norm = (gray - mn) / (mx - mn + 1e-9)\n    gy, gx = np.gradient(norm)\n    bottom = norm[2*h//3:h, :]\n    bottom_gy = gy[2*h//3:h, :]\n    if bottom_gy.size == 0:\n        return 0.0\n    return float(np.mean(np.abs(bottom_gy)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum foreground projection in top half to maximum in bottom half (top_peak / bottom_peak)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    proj = np.sum(fg.astype(np.int32), axis=1)  # per-row foreground count\n    mid = h // 2\n    top_peak = float(np.max(proj[:max(1, mid)])) if mid > 0 else float(np.max(proj))\n    bottom_peak = float(np.max(proj[mid:])) if mid < h else float(np.max(proj))\n    return float(top_peak / (bottom_peak + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative bias of ink between upper-right and upper-left quadrants: (UR - UL) / (UR + UL + eps) in upper half'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh)\n    h, w = ink.shape\n    mid_r = h // 2\n    mid_c = w // 2\n    upper = ink[0:mid_r, :]\n    ul = np.count_nonzero(upper[:, 0:mid_c])\n    ur = np.count_nonzero(upper[:, mid_c:w])\n    val = (float(ur) - float(ul)) / (float(ur) + float(ul) + 1e-9)\n    return float(val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized radial variance of ink pixels around centroid (lower => more circular shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if ys.size == 0:\n        return 0.0\n    cy = ys.mean()\n    cx = xs.mean()\n    d = np.sqrt((ys - cy)**2 + (xs - cx)**2)\n    mean_d = d.mean() + 1e-8\n    var_d = d.var()\n    # normalized variance\n    return float(var_d / (mean_d**2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of total edge energy located in a small circular region near the lower-right (detects 9 lower loop)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    total = float(np.sum(grad)) + 1e-9\n    # circle centered toward lower-right\n    cy, cx = int(3 * h / 4), int(3 * w / 4)\n    r = max(1, min(h, w) // 8)\n    yy, xx = np.ogrid[:h, :w]\n    mask = (yy - cy) ** 2 + (xx - cx) ** 2 <= r * r\n    region_sum = float(np.sum(grad[mask]))\n    return float(region_sum) / total\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal gradient magnitude in the central horizontal band normalized by overall gradient (bridge strength)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    mn, mx = gray.min(), gray.max()\n    rng = mx - mn\n    if rng <= 0:\n        return 0.0\n    norm = (gray - mn) / (rng + 1e-9)\n    gy, gx = np.gradient(norm)\n    abs_gx = np.abs(gx)\n    ch0 = h // 3\n    ch1 = 2 * h // 3\n    center_band = abs_gx[ch0:ch1, :]\n    center_mean = float(np.mean(center_band))\n    overall_mean = float(np.mean(abs_gx)) + 1e-9\n    return center_mean / overall_mean\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in mean absolute horizontal gradient between right and left halves normalized by global gradient energy'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.asarray(image).astype(float)\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    left = abs_gx[:, :w//2]\n    right = abs_gx[:, w//2:]\n    mean_left = left.mean() if left.size else 0.0\n    mean_right = right.mean() if right.size else 0.0\n    global_mean = abs_gx.mean() + 1e-9\n    return float((mean_right - mean_left) / global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical gradient energy concentrated in the center third of the image'\n    if image is None:\n        return 0.0\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.abs(gy)\n    total_energy = vert_energy.sum() + 1e-9\n    c1 = w // 3\n    c2 = 2 * w // 3\n    center_energy = vert_energy[:, c1:c2].sum()\n    return float(center_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry score: average absolute column difference between left and flipped right'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    # compare left half to flipped right half\n    mid = w // 2\n    left = norm[:, :mid]\n    right = norm[:, w - mid:]\n    right_flipped = right[:, ::-1]\n    # resize if they mismatch due to odd width\n    if left.shape[1] != right_flipped.shape[1]:\n        minc = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minc]\n        right_flipped = right_flipped[:, :minc]\n    score = np.mean(np.abs(left - right_flipped))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: (perimeter^2) / area for the foreground (higher means thinner/elongated strokes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    p10, p90 = np.percentile(gray, (10, 90))\n    low_mean = float(np.mean(gray[gray <= p10])) if np.any(gray <= p10) else p10\n    high_mean = float(np.mean(gray[gray >= p90])) if np.any(gray >= p90) else p90\n    median = np.median(gray)\n    if low_mean < high_mean:\n        ink = (gray <= median).astype(np.uint8)\n    else:\n        ink = (gray >= median).astype(np.uint8)\n    area = float(np.count_nonzero(ink))\n    if area <= 0:\n        return 0.0\n    # approximate perimeter: foreground pixels that touch background\n    perimeter = 0\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j]:\n                for di, dj in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                    ni, nj = i + di, j + dj\n                    if not (0 <= ni < h and 0 <= nj < w and ink[ni, nj]):\n                        perimeter += 1\n    if perimeter <= 0:\n        return 0.0\n    compactness = (perimeter * perimeter) / (area + 1e-9)\n    return float(compactness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient in right half divided by left half ( >1 means stronger vertical changes on right side )'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    mag_v = np.abs(gy)\n    mid = w // 2\n    left_mean = float(np.mean(mag_v[:, 0:mid])) if mid > 0 else 0.0\n    right_mean = float(np.mean(mag_v[:, mid:])) if mid < w else 0.0\n    denom = left_mean + 1e-9\n    return float(right_mean / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-quarter horizontal edge strength: average absolute horizontal gradient magnitude in top 25% of image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = gray[:top_h, :]\n    # horizontal gradient: difference along columns\n    horiz_grad = np.abs(np.diff(top_region, axis=1))\n    # average normalized by intensity range\n    denom = max(1.0, float(np.ptp(gray)))\n    score = float(horiz_grad.mean()) / denom\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal run length of ink in the top third of the image (normalized by width)'\n    import numpy as np\n    arr = np.asarray(image)\n    h, w = arr.shape[:2]\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2).astype(float)\n    else:\n        gray = arr.astype(float)\n    mn, mx = gray.min(), gray.max()\n    rng = mx - mn + 1e-9\n    g = (gray - mn) / rng\n    fg = (g < 0.5) if (g.mean() > 0.5) else (g > 0.5)\n    top_h = max(1, h // 3)\n    run_lengths = []\n    for r in range(top_h):\n        row = fg[r].astype(np.int32)\n        if row.sum() == 0:\n            continue\n        # find run lengths\n        dif = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        lengths = (ends - starts).tolist()\n        run_lengths.extend(lengths)\n    if len(run_lengths) == 0:\n        return 0.0\n    avg_len = float(np.mean(run_lengths))\n    return float(avg_len / float(w + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of enclosed background components (holes) detected inside the foreground'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = float(np.mean(gray))\n    mask = gray < thresh\n    prop = np.count_nonzero(mask) / float(h * w) if h * w > 0 else 0.0\n    if prop > 0.6:\n        mask = ~mask\n    # background mask: True where background\n    bg = ~mask\n    # flood-fill external background from borders\n    visited = np.zeros_like(bg, dtype=bool)\n    from collections import deque\n    q = deque()\n    # add border background pixels\n    for c in range(w):\n        if bg[0, c] and not visited[0, c]:\n            visited[0, c] = True\n            q.append((0, c))\n        if bg[h - 1, c] and not visited[h - 1, c]:\n            visited[h - 1, c] = True\n            q.append((h - 1, c))\n    for r in range(h):\n        if bg[r, 0] and not visited[r, 0]:\n            visited[r, 0] = True\n            q.append((r, 0))\n        if bg[r, w - 1] and not visited[r, w - 1]:\n            visited[r, w - 1] = True\n            q.append((r, w - 1))\n    # 4-neighbor flood\n    while q:\n        r, c = q.popleft()\n        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w and bg[nr, nc] and not visited[nr, nc]:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n    # any background pixel not visited is a hole; count connected hole components\n    holes_mask = bg & (~visited)\n    if not np.any(holes_mask):\n        return 0.0\n    hole_visited = np.zeros_like(holes_mask, dtype=bool)\n    hole_count = 0\n    for r in range(h):\n        for c in range(w):\n            if holes_mask[r, c] and not hole_visited[r, c]:\n                hole_count += 1\n                # flood this hole\n                dq = deque([(r, c)])\n                hole_visited[r, c] = True\n                while dq:\n                    rr, cc = dq.popleft()\n                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                        nr, nc = rr + dr, cc + dc\n                        if 0 <= nr < h and 0 <= nc < w and holes_mask[nr, nc] and not hole_visited[nr, nc]:\n                            hole_visited[nr, nc] = True\n                            dq.append((nr, nc))\n    return float(hole_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink pixels located in the top quarter of the image (top density ratio)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink_mask_candidate = gray < thresh\n    if np.count_nonzero(ink_mask_candidate) > (h * w / 2):\n        ink = (~ink_mask_candidate).astype(float)\n    else:\n        ink = ink_mask_candidate.astype(float)\n    top_rows = max(1, h // 4)\n    top_ink = np.sum(ink[:top_rows, :])\n    total_ink = np.sum(ink)\n    if total_ink == 0:\n        return 0.0\n    return float(top_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient on right half to left half (right/left)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    abs_v = np.abs(gy)\n    left_mean = abs_v[:, :w//2].mean() if w//2 > 0 else 0.0\n    right_mean = abs_v[:, w//2:].mean() if w - w//2 > 0 else 0.0\n    # avoid division by zero\n    return float((right_mean + 1e-8) / (left_mean + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute diagonal gradient along NW-SE vs NE-SW (detects dominant diagonal stroke direction)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gx, gy = np.gradient(gray)\n    # diagonal components\n    diag1 = (gx + gy) / np.sqrt(2.0)  # NW-SE\n    diag2 = (gx - gy) / np.sqrt(2.0)  # NE-SW\n    m1 = np.mean(np.abs(diag1))\n    m2 = np.mean(np.abs(diag2))\n    return float(m1 / (m2 + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of internal background pixels (holes) normalized by ink area using border flood fill'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    bg = ~ink\n    # border-reachable background initialization\n    reachable = np.zeros_like(bg, dtype=bool)\n    reachable[0, :] = bg[0, :]\n    reachable[-1, :] = bg[-1, :]\n    reachable[:, 0] = reachable[:, 0] | bg[:, 0]\n    reachable[:, -1] = reachable[:, -1] | bg[:, -1]\n    # iterative expansion using 8-neighborhood until stable or iteration cap\n    pad = lambda arr: np.pad(arr, 1, mode='constant', constant_values=False)\n    hcap = h * w\n    for _ in range(min(1000, hcap)):\n        old = reachable.copy()\n        p = pad(reachable)\n        neigh = (\n            p[0:h, 0:w] | p[0:h, 1:w+1] | p[0:h, 2:w+2] |\n            p[1:h+1, 0:w] | p[1:h+1, 2:w+2] |\n            p[2:h+2, 0:w] | p[2:h+2, 1:w+1] | p[2:h+2, 2:w+2]\n        )\n        reachable = reachable | (bg & neigh)\n        if reachable.sum() == old.sum():\n            break\n    holes = bg & (~reachable)\n    hole_area = float(holes.sum())\n    ink_area = float(ink.sum())\n    if ink_area == 0:\n        return 0.0\n    return float(hole_area / (ink_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels that lie within a border band (border ink density / total ink)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    bw = max(1, min(h, w) // 10)\n    border_mask = np.zeros_like(ink, dtype=bool)\n    border_mask[:bw, :] = True\n    border_mask[-bw:, :] = True\n    border_mask[:, :bw] = True\n    border_mask[:, -bw:] = True\n    total = float(np.sum(ink))\n    if total == 0:\n        return 0.0\n    border = float(np.sum(ink & border_mask))\n    return float(border / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Local gradient-orientation variability in the central region (high when strokes cross like in 8)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        norm = (gray - mn) / (mx - mn)\n    else:\n        norm = gray - mn\n    gy, gx = np.gradient(norm)\n    # compute orientation in radians\n    orient = np.arctan2(gy, gx)\n    r0, r1 = h // 3, (2 * h) // 3\n    c0, c1 = w // 3, (2 * w) // 3\n    cen = orient[r0:r1, c0:c1]\n    if cen.size == 0:\n        return 0.0\n    # circular variance approximation: 1 - R where R = sqrt(mean(cos)^2 + mean(sin)^2)\n    cos_mean = float(np.mean(np.cos(cen)))\n    sin_mean = float(np.mean(np.sin(cen)))\n    R = np.sqrt(cos_mean * cos_mean + sin_mean * sin_mean)\n    circ_var = 1.0 - R\n    return float(circ_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of significant horizontal-edge peaks across rows (useful to detect two-curved 3 vs single bars)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy = np.gradient(gray, axis=0)  # response to horizontal edges\n    row_strength = np.mean(np.abs(gy), axis=1)\n    # smooth with simple 3-point moving average\n    kernel = np.array([1., 1., 1.]) / 3.0\n    padded = np.r_[row_strength[0], row_strength, row_strength[-1]]\n    smooth = np.convolve(padded, kernel, mode='valid')\n    mean = smooth.mean()\n    std = smooth.std()\n    # peak threshold\n    thresh = mean + 0.5 * std\n    peaks = np.where(smooth > thresh)[0]\n    # compress counts by grouping neighboring indices as a single peak\n    if peaks.size == 0:\n        return 0.0\n    groups = 1 + np.sum(np.diff(peaks) > 1)\n    return float(groups)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean dominant edge angle in degrees (edges from left-top to right-bottom are ~45\u00b0; captures slanted 7)'\n    import numpy as np\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = _np.gradient(gray)\n    mag = _np.hypot(gx, gy)\n    if mag.sum() == 0:\n        return 0.0\n    # consider only sufficiently strong edges\n    thr = _np.percentile(mag.flatten(), 60)\n    mask = mag >= thr\n    angles = _np.arctan2(gy[mask], gx[mask])  # radians\n    if angles.size == 0:\n        return 0.0\n    mean_angle = _np.mean(angles)\n    # return degrees in range [-180,180]\n    deg = float(_np.degrees(mean_angle))\n    return deg\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight ink bounding box (1.0 ~ square); distinguishes tall strokes from round loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = gray < thr\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = gray > thr\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n    bbox_h = max_r - min_r + 1\n    bbox_w = max_c - min_c + 1\n    if bbox_w <= 0:\n        return float(bbox_h)\n    return float(bbox_h) / float(bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a top horizontal stroke: proportion of ink in the top 20% rows'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_count = float(np.count_nonzero(ink[:top_rows, :]))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of 8-connected ink components normalized by total pixels (higher if disjoint pieces exist)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thresh = (float(np.min(gray)) + float(np.max(gray))) / 2.0\n    ink = (gray < thresh)\n    visited = np.zeros_like(ink, dtype=bool)\n    comps = 0\n    stack = []\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j] and not visited[i, j]:\n                comps += 1\n                # flood fill (8-connected)\n                stack.append((i, j))\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if (0 <= ny < h) and (0 <= nx < w) and not visited[ny, nx] and ink[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n    return float(comps / (h * w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized preference between the two diagonal gradient directions: (sum|dx+dy|-sum|dx-dy|) / (sum total)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    try:\n        dy, dx = np.gradient(gray)\n    except Exception:\n        dy = np.zeros_like(gray)\n        dx = np.zeros_like(gray)\n    diag1 = np.sum(np.abs(dx + dy))\n    diag2 = np.sum(np.abs(dx - dy))\n    return float((diag1 - diag2) / (diag1 + diag2 + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Elongation ratio from PCA (largest eigenvalue / smallest eigenvalue) of foreground coordinates; high for thin digits like \"1\"'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    coords = np.argwhere(ink).astype(float)\n    if coords.shape[0] < 3:\n        return 0.0\n    # compute covariance of (x,y) where we use columns as x, rows as y\n    ys = coords[:, 0]\n    xs = coords[:, 1]\n    X = np.column_stack((xs - np.mean(xs), ys - np.mean(ys)))\n    cov = np.cov(X, rowvar=False)\n    # ensure 2x2\n    if cov.shape != (2,2):\n        return 0.0\n    eig = np.linalg.eigvals(cov)\n    eig = np.real(eig)\n    eig = np.sort(eig)\n    eps = 1e-9\n    ratio = (float(eig[-1]) + eps) / (float(eig[0]) + eps)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical edge strength in the left half (useful to detect left-side vertical strokes)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # scale to 0..1\n    vmin, vmax = float(np.min(gray)), float(np.max(gray))\n    if vmax == vmin:\n        return 0.0\n    norm = (gray - vmin) / (vmax - vmin)\n    gy, gx = np.gradient(norm)\n    vert = np.abs(gy)\n    left = vert[:, :w//2]\n    return float(np.mean(left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative energy of image gradients aligned with -45\u00b0 diagonal vs +45\u00b0 diagonal (captures diagonal strokes like in 7)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.hypot(gx, gy)\n    # angles in [-pi, pi]\n    ang = np.arctan2(gy, gx)\n    # Gaussian-like weighting around -45deg (-pi/4) and +45deg (+pi/4)\n    target1 = -np.pi / 4\n    target2 = np.pi / 4\n    sigma = 0.35\n    w1 = np.exp(-0.5 * ((ang - target1) ** 2) / (sigma ** 2))\n    w2 = np.exp(-0.5 * ((ang - target2) ** 2) / (sigma ** 2))\n    e1 = float(np.sum(mag * w1))\n    e2 = float(np.sum(mag * w2))\n    tot = e1 + e2 + 1e-8\n    return float((e1 - e2) / tot)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of junction pixels (8-neighbor ink neighbors >= 3) indicating intersections like in \"4\"'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray)\n    ink = (gray < thr).astype(np.uint8)\n    # handle degenerate\n    if ink.sum() == 0:\n        return 0.0\n    # compute neighbor counts by shifted sums\n    neighbors = np.zeros_like(ink, dtype=np.int32)\n    shifts = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for dy, dx in shifts:\n        ys = slice(max(0, dy), None if dy >= 0 else dy)\n        xs = slice(max(0, dx), None if dx >= 0 else dx)\n        target_ys = slice(max(0, -dy), None if dy <= 0 else h - dy)\n        target_xs = slice(max(0, -dx), None if dx <= 0 else w - dx)\n        neighbors[target_ys, target_xs] += ink[ys, xs]\n    junctions = np.logical_and(ink == 1, neighbors >= 3)\n    return float(int(np.count_nonzero(junctions)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute 45-degree diagonal gradient to mean absolute -45-degree diagonal gradient (skewed stroke indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # compute diagonal differences\n    d1 = np.abs(gray[1:, 1:] - gray[:-1, :-1])\n    d2 = np.abs(gray[1:, :-1] - gray[:-1, 1:])\n    m1 = float(np.mean(d1)) + 1e-9\n    m2 = float(np.mean(d2)) + 1e-9\n    return float(m1 / m2)\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal component strength: ratio of largest to smallest eigenvalue of foreground coordinate covariance (>=1.0)'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = (gray_n < thr) if np.mean(gray_n) > 0.5 else (gray_n > thr)\n    ys, xs = np.where(fg)\n    if xs.size < 2:\n        return 1.0\n    coords = np.vstack([xs.astype(float), ys.astype(float)])\n    coords -= np.mean(coords, axis=1, keepdims=True)\n    cov = np.cov(coords)\n    # numerical stability\n    try:\n        vals = np.linalg.eigvalsh(cov)\n        vals = np.clip(vals, 1e-12, None)\n        ratio = float(vals[-1] / vals[0])\n    except Exception:\n        ratio = 1.0\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient: detects prevalence of horizontal bars vs round edges'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    if gray.size == 0:\n        return 1.0\n    try:\n        gy, gx = np.gradient(gray)  # gy: d/drow (vertical), gx: d/dcol (horizontal)\n    except Exception:\n        return 1.0\n    mean_abs_gx = float(np.mean(np.abs(gx)))\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    return float(mean_abs_gx / (mean_abs_gy + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Global slant estimate: arctangent of best-fit line slope to edge pixels, normalized to [-1,1]'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float64)\n    h, w = gray.shape[:2]\n    med = np.percentile(gray, 50)\n    if gray.max() == gray.min():\n        return 0.0\n    low_mean = np.mean(gray[gray <= med]) if np.any(gray <= med) else med\n    high_mean = np.mean(gray[gray > med]) if np.any(gray > med) else med\n    ink = (gray <= med).astype(np.uint8) if low_mean < high_mean else (gray >= med).astype(np.uint8)\n    # find edge pixels by neighbor variance: ink pixels that have at least one non-ink neighbor\n    pad = np.pad(ink, 1, mode='constant', constant_values=0)\n    neigh_sum = (pad[0:-2,0:-2] + pad[0:-2,1:-1] + pad[0:-2,2:] +\n                 pad[1:-1,0:-2] +                 0 + pad[1:-1,2:] +\n                 pad[2:,0:-2]   + pad[2:,1:-1]   + pad[2:,2:])\n    center = pad[1:-1,1:-1]\n    edge = np.logical_and(center == 1, neigh_sum < 8)\n    ys, xs = np.nonzero(edge)\n    if xs.size < 2:\n        return 0.0\n    # fit line x = a*y + b (so slope sign corresponds to slant of strokes)\n    a, b = np.polyfit(ys.astype(np.float64), xs.astype(np.float64), 1)\n    ang = np.arctan(a)  # between -pi/2..pi/2\n    return float(ang / (np.pi / 2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal gradient energy (sum|dI/dy| / (sum|dI/dx| + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    vert_energy = np.sum(np.abs(gy))\n    horz_energy = np.sum(np.abs(gx))\n    return float(vert_energy / (horz_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of enclosed background regions (holes) inside ink strokes (helps detect two loops like in \"8\")'\n    import numpy as np\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    # normalize to 0..1\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn > eps:\n        g = (gray - mn) / (mx - mn)\n    else:\n        g = np.zeros_like(gray, dtype=float)\n    # infer ink polarity from border brightness\n    border = np.concatenate([g[0, :], g[-1, :], g[:, 0], g[:, -1]])\n    border_mean = float(np.mean(border)) if border.size else 1.0\n    if border_mean > 0.5:\n        ink = g < 0.5\n    else:\n        ink = g > 0.5\n    back = ~ink\n    visited = np.zeros_like(back, dtype=bool)\n    holes = 0\n    # Flood-fill background components and count those not touching border -> holes\n    for r in range(h):\n        for c in range(w):\n            if back[r, c] and not visited[r, c]:\n                stack = [(r, c)]\n                touch_border = False\n                while stack:\n                    rr, cc = stack.pop()\n                    if visited[rr, cc]:\n                        continue\n                    visited[rr, cc] = True\n                    if rr == 0 or rr == h - 1 or cc == 0 or cc == w - 1:\n                        touch_border = True\n                    # 4-neighborhood\n                    if rr > 0 and back[rr - 1, cc] and not visited[rr - 1, cc]:\n                        stack.append((rr - 1, cc))\n                    if rr < h - 1 and back[rr + 1, cc] and not visited[rr + 1, cc]:\n                        stack.append((rr + 1, cc))\n                    if cc > 0 and back[rr, cc - 1] and not visited[rr, cc - 1]:\n                        stack.append((rr, cc - 1))\n                    if cc < w - 1 and back[rr, cc + 1] and not visited[rr, cc + 1]:\n                        stack.append((rr, cc + 1))\n                if not touch_border:\n                    holes += 1\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center gap fraction: fraction of central columns in the top quarter that are completely empty (useful to detect open tops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    mask = mask.astype(np.uint8)\n    top_h = max(1, h // 4)\n    c0 = w // 4\n    c1 = 3 * w // 4\n    central = mask[0:top_h, c0:c1]\n    if central.shape[1] == 0:\n        return 0.0\n    empty_cols = np.sum(np.all(central == 0, axis=0))\n    return float(empty_cols / (central.shape[1] + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of ink/background transitions per row in the central third of rows (measures stroke complexity and crossings like the crossbar in \"4\")'\n    import numpy as np\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray)\n    mask = gray < thr\n    prop = mask.mean()\n    if prop > 0.9 or prop < 0.01:\n        mask = gray > thr\n    r1 = h // 3; r2 = min(h, 2 * h // 3)\n    if r2 <= r1:\n        return 0.0\n    region = mask[r1:r2, :]\n    # transitions per row: sum of absolute diffs along columns\n    diffs = np.abs(np.diff(region.astype(np.int8), axis=1))\n    transitions_per_row = diffs.sum(axis=1)\n    avg_trans = float(transitions_per_row.mean() / (w + 1e-9))\n    return avg_trans\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in top-left quadrant to top-right quadrant (helps detect slanted/top-left hooks)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    mn, mx = gray.min(), gray.max()\n    if mx - mn < 1e-6:\n        return 0.5\n    scaled = ((gray - mn) / (mx - mn) * 255.0).astype(np.uint8)\n    hist, _ = np.histogram(scaled, bins=256, range=(0, 255))\n    prob = hist.astype(np.float64) / scaled.size\n    cum_prob = np.cumsum(prob)\n    cum_mean = np.cumsum(prob * np.arange(256))\n    total_mean = cum_mean[-1]\n    denom = cum_prob * (1.0 - cum_prob) + 1e-12\n    between = (total_mean * cum_prob - cum_mean) ** 2 / denom\n    thr_idx = int(np.nanargmax(between))\n    thr = thr_idx\n    mask = (scaled <= thr)\n    mid_w = w // 2\n    mid_h = h // 2\n    top_left = mask[:mid_h, :mid_w].sum()\n    top_right = mask[:mid_h, mid_w:].sum()\n    if top_right == 0:\n        return float(top_left)\n    return float(top_left / top_right)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient restricted to the right half (captures right-side curvature)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        # smooth-ish by simple local mean to reduce noise\n        # compute gradients\n        gx, gy = np.gradient(gray.astype(float))\n        right_gx = gx[:, w//2:]\n        right_gy = gy[:, w//2:]\n        mag_x = np.mean(np.abs(right_gx)) if right_gx.size > 0 else 0.0\n        mag_y = np.mean(np.abs(right_gy)) if right_gy.size > 0 else 0.0\n        if mag_y == 0:\n            return float(mag_x)\n        return float(mag_x) / float(mag_y)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio: number of edge (boundary) ink pixels divided by total ink pixels (higher => more complex or broken strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thresh = np.percentile(gray, 40)\n    binary = (gray < thresh).astype(np.uint8)\n    if np.count_nonzero(binary) == 0:\n        thresh = np.mean(gray)\n        binary = (gray < thresh).astype(np.uint8)\n    area = float(np.count_nonzero(binary))\n    if area == 0.0:\n        return 0.0\n    pad = np.pad(binary, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    neigh_sum = (pad[:-2, :-2] + pad[:-2, 1:-1] + pad[:-2, 2:] +\n                 pad[1:-1, :-2] + pad[1:-1, 2:] +\n                 pad[2:, :-2] + pad[2:, 1:-1] + pad[2:, 2:])\n    # edge pixels have at least one background neighbor => neigh_sum < 8\n    edge_pixels = np.logical_and(binary == 1, neigh_sum < 8)\n    perimeter = float(np.count_nonzero(edge_pixels))\n    return perimeter / area\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight ink bounding box (1.0 ~ square); distinguishes tall strokes from round loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = gray < thr\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = gray > thr\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n    bbox_h = max_r - min_r + 1\n    bbox_w = max_c - min_c + 1\n    if bbox_w <= 0:\n        return float(bbox_h)\n    return float(bbox_h) / float(bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical edge strength in the lower half: mean absolute horizontal-gradient in bottom half divided by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    grayn = (gray - mn) / (mx - mn + 1e-8)\n    gy, gx = np.gradient(grayn)\n    lower_gy = gy[h//2:, :]\n    mean_lower = float(np.mean(np.abs(lower_gy)))\n    mean_global = float((np.mean(np.abs(gx)) + np.mean(np.abs(gy))) / 2.0 + 1e-10)\n    return float(mean_lower / mean_global)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal transitions per row in the central 30% band, normalized by width'\n    import numpy as np\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p30, p70 = np.percentile(gray, 30), np.percentile(gray, 70)\n    mask = (gray <= p30) if np.sum(gray <= p30) <= np.sum(gray >= p70) and np.sum(gray <= p30) > 0 else ((gray >= p70) if np.sum(gray >= p70) > 0 else (gray < gray.mean()))\n    M = mask.astype(np.uint8)\n    top = max(0, h//2 - max(1, h//6))\n    bottom = min(h, h//2 + max(1, h//6))\n    band = M[top:bottom, :] if bottom > top else M\n    if band.size == 0:\n        return 0.0\n    diffs = np.abs(np.diff(band, axis=1))\n    transitions_per_row = diffs.sum(axis=1)\n    avg_trans = transitions_per_row.mean() / (w + 1e-9)\n    return float(avg_trans)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized distance from top to the first ink row (top gap / image height)'\n    import numpy as np\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    rows = np.where(mask.any(axis=1))[0]\n    if rows.size == 0:\n        return 1.0\n    top_row = rows.min()\n    return float(top_row / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient in the central horizontal band (high for strong horizontal strokes like crossbars)'\n    import numpy as np\n    # prepare grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # avoid uniform images\n    p10, p90 = np.percentile(gray, (10, 90))\n    if (p90 - p10) < 1e-6 or h < 3:\n        return 0.0\n    # gradients\n    gy, gx = np.gradient(gray.astype(float))\n    # central band (middle third)\n    r0, r1 = h // 3, (2 * h) // 3\n    center_abs_gy = np.mean(np.abs(gy[r0:r1, :]))\n    global_abs_gy = np.mean(np.abs(gy)) + 1e-9\n    return float(center_abs_gy / global_abs_gy)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of radial distances of foreground pixels from centroid (normalized) \u2014 \"0\" tends to have larger circular spread'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.0\n    cx, cy = np.mean(xs), np.mean(ys)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = np.std(dists)\n    # normalize by image diagonal\n    diag = np.sqrt(w * w + h * h)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink mass located in the top-right quadrant (helps detect digits with right-side strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.float64)\n    if ink.sum() <= 1e-9:\n        return 0.0\n    top = slice(0, h//2)\n    right = slice(w//2, w)\n    top_right = ink[top, right].sum()\n    return float(top_right / (ink.sum() + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-left quadrant ink density normalized by overall ink density (captures presence of upper-left vertical stroke / mass)'\n    import numpy as np\n    try:\n        h, w = image.shape[:2]\n        if h == 0 or w == 0:\n            return 0.0\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n        midpoint = (gray.max() + gray.min()) / 2.0\n        if np.mean(gray) > midpoint:\n            ink = gray < p40\n        else:\n            ink = gray > p60\n        ul = ink[:h // 2, :w // 2]\n        overall = ink\n        overall_count = float(np.count_nonzero(overall))\n        if overall_count == 0.0:\n            return 0.0\n        ul_count = float(np.count_nonzero(ul))\n        return (ul_count / float(ul.size + 1e-12)) / (overall_count / float(overall.size))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of distances from centroid (radial spread normalized by half-min-dim)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    thr = np.percentile(gray, 40)\n    ink = gray <= thr\n    if np.count_nonzero(ink) == 0:\n        thr = np.percentile(gray, 60); ink = gray <= thr\n    ys, xs = np.where(ink)\n    if xs.size == 0:\n        return 0.0\n    h, w = gray.shape[:2]\n    cx = xs.mean(); cy = ys.mean()\n    dx = (xs - cx) / (min(h, w) / 2.0 + 1e-6)\n    dy = (ys - cy) / (min(h, w) / 2.0 + 1e-6)\n    d = np.sqrt(dx * dx + dy * dy)\n    return float(np.std(d))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal gradient energy: (negative-slope minus positive-slope) normalized to [-1,1]'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    norm = (gray - mn) / (mx - mn + 1e-9)\n    gy, gx = np.gradient(norm)\n    # energy for negative slope edges (~top-right to bottom-left) and positive slope\n    energy_neg = np.sum(np.abs(gx - gy))\n    energy_pos = np.sum(np.abs(gx + gy))\n    denom = energy_neg + energy_pos + 1e-9\n    return float((energy_neg - energy_pos) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Angle in degrees from global ink centroid to the top-right ink centroid (captures diagonal down-right of 7)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    pad_h = max(1, h // 10)\n    pad_w = max(1, w // 10)\n    border = np.concatenate([gray[:pad_h, :].ravel(), gray[-pad_h:, :].ravel(),\n                             gray[:, :pad_w].ravel(), gray[:, -pad_w:].ravel()])\n    border_mean = float(np.mean(border)) if border.size else float(np.mean(gray))\n    rng = float(np.max(gray) - np.min(gray) + 1e-8)\n    if np.median(gray) < border_mean:\n        thresh = border_mean - 0.08 * rng\n        ink = (gray < thresh).astype(np.uint8)\n    else:\n        thresh = border_mean + 0.08 * rng\n        ink = (gray > thresh).astype(np.uint8)\n    ys, xs = np.nonzero(ink)\n    if ys.size == 0:\n        return 0.0\n    cx_global = float(np.mean(xs))\n    cy_global = float(np.mean(ys))\n    # top-right region (top half, right half)\n    mask_tr = np.zeros_like(ink)\n    mask_tr[:h//2, w//2:] = 1\n    ys_tr, xs_tr = np.nonzero(ink * mask_tr)\n    if ys_tr.size == 0:\n        return 0.0\n    cx_tr = float(np.mean(xs_tr))\n    cy_tr = float(np.mean(ys_tr))\n    dx = cx_tr - cx_global\n    dy = cy_tr - cy_global\n    angle = np.degrees(np.arctan2(dy, dx))\n    return float(angle)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant gradient angle (circular mean) normalized to [-1,1]; captures prevailing stroke orientation'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gx, gy = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    if np.sum(mag) == 0:\n        return 0.0\n    ang = np.arctan2(gy, gx)  # [-pi, pi]\n    # circular mean\n    s = np.sum(np.sin(ang) * mag)\n    c = np.sum(np.cos(ang) * mag)\n    mean_ang = np.arctan2(s, c)\n    return float(mean_ang / np.pi)  # normalized to [-1,1]\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of gradient magnitude concentrated in the lower-right quadrant'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # Compute gradients on grayscale\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    total = np.sum(mag)\n    if total <= eps:\n        return 0.0\n    r0 = int(h * 0.5)\n    c0 = int(w * 0.5)\n    lower_right = mag[r0:, c0:]\n    return float(np.sum(lower_right) / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of distinct connected ink components restricted to the right half'\n    import numpy as np\n    from collections import deque\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn + 1e-9\n    norm = (gray - mn) / rng\n    ink = (1.0 - norm) > 0.25\n    # restrict to right half\n    x0 = w // 2\n    sub = ink[:, x0:]\n    sh, sw = sub.shape\n    visited = np.zeros_like(sub, dtype=bool)\n    comps = 0\n    for i in range(sh):\n        for j in range(sw):\n            if sub[i, j] and not visited[i, j]:\n                comps += 1\n                # BFS\n                q = deque()\n                visited[i, j] = True\n                q.append((i, j))\n                while q:\n                    a, b = q.popleft()\n                    if a > 0 and sub[a - 1, b] and not visited[a - 1, b]:\n                        visited[a - 1, b] = True; q.append((a - 1, b))\n                    if a + 1 < sh and sub[a + 1, b] and not visited[a + 1, b]:\n                        visited[a + 1, b] = True; q.append((a + 1, b))\n                    if b > 0 and sub[a, b - 1] and not visited[a, b - 1]:\n                        visited[a, b - 1] = True; q.append((a, b - 1))\n                    if b + 1 < sw and sub[a, b + 1] and not visited[a, b + 1]:\n                        visited[a, b + 1] = True; q.append((a, b + 1))\n    return float(comps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of binary transitions across rows (mean transitions per row normalized by width)'\n    import numpy as np\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    if w <= 1:\n        return 0.0\n    transitions = np.abs(mask[:, :-1].astype(int) - mask[:, 1:].astype(int)).sum(axis=1)\n    avg_trans = float(transitions.mean()) / max(1.0, (w - 1))\n    return float(avg_trans)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the minimal bounding box of the ink (clipped to [0,10])'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    coords = np.nonzero(ink)\n    if len(coords[0]) == 0:\n        return 0.0\n    min_r, max_r = coords[0].min(), coords[0].max()\n    min_c, max_c = coords[1].min(), coords[1].max()\n    bw = max_c - min_c + 1\n    bh = max_r - min_r + 1\n    if bh == 0:\n        return 0.0\n    ratio = float(bw) / float(bh)\n    return float(np.clip(ratio, 0.0, 10.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of ink runs (background->ink segments) across the central vertical columns'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    scale = (gray - mn) / (mx - mn + 1e-9)\n    thr = scale.mean()\n    cand = scale < thr\n    if cand.sum() > 0.5 * h * w:\n        ink = ~cand\n    else:\n        ink = cand\n    cols = [w // 2 - 1, w // 2, w // 2 + 1]\n    cols = [c for c in cols if 0 <= c < w]\n    runs = []\n    for c in cols:\n        col = ink[:, c].astype(np.int8)\n        # count runs of consecutive 1s\n        if col.size == 0:\n            runs.append(0)\n            continue\n        diff = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        runs.append(float(len(starts)))\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in lower-right half to ink in lower-left half (captures right-leaning bottoms vs left loops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    maxv = float(np.max(gray)) if np.max(gray) != 0 else 1.0\n    gray = gray / maxv\n    p_low = np.percentile(gray, 40)\n    p_high = np.percentile(gray, 60)\n    fg = (gray < p_low) if np.mean(gray) <= np.median(gray) else (gray > p_high)\n    h, w = gray.shape\n    lower = slice(h // 2, h)\n    left = slice(0, w // 2)\n    right = slice(w // 2, w)\n    ink_lr = np.count_nonzero(fg[lower, right])\n    ink_ll = np.count_nonzero(fg[lower, left])\n    eps = 1e-6\n    return float((ink_lr + eps) / (ink_ll + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal variance to vertical variance of foreground points (var_x / (var_y + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= 1 else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if xs.size < 2:\n        return 1.0\n    var_x = float(np.var(xs.astype(float)))\n    var_y = float(np.var(ys.astype(float)))\n    eps = 1e-8\n    return float(var_x / (var_y + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated local curvature: mean absolute second difference along a right-side vertical slice normalized by first-derivative magnitude'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.asarray(image).astype(float)\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr\n    h, w = gray.shape[:2]\n    if h < 3 or w < 4:\n        return 0.0\n    x = min(w - 1, max(0, (3 * w) // 4))\n    profile = gray[:, x]\n    first = np.abs(np.diff(profile))\n    second = np.abs(np.diff(profile, n=2))\n    mean_second = second.mean() if second.size else 0.0\n    mean_first = first.mean() if first.size else 1e-9\n    return float(mean_second / (mean_first + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of left-third columns that contain any ink (indicates presence of a left vertical stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    left_w = max(1, w // 3)\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    left_block = ink[:, :left_w]\n    if left_block.size == 0:\n        return 0.0\n    cols_with_ink = np.sum(np.any(left_block, axis=0))\n    return float(cols_with_ink / left_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom third of the image (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        bottom = np.count_nonzero(ink[(2*h)//3 : , :])\n        return float(bottom) / float(total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal edge bias: (NW-SE - NE-SW) / total diagonal energy (range -1..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # NW-SE differences\n    a = gray[:-1, :-1] - gray[1:, 1:]\n    b = gray[:-1, 1:] - gray[1:, :-1]  # NE-SW\n    en_a = np.sum(np.abs(a))\n    en_b = np.sum(np.abs(b))\n    denom = en_a + en_b + 1e-9\n    return float((en_a - en_b) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Global slant estimate: arctangent of best-fit line slope to edge pixels, normalized to [-1,1]'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float64)\n    h, w = gray.shape[:2]\n    med = np.percentile(gray, 50)\n    if gray.max() == gray.min():\n        return 0.0\n    low_mean = np.mean(gray[gray <= med]) if np.any(gray <= med) else med\n    high_mean = np.mean(gray[gray > med]) if np.any(gray > med) else med\n    ink = (gray <= med).astype(np.uint8) if low_mean < high_mean else (gray >= med).astype(np.uint8)\n    # find edge pixels by neighbor variance: ink pixels that have at least one non-ink neighbor\n    pad = np.pad(ink, 1, mode='constant', constant_values=0)\n    neigh_sum = (pad[0:-2,0:-2] + pad[0:-2,1:-1] + pad[0:-2,2:] +\n                 pad[1:-1,0:-2] +                 0 + pad[1:-1,2:] +\n                 pad[2:,0:-2]   + pad[2:,1:-1]   + pad[2:,2:])\n    center = pad[1:-1,1:-1]\n    edge = np.logical_and(center == 1, neigh_sum < 8)\n    ys, xs = np.nonzero(edge)\n    if xs.size < 2:\n        return 0.0\n    # fit line x = a*y + b (so slope sign corresponds to slant of strokes)\n    a, b = np.polyfit(ys.astype(np.float64), xs.astype(np.float64), 1)\n    ang = np.arctan(a)  # between -pi/2..pi/2\n    return float(ang / (np.pi / 2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference of horizontal edge energy between right and left halves ((right-left)/(right+left+eps))'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    left = np.sum(abs_gx[:, :w//2])\n    right = np.sum(abs_gx[:, w//2:])\n    return float((right - left) / (right + left + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal edge energy: sum of absolute diagonal differences over vertical+horizontal gradient energy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0 or np.std(gray) < 1e-9:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    horver = np.sum(np.abs(gx)) + np.sum(np.abs(gy))\n    # diagonal differences\n    d1 = np.abs(gray[1:, 1:] - gray[:-1, :-1])\n    d2 = np.abs(gray[1:, :-1] - gray[:-1, 1:])\n    diag = np.sum(d1) + np.sum(d2)\n    eps = 1e-9\n    return float(diag) / float(horver + eps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a descending diagonal stroke (top-left to bottom-right) measured by mean absolute of gx+gy'\n    import numpy as np\n    # convert to single-channel gray\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gx, gy = np.gradient(gray)\n    # use absolute of gx+gy: edges oriented along -45/45 degrees produce large same-sign gradients\n    diag = np.abs(gx + gy)\n    # normalize by overall gradient energy to be robust to contrast\n    denom = np.mean(np.abs(gx)) + np.mean(np.abs(gy)) + 1e-9\n    return float(np.mean(diag) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset normalized by image height (positive means centroid is lower than center)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    yc = float(np.mean(coords[:, 0]))\n    offset_norm = (yc - (h / 2.0)) / max(1.0, h)\n    return float(offset_norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels inside a narrow central vertical strip (detects vertical strokes like \"1\")'\n    import numpy as np\n    # Grayscale conversion\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # Robust foreground: pick minority side of mean\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    # central vertical strip width ~ w//8 (at least 1)\n    strip_w = max(1, w // 8)\n    c1 = w // 2 - strip_w // 2\n    c2 = c1 + strip_w\n    central = fg[:, c1:c2]\n    central_count = np.count_nonzero(central)\n    total_fg = np.count_nonzero(fg)\n    if total_fg == 0:\n        return 0.0\n    return float(central_count) / float(total_fg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized ink density in the lower-right quadrant (detects 9-like tails)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mu, sigma = float(np.mean(gray)), float(np.std(gray))\n    thr = mu - 0.25*(sigma + 1e-9)\n    mask = gray < thr if np.count_nonzero(gray < thr) > 5 else gray > (mu + 0.25*(sigma+1e-9))\n    lr = mask[2*h//3:h, 2*w//3:w]\n    return float(np.count_nonzero(lr) / (np.count_nonzero(mask) + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient in the left third to the right third (detects left vertical stroke in \"5\")'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gy = np.abs(gy)\n    left_w = max(1, w // 3)\n    right_w = max(1, w - (2 * w // 3))\n    left_mean = np.mean(abs_gy[:, :left_w]) if left_w > 0 else 0.0\n    right_mean = np.mean(abs_gy[:, w - right_w:]) if right_w > 0 else 0.0\n    eps = 1e-6\n    return float((left_mean + eps) / (right_mean + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid of ink (0=left, 1=right)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.5\n    m = float(np.mean(gray))\n    lower = gray <= m\n    upper = gray > m\n    mean_lower = float(np.mean(gray[lower])) if np.any(lower) else m\n    mean_upper = float(np.mean(gray[upper])) if np.any(upper) else m\n    ink = lower if mean_lower < mean_upper else upper\n    ys, xs = np.nonzero(ink)\n    if xs.size == 0:\n        return 0.5\n    cx = float(np.mean(xs)) / max(1.0, w - 1)\n    return float(cx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal edge energy ratio: (sum of absolute diagonal gradients) divided by total gradient energy (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute diagonal gradients using shifts\n    g1 = np.zeros_like(gray)\n    g2 = np.zeros_like(gray)\n    # shift down-right minus original\n    g1[:-1, :-1] = gray[1:, 1:] - gray[:-1, :-1]\n    # shift down-left minus original\n    g2[:-1, 1:] = gray[1:, :-1] - gray[:-1, 1:]\n    diag_energy = np.sum(np.abs(g1)) + np.sum(np.abs(g2))\n    # horizontal and vertical gradients\n    gx = np.zeros_like(gray)\n    gy = np.zeros_like(gray)\n    gx[:, :-1] = gray[:, 1:] - gray[:, :-1]\n    gy[:-1, :] = gray[1:, :] - gray[:-1, :]\n    total = diag_energy + np.sum(np.abs(gx)) + np.sum(np.abs(gy))\n    if total <= 0:\n        return 0.0\n    return float(diag_energy / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average length of longest horizontal ink run per row in the top quarter normalized by image width (captures long top bars)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray)\n    dark_mask = gray < thr\n    light_mask = gray > thr\n    ink = dark_mask if np.count_nonzero(dark_mask) <= np.count_nonzero(light_mask) else light_mask\n    top_h = max(1, h // 4)\n    region = ink[0:top_h, :]\n    if region.size == 0:\n        return 0.0\n    longest_per_row = []\n    for r in range(region.shape[0]):\n        row = region[r, :].astype(np.uint8)\n        if not np.any(row):\n            longest_per_row.append(0)\n            continue\n        padded = np.concatenate(([0], row, [0]))\n        changes = np.flatnonzero(padded[1:] != padded[:-1]).reshape(-1, 2)\n        # runs correspond to segments where value == 1: starting at changes[0], every other\n        runs = changes[::2]\n        if runs.size == 0:\n            longest_per_row.append(0)\n        else:\n            lengths = runs[:,1] - runs[:,0]\n            longest_per_row.append(int(lengths.max()))\n    avg_longest = float(np.mean(longest_per_row))\n    return float(avg_longest / max(1.0, w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous horizontal ink run within the top quarter center zone normalized by width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    center_w1 = max(0, w//4)\n    center_w2 = min(w, 3*w//4)\n    zone = gray[0:top_h, center_w1:center_w2]\n    if zone.size == 0:\n        return 0.0\n    thresh = float(np.mean(zone))\n    low = int(np.count_nonzero(zone < thresh))\n    high = int(np.count_nonzero(zone > thresh))\n    if low < high:\n        ink_zone = (zone < thresh).astype(np.uint8)\n    else:\n        ink_zone = (zone > thresh).astype(np.uint8)\n    # compute longest horizontal run across all rows in zone\n    longest = 0\n    for row in ink_zone:\n        # find longest run of ones in row\n        current = 0\n        maxr = 0\n        for v in row:\n            if v:\n                current += 1\n            else:\n                if current > maxr:\n                    maxr = current\n                current = 0\n        if current > maxr:\n            maxr = current\n        if maxr > longest:\n            longest = maxr\n    norm = float(longest / max(1, center_w2 - center_w1))\n    return norm\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical to horizontal gradient magnitudes calculated on the right half'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2).astype(float)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    right = slice(w//2, w)\n    abs_vert = np.abs(gy[:, right])\n    abs_horz = np.abs(gx[:, right])\n    mean_vert = float(np.mean(abs_vert)) if abs_vert.size else 0.0\n    mean_horz = float(np.mean(abs_horz)) if abs_horz.size else 0.0\n    eps = 1e-9\n    return float(mean_vert / (mean_horz + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-left quadrant ink density: fraction of ink pixels located in the bottom-left quadrant'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        th = np.mean(gray)\n        ink = gray < th\n        if np.count_nonzero(ink) == 0:\n            ink = gray > th\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        lower_half = np.s_[h//2: h, 0: w//2]\n        lower_left = ink[lower_half]\n        return float(np.count_nonzero(lower_left) / (total + 1e-9))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal offset of the largest hole centroid from image center (0..0.5 normalized)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        bg = ~ink\n        ext = np.zeros_like(bg, dtype=bool)\n        stack = []\n        for i in range(h):\n            for j in (0, w-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        for j in range(w):\n            for i in (0, h-1):\n                if bg[i, j] and not ext[i, j]:\n                    stack.append((i, j)); ext[i, j] = True\n        while stack:\n            y, x = stack.pop()\n            for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                ny, nx = y+dy, x+dx\n                if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and not ext[ny, nx]:\n                    ext[ny, nx] = True\n                    stack.append((ny, nx))\n        enclosed = bg & (~ext)\n        visited = np.zeros_like(enclosed, dtype=bool)\n        best_area = 0\n        best_cx = None\n        for i in range(h):\n            for j in range(w):\n                if enclosed[i, j] and not visited[i, j]:\n                    area = 0\n                    sumx = 0.0\n                    q = [(i, j)]\n                    visited[i, j] = True\n                    while q:\n                        y, x = q.pop()\n                        area += 1\n                        sumx += x\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < h and 0 <= nx < w and enclosed[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                q.append((ny, nx))\n                    if area > best_area:\n                        best_area = area\n                        best_cx = (sumx / area)\n        if best_cx is None:\n            return 0.0\n        center = (w - 1) / 2.0\n        return float(abs(best_cx - center) / max(1.0, w))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest enclosed hole area divided by total ink area (detects closed loops like in 9 or 6)'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Determine ink polarity by choosing the smaller side of mean threshold\n    m = gray.mean()\n    low_count = np.sum(gray < m)\n    if low_count <= (h * w / 2):\n        ink = (gray < m)\n    else:\n        ink = (gray > m)\n    ink = ink.astype(np.bool_)\n    ink_area = float(ink.sum())\n    if ink_area < 1:\n        return 0.0\n    # Find holes: connected components on inverted mask that do NOT touch the border\n    inv = (~ink)\n    visited = np.zeros_like(inv, dtype=np.bool_)\n    max_hole = 0\n    # iterate over pixels\n    for r in range(h):\n        for c in range(w):\n            if inv[r, c] and not visited[r, c]:\n                # BFS\n                stack = [(r, c)]\n                visited[r, c] = True\n                touches_border = False\n                comp_size = 0\n                while stack:\n                    y, x = stack.pop()\n                    comp_size += 1\n                    if y == 0 or x == 0 or y == h - 1 or x == w - 1:\n                        touches_border = True\n                    # 8-neighbors\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if 0 <= ny < h and 0 <= nx < w and not visited[ny, nx] and inv[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n                if not touches_border:\n                    if comp_size > max_hole:\n                        max_hole = comp_size\n    return float(max_hole / (ink_area + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest vertical consecutive ink run within the left-third of the image, normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    gray = np.array(gray, dtype=float)\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.sum(ink) > gray.size / 2:\n        ink = ~ink\n    left_w = max(1, w // 3)\n    region = ink[:, 0:left_w]\n    max_run = 0\n    # compute vertical runs per column\n    for c in range(region.shape[1]):\n        col = region[:, c].astype(int)\n        # compute run lengths\n        if col.sum() == 0:\n            continue\n        # diff trick to get runs\n        diff = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, np.max(runs))\n    return float(max_run / max(h, 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels that lie within the rightmost quarter of the image width (right-border density)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n    left_vals = gray[gray <= p40]\n    right_vals = gray[gray >= p60]\n    left_mean = left_vals.mean() if left_vals.size else gray.min()\n    right_mean = right_vals.mean() if right_vals.size else gray.max()\n    thr = (left_mean + right_mean) / 2.0\n    ink_is_dark = left_mean < right_mean\n    ink = (gray < thr) if ink_is_dark else (gray > thr)\n    right_strip = ink[:, int(3*w/4):]\n    total_ink = np.count_nonzero(ink)\n    if total_ink == 0:\n        return 0.0\n    return float(np.count_nonzero(right_strip) / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative right-edge strength: mean vertical gradient magnitude in right third divided by left third ( >1 => stronger edges on right )'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    grayf = gray.astype(float)\n    h, w = grayf.shape[:2]\n    # compute vertical gradient (abs difference along columns)\n    gy = np.abs(np.gradient(grayf, axis=0))\n    gx = np.abs(np.gradient(grayf, axis=1))\n    mag = gx + gy\n    third = max(1, w // 3)\n    left_mean = np.mean(mag[:, :third]) if third > 0 else 0.0\n    right_mean = np.mean(mag[:, -third:]) if third > 0 else 0.0\n    if left_mean == 0:\n        return float(right_mean)\n    return float(right_mean / left_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal spread (std of x) of ink in the lower quarter normalized by half-width (higher = wider bottom spread)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    low = np.percentile(gray, 10)\n    high = np.percentile(gray, 90)\n    if high - low < eps:\n        return 0.0\n    mid = 0.5 * (low + high)\n    ink = (gray < mid) if (low < mid) else (gray > mid)\n    ys, xs = np.nonzero(ink)\n    if ys.size == 0:\n        return 0.0\n    bottom_thr = int(h * 0.75)\n    mask = ys >= bottom_thr\n    if not np.any(mask):\n        mask = ys >= int(h * 0.6)\n    if not np.any(mask):\n        return 0.0\n    std_x = float(np.std(xs[mask]))\n    return float(std_x / (w / 2.0 + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-half to bottom-half foreground pixel mass ratio (top_mass / bottom_mass), clipped and normalized'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    thr = float(np.percentile(gray, 75))\n    mask = gray >= thr\n    if mask.sum() > 0.6 * (h * w):\n        mask = ~mask\n    mask = mask.astype(float)\n    top_mass = mask[:h // 2, :].sum()\n    bottom_mass = mask[h // 2:, :].sum()\n    # avoid division by zero\n    if bottom_mass <= 1e-6:\n        return float(min(10.0, top_mass + 0.0))\n    ratio = top_mass / bottom_mass\n    # clip to reasonable range and return\n    return float(max(0.0, min(10.0, ratio)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized radial variance of ink pixels around centroid (lower => more circular shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if ys.size == 0:\n        return 0.0\n    cy = ys.mean()\n    cx = xs.mean()\n    d = np.sqrt((ys - cy)**2 + (xs - cx)**2)\n    mean_d = d.mean() + 1e-8\n    var_d = d.var()\n    # normalized variance\n    return float(var_d / (mean_d**2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average longest continuous horizontal run length in the top 20% rows (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.asarray(image).astype(float)\n    h, w = arr.shape[:2]\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    mx = gray.max() if gray.max() != 0 else 1.0\n    gray = gray / float(mx)\n    mean = float(gray.mean())\n    std = float(gray.std()) if float(gray.std()) > 0 else 1e-6\n    if mean > 0.5:\n        ink = gray < (mean - 0.15 * std)\n    else:\n        ink = gray > (mean + 0.15 * std)\n    top_h = max(1, h // 5)\n    top_region = ink[:top_h, :]\n    if top_region.size == 0:\n        return 0.0\n    longest_runs = []\n    for row in top_region:\n        # find longest consecutive True in row\n        if not np.any(row):\n            longest_runs.append(0)\n            continue\n        # compute run lengths\n        diffs = np.diff(np.concatenate(([0], row.view(np.int8), [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        if starts.size == 0:\n            longest_runs.append(0)\n        else:\n            lengths = ends - starts\n            longest_runs.append(np.max(lengths))\n    avg_longest = float(np.mean(longest_runs)) / float(max(1, w))\n    return float(np.clip(avg_longest, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude on the right half minus left half (positive if right half has stronger edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    left_mag = np.mean(mag[:, :w//2]) if w//2 > 0 else 0.0\n    right_mag = np.mean(mag[:, w//2:]) if w - w//2 > 0 else 0.0\n    return float(right_mag - left_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top-center band that are background (open-top indicator): top 20% rows, central 40% columns'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    r0 = 0\n    r1 = max(1, int(h * 0.2))\n    c0 = max(0, int(w * 0.3))\n    c1 = min(w, int(w * 0.7))\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    fg_region = region < np.mean(gray)\n    bg_fraction = float(1.0 - (np.count_nonzero(fg_region) / region.size))\n    return bg_fraction\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal edges in the upper third: mean horizontal gradient in top band divided by global gradient'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    # horizontal gradient (differences along columns)\n    hg = np.abs(np.diff(gray, axis=1))\n    # average in upper third\n    top_rows = max(1, h // 3)\n    top_hg = hg[:top_rows, :]\n    mean_top = top_hg.mean() if top_hg.size else 0.0\n    mean_all = hg.mean() if hg.size else 0.0\n    denom = mean_all + 1e-8\n    return float(mean_top / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of the largest hole centroid from image center normalized by width (positive -> hole to the right)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr  # True = ink, False = background\n    background = ~ink\n    # Flood fill external background starting from borders\n    seen = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    # push all border background pixels\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); seen[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); seen[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not seen[y, 0]:\n            dq.append((y, 0)); seen[y, 0] = True\n        if background[y, w - 1] and not seen[y, w - 1]:\n            dq.append((y, w - 1)); seen[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        # 4-neighbors\n        if y > 0 and background[y - 1, x] and not seen[y - 1, x]:\n            seen[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not seen[y + 1, x]:\n            seen[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not seen[y, x - 1]:\n            seen[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not seen[y, x + 1]:\n            seen[y, x + 1] = True; dq.append((y, x + 1))\n    # Holes are background pixels not reached by external fill\n    holes = background & (~seen)\n    hole_count = np.count_nonzero(holes)\n    if hole_count == 0:\n        return 0.0\n    ys, xs = np.where(holes)\n    cx = np.mean(xs)\n    center_x = (w - 1) / 2.0\n    return float((cx - center_x) / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Width of largest continuous background gap on the central row normalized by image width (detects open center in 3)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    th = np.percentile(gray, 50)\n    mid = 0.5 * (np.max(gray) + np.min(gray))\n    fg = (gray < th) if np.mean(gray) > mid else (gray > th)\n    fg = fg.astype(np.uint8)\n    if h == 0 or w == 0:\n        return 0.0\n    r = h // 2\n    row = fg[r, :]\n    # background segments (zeros)\n    inv = 1 - row\n    if inv.sum() == 0:\n        return 0.0\n    d = np.diff(np.concatenate(([0], inv, [0])))\n    starts = np.where(d == 1)[0]\n    ends = np.where(d == -1)[0]\n    runs = (ends - starts)\n    if runs.size == 0:\n        return 0.0\n    max_run = runs.max()\n    return float(max_run / max(1, w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal edge energy (diagonal gradients compared to total gradient energy)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    diag1 = gx + gy\n    diag2 = gx - gy\n    diag_energy = np.sum(np.abs(diag1)) + np.sum(np.abs(diag2))\n    total_energy = np.sum(np.abs(gx)) + np.sum(np.abs(gy))\n    if total_energy == 0:\n        return 0.0\n    return float(diag_energy / (total_energy + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a top horizontal stroke: proportion of ink in the top 20% rows'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_count = float(np.count_nonzero(ink[:top_rows, :]))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy favoring descending diagonal (sum|dx+dy| / (sum|dx-dy| + eps))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    dy, dx = np.gradient(gray)\n    diag1 = dy + dx\n    diag2 = dy - dx\n    e1 = np.sum(np.abs(diag1))\n    e2 = np.sum(np.abs(diag2))\n    return float(e1 / (e2 + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient to horizontal gradient in the top-right quadrant (vertical/horizontal)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    r0, c0 = 0, w // 2\n    r1, c1 = max(1, h // 2), w\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mean_abs_gx = np.mean(np.abs(gx)) + 1e-9\n    mean_abs_gy = np.mean(np.abs(gy))\n    return float(mean_abs_gy / mean_abs_gx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row-wise centroid variation (std of column centroid across rows) normalized by image width (higher for curved digits like 6 or 0)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    centroids = []\n    for r in range(h):\n        row = ink[r, :]\n        if np.any(row):\n            cols = np.nonzero(row)[0]\n            centroids.append(float(np.mean(cols)))\n    if len(centroids) < 2:\n        return 0.0\n    std_centroid = float(np.std(centroids))\n    return float(std_centroid / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized x-coordinate of the ink centroid (0 = left, 1 = right); returns 0.5 if no ink'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    thresh = np.mean(gray)\n    dark_count = np.count_nonzero(gray < thresh)\n    bright_count = np.count_nonzero(gray > thresh)\n    ink = (gray < thresh) if dark_count < bright_count else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.5\n    # coords are (row, col)\n    centroid_col = float(np.mean(coords[:, 1]))\n    return float(centroid_col / max(1, w - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal stroke energy in the top-right quadrant: measures strength of 45-degree strokes (useful to detect 7-like diagonals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    tr = gray[0:h//2, w//2:w]\n    if tr.size == 0:\n        return 0.0\n    gy, gx = np.gradient(tr.astype(float))\n    mag = np.hypot(gx, gy) + 1e-9\n    absgx = np.abs(gx)\n    absgy = np.abs(gy)\n    # diagonal indicator per pixel: 2*min(|gx|,|gy|)/( |gx|+|gy| )\n    diag_frac = 2.0 * np.minimum(absgx, absgy) / (absgx + absgy + 1e-9)\n    diag_weighted = (diag_frac * mag).sum()\n    # normalize by total gradient energy in the quadrant\n    total_energy = mag.sum() + 1e-9\n    return float(diag_weighted / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate stroke thickness: foreground area divided by foreground perimeter (higher = thicker)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    gray = (gray - mn) / (mx - mn)\n    thr = float(np.mean(gray))\n    foreground_dark = float(np.mean(gray)) > 0.5\n    mask = (gray < thr) if foreground_dark else (gray > thr)\n    area = float(mask.sum())\n    if area == 0.0:\n        return 0.0\n    # interior pixels have all 8 neighbors foreground\n    nbrs = np.zeros_like(mask, dtype=int)\n    shifts = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for dr, dc in shifts:\n        sr = slice(max(0, dr), h + min(0, dr))\n        sc = slice(max(0, dc), w + min(0, dc))\n        tr = slice(max(0, -dr), h + min(0, -dr))\n        tc = slice(max(0, -dc), w + min(0, -dc))\n        nbrs[sr, sc] += mask[tr, tc]\n    interior = (mask) & (nbrs == 8)\n    perimeter_pixels = mask & (~interior)\n    perimeter = float(perimeter_pixels.sum())\n    if perimeter <= 0.0:\n        return float(area)\n    return float(area) / float(perimeter)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in top-right quadrant to top-left quadrant (captures right-facing bulges seen in \"3\")'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        norm = (gray - mn) / (mx - mn)\n    else:\n        norm = gray * 0.0\n    ink = (norm < 0.5).astype(np.uint8)\n    h, w = ink.shape\n    top_half = slice(0, max(1, h // 2))\n    left = slice(0, w // 2)\n    right = slice(w // 2, w)\n    left_top = ink[top_half, left].sum()\n    right_top = ink[top_half, right].sum()\n    return float(right_top / (left_top + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Radial dispersion: std(distance to ink centroid) / mean(distance) for ink pixels; lower for round shapes'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(gray.min()), float(gray.max())\n    if mx <= mn:\n        return 0.0\n    thresh = mn + 0.1 * (mx - mn)\n    ink = gray > thresh\n    ys, xs = np.where(ink)\n    if xs.size <= 1:\n        return 0.0\n    cy, cx = float(ys.mean()), float(xs.mean())\n    d = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    mean_d = float(d.mean())\n    if mean_d == 0:\n        return 0.0\n    return float(d.std() / mean_d)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative ink density bottom-left vs bottom-right: bottom-left / (bottom-right + eps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    thresh = (np.mean(border) + np.mean(gray)) / 2.0\n    ink = (gray < thresh) if (np.mean(border) > np.mean(gray)) else (gray > thresh)\n    mid_h = h * 2 // 3\n    mid_w = w // 2\n    bottom_slice = slice(mid_h, h)\n    bl = float(np.count_nonzero(ink[bottom_slice, :mid_w]))\n    br = float(np.count_nonzero(ink[bottom_slice, mid_w:]))\n    eps = 1e-6\n    return float(bl / (br + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in the right half to ink in the left half (captures horizontal bias)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = float(np.percentile(gray.flatten(), 35))\n    ink = (gray <= thresh)\n    left = float(np.count_nonzero(ink[:, :w//2]))\n    right = float(np.count_nonzero(ink[:, w//2:]))\n    # return ratio right / left (symmetric if left is zero)\n    return float((right + 1e-6) / (left + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean of signed product of x and y gradients in the lower-left quadrant (captures diagonal stroke orientation)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    # focus on lower-left quadrant\n    sub = gray[h//2:, :w//2]\n    gy, gx = np.gradient(sub.astype(float))\n    prod = gx * gy\n    if prod.size == 0:\n        return 0.0\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between fraction of ink in the lower third and the middle third (lower_density - middle_density)'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Binarize by choosing the polarity where ink is minority\n    meanv = gray.mean()\n    m1 = gray < meanv\n    m2 = gray > meanv\n    ink = m1 if np.count_nonzero(m1) <= np.count_nonzero(m2) else m2\n    total = float(np.count_nonzero(ink))\n    if total == 0:\n        return 0.0\n    lower = ink[2*h//3:h, :].sum() / total\n    middle = ink[h//3:2*h//3, :].sum() / total\n    return float(lower - middle)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-center loop density: fraction of ink located in the lower central third of the image (useful to detect closed loops at the bottom like in 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    mask = mask.astype(np.uint8)\n    ink_total = mask.sum()\n    if ink_total == 0:\n        return 0.0\n    r0 = (2 * h) // 3\n    c0 = w // 4\n    c1 = 3 * w // 4\n    bottom_center = mask[r0:h, c0:c1]\n    return float(bottom_center.sum() / (ink_total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical (left-right) normalized L1 symmetry: average absolute column difference between left and flipped right, normalized by image width'\n    # Convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Determine ink polarity robustly (ink should be sparse)\n    thr = np.mean(gray)\n    ink_mask = gray < thr\n    if np.count_nonzero(ink_mask) > 0.9 * h * w:\n        ink_mask = gray > thr\n    # Compute left-right symmetry on binary ink mask\n    left = ink_mask[:, :w//2].astype(float)\n    right = np.fliplr(ink_mask[:, (w - w//2):]).astype(float)\n    # Resize to same width if needed\n    if left.shape[1] != right.shape[1]:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    # L1 normalized by number of compared pixels\n    denom = float(left.size) if left.size > 0 else 1.0\n    score = np.sum(np.abs(left - right)) / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass (y coordinate of ink centroid divided by height) \u2014 >0.5 means ink bottom-heavy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    ys, xs = np.nonzero(ink)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(cy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box fill ratio: ink pixel count divided by bounding box area containing ink (compactness)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    mask_lo = gray < th\n    mask_hi = gray > th\n    mask = (mask_lo if np.count_nonzero(mask_lo) <= np.count_nonzero(mask_hi) else mask_hi)\n    coords = np.column_stack(np.nonzero(mask))\n    if coords.size == 0:\n        return 0.0\n    y0, x0 = coords.min(axis=0)\n    y1, x1 = coords.max(axis=0)\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    ink_count = float(np.count_nonzero(mask))\n    return float(ink_count / max(1e-6, bbox_area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows in the middle third that contain a long horizontal ink run (>40% width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    mask = norm < 0.5\n    r0, r1 = h // 3, (2 * h) // 3\n    if r1 <= r0:\n        return 0.0\n    rows = mask[r0:r1, :]\n    long_thresh = max(1, int(0.4 * w))\n    count_rows_with_long = 0\n    for row in rows:\n        # find runs\n        if not np.any(row):\n            continue\n        # compute lengths of contiguous True segments\n        padded = np.concatenate([[0], row.astype(int), [0]])\n        diffs = np.diff(padded)\n        starts = np.nonzero(diffs == 1)[0]\n        ends = np.nonzero(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= long_thresh):\n            count_rows_with_long += 1\n    total_rows = rows.shape[0]\n    if total_rows == 0:\n        return 0.0\n    return float(count_rows_with_long / float(total_rows))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average of the longest horizontal ink run per row in the central band (measures mid-line continuity like the middle bar of 5)'\n    import numpy as np\n    h, w = image.shape[:2]\n    r0 = h // 3\n    r1 = min(h, 2 * h // 3)\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    band = gray[r0:r1, :]\n    if band.size == 0:\n        return 0.0\n    thr = np.mean(band) - 0.5 * np.std(band)\n    mask = band < thr\n    if mask.sum() == 0:\n        thr = np.percentile(band, 50)\n        mask = band < thr\n    runs = []\n    for row in mask.astype(np.uint8):\n        if row.sum() == 0:\n            runs.append(0)\n            continue\n        dif = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size and ends.size:\n            runs.append((ends - starts).max())\n        else:\n            runs.append(0)\n    avg_longest = float(np.mean(runs)) / float(w + 1e-9)\n    return avg_longest\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal edge strength (45 and -45 deg) to the sum of vertical+horizontal edge strength'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        gy, gx = np.gradient(gray)\n        abs_gx = np.abs(gx)\n        abs_gy = np.abs(gy)\n        # diagonal proxies: |gx +/- gy|\n        diag1 = np.abs(gx + gy)\n        diag2 = np.abs(gx - gy)\n        diag_strength = np.sum(diag1) + np.sum(diag2)\n        vert_horiz = np.sum(abs_gx) + np.sum(abs_gy)\n        denom = vert_horiz + 1e-9\n        return float(diag_strength / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient energy in the top third to bottom third (top_horiz / (bottom_horiz+eps))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute horizontal gradient (difference along cols)\n    gx = np.abs(np.diff(gray, axis=1))\n    # align shapes: pad one column to the right to match original width-1 -> we will average per region\n    top_cut = max(1, h // 3)\n    top_gx = gx[:top_cut, :]\n    bottom_gx = gx[-top_cut:, :] if top_cut <= h else gx\n    top_energy = float(np.mean(top_gx)) if top_gx.size else 0.0\n    bottom_energy = float(np.mean(bottom_gx)) if bottom_gx.size else 0.0\n    eps = 1e-6\n    return float(top_energy / (bottom_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical gradient magnitude (average absolute d/dy) normalized by intensity range'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    minv = float(np.min(gray))\n    maxv = float(np.max(gray))\n    if maxv > minv:\n        gray = (gray - minv) / (maxv - minv)\n    else:\n        gray = gray * 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.abs(gy)\n    return float(np.mean(mag))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the foreground bounding box (width/height), clipped and normalized to [0,1] \u2014 tall thin like \"1\" gives small values'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.5\n    x_min, x_max = int(xs.min()), int(xs.max())\n    y_min, y_max = int(ys.min()), int(ys.max())\n    bw = x_max - x_min + 1\n    bh = y_max - y_min + 1\n    if bh == 0:\n        return 0.0\n    ar = float(bw) / float(bh)\n    # normalize: expect ar in [0.25,4], clip then map to [0,1]\n    ar_clamped = max(0.25, min(4.0, ar))\n    return float((ar_clamped - 0.25) / (4.0 - 0.25))\n",
    "def feature(image: np.ndarray) -> float:\n    'Bias of ink lying near the anti-diagonal (top-right -> bottom-left) versus main diagonal (-1..1)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    low_count = np.sum(norm < 0.5)\n    high_count = norm.size - low_count\n    if low_count < high_count:\n        ink = (norm < 0.5)\n    else:\n        ink = (norm > 0.5)\n    Y, X = np.indices((h, w))\n    # normalized coordinates 0..1\n    xn = X / max(1.0, (w - 1))\n    yn = Y / max(1.0, (h - 1))\n    # distance to main diagonal y ~= x and anti-diagonal y ~= 1-x\n    dist_main = np.abs(yn - xn)\n    dist_anti = np.abs(yn - (1.0 - xn))\n    # choose a band width relative to image diag span\n    band = 0.15\n    near_main = np.logical_and(ink, dist_main < band)\n    near_anti = np.logical_and(ink, dist_anti < band)\n    nm = float(np.sum(near_main))\n    na = float(np.sum(near_anti))\n    if nm + na < 1e-6:\n        return 0.0\n    val = (na - nm) / (nm + na)\n    return float(val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-right vs lower-left ink density difference: (lower-right - lower-left) normalized by total ink'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    thresh = np.mean(gray)\n    bin_img = (gray < thresh).astype(np.float32)\n    if np.sum(bin_img) < 1:\n        bin_img = (gray > thresh).astype(np.float32)\n        if np.sum(bin_img) < 1:\n            return 0.0\n    half_h = h // 2\n    half_w = w // 2\n    lower = bin_img[half_h:, :]\n    lr = np.sum(lower[:, half_w:])\n    ll = np.sum(lower[:, :half_w])\n    total = np.sum(bin_img)\n    return float((lr - ll) / (total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between right-half and left-half ink density (right - left)'\n    import numpy as np\n    # Convert to grayscale float in [0,1]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    # Robust thresholding: median, determine if ink is darker than background by comparing border vs center\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h >=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    center_mean = float(center.mean()) if center.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > center_mean else (gray > thresh)\n    ink = ink.astype(np.float64)\n    total = ink.sum()\n    if total <= 1e-6:\n        return 0.0\n    left = ink[:, :w//2].sum()\n    right = ink[:, w//2:].sum()\n    return float((right - left) / (total + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the right third of the image (right-side density)'\n    import numpy as np\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    # convert to grayscale\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img.astype(float)\n    # robust binarization: prefer sparser side for ink detection\n    med = np.median(gray)\n    prop = float(np.mean(gray < med))\n    thr = np.percentile(gray, 20) if prop > 0.5 else med\n    bw = (gray < thr).astype(np.uint8)\n    if bw.sum() == 0:\n        bw = (gray > thr).astype(np.uint8)\n    right = bw[:, (2*w)//3 : ].sum()\n    total = max(1.0, bw.sum())\n    return float(right / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of edge/gradient pixels with diagonal angles between ~20 and ~70 degrees (captures diagonal stroke prevalence)'\n    import numpy as np\n    import numpy as _np\n    if image is None:\n        return 0.0\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if h < 2 or w < 2:\n        return 0.0\n    gx, gy = _np.gradient(gray)\n    mag = _np.hypot(gx, gy)\n    if _np.all(mag == 0):\n        return 0.0\n    # consider only strong gradients (>70th percentile)\n    thr = _np.percentile(mag, 70)\n    mask = mag > thr\n    if _np.count_nonzero(mask) == 0:\n        return 0.0\n    angles = _np.abs(_np.arctan2(gy[mask], gx[mask]))  # 0..pi\n    # diagonal angles roughly between 20deg (0.35) and 70deg (1.22)\n    diag_mask = (angles >= 0.35) & (angles <= 1.22)\n    return float(_np.count_nonzero(diag_mask)) / float(_np.count_nonzero(mask))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean binary ink presence in a narrow horizontal band around the image midline (detects middle crossbar like in \"4\")'\n    import numpy as np\n    h, w = image.shape[:2]\n    # convert to grayscale\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # robust binarization (assume ink differs from median)\n    thr = np.mean(gray)\n    mask = gray < thr\n    prop = mask.mean()\n    if prop > 0.9 or prop < 0.01:\n        mask = gray > thr\n    # choose a narrow band around middle (10% of height)\n    band_h = max(1, h // 10)\n    start = max(0, h // 2 - band_h // 2)\n    band = mask[start:start + band_h, :]\n    return float(band.mean())\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy to combined horizontal+vertical gradient energy (higher = more diagonal strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray.astype(float))\n    except Exception:\n        # fallback if gradient fails\n        gy = np.zeros_like(gray, dtype=float)\n        gx = np.zeros_like(gray, dtype=float)\n    # approximate diagonal energy as |gx + gy|\n    diag = np.mean(np.abs(gx + gy))\n    hv = np.mean(np.abs(gx)) + np.mean(np.abs(gy))\n    return float(diag / (hv + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the central horizontal band (middle 30% of rows) vs whole ink mass (detects open-center 3/5)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    p5, p95 = np.percentile(gray, 5), np.percentile(gray, 95)\n    th = (p5 + p95) / 2.0\n    mask = gray < th\n    if mask.sum() > 0.9 * gray.size:\n        mask = gray > th\n    if mask.sum() == 0:\n        mask = gray < np.mean(gray)\n    top = int(h * 0.35)\n    bottom = int(h * 0.65)\n    central = mask[top:bottom, :]\n    central_count = float(np.sum(central))\n    total = float(np.sum(mask))\n    if total == 0:\n        return 0.0\n    return float(central_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient magnitude in the right third of the image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute x-gradient (axis=1)\n    gy = np.gradient(gray, axis=0)  # vertical gradient unused\n    gx = np.gradient(gray, axis=1)\n    right_third = gx[:, (2*w)//3:]\n    if right_third.size == 0:\n        return 0.0\n    return float(np.mean(np.abs(right_third)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of strong edge energy aligned with diagonal orientations (~\u00b145\u00b0) compared to all strong edges'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if h < 2 or w < 2:\n            return 0.0\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        gy, gx = np.gradient(gray)\n        mag = np.hypot(gx, gy)\n        if np.all(mag == 0):\n            return 0.0\n        # consider only relatively strong edges\n        thr = np.percentile(mag, 60)\n        strong = mag > thr\n        if not np.any(strong):\n            return 0.0\n        angle = np.abs(np.arctan2(gy, gx))  # absolute angle [0, pi]\n        # diagonal proximity to 45deg (pi/4) or 135deg (3pi/4)\n        diag_dist = np.minimum(np.abs(angle - (np.pi/4)), np.abs(angle - (3*np.pi/4)))\n        diag_mask = (diag_dist <= (np.pi/8)) & strong\n        return float(np.sum(mag[diag_mask]) / (np.sum(mag[strong]) + 1e-12))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical-edge asymmetry: (sum of vertical edge strength right - left) / total vertical edge strength'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy = np.gradient(gray.astype(float))[1]  # dI/dx approximates vertical edges\n    left_sum = float(np.sum(np.abs(gy[:, :w//2])))\n    right_sum = float(np.sum(np.abs(gy[:, w//2:])))\n    return float((right_sum - left_sum) / (left_sum + right_sum + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference of hole area between upper and lower halves of bounding box (top - bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 50)\n    mask = gray < thr\n    if mask.sum() < max(5, int(0.005 * h * w)):\n        mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    sub = mask[r0:r1+1, c0:c1+1]\n    inv = ~sub\n    H, W = inv.shape\n    # mark outer background\n    visited = np.zeros_like(inv, dtype=bool)\n    stack = []\n    for i in range(H):\n        for j in (0, W-1):\n            if inv[i, j] and not visited[i, j]:\n                stack.append((i, j)); visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = y+dy, x+dx\n                        if 0 <= ny < H and 0 <= nx < W and inv[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True; stack.append((ny, nx))\n    # count hole pixels in top half and bottom half\n    top_hole = 0\n    bottom_hole = 0\n    for i in range(H):\n        for j in range(W):\n            if inv[i, j] and not visited[i, j]:\n                # part of hole\n                if i < H // 2:\n                    top_hole += 1\n                else:\n                    bottom_hole += 1\n    denom = float(top_hole + bottom_hole) + 1e-8\n    return float((top_hole - bottom_hole) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-left vs top-right foreground density difference normalized by total top-half foreground (positive if more top-left)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    mn, mx = np.min(gray), np.max(gray)\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    m1 = gray < np.mean(gray)\n    m2 = gray > np.mean(gray)\n    mask = m1 if m1.sum() <= m2.sum() else m2\n    top_half = mask[:h//2, :]\n    left = top_half[:, :w//2].sum()\n    right = top_half[:, w//2:].sum()\n    denom = left + right\n    if denom == 0:\n        return 0.0\n    return float((left - right) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge energy (abs vertical gradient) in upper third to lower third (values >1 -> stronger upper horizontal structure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.asarray(image).astype(float)\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr\n    h, w = gray.shape[:2]\n    if h < 3:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gy = np.abs(gy)\n    upper = abs_gy[:h//3, :]\n    lower = abs_gy[-h//3:, :]\n    upper_energy = upper.mean() if upper.size else 0.0\n    lower_energy = lower.mean() if lower.size else 0.0\n    return float((upper_energy + 1e-9) / (lower_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of transitions (ink <-> background) along the central column normalized by image height (high for multiple separated strokes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image)\n    if arr.size == 0:\n        return 0.0\n    h, w = arr.shape[:2]\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr.astype(float)\n    meanv = float(np.mean(gray))\n    mask = gray < meanv\n    if mask.sum() == 0:\n        mask = gray > meanv\n    col = mask[:, w//2].astype(int) if w > 0 else np.zeros((h,), dtype=int)\n    if col.size < 2:\n        return 0.0\n    transitions = np.sum(col[1:] != col[:-1])\n    return float(transitions / max(1, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of horizontal gradient energy in the upper half of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    if gray.size == 0:\n        return 0.0\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    gy, gx = np.gradient(gray.astype(np.float32))\n    abs_gx = np.abs(gx)\n    h = gray.shape[0]\n    mid = max(1, h // 2)\n    upper_energy = np.sum(abs_gx[:mid, :])\n    total_energy = np.sum(abs_gx) + 1e-9\n    return float(upper_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Max horizontal run length fraction weighted to emphasize runs near the top (long top bar detection)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 50))\n    ink = (gray < thr)\n    if np.count_nonzero(ink) < 1:\n        ink = (gray > thr)\n    max_run = 0\n    max_row = 0\n    for r in range(h):\n        row = ink[r, :]\n        # find longest contiguous True sequence\n        cur = 0\n        best = 0\n        for val in row:\n            if val:\n                cur += 1\n            else:\n                if cur > best:\n                    best = cur\n                cur = 0\n        if cur > best:\n            best = cur\n        if best > max_run:\n            max_run = int(best)\n            max_row = r\n    run_frac = float(max_run) / float(max(w, 1))\n    # weight toward top rows: if max_row near top -> boost\n    row_norm = float(max_row) / float(max(h - 1, 1))\n    weighted = run_frac * (1.0 + (1.0 - row_norm))\n    return float(weighted)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical vs horizontal gradient energy in the right half (higher if there are strong vertical strokes on the right)'\n    try:\n        import numpy as np\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        g = (gray - np.min(gray)) / (np.max(gray) - np.min(gray) + 1e-9)\n        gy, gx = np.gradient(g)\n        h, w = g.shape\n        right = slice(w//2, w)\n        vert_energy = np.sum(np.abs(gy[:, right]))\n        horiz_energy = np.sum(np.abs(gx[:, right]))\n        return float(vert_energy / (horiz_energy + 1e-8))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute diagonal (top-right to bottom-left) gradient energy inside the top-right quadrant'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    # quadrant bounds (top-right)\n    r0, r1 = 0, max(1, h // 2)\n    c0, c1 = max(0, w // 2), w\n    sub = gray[r0:r1, c0:c1]\n    if sub.size == 0:\n        return 0.0\n    gy, gx = np.gradient(sub)\n    # projection onto diagonal vector (1,-1) normalized\n    proj = (gx - gy) / np.sqrt(2.0)\n    return float(np.mean(np.abs(proj)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between SE and SW diagonal edge energies (positive -> SE dominant)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 0.0\n    diff_se = np.sum(np.abs(gray[:-1, :-1] - gray[1:, 1:]))\n    diff_sw = np.sum(np.abs(gray[:-1, 1:] - gray[1:, :-1]))\n    denom = diff_se + diff_sw + 1e-6\n    return float((diff_se - diff_sw) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of enclosed holes (loops) in the digit stroke (9 and 8 tend to have loops)'\n    try:\n        import numpy as np\n        # grayscale + normalize\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        # bounding box around foreground\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 0.0\n        y0, y1 = ys.min(), ys.max()\n        x0, x1 = xs.min(), xs.max()\n        sub = ~fg[y0:y1+1, x0:x1+1]  # background inside bbox\n        # flood fill the background component that touches the border to exclude outer background\n        H, W = sub.shape\n        visited = np.zeros_like(sub, dtype=np.bool_)\n        from collections import deque\n        q = deque()\n        for i in range(H):\n            for j in (0, W-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        for j in range(W):\n            for i in (0, H-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        while q:\n            y, x = q.popleft()\n            for dy in (-1, 0, 1):\n                for dx in (-1, 0, 1):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n        # now count remaining background components (holes)\n        holes = 0\n        for i in range(H):\n            for j in range(W):\n                if sub[i, j] and not visited[i, j]:\n                    # new hole\n                    holes += 1\n                    # mark component\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        for dy in (-1, 0, 1):\n                            for dx in (-1, 0, 1):\n                                ny, nx = y+dy, x+dx\n                                if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n        return float(holes)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of separated dark runs along the central vertical column (counts lobes along center line)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = (gray < thr)\n    if fg.sum() == 0 or fg.sum() > 0.9 * fg.size:\n        fg = (gray > thr)\n    c = w // 2\n    col = fg[:, c].astype(int)\n    if col.sum() == 0:\n        return 0.0\n    padded = np.concatenate(([0], col, [0]))\n    changes = np.where(padded[1:] != padded[:-1])[0]\n    runs = changes.reshape(-1, 2)\n    num_runs = runs.shape[0]\n    return float(num_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of foreground point cloud (linear regression slope of y vs x), positive indicates down-right dominant strokes'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    maxv = float(np.max(gray)) if np.max(gray) != 0 else 1.0\n    gray = gray / maxv\n    p_low = np.percentile(gray, 40)\n    p_high = np.percentile(gray, 60)\n    fg = ((gray < p_low) if np.mean(gray) <= np.median(gray) else (gray > p_high)).astype(np.uint8)\n    ys, xs = np.nonzero(fg)\n    if xs.size < 2:\n        return 0.0\n    xs = xs.astype(float)\n    ys = ys.astype(float)\n    xm = xs.mean()\n    ym = ys.mean()\n    varx = np.sum((xs - xm) ** 2)\n    if varx == 0:\n        return 0.0\n    cov = np.sum((xs - xm) * (ys - ym))\n    slope = cov / varx\n    # normalize roughly by aspect ratio (height/width) to keep values comparable\n    h, w = gray.shape\n    norm = (h / (w + 1e-9))\n    return float(slope * norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom quarter of the image (lower density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gmax = gray.max()\n    if gmax > 1.5:\n        gray = gray / gmax\n    thresh = float(np.mean(gray))\n    dark_frac = float(np.mean(gray < thresh))\n    if 0.01 < dark_frac < 0.99:\n        ink = (gray < thresh) if dark_frac < 0.5 else (gray > thresh)\n    else:\n        ink = gray < thresh\n    h, w = gray.shape\n    if h < 4:\n        return float(np.count_nonzero(ink) / max(1.0, h*w))\n    bottom_start = (3 * h) // 4\n    bottom_count = float(np.count_nonzero(ink[bottom_start:h, :]))\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    return float(bottom_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in the upper-left quadrant to the upper-right quadrant (helps detect left-leaning top strokes)'\n    import numpy as np\n    # convert to grayscale\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    # robust binarization: choose ink as the minority side of mean threshold\n    thresh = np.mean(gray)\n    mask = gray < thresh\n    if np.count_nonzero(mask) > mask.size / 2:\n        mask = ~mask\n    ul = mask[:h//2, :w//2].sum()\n    ur = mask[:h//2, w//2:].sum()\n    eps = 1e-6\n    return float((ul + eps) / (ur + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in the top third vs bottom third (top_third / (bottom_third+eps)); 5s often have heavier bottom third'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(int)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(int)\n    t = max(1, h // 3)\n    top = np.sum(ink[:t, :])\n    bottom = np.sum(ink[-t:, :])\n    return float(top) / (float(bottom) + 1e-6)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient: detects prevalence of horizontal bars vs round edges'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    if gray.size == 0:\n        return 1.0\n    try:\n        gy, gx = np.gradient(gray)  # gy: d/drow (vertical), gx: d/dcol (horizontal)\n    except Exception:\n        return 1.0\n    mean_abs_gx = float(np.mean(np.abs(gx)))\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    return float(mean_abs_gx / (mean_abs_gy + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'L1-normalized 180-degree rotational asymmetry: mean absolute difference between image and rotated 180'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    rot = np.rot90(gray, 2)\n    diff = np.abs(gray - rot)\n    denom = float(np.mean(np.abs(gray)) + 1e-6)\n    return float(np.mean(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the top-right quadrant (upper-right density ratio)'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    thresh = np.mean(norm)\n    ink = (norm < thresh).astype(np.float32)\n    if np.mean(ink) < 1e-3:\n        ink = 1.0 - ink\n    mid_h, mid_w = h // 2, w // 2\n    top_right = ink[0:mid_h, mid_w:w]\n    total = ink.sum()\n    if total <= 0:\n        return 0.0\n    return float(top_right.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal bias: (sum along / diagonal - sum anti-diagonal) normalized by total, captures slanted strokes'\n    eps = 1e-9\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < eps:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    ink = (norm < 0.5).astype(float)\n    # project coordinates onto diagonal vectors\n    ys, xs = np.nonzero(ink)\n    if xs.size == 0:\n        return 0.0\n    proj_diag = xs + ys  # projection onto (1,1)\n    proj_antidiag = xs - ys  # projection onto (1,-1)\n    # compute weighted sums\n    sd = float(np.sum(proj_diag))\n    sa = float(np.sum(np.abs(proj_antidiag)))\n    total = float(np.sum(ink))\n    return float((sd - sa) / (total + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box fill ratio: fraction of the bounding box area that is ink (low values indicate holes or thin strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    mask = mask.astype(np.uint8)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n    bh = rmax - rmin + 1\n    bw = cmax - cmin + 1\n    bbox_area = max(1, bh * bw)\n    ink = mask.sum()\n    return float(ink / bbox_area)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude on the right half minus left half (positive if right half has stronger edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    left_mag = np.mean(mag[:, :w//2]) if w//2 > 0 else 0.0\n    right_mag = np.mean(mag[:, w//2:]) if w - w//2 > 0 else 0.0\n    return float(right_mag - left_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the right-middle region (rows h/4..3h/4, cols w/2..w)'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    p40 = np.percentile(gray.flatten(), 40)\n    p60 = np.percentile(gray.flatten(), 60)\n    mask = gray <= p40\n    total = mask.sum()\n    if total == 0 or total > 0.9 * h * w:\n        mask = gray >= p60\n        total = mask.sum()\n    if total == 0:\n        # fallback: threshold by mean\n        mask = gray <= np.mean(gray)\n        total = mask.sum()\n        if total == 0:\n            return 0.0\n    r0, r1 = h // 4, 3 * h // 4\n    c0, c1 = w // 2, w\n    right_mid = mask[r0:r1, c0:c1]\n    right_mid_count = int(np.count_nonzero(right_mid))\n    return float(right_mid_count) / float(total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of ink/background transitions per column (columns with many transitions indicate loops/complex shapes like 3)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    mx = gray.max()\n    if mx > 1e-9:\n        gray = gray / float(mx)\n    thr = np.mean(gray)\n    ink = (gray < thr).astype(np.int8)\n    # transitions along each column: sum of abs differences between adjacent rows\n    transitions_per_col = np.sum(np.abs(np.diff(ink, axis=0)), axis=0)\n    # average transitions per column\n    avg_trans = float(np.mean(transitions_per_col))\n    # normalized by possible maximum (h-1)\n    return float(avg_trans / max(1.0, h - 1))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean 45-degree diagonal edge energy in the right half normalized by global diagonal energy (detects diagonal strokes like in 7)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mi, ma = float(np.min(gray)), float(np.max(gray))\n    gray = (gray - mi) / (ma - mi + 1e-8)\n    gy, gx = np.gradient(gray)\n    diag_energy = np.abs(gx + gy)  # energy along one diagonal direction\n    h, w = gray.shape[:2]\n    right = diag_energy[:, w//2:]\n    global_mean = float(np.mean(diag_energy) + 1e-8)\n    right_mean = float(np.mean(right))\n    return float(right_mean / global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength (|vertical derivative|) in the bottom third of the image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    start = (2 * h) // 3\n    bottom = gray[start:h, :]\n    gy, gx = np.gradient(bottom.astype(float))\n    horiz_edge = np.abs(gy)\n    return float(np.mean(horiz_edge))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-to-lower stroke density ratio (higher if more strokes in upper half)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn + 1e-8\n    norm = (gray - mn) / rng\n    stroke_darker = np.mean(norm) < 0.5\n    mask = (norm < 0.5) if stroke_darker else (norm > 0.5)\n    mid = h // 2\n    upper = mask[:mid, :]\n    lower = mask[mid:, :]\n    upper_mean = float(np.sum(upper) / (upper.size + 1e-8))\n    lower_mean = float(np.sum(lower) / (lower.size + 1e-8))\n    return float((upper_mean - lower_mean))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized x-component of vector from global centroid to top-quarter centroid (tail direction score)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    meanv = float(np.mean(gray))\n    if meanv > (mn + mx) / 2.0:\n        fg = (gray < meanv)\n    else:\n        fg = (gray > meanv)\n    coords = np.argwhere(fg)\n    if coords.size == 0:\n        return 0.0\n    # overall centroid (x,y)\n    overall = np.array([coords[:, 1].mean(), coords[:, 0].mean()], dtype=float)\n    # top quarter region\n    top_lim = max(1, h // 4)\n    top_coords = coords[coords[:, 0] < top_lim]\n    if top_coords.shape[0] < 3:\n        # if not enough top pixels, try upper-middle quarter\n        top_coords = coords[(coords[:, 0] >= h//4) & (coords[:, 0] < h//2)]\n        if top_coords.shape[0] < 3:\n            return 0.0\n    top_centroid = np.array([top_coords[:, 1].mean(), top_coords[:, 0].mean()], dtype=float)\n    vec = top_centroid - overall\n    norm = np.sqrt(vec[0] * vec[0] + vec[1] * vec[1]) + 1e-8\n    # return normalized x component in range [-1,1]\n    return float(vec[0] / norm)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside a small central circular region (higher for digits with centered hole like 0)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    r = max(1, min(h, w) // 6)\n    ys = np.arange(h)[:, None]\n    xs = np.arange(w)[None, :]\n    mask = ((ys - cy) ** 2 + (xs - cx) ** 2) <= (r ** 2)\n    bg = ~fg\n    region = bg & mask\n    denom = float(np.count_nonzero(mask)) + 1e-6\n    return float(np.count_nonzero(region) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of the discrete curvature (second differences) of the rightmost ink boundary (higher for more curved shapes like 3)'\n    import numpy as np\n    eps = 1e-6\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.copy()\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 40)\n    bin_img = (gray <= thresh).astype(np.uint8)\n    if bin_img.sum() > (h * w) * 0.6:\n        bin_img = 1 - bin_img\n    rightmost = []\n    for r in range(h):\n        cols = np.where(bin_img[r, :])[0]\n        if cols.size:\n            rightmost.append(cols[-1])\n    if len(rightmost) < 3:\n        return 0.0\n    rightmost = np.array(rightmost, dtype=float)\n    # second differences\n    second_diff = rightmost[2:] - 2 * rightmost[1:-1] + rightmost[:-2]\n    return float(np.var(second_diff) / (w**2 + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy on the right half to total vertical gradient energy (captures vertical edge concentration on the right)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # compute vertical gradient on grayscale image\n    gy, gx = np.gradient(gray)\n    vmag = np.abs(gy)\n    h, w = gray.shape\n    right = vmag[:, w // 2:]\n    total_energy = vmag.sum()\n    if total_energy == 0:\n        return 0.0\n    right_energy = right.sum()\n    return float(right_energy / total_energy)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal distance from the right edge to the rightmost ink pixel (0 means ink touches right border)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    bg_med = float(np.median(border))\n    img_med = float(np.median(gray))\n    thresh = (bg_med + img_med) / 2.0\n    if bg_med > img_med:\n        ink = gray < thresh\n    else:\n        ink = gray > thresh\n    ink = ink.astype(bool)\n    if not np.any(ink):\n        return 1.0\n    # find rightmost ink column index\n    cols = np.where(np.any(ink, axis=0))[0]\n    if cols.size == 0:\n        return 1.0\n    rightmost = float(cols.max())\n    dist = (w - 1.0 - rightmost) / float(w)\n    return float(dist)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom third of the image (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        bottom = np.count_nonzero(ink[(2*h)//3 : , :])\n        return float(bottom) / float(total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in a central square region (middle half) to indicate center occlusion vs hole'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    ch0, ch1 = h // 4, 3 * h // 4\n    cw0, cw1 = w // 4, 3 * w // 4\n    # ensure indices valid\n    ch0 = max(0, min(h, ch0)); ch1 = max(0, min(h, ch1))\n    cw0 = max(0, min(w, cw0)); cw1 = max(0, min(w, cw1))\n    center_region = ink[ch0:ch1, cw0:cw1]\n    center_ink = float(np.sum(center_region))\n    total_ink = float(np.sum(ink))\n    if total_ink <= 0.0:\n        return 0.0\n    return float(center_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right (vertical) symmetry: average absolute column difference between left and flipped right halves (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # normalize 0..1\n    mn, mx = float(gray.min()), float(gray.max())\n    if mx == mn:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    mid = w // 2\n    left = norm[:, :mid]\n    if w % 2 == 0:\n        right = norm[:, mid:]\n    else:\n        right = norm[:, mid+1:]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # crop to common width\n    minw = min(left.shape[1], right_flipped.shape[1])\n    if minw == 0:\n        return 0.0\n    diff = np.abs(left[:, :minw] - right_flipped[:, :minw])\n    # normalize by mean intensity to avoid scale effects\n    return float(np.mean(diff))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of the largest hole centroid from image center normalized by width (positive -> hole to the right)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr  # True = ink, False = background\n    background = ~ink\n    # Flood fill external background starting from borders\n    seen = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    # push all border background pixels\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); seen[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); seen[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not seen[y, 0]:\n            dq.append((y, 0)); seen[y, 0] = True\n        if background[y, w - 1] and not seen[y, w - 1]:\n            dq.append((y, w - 1)); seen[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        # 4-neighbors\n        if y > 0 and background[y - 1, x] and not seen[y - 1, x]:\n            seen[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not seen[y + 1, x]:\n            seen[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not seen[y, x - 1]:\n            seen[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not seen[y, x + 1]:\n            seen[y, x + 1] = True; dq.append((y, x + 1))\n    # Holes are background pixels not reached by external fill\n    holes = background & (~seen)\n    hole_count = np.count_nonzero(holes)\n    if hole_count == 0:\n        return 0.0\n    ys, xs = np.where(holes)\n    cx = np.mean(xs)\n    center_x = (w - 1) / 2.0\n    return float((cx - center_x) / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal stroke orientation (angle in radians normalized to [-pi,pi]) estimated from ink pixel PCA'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.percentile(gray, 50))\n    mask_dark = gray < thr\n    ink_ratio = float(mask_dark.mean())\n    if ink_ratio > 0.6 or ink_ratio < 0.01:\n        thr = float(np.mean(gray))\n        mask_dark = gray < thr\n    mask = mask_dark if float(mask_dark.mean()) <= 0.6 else (~mask_dark)\n    coords = np.column_stack(np.nonzero(mask))\n    if coords.shape[0] < 3:\n        return 0.0\n    coords = coords.astype(float)\n    coords -= coords.mean(axis=0)\n    U, S, Vt = np.linalg.svd(coords, full_matrices=False)\n    # principal axis is Vt[0]; compute angle of vector (dy, dx)\n    vy, vx = Vt[0,0], Vt[0,1]\n    angle = float(np.arctan2(vy, vx))\n    # normalize to a bounded float between -pi and pi\n    return float(angle)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom-right quadrant'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = (float(gray.max()) + float(gray.min())) / 2.0\n    ink = (gray < thresh).astype(np.float32)\n    br = ink[h//2:, w//2:]\n    total = float(np.sum(ink))\n    if total == 0.0:\n        return 0.0\n    return float(np.sum(br) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of binary transitions across rows (mean transitions per row normalized by width)'\n    import numpy as np\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    if w <= 1:\n        return 0.0\n    transitions = np.abs(mask[:, :-1].astype(int) - mask[:, 1:].astype(int)).sum(axis=1)\n    avg_trans = float(transitions.mean()) / max(1.0, (w - 1))\n    return float(avg_trans)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between mean intensity in a small central disk and an outer ring (high when a light hole is surrounded by dark ink)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    h, w = arr.shape[:2]\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    Y, X = np.ogrid[:h, :w]\n    dist = np.sqrt((Y - cy) ** 2 + (X - cx) ** 2)\n    r = max(1.0, min(h, w) / 8.0)\n    inner_mask = dist <= r\n    outer_mask = (dist > r) & (dist <= 2.0 * r)\n    if inner_mask.sum() == 0 or outer_mask.sum() == 0:\n        return 0.0\n    inner_mean = float(np.mean(gray[inner_mask]))\n    outer_mean = float(np.mean(gray[outer_mask]))\n    # contrast where hole is lighter than surrounding ink -> positive\n    return float((inner_mean - outer_mean) / (np.abs(outer_mean) + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ink density in the left vertical third within the middle third of rows (detects left vertical strokes)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    r0 = h // 3\n    r1 = min(h, 2 * h // 3)\n    c1 = max(1, w // 3)\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.float32)\n    region = ink[r0:r1, 0:c1]\n    area = region.size if region.size > 0 else 1.0\n    return float(region.sum() / area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ink density ratio: top third ink density divided by bottom third ink density (captures top-heavy strokes like in 7)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3:\n        return 0.0\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    if p10 < p90:\n        thresh = 0.5 * (p10 + p90)\n        ink = gray < thresh\n    else:\n        thresh = np.mean(gray)\n        ink = gray > thresh\n    top_block = ink[:h//3, :]\n    bottom_block = ink[2*h//3:, :]\n    top_density = float(np.sum(top_block)) / max(1.0, top_block.size)\n    bottom_density = float(np.sum(bottom_block)) / max(1.0, bottom_block.size)\n    return float(top_density / (bottom_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in right third to ink in left third (detects right-heavy digits like 3/7)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    if np.max(gray) > 1.5:\n        gray = gray / 255.0\n    mid = float(np.percentile(gray, 50))\n    ink = (gray < mid) if (np.mean(gray) > 0.5) else (gray > mid)\n    ink = ink.astype(np.uint8)\n    h, w = gray.shape\n    third = max(1, w // 3)\n    left = float(np.sum(ink[:, :third]))\n    right = float(np.sum(ink[:, -third:]))\n    # return ratio right/left (higher means more ink on right)\n    return float(right / (left + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical edge strength to mean absolute diagonal (descending) edge strength'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-9:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    gx, gy = np.gradient(norm)\n    vert = np.mean(np.abs(gx))\n    diag_desc = np.mean(np.abs(gx + gy))\n    eps = 1e-9\n    return float((vert + eps) / (diag_desc + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized index of the topmost foreground row (0 at top, 1 at bottom); smaller values indicate top-heavy marks like the bar of \"7\"'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    rows = np.any(fg, axis=1)\n    idxs = np.where(rows)[0]\n    if idxs.size == 0:\n        return 1.0\n    top_idx = idxs[0]\n    return float(top_idx) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of left half mass to total mass (0..1); >0.5 means left-heavy'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.5\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        binar = (gray < (med - delta)).astype(float)\n    else:\n        binar = (gray > (med + delta)).astype(float)\n    half = w // 2\n    left = float(binar[:, :half].sum())\n    right = float(binar[:, half:].sum())\n    total = left + right\n    if total == 0:\n        return 0.5\n    return float(left / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal gradient in the top third vs overall (high value indicates a prominent top bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # horizontal gradient\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    top_region = abs_gx[0:max(1, h//3), :]\n    top_mean = float(np.mean(top_region)) if top_region.size > 0 else 0.0\n    overall_mean = float(np.mean(abs_gx)) + 1e-9\n    return float(top_mean / overall_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute diagonal difference (shift (1,1)) to mean absolute vertical gradient (detects diagonal strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-12)\n    # diagonal difference (down-right)\n    diag = np.abs(g - np.roll(np.roll(g, -1, axis=0), -1, axis=1))\n    # avoid wrap-around influence by zeroing last row and column\n    diag[-1, :] = 0\n    diag[:, -1] = 0\n    gy = np.abs(np.gradient(g, axis=0))\n    diab = float(np.mean(np.abs(diag)))\n    vertb = float(np.mean(np.abs(gy))) + 1e-12\n    return float(diab / vertb)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge strength to horizontal edge strength (mean absolute dy / mean absolute dx)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    v_strength = float(np.mean(np.abs(gy)))\n    h_strength = float(np.mean(np.abs(gx)))\n    if h_strength <= 1e-9:\n        return float(v_strength / (1e-9))\n    return float(v_strength / h_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of hole pixels located in the upper half of the image (0 if no holes)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr\n    background = ~ink\n    # Flood-fill external background\n    ext = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); ext[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); ext[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not ext[y, 0]:\n            dq.append((y, 0)); ext[y, 0] = True\n        if background[y, w - 1] and not ext[y, w - 1]:\n            dq.append((y, w - 1)); ext[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        if y > 0 and background[y - 1, x] and not ext[y - 1, x]:\n            ext[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not ext[y + 1, x]:\n            ext[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not ext[y, x - 1]:\n            ext[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not ext[y, x + 1]:\n            ext[y, x + 1] = True; dq.append((y, x + 1))\n    holes = background & (~ext)\n    total_hole = np.count_nonzero(holes)\n    if total_hole == 0:\n        return 0.0\n    upper = holes[:h // 2, :]\n    upper_count = np.count_nonzero(upper)\n    return float(upper_count) / float(total_hole)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Area of the largest background cavity inside the ink bounding box normalized by bbox area'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = (np.max(gray) + np.min(gray)) / 2.0\n    ink = (gray > thresh).astype(np.uint8)\n    if np.count_nonzero(ink) == 0:\n        return 0.0\n    rows = np.any(ink, axis=1)\n    cols = np.any(ink, axis=0)\n    rmin = int(np.argmax(rows))\n    rmax = int(h - 1 - np.argmax(rows[::-1]))\n    cmin = int(np.argmax(cols))\n    cmax = int(w - 1 - np.argmax(cols[::-1]))\n    if rmax < rmin or cmax < cmin:\n        return 0.0\n    sub = 1 - ink[rmin:rmax+1, cmin:cmax+1]  # background inside bbox\n    sh, sw = sub.shape\n    visited = np.zeros_like(sub, dtype=bool)\n    largest = 0\n    for i in range(sh):\n        for j in range(sw):\n            if sub[i, j] and not visited[i, j]:\n                stack = [(i, j)]\n                visited[i, j] = True\n                area = 0\n                touches_border = False\n                while stack:\n                    y, x = stack.pop()\n                    area += 1\n                    if y == 0 or x == 0 or y == sh-1 or x == sw-1:\n                        touches_border = True\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = y+dy, x+dx\n                        if 0 <= ny < sh and 0 <= nx < sw and sub[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n                if not touches_border and area > largest:\n                    largest = area\n    bbox_area = max(1, sh * sw)\n    return float(largest / bbox_area)\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 vertical symmetry score for the upper half: average absolute column difference between left and flipped right (normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    half_h = max(1, h // 2)\n    upper = gray[0:half_h, :]\n    # Normalized to [0,1] by dividing by intensity range\n    amax = upper.max()\n    amin = upper.min()\n    rng = amax - amin if amax != amin else 1.0\n    norm = (upper - amin) / rng\n    left = norm[:, :w//2]\n    right = norm[:, w - (w//2):]  # ensure same width when w odd\n    # flip right horizontally to compare with left\n    right_flipped = np.fliplr(right)\n    # pad to equal widths if necessary\n    if left.shape[1] != right_flipped.shape[1]:\n        minw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minw]\n        right_flipped = right_flipped[:, :minw]\n    diff = np.abs(left - right_flipped)\n    # normalized by number of pixels\n    return float(np.mean(diff))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink located in the rightmost third of the image (useful to detect right-side tails/strokes like 4 and 9)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(img)\n    ink = img < thresh\n    total = ink.sum()\n    if total == 0:\n        return 0.0\n    right = ink[:, (2*w)//3 : w].sum()\n    return float(right / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom quarter of the image'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    t = np.percentile(gray, 40)\n    ink = gray <= t\n    if np.count_nonzero(ink) == 0:\n        t2 = np.percentile(gray, 60)\n        ink = gray >= t2\n    if np.count_nonzero(ink) == 0:\n        return 0.0\n    bottom_start = int(3 * h / 4)\n    bottom_ink = ink[bottom_start:h, :].sum()\n    total_ink = ink.sum()\n    return float(bottom_ink / (total_ink + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal (main) symmetry score: mean absolute difference between center square and its transpose (0=perfect)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    s = min(h, w)\n    if s == 0:\n        return 0.0\n    r0 = (h - s) // 2\n    c0 = (w - s) // 2\n    square = gray[r0:r0+s, c0:c0+s]\n    # normalize by dynamic range\n    rng = float(np.max(square) - np.min(square))\n    if rng == 0:\n        return 0.0\n    diff = np.abs(square - square.T)\n    score = float(np.mean(diff) / rng)\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal edge energy: mean absolute diagonal differences normalized by total gradient energy'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gray = gray.astype(float)\n    # normalize to 0..1\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn if mx != mn else 1.0\n    grayn = (gray - mn) / rng\n    # diagonal difference along NW->SE and NE->SW\n    d1 = np.abs(grayn - np.roll(grayn, 1, axis=0).astype(float))\n    d1 = np.abs(d1 - np.roll(d1, 1, axis=1))\n    d2 = np.abs(grayn - np.roll(grayn, 1, axis=0))\n    d2 = np.abs(d2 - np.roll(d2, -1, axis=1))\n    diag_energy = np.mean(d1) + np.mean(d2)\n    # total (vertical+horizontal) energy\n    gy, gx = np.gradient(grayn)\n    total_energy = (np.mean(np.abs(gy)) + np.mean(np.abs(gx))) + 1e-8\n    return float(diag_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute diagonal gradient magnitude inside a band around the main diagonal (measures diagonal stroke strength)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    # grayscale\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    # gradients\n    try:\n        gy, gx = np.gradient(gray.astype(float))\n    except Exception:\n        return 0.0\n    # diagonal component approximately (gx + gy) / sqrt(2)\n    diag = (gx + gy) / np.sqrt(2.0)\n    # build band mask around main diagonal\n    yy, xx = np.mgrid[0:h, 0:w]\n    # distance from main diagonal normalized\n    diag_dist = np.abs((yy / max(1.0, h - 1)) - (xx / max(1.0, w - 1)))\n    band_width = 0.12  # proportion of image; adjustable\n    mask = diag_dist <= band_width\n    vals = np.abs(diag[mask])\n    if vals.size == 0:\n        return 0.0\n    return float(vals.mean())\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average corner-like response: mean of |gx|*|gy| (high for sharp corners common in 5)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = np.min(gray), np.max(gray)\n    denom = mx - mn if mx > mn else 1.0\n    gray_norm = (gray - mn) / denom\n    gy, gx = np.gradient(gray_norm)\n    cornerness = np.abs(gx) * np.abs(gy)\n    # normalize by average gradient magnitude to be scale invariant\n    avg_grad = (np.mean(np.abs(gx)) + np.mean(np.abs(gy))) / 2.0 + 1e-9\n    return float(np.mean(cornerness) / avg_grad)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Skewness of the vertical projection (column sums) indicating right-skew or left-skew of ink'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if image.ndim == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n        thr = 0.5 * (np.percentile(gray, 10) + np.percentile(gray, 90))\n        lower_count = np.sum(gray < thr)\n        ink = (gray < thr) if lower_count < (gray.size - lower_count) else (gray >= thr)\n        col_sums = ink.sum(axis=0).astype(float)\n        if col_sums.sum() == 0:\n            return 0.0\n        p = col_sums / col_sums.sum()\n        xs = np.linspace(0.0, 1.0, num=w)\n        mean = (xs * p).sum()\n        std = np.sqrt(((xs - mean)**2 * p).sum())\n        if std <= 1e-6:\n            return 0.0\n        skew = (( (xs - mean)**3 * p).sum()) / (std**3)\n        return float(skew)\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate vertical separation between two prominent background peaks inside a central vertical strip (returns normalized row-distance, 0 if <2 peaks)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    # central vertical strip\n    half = max(1, w // 10)\n    c = w // 2\n    c0 = max(0, c - half)\n    c1 = min(w, c + half + 1)\n    strip_bg_fraction = np.mean((~fg)[:, c0:c1], axis=1)\n    peak_mask = strip_bg_fraction > 0.5\n    padded = np.concatenate(([0], peak_mask.view(np.int8), [0]))\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0] - 1\n    centers = []\n    for s, e in zip(starts, ends):\n        centers.append((s + e) / 2.0)\n    if len(centers) < 2:\n        return 0.0\n    # take two largest separated centers by distance\n    centers = np.array(centers)\n    # choose the two peaks with largest separation\n    i, j = np.unravel_index(np.argmax(np.abs(centers[:, None] - centers[None, :])), centers.shape*2)\n    sep = abs(centers[i] - centers[j])\n    return float(sep / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean signed horizontal balance of edge strength in the upper half (captures asymmetry of top curve orientations)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    upper = gray[0:h // 2, :]\n    # approximate gradients\n    gx = np.abs(np.gradient(upper, axis=1))\n    gy = np.abs(np.gradient(upper, axis=0))\n    # signed measure: positive when horizontal edges stronger, negative when vertical stronger\n    diff = gx - gy\n    # weight right side a bit more to emphasize curvature on the right\n    weights = np.linspace(0.5, 1.5, upper.shape[1])[None, :]\n    weighted = diff * weights\n    result = float(np.mean(weighted)) / (np.mean(np.abs(diff)) + 1e-8)\n    return result\n",
    "def feature(image: np.ndarray) -> float:\n    'Ink density inside the lower-right triangular region (captures lower-right diagonal strokes)'\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) == 0:\n        ink = gray > thresh\n    # define lower-right triangle: rows r and cols c where (c/w) + ( (h-1-r)/h ) > 1\n    rows = np.arange(h).reshape(-1, 1)\n    cols = np.arange(w).reshape(1, -1)\n    mask = (cols / max(1, w - 1)) + ((h - 1 - rows) / max(1, h - 1)) > 1.0\n    tri = ink & mask\n    total = np.count_nonzero(ink)\n    if total == 0:\n        return 0.0\n    return float(np.count_nonzero(tri) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average diagonal orientation score (high when gradients align near 45\u00b0 or 225\u00b0)'\n    import numpy as np\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gx = np.zeros_like(gray)\n        gy = np.zeros_like(gray)\n    mag = np.hypot(gx, gy)\n    if mag.sum() == 0:\n        return 0.0\n    ang = np.abs(np.arctan2(gy, gx))  # range [0, pi]\n    # distance from diagonal (pi/4), normalized to [0,1] where 1 means perfect diagonal\n    dist = np.abs(ang - (np.pi / 4.0)) / (np.pi / 4.0)\n    diag_score = 1.0 - np.clip(dist, 0.0, 1.0)\n    # weighted mean by magnitude\n    return float((diag_score * mag).sum() / mag.sum())\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of edge energy that is diagonal (detects slanted strokes like the 9 tail)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gray = gray.astype(float)\n    gx, gy = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    total = mag.sum()\n    if total < 1e-9:\n        return 0.0\n    # diagonal if |abs(gx)-abs(gy)| is small relative to their sum\n    diag_mask = np.abs(np.abs(gx) - np.abs(gy)) <= 0.3 * (np.abs(gx) + np.abs(gy) + 1e-9)\n    diag_energy = mag[diag_mask].sum()\n    return float(diag_energy / (total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Stddev of per-row stroke-thickness estimates (higher = more variation in thickness vertically)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray)\n    ink = (gray < thr)\n    if ink.sum() == 0:\n        return 0.0\n    h, w = ink.shape[:2]\n    thicknesses = []\n    for r in range(h):\n        row = ink[r, :].astype(int)\n        ink_pixels = row.sum()\n        # count transitions (changes between 0 and 1). Each stroke segment contributes 2 transitions.\n        trans = np.sum(row[:-1] != row[1:])\n        segments = max(1, trans // 2)\n        thickness = ink_pixels / segments if segments > 0 else float(ink_pixels)\n        thicknesses.append(thickness)\n    if len(thicknesses) <= 1:\n        return 0.0\n    return float(np.std(thicknesses) / (np.mean(thicknesses) + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical separation between two largest enclosed hole centroids normalized by image height (0 if fewer than 2 holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # exterior fill\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal = (~ink) & (~exterior)\n    visited = np.zeros_like(internal, dtype=bool)\n    centroids = []\n    for i in range(h):\n        for j in range(w):\n            if internal[i, j] and not visited[i, j]:\n                # BFS\n                q = deque()\n                q.append((i, j))\n                visited[i, j] = True\n                pts = [(i, j)]\n                while q:\n                    ci, cj = q.popleft()\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and internal[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            pts.append((ni, nj))\n                            q.append((ni, nj))\n                pts = np.array(pts)\n                centroids.append((float(np.mean(pts[:,0])), float(np.mean(pts[:,1])), pts.shape[0]))\n    if len(centroids) < 2:\n        return 0.0\n    # sort by area desc and take two largest\n    centroids.sort(key=lambda x: x[2], reverse=True)\n    y1 = centroids[0][0]\n    y2 = centroids[1][0]\n    return float(abs(y1 - y2) / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of significant peaks in the vertical projection (row-sum peaks), smoothed and normalized'\n    import numpy as np\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img.astype(float)\n    med = np.median(gray)\n    prop = float(np.mean(gray < med))\n    thr = np.percentile(gray, 20) if prop > 0.5 else med\n    bw = (gray < thr).astype(np.uint8)\n    if bw.sum() == 0:\n        bw = (gray > thr).astype(np.uint8)\n    proj = bw.sum(axis=1).astype(float)\n    if proj.max() == 0:\n        return 0.0\n    # smooth projection\n    kernel = np.ones(5) / 5.0\n    smooth = np.convolve(proj, kernel, mode='same')\n    meanv = smooth.mean()\n    # count local maxima above a fraction of mean\n    peaks = 0\n    for i in range(1, len(smooth)-1):\n        if smooth[i] > smooth[i-1] and smooth[i] > smooth[i+1] and smooth[i] > max(1e-6, 0.5*meanv):\n            peaks += 1\n    # normalize by plausible max (3 or h/10)\n    norm = max(1.0, float(min(5, h/10.0)))\n    return float(peaks / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in the upper-left quadrant to ink in the upper-right quadrant (top-left/top-right asymmetry)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 50))\n    mask_dark = gray < thr\n    if float(mask_dark.mean()) > 0.6 or float(mask_dark.mean()) < 0.01:\n        thr = float(np.mean(gray))\n        mask_dark = gray < thr\n    mask = (mask_dark if float(mask_dark.mean()) <= 0.6 else (~mask_dark)).astype(bool)\n    if mask.sum() == 0:\n        return 0.0\n    ul = mask[:h//2, :w//2].sum()\n    ur = mask[:h//2, w//2:].sum()\n    return float((ul + 1e-6) / (ur + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal gradient energy (sum|dI/dy| / (sum|dI/dx| + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    vert_energy = np.sum(np.abs(gy))\n    horz_energy = np.sum(np.abs(gx))\n    return float(vert_energy / (horz_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows with 4 or more binary transitions (proxy for loops/multiple segments)'\n    import numpy as np\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    if w <= 1:\n        return 0.0\n    transitions = np.abs(mask[:, :-1].astype(int) - mask[:, 1:].astype(int)).sum(axis=1)\n    rows_with_many = (transitions >= 4).sum()\n    return float(rows_with_many / max(1.0, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels contained in the largest connected component (1.0 if only one component or all ink in one piece)'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    h, w = gray.shape\n    m = _np.mean(gray)\n    ink = (gray < m).astype(_np.uint8)\n    total = int(ink.sum())\n    if total == 0:\n        return 0.0\n    visited = _np.zeros_like(ink, dtype=_np.uint8)\n    max_size = 0\n    for y in range(h):\n        for x in range(w):\n            if ink[y, x] and not visited[y, x]:\n                size = 0\n                stack = [(y, x)]\n                visited[y, x] = 1\n                while stack:\n                    cy, cx = stack.pop()\n                    size += 1\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = cy + dy, cx + dx\n                            if 0 <= ny < h and 0 <= nx < w:\n                                if ink[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = 1\n                                    stack.append((ny, nx))\n                if size > max_size:\n                    max_size = size\n    frac = float(max_size / float(total))\n    return frac\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate circularity: 4*pi*area / (perimeter^2) where 1.0 is perfect circle, 0 if undefined'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    m = _np.mean(gray)\n    ink = (gray < m).astype(_np.uint8)\n    area = float(ink.sum())\n    if area <= 0.0:\n        return 0.0\n    # perimeter estimate: ink pixels that have at least one 4-neighbor background\n    padded = _np.pad(ink, pad_width=1, mode='constant', constant_values=0)\n    perim = 0\n    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n        neighbor = padded[1+dy:padded.shape[0]-1+dy, 1+dx:padded.shape[1]-1+dx]\n        perim += _np.sum((ink == 1) & (neighbor == 0))\n    perim = float(perim)\n    if perim <= 0.0:\n        return 0.0\n    circ = float((4.0 * _np.pi * area) / (perim * perim))\n    return circ\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-quarter vs lower-quarter ink imbalance: (upper_quarter - lower_quarter) / (total + eps), range [-1,1]'\n    import numpy as _np\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(_np.float32)\n    h, w = gray.shape\n    m = _np.mean(gray)\n    ink = (gray < m).astype(_np.float32)\n    q = max(1, h // 4)\n    upper = float(ink[:q, :].sum())\n    lower = float(ink[-q:, :].sum())\n    total = float(ink.sum()) + 1e-6\n    imbalance = float((upper - lower) / total)\n    return imbalance\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of top-right quadrant ink pixels to the top-right corner (smaller if strokes start near corner)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = gray.min(), gray.max()\n    if mx - mn <= 1e-8:\n        return 1.0\n    norm = (gray - mn) / (mx - mn)\n    bin_img = norm < 0.5\n    if np.sum(bin_img) == 0:\n        bin_img = norm > 0.5\n    tr = bin_img[0:h//2, w//2:w]\n    ys, xs = np.nonzero(tr)\n    if ys.size == 0:\n        return 1.0\n    # coordinates relative to full image\n    ys_full = ys\n    xs_full = xs + (w//2)\n    dists = np.hypot((ys_full - 0), (xs_full - (w - 1)))\n    maxd = np.hypot(h, w) + 1e-8\n    result = float(np.mean(dists) / maxd)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal (main) symmetry score: mean absolute difference between center square and its transpose (0=perfect)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    s = min(h, w)\n    if s == 0:\n        return 0.0\n    r0 = (h - s) // 2\n    c0 = (w - s) // 2\n    square = gray[r0:r0+s, c0:c0+s]\n    # normalize by dynamic range\n    rng = float(np.max(square) - np.min(square))\n    if rng == 0:\n        return 0.0\n    diff = np.abs(square - square.T)\n    score = float(np.mean(diff) / rng)\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy to (vertical + horizontal) gradient energy'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)  # gy = d/drow (vertical), gx = d/dcol (horizontal)\n    vert = np.abs(gy)\n    hor = np.abs(gx)\n    diag1 = np.abs(gx + gy)\n    diag2 = np.abs(gx - gy)\n    diag_energy = diag1.sum() + diag2.sum()\n    base_energy = vert.sum() + hor.sum()\n    eps = 1e-8\n    return float(diag_energy / (base_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant average gradient angle in the top-right quadrant in degrees (negative/positive slope of strokes there can distinguish 7s or slanted parts of 4)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    tr = gray[: max(1, h // 3), max(0, 2 * w // 3):]\n    if tr.size == 0:\n        return 0.0\n    gy, gx = np.gradient(tr)\n    # average gradients\n    mean_gx = np.mean(gx)\n    mean_gy = np.mean(gy)\n    angle = np.arctan2(mean_gy, mean_gx)  # radians\n    # convert to degrees and normalize to [-180,180]\n    deg = np.degrees(angle)\n    return float(deg)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energies (NE-SW over NW-SE) to detect slanted strokes like in 7 or skewed 5/6'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    diag_ne_sw = gx - gy   # one diagonal orientation\n    diag_nw_se = gx + gy   # the other diagonal orientation\n    e1 = np.sum(np.abs(diag_ne_sw))\n    e2 = np.sum(np.abs(diag_nw_se))\n    return float((e1 + 1e-8) / (e2 + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative radial spread of ink: std(distance to centroid) / (mean distance + eps)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        thresh = np.percentile(gray, 50.0)\n        mask = (gray <= thresh)\n        ys, xs = np.where(mask)\n        if ys.size == 0:\n            return 0.0\n        cy, cx = ys.mean(), xs.mean()\n        dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n        mean_d = dists.mean()\n        std_d = dists.std()\n        eps = 1e-6\n        return float(std_d / (mean_d + eps))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude on the right half minus left half (positive if right half has stronger edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    left_mag = np.mean(mag[:, :w//2]) if w//2 > 0 else 0.0\n    right_mag = np.mean(mag[:, w//2:]) if w - w//2 > 0 else 0.0\n    return float(right_mag - left_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of ink along the top-right to bottom-left main diagonal (samples a stripe along that diagonal, high for 7)'\n    import numpy as np\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    m = np.mean(gray)\n    mask_dark = gray < m\n    mask_light = gray > m\n    mask = mask_dark if np.count_nonzero(mask_dark) <= np.count_nonzero(mask_light) else mask_light\n    n = max(h, w, 1)\n    total_samples = 0\n    ink_hits = 0\n    half_width = max(1, int(min(h, w) * 0.03) )  # sample a small stripe width\n    for t in range(n):\n        row = int((t / (n - 1)) * (h - 1))\n        col = int(((n - 1 - t) / (n - 1)) * (w - 1))\n        # sample small neighborhood\n        r0 = max(0, row - half_width)\n        r1 = min(h, row + half_width + 1)\n        c0 = max(0, col - half_width)\n        c1 = min(w, col + half_width + 1)\n        total_samples += (r1 - r0) * (c1 - c0)\n        ink_hits += np.count_nonzero(mask[r0:r1, c0:c1])\n    if total_samples == 0:\n        return 0.0\n    return float(ink_hits / total_samples)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels contained in the bottom-left quadrant of the tight ink bounding box'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    ink = gray > 0\n    if not np.any(ink):\n        return 0.0\n    rows = np.nonzero(np.any(ink, axis=1))[0]\n    cols = np.nonzero(np.any(ink, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1] + 1\n    c0, c1 = cols[0], cols[-1] + 1\n    sub = ink[r0:r1, c0:c1]\n    sh, sw = sub.shape\n    if sh == 0 or sw == 0:\n        return 0.0\n    bh = sh // 2\n    bw = sw // 2\n    bottom_left = sub[bh:, :bw]\n    total = float(np.count_nonzero(sub))\n    bl = float(np.count_nonzero(bottom_left))\n    return float(bl / (total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of ink/background transitions per row in the central horizontal band (captures loop multiplicity)'\n    import numpy as np\n    # Convert to grayscale float\n    if image is None:\n        return 0.0\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = img.mean(axis=2)\n    else:\n        gray = img\n    # Robust binarization: decide whether ink is darker than background\n    med = np.median(gray)\n    mean = np.mean(gray)\n    thresh = np.percentile(gray, 50)\n    if (med - mean) > 0:\n        ink = gray < thresh\n    else:\n        ink = gray > thresh\n    # central band (middle 1/5 of rows)\n    band_h = max(1, h // 5)\n    start = max(0, h // 2 - band_h // 2)\n    band = ink[start:start + band_h, :]\n    # transitions per row\n    diffs = np.abs(np.diff(band.astype(np.int32), axis=1))\n    transitions_per_row = diffs.sum(axis=1)\n    if transitions_per_row.size == 0:\n        return 0.0\n    return float(np.mean(transitions_per_row))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of ink relative to tight bounding box center (positive -> centroid to the right), normalized by bbox width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) if h * w > 0 else 0.0\n    ink_mask_candidate = gray < thr\n    if np.sum(ink_mask_candidate) > (h * w / 2):\n        ink = (~ink_mask_candidate).astype(np.uint8)\n    else:\n        ink = ink_mask_candidate.astype(np.uint8)\n    if np.sum(ink) == 0:\n        return 0.0\n    rows = np.any(ink, axis=1)\n    cols = np.any(ink, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    r0, r1 = int(np.argmax(rows)), int(len(rows) - np.argmax(rows[::-1]))\n    c0, c1 = int(np.argmax(cols)), int(len(cols) - np.argmax(cols[::-1]))\n    bbox = ink[r0:r1, c0:c1]\n    ys, xs = np.nonzero(bbox)\n    if len(xs) == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    bbox_width = max(1.0, bbox.shape[1])\n    center_x = (bbox_width - 1) / 2.0\n    offset = (centroid_x - center_x) / bbox_width\n    return float(offset)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry: average absolute column difference between left and flipped right'\n    import numpy as np\n    # Convert to grayscale and normalize to [0,1]\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn > 1e-8:\n        gray_n = (gray - mn) / (mx - mn)\n    else:\n        gray_n = np.zeros_like(gray)\n    # Foreground assumption adaptive to mean\n    thr = np.mean(gray_n)\n    fg = gray_n < thr if np.mean(gray_n) > 0.5 else gray_n > thr\n    # split left/right\n    mid = w // 2\n    left = fg[:, :mid].astype(float)\n    right = fg[:, w - mid:][:, ::-1].astype(float)  # flip right to compare\n    # pad to same shape if odd width\n    if left.shape[1] != right.shape[1]:\n        if left.shape[1] < right.shape[1]:\n            left = np.pad(left, ((0, 0), (0, right.shape[1] - left.shape[1])), mode='constant')\n        else:\n            right = np.pad(right, ((0, 0), (0, left.shape[1] - right.shape[1])), mode='constant')\n    # L1 normalized score\n    diff = np.abs(left - right)\n    score = np.mean(diff)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized strength of a continuous horizontal stroke in the top 25% rows (detects top bar of \"7\")'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    top_rows = max(1, h // 4)\n    # for each top row compute fraction of columns that are foreground; take the maximum\n    row_sums = np.sum(fg[:top_rows, :], axis=1).astype(float)\n    max_frac = np.max(row_sums) / float(w)\n    # Also scale by how many top rows have above-median fill\n    median_row = np.median(row_sums)\n    high_rows = np.count_nonzero(row_sums > median_row)\n    score = max_frac * (high_rows / float(top_rows))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate count of stroke endpoints (foreground pixels with <=1 8-neighbors)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray)\n    fg = (gray > thr).astype(np.uint8)\n    if fg.sum() == 0:\n        return 0.0\n    p = np.pad(fg, pad_width=1, mode='constant', constant_values=0)\n    # sum of 8 neighbors\n    neigh = (\n        p[0:-2,0:-2] + p[0:-2,1:-1] + p[0:-2,2:] +\n        p[1:-1,0:-2] +               p[1:-1,2:] +\n        p[2:,0:-2]   + p[2:,1:-1]   + p[2:,2:]\n    )\n    neigh = neigh * fg  # align dims (neigh already same shape as fg)\n    endpoints = np.count_nonzero((fg == 1) & (neigh <= 1))\n    return float(endpoints)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground density in top half versus bottom half (top_density / (bottom_density + eps))'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = gray_n < thr if np.mean(gray_n) > 0.5 else gray_n > thr\n    top = fg[:h // 2, :]\n    bottom = fg[h // 2:, :]\n    top_count = float(np.count_nonzero(top))\n    bottom_count = float(np.count_nonzero(bottom))\n    eps = 1e-6\n    return float(top_count / (bottom_count + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns in the top half that have two or more separated ink runs (detects stacked lobes)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        if h < 2 or w < 1:\n            return 0.0\n        lo, hi = float(np.min(gray)), float(np.max(gray))\n        if hi == lo:\n            return 0.0\n        th = lo + 0.5 * (hi - lo)\n        ink = (gray < th)\n        top_h = max(1, h // 2)\n        region = ink[:top_h, :]\n        cols_with_multi = 0\n        for c in range(w):\n            col = region[:, c].astype(np.uint8)\n            if col.sum() == 0:\n                continue\n            # count runs\n            diffs = np.diff(np.concatenate(([0], col, [0])))\n            runs = np.sum(diffs == 1)\n            if runs >= 2:\n                cols_with_multi += 1\n        return float(cols_with_multi) / float(w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of vertical transitions per column (variation across columns); higher => more vertical complexity'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mask = gray < np.mean(gray)\n    if mask.sum() > mask.size * 0.6:\n        mask = ~mask\n    h, w = mask.shape\n    if mask.sum() == 0:\n        return 0.0\n    transitions = []\n    for c in range(w):\n        col = mask[:, c].astype(np.uint8)\n        t = np.sum(col[:-1] != col[1:])\n        transitions.append(t)\n    return float(np.std(np.array(transitions)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum consecutive background gap (in columns) in the central 50% columns within the top 25% rows, normalized by width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = np.percentile(gray, 50)\n    ink = (gray < thr)\n    if np.count_nonzero(ink) == 0:\n        thr = np.mean(gray)\n        ink = (gray < thr)\n    top_rows = max(1, h // 4)\n    c0 = w // 4\n    c1 = w - c0\n    region = ~ink[0:top_rows, c0:c1]  # True where background\n    if region.size == 0:\n        return 0.0\n    # find max consecutive True in each row, take max across rows\n    max_gap = 0\n    for r in range(region.shape[0]):\n        row = region[r, :]\n        cur = 0\n        for v in row:\n            if v:\n                cur += 1\n                if cur > max_gap:\n                    max_gap = cur\n            else:\n                cur = 0\n    return float(max_gap / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge energy in the upper half vs lower half (upper_energy / (lower_energy + eps))'\n    eps = 1e-9\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    # horizontal gradient magnitude (differences along columns)\n    grad_h = np.abs(np.diff(norm, axis=1))\n    mid = h // 2\n    upper_energy = grad_h[:mid, :].sum()\n    lower_energy = grad_h[mid:, :].sum()\n    return float(upper_energy / (lower_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (mean row index of ink) normalized to [0,1] where 0 is top and 1 is bottom'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thresh = (float(np.min(gray)) + float(np.max(gray))) / 2.0\n    ink = (gray < thresh)\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.5\n    mean_row = coords[:, 0].mean()\n    return float(mean_row / max(1.0, h - 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest vertical background run in the center column within the top half normalized by image height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = (gray < thresh)\n    center_col = w // 2\n    col = ink[:h//2, center_col]  # top half center column\n    # find longest run of False (background) in this column slice\n    max_run = 0\n    cur = 0\n    for val in col:\n        if not val:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / float(h + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average length of horizontal ink runs divided by average length of vertical ink runs (>=1.0 indicates wider strokes).'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh).astype(np.uint8)\n    # horizontal runs: for each row, compute lengths of consecutive ones\n    horiz_lengths = []\n    for r in range(h):\n        row = ink[r]\n        if np.any(row):\n            # find run lengths\n            dif = np.diff(np.concatenate(([0], row, [0])))\n            starts = np.where(dif == 1)[0]\n            ends = np.where(dif == -1)[0]\n            lengths = ends - starts\n            horiz_lengths.extend(lengths.tolist())\n    vert_lengths = []\n    for c in range(w):\n        col = ink[:, c]\n        if np.any(col):\n            dif = np.diff(np.concatenate(([0], col, [0])))\n            starts = np.where(dif == 1)[0]\n            ends = np.where(dif == -1)[0]\n            lengths = ends - starts\n            vert_lengths.extend(lengths.tolist())\n    if len(horiz_lengths) == 0 and len(vert_lengths) == 0:\n        return 0.0\n    mean_h = float(np.mean(horiz_lengths)) if len(horiz_lengths) > 0 else 0.0\n    mean_v = float(np.mean(vert_lengths)) if len(vert_lengths) > 0 else 0.0\n    eps = 1e-6\n    return float(mean_h / (mean_v + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal gradients in the top third (fraction of total horizontal gradient energy)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute gradients: np.gradient returns [gy, gx]\n    gy, gx = np.gradient(gray.astype(float))\n    horiz_energy = np.abs(gx)\n    total = np.sum(horiz_energy) + 1e-9\n    top_region = slice(0, max(1, h // 3))\n    top_energy = np.sum(horiz_energy[top_region, :])\n    return float(top_energy / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energies: (|gx+gy| energy) / (|gx-gy| energy)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    diag1 = gx + gy\n    diag2 = gx - gy\n    e1 = np.sum(np.abs(diag1))\n    e2 = np.sum(np.abs(diag2))\n    eps = 1e-9\n    return float((e1 + eps) / (e2 + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the top third of the image (detects prominent top bars like in 7 or 9)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        top = gray[:max(1, h//3), :]\n        gy, gx = np.gradient(top)\n        horiz_edges = np.abs(gx)\n        return float(np.mean(horiz_edges))\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical-edge energy (abs gradient along columns) in the left half, normalized by region area'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    left = gray[:, : max(1, w // 2)]\n    gy, gx = np.gradient(left)\n    energy = np.mean(np.abs(gx))  # gx corresponds to changes across columns -> vertical strokes\n    return float(energy)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient (vertical strokes produce higher horizontal gradient)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mean_abs_gx = float(np.mean(np.abs(gx)))\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    return float((mean_abs_gx + 1e-9) / (mean_abs_gy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink mass in top half to bottom half (7 often has heavier top mass compared to 4)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p50 = np.percentile(gray, 50)\n    if gray.mean() > p50:\n        thresh = np.percentile(gray, 70); binary = gray > thresh\n    else:\n        thresh = np.percentile(gray, 30); binary = gray < thresh\n    h = binary.shape[0]\n    top = binary[:h // 2, :].sum()\n    bottom = binary[h // 2:, :].sum()\n    if bottom == 0:\n        return float(top)\n    return float((top + 1e-9) / (bottom + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal transitions per row (higher for complex shapes, lower for single-stroke 1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mx = gray.max()\n    weights = (mx - gray)\n    thr = np.percentile(weights, 60)\n    bin_fore = (weights >= thr).astype(np.uint8)\n    # transitions per row\n    if w < 2:\n        return 0.0\n    row_trans = np.abs(np.diff(bin_fore, axis=1)).sum(axis=1)\n    return float(np.mean(row_trans))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative density of foreground in lower-right quadrant vs lower-left quadrant (detects 7\\'s diagonal)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if image.ndim == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n        mn, mx = gray.min(), gray.max()\n        rng = mx - mn + 1e-9\n        norm = (gray - mn) / rng\n        dark_count = np.count_nonzero(norm < 0.5)\n        light_count = np.count_nonzero(norm > 0.5)\n        if dark_count == 0 and light_count == 0:\n            return 0.0\n        fg = (norm < 0.5) if dark_count <= light_count else (norm > 0.5)\n        mid_r = h // 2\n        mid_c = w // 2\n        br = fg[mid_r:h, mid_c:w]\n        bl = fg[mid_r:h, 0:mid_c]\n        br_sum = float(np.count_nonzero(br))\n        bl_sum = float(np.count_nonzero(bl)) + 1e-9\n        return br_sum / bl_sum\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median stroke thickness estimated as median length of contiguous foreground runs in rows, normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.0\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        fg = (gray < (med - delta)).astype(int)\n    else:\n        fg = (gray > (med + delta)).astype(int)\n    run_lengths = []\n    for r in range(h):\n        row = fg[r, :]\n        if row.sum() == 0:\n            continue\n        # find contiguous runs\n        diff = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = (ends - starts).astype(float)\n        if lengths.size > 0:\n            run_lengths.extend(lengths.tolist())\n    if len(run_lengths) == 0:\n        return 0.0\n    median_len = float(np.median(np.array(run_lengths)))\n    return float(median_len / max(1.0, w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical ink/background transitions along center column (normalized by height)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    flat = gray.flatten()\n    p50 = np.percentile(flat, 50) if flat.size else 0.0\n    lower_mean = np.mean(flat[flat <= p50]) if np.any(flat <= p50) else p50\n    upper_mean = np.mean(flat[flat >= p50]) if np.any(flat >= p50) else p50\n    if lower_mean < upper_mean:\n        mask = gray <= p50\n    else:\n        mask = gray >= p50\n    col = mask[:, w//2].astype(int)\n    if col.size < 2:\n        return 0.0\n    transitions = np.sum(np.abs(np.diff(col)))\n    return float(transitions) / float(h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center ring contrast: difference between average ring intensity and center disk intensity (positive if center is background hole)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    r = max(1, int(min(h, w) / 6.0))\n    yy, xx = np.ogrid[0:h, 0:w]\n    dist = np.sqrt((yy - cy)**2 + (xx - cx)**2)\n    center_mask = dist <= r\n    ring_mask = (dist > r) & (dist <= 2*r)\n    if np.sum(center_mask) == 0 or np.sum(ring_mask) == 0:\n        return 0.0\n    center_mean = float(np.mean(gray[center_mask]))\n    ring_mean = float(np.mean(gray[ring_mask]))\n    # use border to determine polarity: if border is lighter than mean then ink is dark; then hole means center is bright\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    # if border is light, background is large values; so a hole has center mean close to border_mean and ring mean is ink (low)\n    polarity = 1.0 if border_mean > np.mean(gray) else -1.0\n    contrast = polarity * (center_mean - ring_mean)\n    # normalize by global intensity range\n    denom = (np.max(gray) - np.min(gray)) + 1e-9\n    return float(contrast / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in the top third vs bottom third (top_third / (bottom_third+eps)); 5s often have heavier bottom third'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(int)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(int)\n    t = max(1, h // 3)\n    top = np.sum(ink[:t, :])\n    bottom = np.sum(ink[-t:, :])\n    return float(top) / (float(bottom) + 1e-6)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous horizontal ink run length normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    mask_lo = gray < th\n    mask_hi = gray > th\n    mask = mask_lo if np.count_nonzero(mask_lo) <= np.count_nonzero(mask_hi) else mask_hi\n    max_run = 0\n    for r in range(h):\n        row = mask[r]\n        # fast run length scan\n        run = 0\n        # iterate over booleans\n        for val in row:\n            if val:\n                run += 1\n            else:\n                if run > max_run:\n                    max_run = run\n                run = 0\n        if run > max_run:\n            max_run = run\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal stroke energy in the top-right quadrant: measures strength of 45-degree strokes (useful to detect 7-like diagonals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    tr = gray[0:h//2, w//2:w]\n    if tr.size == 0:\n        return 0.0\n    gy, gx = np.gradient(tr.astype(float))\n    mag = np.hypot(gx, gy) + 1e-9\n    absgx = np.abs(gx)\n    absgy = np.abs(gy)\n    # diagonal indicator per pixel: 2*min(|gx|,|gy|)/( |gx|+|gy| )\n    diag_frac = 2.0 * np.minimum(absgx, absgy) / (absgx + absgy + 1e-9)\n    diag_weighted = (diag_frac * mag).sum()\n    # normalize by total gradient energy in the quadrant\n    total_energy = mag.sum() + 1e-9\n    return float(diag_weighted / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical-edge energy (abs gradient along columns) in the left half, normalized by region area'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    left = gray[:, : max(1, w // 2)]\n    gy, gx = np.gradient(left)\n    energy = np.mean(np.abs(gx))  # gx corresponds to changes across columns -> vertical strokes\n    return float(energy)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized diagonal (45\u00b0) edge energy: diagonal magnitude / total edge energy (captures slanted strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    # diagonal projection (45\u00b0)\n    diag = (gx + gy) / np.sqrt(2.0)\n    diag_energy = np.sum(np.abs(diag))\n    total_energy = np.sum(np.abs(gx)) + np.sum(np.abs(gy))\n    return float(diag_energy / (total_energy + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical transitions per column (measures stroke complexity like loops vs single strokes)'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    # transitions per column: count changes along rows\n    diffs = np.abs(np.diff(fg.astype(int), axis=0))\n    transitions_per_col = np.sum(diffs, axis=0)  # number of changes per column\n    avg_trans = np.mean(transitions_per_col) / max(1.0, float(h))\n    return float(avg_trans)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding box aspect ratio of the foreground (height/width); returns 0 if no foreground'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = float(np.mean(gray)) if np.mean(gray) != np.min(gray) else (float(np.min(gray)) + 1.0)\n    fg_idx = np.argwhere(gray > thr)\n    if fg_idx.size == 0:\n        return 0.0\n    rows = fg_idx[:, 0]\n    cols = fg_idx[:, 1]\n    h = float(rows.max() - rows.min() + 1)\n    w = float(cols.max() - cols.min() + 1)\n    if w == 0.0:\n        return float(h)\n    return float(h / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of horizontal projection peaks in the middle third of the image (how many separated horizontal strokes), normalized by image height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thresh = np.mean(gray)\n    ink = (gray < thresh) if np.max(gray) > np.min(gray) else (gray != 0)\n    c1, c2 = w // 3, 2 * w // 3\n    band = ink[:, c1:c2]\n    proj = band.sum(axis=1).astype(float)\n    if proj.max() == 0:\n        return 0.0\n    # smooth with 3-point median-ish smoothing\n    sm = np.convolve(proj, np.ones(3)/3.0, mode='same')\n    # threshold peaks relative to max and mean\n    peak_thresh = max(1.0, 0.3 * sm.max(), sm.mean())\n    above = sm > peak_thresh\n    # count upward transitions\n    peaks = int(np.sum((~above[:-1]) & (above[1:]))) if above.size > 1 else int(above[0])\n    return float(peaks / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of left-third columns that contain any ink (indicates presence of a left vertical stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    left_w = max(1, w // 3)\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    left_block = ink[:, :left_w]\n    if left_block.size == 0:\n        return 0.0\n    cols_with_ink = np.sum(np.any(left_block, axis=0))\n    return float(cols_with_ink / left_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient restricted to the right half (captures right-side curvature)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        # smooth-ish by simple local mean to reduce noise\n        # compute gradients\n        gx, gy = np.gradient(gray.astype(float))\n        right_gx = gx[:, w//2:]\n        right_gy = gy[:, w//2:]\n        mag_x = np.mean(np.abs(right_gx)) if right_gx.size > 0 else 0.0\n        mag_y = np.mean(np.abs(right_gy)) if right_gy.size > 0 else 0.0\n        if mag_y == 0:\n            return float(mag_x)\n        return float(mag_x) / float(mag_y)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous horizontal ink run within the top quarter center zone normalized by width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    center_w1 = max(0, w//4)\n    center_w2 = min(w, 3*w//4)\n    zone = gray[0:top_h, center_w1:center_w2]\n    if zone.size == 0:\n        return 0.0\n    thresh = float(np.mean(zone))\n    low = int(np.count_nonzero(zone < thresh))\n    high = int(np.count_nonzero(zone > thresh))\n    if low < high:\n        ink_zone = (zone < thresh).astype(np.uint8)\n    else:\n        ink_zone = (zone > thresh).astype(np.uint8)\n    # compute longest horizontal run across all rows in zone\n    longest = 0\n    for row in ink_zone:\n        # find longest run of ones in row\n        current = 0\n        maxr = 0\n        for v in row:\n            if v:\n                current += 1\n            else:\n                if current > maxr:\n                    maxr = current\n                current = 0\n        if current > maxr:\n            maxr = current\n        if maxr > longest:\n            longest = maxr\n    norm = float(longest / max(1, center_w2 - center_w1))\n    return norm\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink pixels located in the top quarter of the image (top density ratio)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink_mask_candidate = gray < thresh\n    if np.count_nonzero(ink_mask_candidate) > (h * w / 2):\n        ink = (~ink_mask_candidate).astype(float)\n    else:\n        ink = ink_mask_candidate.astype(float)\n    top_rows = max(1, h // 4)\n    top_ink = np.sum(ink[:top_rows, :])\n    total_ink = np.sum(ink)\n    if total_ink == 0:\n        return 0.0\n    return float(top_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels that lie within the rightmost quarter of the image width (right-border density)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n    left_vals = gray[gray <= p40]\n    right_vals = gray[gray >= p60]\n    left_mean = left_vals.mean() if left_vals.size else gray.min()\n    right_mean = right_vals.mean() if right_vals.size else gray.max()\n    thr = (left_mean + right_mean) / 2.0\n    ink_is_dark = left_mean < right_mean\n    ink = (gray < thr) if ink_is_dark else (gray > thr)\n    right_strip = ink[:, int(3*w/4):]\n    total_ink = np.count_nonzero(ink)\n    if total_ink == 0:\n        return 0.0\n    return float(np.count_nonzero(right_strip) / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right horizontal gradient asymmetry: (sum of positive grads on left half - right half) normalized (positive -> left-to-right transitions stronger on left)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.0\n    hg = np.diff(gray, axis=1)  # shape (h, w-1)\n    pos = np.maximum(hg, 0.0)\n    mid = (w-1)//2\n    left_sum = pos[:, :mid].sum()\n    right_sum = pos[:, mid:].sum()\n    denom = (left_sum + right_sum + 1e-9)\n    return float((left_sum - right_sum) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical edge energy concentrated in the left half (helps detect a left vertical stroke like in 4)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # gradients: np.gradient returns [d/drow (gy), d/dcol (gx)]\n    gy, gx = np.gradient(gray)\n    vertical_energy = np.abs(gx)\n    total = np.sum(vertical_energy) + 1e-9\n    left_energy = np.sum(vertical_energy[:, :max(1, w//2)])\n    return float(left_energy / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center ring contrast: difference between average ring intensity and center disk intensity (positive if center is background hole)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    r = max(1, int(min(h, w) / 6.0))\n    yy, xx = np.ogrid[0:h, 0:w]\n    dist = np.sqrt((yy - cy)**2 + (xx - cx)**2)\n    center_mask = dist <= r\n    ring_mask = (dist > r) & (dist <= 2*r)\n    if np.sum(center_mask) == 0 or np.sum(ring_mask) == 0:\n        return 0.0\n    center_mean = float(np.mean(gray[center_mask]))\n    ring_mean = float(np.mean(gray[ring_mask]))\n    # use border to determine polarity: if border is lighter than mean then ink is dark; then hole means center is bright\n    border = np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    # if border is light, background is large values; so a hole has center mean close to border_mean and ring mean is ink (low)\n    polarity = 1.0 if border_mean > np.mean(gray) else -1.0\n    contrast = polarity * (center_mean - ring_mean)\n    # normalize by global intensity range\n    denom = (np.max(gray) - np.min(gray)) + 1e-9\n    return float(contrast / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom third of the image (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        bottom = np.count_nonzero(ink[(2*h)//3 : , :])\n        return float(bottom) / float(total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of total ink pixels that lie within a narrow vertical strip centered at the image middle (vertical midline ink concentration)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink_candidate = gray < thresh\n    if np.count_nonzero(ink_candidate) > 0.9 * h * w:\n        ink = ~ink_candidate\n    else:\n        ink = ink_candidate\n    ink = ink.astype(bool)\n    total_ink = np.count_nonzero(ink)\n    if total_ink == 0:\n        return 0.0\n    band_width = max(1, w // 8)\n    center = w // 2\n    left = max(0, center - band_width // 2)\n    right = min(w, left + band_width)\n    mid_ink = np.count_nonzero(ink[:, left:right])\n    return float(mid_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean number of ink/background transitions per horizontal scanline (rows) - closed loops produce ~2 transitions'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = (gray > thr).astype(np.uint8)\n    if h == 0:\n        return 0.0\n    # For each row count transitions 0->1 or 1->0\n    transitions = np.count_nonzero(ink[:, :-1] != ink[:, 1:], axis=1)\n    # Return average transitions per row (float)\n    return float(np.mean(transitions))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative concentration of ink in the inner upper-right quadrant vs its border (indicates small top-right loops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    h, w = gray.shape[:2]\n    meanv = np.mean(gray)\n    ink = gray < meanv\n    if np.count_nonzero(ink) > 0.5 * h * w:\n        ink = gray > meanv\n    # define upper-right quadrant\n    mid_h = h // 2\n    mid_w = w // 2\n    ur = ink[0:mid_h, mid_w:w]\n    if ur.size == 0:\n        return 0.0\n    # inner region (center of that quadrant)\n    ih = max(1, ur.shape[0] // 2)\n    iw = max(1, ur.shape[1] // 2)\n    inner = ur[ih//2:ih//2 + ih, iw//2:iw//2 + iw]\n    border_mask = np.ones_like(ur, dtype=bool)\n    # carve out inner area\n    inner_r0 = ih//2; inner_c0 = iw//2\n    inner_r1 = inner_r0 + ih; inner_c1 = inner_c0 + iw\n    inner_r1 = min(inner_r1, ur.shape[0]); inner_c1 = min(inner_c1, ur.shape[1])\n    border_mask[inner_r0:inner_r1, inner_c0:inner_c1] = False\n    inner_count = inner.sum() if inner.size > 0 else 0\n    border_count = ur[border_mask].sum() if border_mask.sum() > 0 else 0\n    eps = 1e-8\n    return float(inner_count / (border_count + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of rightmost ink column index across rows (captures bottom-right loop variability)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = float(np.percentile(gray, 50.0))\n    ink = gray < thresh\n    if np.count_nonzero(ink) == 0:\n        ink = gray > float(np.percentile(gray, 50.0))\n    rightmost = []\n    for i in range(h):\n        row = ink[i, :]\n        cols = np.nonzero(row)[0]\n        if cols.size > 0:\n            rightmost.append(float(cols.max()))\n    if len(rightmost) == 0:\n        return 0.0\n    sd = float(np.std(rightmost))\n    result = sd / float(max(1.0, w - 1))\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink concentrated in a central vertical strip (middle 20% width) normalized by overall ink density'\n    import numpy as np\n    if image is None:\n        return 0.0\n    # grayscale conversion\n    arr = np.array(image, dtype=float)\n    h, w = arr.shape[:2]\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr\n    # adaptive binarization: decide whether ink is darker or lighter than background\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    thresh = (p10 + p90) / 2.0\n    if p90 > p10:\n        ink = (gray < thresh)  # ink darker\n    else:\n        ink = (gray > thresh)\n    # central vertical strip (middle 20%)\n    left = max(0, int(w * 0.4))\n    right = min(w, int(w * 0.6))\n    center_count = float(np.count_nonzero(ink[:, left:right]))\n    total_count = float(np.count_nonzero(ink)) + 1e-9\n    return float(center_count / total_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset normalized by image height (positive means centroid is lower than center)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    yc = float(np.mean(coords[:, 0]))\n    offset_norm = (yc - (h / 2.0)) / max(1.0, h)\n    return float(offset_norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between ink proportion in top-left and top-right quadrants (positive => more ink in top-left)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    gray = np.asarray(gray, dtype=float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.mean(fg) > 0.6:\n        fg = gray > thr\n    mid_y = h // 2\n    mid_x = w // 2\n    top_left = fg[:mid_y, :mid_x]\n    top_right = fg[:mid_y, mid_x:]\n    pl = float(np.mean(top_left)) if top_left.size > 0 else 0.0\n    pr = float(np.mean(top_right)) if top_right.size > 0 else 0.0\n    return float(pl - pr)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude on the right half minus left half (positive if right half has stronger edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    left_mag = np.mean(mag[:, :w//2]) if w//2 > 0 else 0.0\n    right_mag = np.mean(mag[:, w//2:]) if w - w//2 > 0 else 0.0\n    return float(right_mag - left_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink mass in right half to left half (captures right-weighted digits like 2 or 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if fg.sum() == 0 or fg.sum() > 0.9 * gray.size:\n        fg = gray > thr\n    left = fg[:, :w//2].sum()\n    right = fg[:, w//2:].sum()\n    # Avoid division by zero\n    if left + right == 0:\n        return 0.0\n    return float((right + 1e-6) / (left + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Correlation between row index and ink centroid x across rows (pearson r, between -1 and 1)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) - 0.15 * np.std(gray)\n    mask = (gray < thr).astype(np.uint8)\n    cols = np.arange(w)\n    ys = []\n    xs = []\n    for r in range(h):\n        row = mask[r, :]\n        s = row.sum()\n        if s > 0:\n            ys.append(float(r))\n            xs.append(float((row * cols).sum() / s))\n    if len(xs) < 2:\n        return 0.0\n    xs = np.array(xs)\n    ys = np.array(ys)\n    xs_mean = xs.mean()\n    ys_mean = ys.mean()\n    cov = ((xs - xs_mean) * (ys - ys_mean)).sum()\n    xs_std = xs.std()\n    ys_std = ys.std()\n    denom = (xs_std * ys_std * len(xs))\n    if denom == 0:\n        return 0.0\n    rcoef = cov / denom\n    # clamp to [-1,1]\n    rcoef = max(-1.0, min(1.0, float(rcoef)))\n    return float(rcoef)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal edge dominance: sum of main-diagonal absolute diffs divided by total orthogonal edge strength'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    a = np.abs(gray[:-1, :-1] - gray[1:, 1:]).sum()\n    b = np.abs(gray[:-1, 1:] - gray[1:, :-1]).sum()\n    diag = float(a + b)\n    hor = float(np.abs(np.diff(gray, axis=1)).sum())\n    ver = float(np.abs(np.diff(gray, axis=0)).sum())\n    return float(diag / (hor + ver + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness of the upper-left quadrant compared to the whole image (positive => upper-left is darker)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    whole_mean = float(np.mean(gray))\n    ul = gray[0:max(1, h//2), 0:max(1, w//2)]\n    ul_mean = float(np.mean(ul)) if ul.size else whole_mean\n    return float(whole_mean - ul_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal stroke orientation (absolute angle normalized to [0,1]; 0=horizontal, 1=vertical)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    if np.max(gray) > 1.5:\n        gray = gray / 255.0\n    mid = float(np.percentile(gray, 50))\n    ink = (gray < mid) if (np.mean(gray) > 0.5) else (gray > mid)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    # center data\n    pts = coords.astype(float)\n    pts -= pts.mean(axis=0, keepdims=True)\n    # SVD to get principal direction\n    try:\n        _, s, vt = np.linalg.svd(pts, full_matrices=False)\n        vx, vy = vt[0, 1], vt[0, 0]  # vt rows are principal components; careful with axis order\n        # compute orientation of principal axis: arctan2(dy, dx) but our coords are (row, col)\n        dx = vt[0, 1]\n        dy = vt[0, 0]\n        angle = float(abs(np.arctan2(dy, dx)))  # 0..pi\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [-1,1], positive for clockwise tilt)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 3:\n        return 0.0\n    y = coords[:, 0].astype(np.float64)\n    x = coords[:, 1].astype(np.float64)\n    x = (x - x.mean())\n    y = (y - y.mean())\n    cov_xx = np.mean(x * x)\n    cov_xy = np.mean(x * y)\n    cov_yy = np.mean(y * y)\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # largest eigenvector\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n        principal = vecs[:, np.argmax(vals)]\n        vx, vy = principal[0], principal[1]\n        # angle where 0 is horizontal, positive means tilt down-right\n        angle = np.arctan2(vy, vx)\n        # normalize by pi to [-1,1]\n        return float(angle / np.pi)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight ink bounding box (1.0 ~ square); distinguishes tall strokes from round loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = gray < thr\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = gray > thr\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n    bbox_h = max_r - min_r + 1\n    bbox_w = max_c - min_c + 1\n    if bbox_w <= 0:\n        return float(bbox_h)\n    return float(bbox_h) / float(bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical separation between two largest enclosed hole centroids normalized by image height (0 if fewer than 2 holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # exterior fill\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal = (~ink) & (~exterior)\n    visited = np.zeros_like(internal, dtype=bool)\n    centroids = []\n    for i in range(h):\n        for j in range(w):\n            if internal[i, j] and not visited[i, j]:\n                # BFS\n                q = deque()\n                q.append((i, j))\n                visited[i, j] = True\n                pts = [(i, j)]\n                while q:\n                    ci, cj = q.popleft()\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and internal[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            pts.append((ni, nj))\n                            q.append((ni, nj))\n                pts = np.array(pts)\n                centroids.append((float(np.mean(pts[:,0])), float(np.mean(pts[:,1])), pts.shape[0]))\n    if len(centroids) < 2:\n        return 0.0\n    # sort by area desc and take two largest\n    centroids.sort(key=lambda x: x[2], reverse=True)\n    y1 = centroids[0][0]\n    y2 = centroids[1][0]\n    return float(abs(y1 - y2) / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ink perimeter (boundary pixels) divided by ink area (higher -> finer/thinner or more complex contours)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(np.uint8)\n    # boundary pixels: ink pixel with at least one 4-neighbor background\n    neighbor_sum = np.zeros_like(ink, dtype=np.int32)\n    neighbor_sum[1:, :] += ink[:-1, :]\n    neighbor_sum[:-1, :] += ink[1:, :]\n    neighbor_sum[:, 1:] += ink[:, :-1]\n    neighbor_sum[:, :-1] += ink[:, 1:]\n    boundary = (ink == 1) & (neighbor_sum < 4)\n    perimeter = float(np.sum(boundary))\n    area = float(np.sum(ink))\n    if area <= 0.0:\n        return 0.0\n    return float(perimeter / area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean hole boundary complexity: average of (perimeter / sqrt(area)) across holes (0 if no holes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink_candidate = gray < thresh\n    if np.count_nonzero(ink_candidate) > 0.9 * h * w:\n        ink = ~ink_candidate\n    else:\n        ink = ink_candidate\n    ink = ink.astype(bool)\n    background = ~ink\n    visited = np.zeros_like(background, dtype=bool)\n    stack = []\n    for i in range(h):\n        if background[i, 0]: stack.append((i, 0)); visited[i, 0] = True\n        if background[i, w - 1] and not visited[i, w - 1]: stack.append((i, w - 1)); visited[i, w - 1] = True\n    for j in range(w):\n        if background[0, j] and not visited[0, j]: stack.append((0, j)); visited[0, j] = True\n        if background[h - 1, j] and not visited[h - 1, j]: stack.append((h - 1, j)); visited[h - 1, j] = True\n    while stack:\n        i, j = stack.pop()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i + di, j + dj\n            if 0 <= ni < h and 0 <= nj < w and background[ni, nj] and not visited[ni, nj]:\n                visited[ni, nj] = True\n                stack.append((ni, nj))\n    holes_mask = background & (~visited)\n    comp_visited = np.zeros_like(holes_mask, dtype=bool)\n    complexities = []\n    for i in range(h):\n        for j in range(w):\n            if holes_mask[i, j] and not comp_visited[i, j]:\n                s = [(i, j)]\n                comp_visited[i, j] = True\n                coords = []\n                while s:\n                    ci, cj = s.pop()\n                    coords.append((ci, cj))\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci + di, cj + dj\n                        if 0 <= ni < h and 0 <= nj < w and holes_mask[ni, nj] and not comp_visited[ni, nj]:\n                            comp_visited[ni, nj] = True\n                            s.append((ni, nj))\n                coords = np.array(coords)\n                area = coords.shape[0]\n                # perimeter approximated as hole pixels having any neighbor that is ink\n                perim = 0\n                for (ci, cj) in coords:\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci + di, cj + dj\n                        if 0 <= ni < h and 0 <= nj < w and ink[ni, nj]:\n                            perim += 1\n                complexities.append(perim / np.sqrt(area + 1e-6))\n    if len(complexities) == 0:\n        return 0.0\n    return float(np.mean(complexities))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate hole area ratio: fraction of ink-area that surrounds enclosed background (holes). 8 has two holes, 0 has one, 5 typically none'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    # robust thresholding as above\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr)\n    ink = ink.astype(np.bool_)\n    if h == 0 or w == 0:\n        return 0.0\n    # flood-fill to find background connected to borders\n    bg = np.zeros_like(ink, dtype=bool)\n    stack = []\n    # push border background pixels\n    for c in range(w):\n        if not ink[0, c]:\n            stack.append((0, c))\n            bg[0, c] = True\n        if not ink[h - 1, c]:\n            stack.append((h - 1, c))\n            bg[h - 1, c] = True\n    for r in range(h):\n        if not ink[r, 0]:\n            stack.append((r, 0))\n            bg[r, 0] = True\n        if not ink[r, w - 1]:\n            stack.append((r, w - 1))\n            bg[r, w - 1] = True\n    # 4-connected flood fill\n    while stack:\n        r, c = stack.pop()\n        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            rr, cc = r + dr, c + dc\n            if 0 <= rr < h and 0 <= cc < w and (not bg[rr, cc]) and (not ink[rr, cc]):\n                bg[rr, cc] = True\n                stack.append((rr, cc))\n    holes = (~ink) & (~bg)\n    hole_area = float(np.count_nonzero(holes))\n    ink_area = float(np.count_nonzero(ink))\n    if ink_area <= 0:\n        return 0.0\n    return float(hole_area) / ink_area\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of total enclosed hole area to ink area (how big holes are relative to ink)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # Flood fill exterior background\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal_bg = (~ink) & (~exterior)\n    hole_area = float(np.sum(internal_bg))\n    ink_area = float(np.sum(ink))\n    if ink_area <= 0.0:\n        return 0.0\n    return float(hole_area / ink_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized x-position (0..1) of the topmost ink pixels averaged across that top row (helps identify left/right top stroke starts)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border))\n    global_min, global_max = float(np.min(gray)), float(np.max(gray))\n    if border_mean > (global_min + global_max) / 2:\n        thresh = 0.5 * (border_mean + global_min)\n        binary = (gray < thresh).astype(np.uint8)\n    else:\n        thresh = 0.5 * (border_mean + global_max)\n        binary = (gray > thresh).astype(np.uint8)\n    rows_with_ink = np.where(np.any(binary == 1, axis=1))[0]\n    if rows_with_ink.size == 0:\n        return 0.5\n    top_row = rows_with_ink[0]\n    xs = np.where(binary[top_row, :] == 1)[0]\n    if xs.size == 0:\n        return 0.5\n    mean_x = float(np.mean(xs))\n    return float(mean_x / (w - 1 + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of ink vertical thickness per column in the lower quarter normalized by image height'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    bg = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    ink_dark = float(np.mean(gray)) < bg\n    if ink_dark:\n        thr = max(np.min(gray), bg - 0.15 * (bg - np.min(gray)))\n        binary = (gray < thr).astype(int)\n    else:\n        thr = min(np.max(gray), bg + 0.15 * (np.max(gray) - bg))\n        binary = (gray > thr).astype(int)\n    lower = slice(max(0, (3 * h) // 4), h)\n    heights = []\n    for col in range(w):\n        colv = binary[lower, col]\n        heights.append(np.sum(colv))\n    if len(heights) == 0:\n        return 0.0\n    std_h = float(np.std(heights))\n    return float(std_h / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Length of longest horizontal stroke in the middle third (useful to detect the cross-bar of a \"4\"), normalized by width'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    thr = np.percentile(gray, 50.0)\n    ink = (gray < thr).astype(np.uint8)\n    if np.sum(ink) == 0:\n        ink = (gray > thr).astype(np.uint8)\n        if np.sum(ink) == 0:\n            return 0.0\n    r0 = h // 3\n    r1 = max(r0 + 1, (2 * h) // 3)\n    middle = ink[r0:r1, :]\n    max_run = 0\n    for row in middle:\n        padded = np.concatenate(([0], row, [0]))\n        changes = np.diff(padded)\n        starts = np.nonzero(changes == 1)[0]\n        ends = np.nonzero(changes == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(int(np.max(runs)), max_run)\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal gradient bias: (NE-SW - NW-SE) / (total diagonal energy)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute two diagonal differences\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 0.0\n    d_ne_sw = np.abs(gray[:-1, :-1] - gray[1:, 1:]).sum()\n    d_nw_se = np.abs(gray[1:, :-1] - gray[:-1, 1:]).sum()\n    total = d_ne_sw + d_nw_se + 1e-8\n    return float((d_ne_sw - d_nw_se) / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical position (0..1) of centroids of internal holes (0 = top), 0.0 when no internal holes'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.percentile(gray, 50)\n    lower = gray <= th\n    if lower.sum() == 0 or (~lower).sum() == 0:\n        foreground = np.zeros_like(gray, dtype=bool)\n    else:\n        foreground = lower if np.mean(gray[lower]) < np.mean(gray[~lower]) else ~lower\n    background = ~foreground\n    # mark border-connected background\n    visited = np.zeros_like(background, dtype=bool)\n    from collections import deque\n    q = deque()\n    # enqueue border background pixels\n    for c in range(w):\n        if background[0, c]:\n            visited[0, c] = True; q.append((0, c))\n        if background[h-1, c]:\n            visited[h-1, c] = True; q.append((h-1, c))\n    for r in range(h):\n        if background[r, 0]:\n            visited[r, 0] = True; q.append((r, 0))\n        if background[r, w-1]:\n            visited[r, w-1] = True; q.append((r, w-1))\n    while q:\n        rr, cc = q.popleft()\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            nr, nc = rr+dr, cc+dc\n            if 0 <= nr < h and 0 <= nc < w and background[nr, nc] and not visited[nr, nc]:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n    # remaining background pixels are internal holes\n    holes_mask = np.logical_and(background, ~visited)\n    if np.count_nonzero(holes_mask) == 0:\n        return 0.0\n    # label holes and compute centroids (simple flood fill)\n    holes_centroids_y = []\n    visited_holes = np.zeros_like(holes_mask, dtype=bool)\n    for r in range(h):\n        for c in range(w):\n            if holes_mask[r, c] and not visited_holes[r, c]:\n                # flood fill this hole\n                stack = [(r, c)]\n                visited_holes[r, c] = True\n                coords = []\n                while stack:\n                    rr, cc = stack.pop()\n                    coords.append((rr, cc))\n                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n                        nr, nc = rr+dr, cc+dc\n                        if 0 <= nr < h and 0 <= nc < w and holes_mask[nr, nc] and not visited_holes[nr, nc]:\n                            visited_holes[nr, nc] = True\n                            stack.append((nr, nc))\n                coords = np.array(coords)\n                cent_y = coords[:,0].mean() / float(h)\n                holes_centroids_y.append(cent_y)\n    if len(holes_centroids_y) == 0:\n        return 0.0\n    return float(np.mean(holes_centroids_y))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized radial variance of ink pixels around centroid (lower => more circular shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    fg = gray < thresh\n    if np.count_nonzero(fg) > 0.5 * h * w:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if ys.size == 0:\n        return 0.0\n    cy = ys.mean()\n    cx = xs.mean()\n    d = np.sqrt((ys - cy)**2 + (xs - cx)**2)\n    mean_d = d.mean() + 1e-8\n    var_d = d.var()\n    # normalized variance\n    return float(var_d / (mean_d**2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean binary ink presence in a narrow horizontal band around the image midline (detects middle crossbar like in \"4\")'\n    import numpy as np\n    h, w = image.shape[:2]\n    # convert to grayscale\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # robust binarization (assume ink differs from median)\n    thr = np.mean(gray)\n    mask = gray < thr\n    prop = mask.mean()\n    if prop > 0.9 or prop < 0.01:\n        mask = gray > thr\n    # choose a narrow band around middle (10% of height)\n    band_h = max(1, h // 10)\n    start = max(0, h // 2 - band_h // 2)\n    band = mask[start:start + band_h, :]\n    return float(band.mean())\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid of ink mass (0=left, 1=right)'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # simple threshold between min and mean to find ink (robust for dark-on-light)\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = gray < thresh if meanv > minv else gray > thresh\n    ys, xs = np.nonzero(ink)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs)) / float(w)\n    return float(cx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative brightness of the top-center small box vs its immediate surround (positive => top-center is brighter/blank)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_h = max(1, h//6)\n    left = w//3\n    right = (2*w)//3\n    box = gray[0:top_h, left:right]\n    # surround ring: slightly below and flanking\n    ring = gray[top_h:top_h+max(1,top_h), max(0,left- max(1,w//10)):min(w,right+ max(1,w//10))]\n    box_mean = float(np.mean(box)) if box.size else 0.0\n    ring_mean = float(np.mean(ring)) if ring.size else box_mean\n    # if box is lighter (higher intensity) than ring -> likely open/top blank\n    denom = (ring_mean + box_mean) / 2.0 + 1e-9\n    return float((box_mean - ring_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical (left-right) normalized L1 symmetry: average absolute column difference between left and flipped right, normalized by image width'\n    # Convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Determine ink polarity robustly (ink should be sparse)\n    thr = np.mean(gray)\n    ink_mask = gray < thr\n    if np.count_nonzero(ink_mask) > 0.9 * h * w:\n        ink_mask = gray > thr\n    # Compute left-right symmetry on binary ink mask\n    left = ink_mask[:, :w//2].astype(float)\n    right = np.fliplr(ink_mask[:, (w - w//2):]).astype(float)\n    # Resize to same width if needed\n    if left.shape[1] != right.shape[1]:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    # L1 normalized by number of compared pixels\n    denom = float(left.size) if left.size > 0 else 1.0\n    score = np.sum(np.abs(left - right)) / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean dominant gradient orientation (circular mean) in the top-right quadrant, normalized to [-1,1] (captures slanted top-right strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    r0, c0 = 0, w//2\n    r1, c1 = h//2, w\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mag = np.hypot(gx, gy)\n    mask = mag > (np.percentile(mag, 50) * 0.2 + 1e-9)\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # range -pi..pi\n    mean_sin = float(np.mean(np.sin(angles)))\n    mean_cos = float(np.mean(np.cos(angles)))\n    mean_angle = np.arctan2(mean_sin, mean_cos)\n    # normalize to [-1,1]\n    result = float(mean_angle / np.pi)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of vertical gradient energy in the right third of the image (vertical_grad_energy_right / total_grad_energy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # normalize\n    gmax = gray.max() if gray.size else 1.0\n    if gmax > 0:\n        gray = gray / float(gmax)\n    # gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        return 0.0\n    vert_energy = np.abs(gy)\n    total_energy = np.sum(np.abs(gy)) + np.sum(np.abs(gx)) + 1e-9\n    h, w = gray.shape[:2]\n    start = (2 * w) // 3\n    right_energy = np.sum(vert_energy[:, start:]) if start < w else 0.0\n    return float(right_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative area of the largest inner hole to the bounding box area (useful: 9 often has one large loop, 8 has two moderate loops)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 0.0\n        y0, y1 = ys.min(), ys.max()\n        x0, x1 = xs.min(), xs.max()\n        sub = ~fg[y0:y1+1, x0:x1+1]\n        H, W = sub.shape\n        if H <= 0 or W <= 0:\n            return 0.0\n        visited = np.zeros_like(sub, dtype=np.bool_)\n        from collections import deque\n        q = deque()\n        for i in range(H):\n            for j in (0, W-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        for j in range(W):\n            for i in (0, H-1):\n                if sub[i, j] and not visited[i, j]:\n                    visited[i, j] = True\n                    q.append((i, j))\n        while q:\n            y, x = q.popleft()\n            for dy in (-1, 0, 1):\n                for dx in (-1, 0, 1):\n                    ny, nx = y+dy, x+dx\n                    if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                        visited[ny, nx] = True\n                        q.append((ny, nx))\n        # find hole components and record largest\n        largest = 0\n        for i in range(H):\n            for j in range(W):\n                if sub[i, j] and not visited[i, j]:\n                    # new hole\n                    size = 0\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        size += 1\n                        for dy in (-1, 0, 1):\n                            for dx in (-1, 0, 1):\n                                ny, nx = y+dy, x+dx\n                                if 0 <= ny < H and 0 <= nx < W and sub[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n                    if size > largest:\n                        largest = size\n        bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1)) + 1e-8\n        return float(largest / bbox_area)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of sign changes (zero crossings) in the vertical gradient per column in the right half (captures alternating bulges)'\n    import numpy as np\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2).astype(float)\n    else:\n        gray = img.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    right = gx[:, max(w//2, 0):]  # horizontal derivative across right half\n    if right.size == 0:\n        return 0.0\n    # count sign changes along each column\n    sign = np.sign(right)\n    # replace zeros with previous nonzero to avoid noisy zero rows\n    sign[sign == 0] = 1\n    changes = np.abs(np.diff(sign, axis=0)) > 0\n    col_changes = changes.sum(axis=0)\n    return float(np.mean(col_changes) / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of principal axis eigenvalues (major / minor) of ink pixel covariance (linear strokes like 7 have high ratio)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border_mean = float(np.mean(np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])))\n    med = float(np.median(gray))\n    if border_mean > med:\n        ink = (gray < np.percentile(gray, 60)).astype(np.uint8)\n    else:\n        ink = (gray > np.percentile(gray, 40)).astype(np.uint8)\n    ys, xs = np.where(ink)\n    if xs.size < 3:\n        return 0.0\n    x = xs.astype(float)\n    y = ys.astype(float)\n    xm = x.mean()\n    ym = y.mean()\n    cov_xx = np.mean((x - xm) ** 2)\n    cov_yy = np.mean((y - ym) ** 2)\n    cov_xy = np.mean((x - xm) * (y - ym))\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    # eigenvalues\n    try:\n        vals = np.linalg.eigvalsh(cov)\n        vals = np.sort(vals)[::-1]  # descending\n        major = float(vals[0])\n        minor = float(vals[1])\n        eps = 1e-10\n        ratio = major / (minor + eps)\n        return float(ratio)\n    except Exception:\n        return 0.0\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical gradient energy concentrated in the central vertical third (distinguishes centered vertical strokes like 1)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        gy, gx = np.gradient(gray)\n        vert = np.abs(gy)\n        h, w = gray.shape\n        c0, c1 = w//3, 2*w//3\n        center_vert = np.sum(vert[:, c0:c1])\n        total = np.sum(vert) + 1e-8\n        return float(center_vert / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of columns that contain a vertical ink run covering at least 60% of image height (indicates strong vertical strokes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    count = 0\n    minrun = max(1, int(0.6 * h))\n    for c in range(w):\n        col = ink[:, c].astype(int)\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if np.any(lengths >= minrun):\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical gradient energy concentrated in the central vertical third (distinguishes centered vertical strokes like 1)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        gy, gx = np.gradient(gray)\n        vert = np.abs(gy)\n        h, w = gray.shape\n        c0, c1 = w//3, 2*w//3\n        center_vert = np.sum(vert[:, c0:c1])\n        total = np.sum(vert) + 1e-8\n        return float(center_vert / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the right half divided by left half (detects right-side lobes like 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)  # gy: d/drow (vertical change -> horizontal edges), gx: d/dcol (vertical edges)\n    horiz_edge = np.abs(gy)\n    mid = w // 2\n    left_energy = np.mean(horiz_edge[:, :mid]) if mid > 0 else 0.0\n    right_energy = np.mean(horiz_edge[:, mid:]) if w - mid > 0 else 0.0\n    denom = left_energy + 1e-9\n    return float(right_energy / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the right half divided by left half (detects right-side lobes like 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)  # gy: d/drow (vertical change -> horizontal edges), gx: d/dcol (vertical edges)\n    horiz_edge = np.abs(gy)\n    mid = w // 2\n    left_energy = np.mean(horiz_edge[:, :mid]) if mid > 0 else 0.0\n    right_energy = np.mean(horiz_edge[:, mid:]) if w - mid > 0 else 0.0\n    denom = left_energy + 1e-9\n    return float(right_energy / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of intensity in the central vertical third to total intensity (captures a centered vertical stroke)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    # convert to gray\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    left = w // 3\n    right = w - left\n    center_region = gray[:, left:right]\n    total = np.sum(gray)\n    center_sum = np.sum(center_region)\n    if total == 0:\n        return 0.0\n    return float(center_sum / (total + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of radial distances of foreground pixels from centroid (normalized) \u2014 \"0\" tends to have larger circular spread'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.0\n    cx, cy = np.mean(xs), np.mean(ys)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = np.std(dists)\n    # normalize by image diagonal\n    diag = np.sqrt(w * w + h * h)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground mass in the top half to total foreground mass (top/both)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy().astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    thr = np.mean(gray)\n    fg_dark = gray < thr\n    fg_bright = gray > thr\n    fg = fg_dark if np.count_nonzero(fg_dark) <= np.count_nonzero(fg_bright) else fg_bright\n    total = np.count_nonzero(fg)\n    if total == 0:\n        return 0.0\n    top = fg[:h//2, :]\n    top_count = np.count_nonzero(top)\n    return float(top_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong diagonal edge energy around \u00b145 degrees (captures diagonal tails/joins)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradient\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.hypot(gx, gy)\n    total_energy = mag.sum() + 1e-9\n    # orientation in degrees\n    ang = np.degrees(np.arctan2(gy, gx))  # -180..180\n    # select energy near +45 or -45 (within 25 degrees)\n    mask_pos = (np.abs(ang - 45) <= 25)\n    mask_neg = (np.abs(ang + 45) <= 25)\n    diag_energy = mag[mask_pos].sum() + mag[mask_neg].sum()\n    return float(diag_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum foreground projection in top half to maximum in bottom half (top_peak / bottom_peak)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    proj = np.sum(fg.astype(np.int32), axis=1)  # per-row foreground count\n    mid = h // 2\n    top_peak = float(np.max(proj[:max(1, mid)])) if mid > 0 else float(np.max(proj))\n    bottom_peak = float(np.max(proj[mid:])) if mid < h else float(np.max(proj))\n    return float(top_peak / (bottom_peak + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center of mass of ink normalized to [0,1] (0 top, 1 bottom): 5 tends to have lower center than 0/8'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.5\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(float)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(float)\n    ink_sum = np.sum(ink)\n    if ink_sum <= 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    com_y = float(np.sum(rows * np.sum(ink, axis=1).reshape(h, 1)) / np.sum(ink))\n    # normalize to 0..1\n    return float(com_y / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative ink density in the middle horizontal third compared to overall density (detects middle bar like in 5)'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = image.mean(axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = float(gray.min()), float(gray.max())\n    if gmax - gmin < 1e-8:\n        return 0.0\n    gnorm = (gray - gmin) / (gmax - gmin)\n    high = np.count_nonzero(gnorm > 0.5)\n    ink = (gnorm > 0.5) if (high < (h * w - high)) else (gnorm <= 0.5)\n    ink = ink.astype(bool)\n    total_ink = float(np.count_nonzero(ink))\n    if total_ink < 1e-8:\n        return 0.0\n    y0, y1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    mid_count = float(np.count_nonzero(ink[y0:y1, :]))\n    mid_area = float((y1 - y0) * w)\n    mid_density = mid_count / (mid_area + 1e-8)\n    overall_density = total_ink / float(h * w)\n    return float(mid_density / (overall_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest run of consecutive ink pixels along the central row normalized by image width (captures long horizontal bars)'\n    import numpy as np\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    scaled = (gray - mn) / (mx - mn + 1e-9)\n    ink = (scaled < 0.5)\n    row = ink[h//2] if h > 0 else np.zeros(w, dtype=bool)\n    # find longest consecutive True run\n    if row.size == 0:\n        return 0.0\n    max_run = 0\n    cur = 0\n    for v in row:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average signed product of x and y gradients (negative values favor top-right to bottom-left diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # Normalize contrast to avoid scale issues\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(grayn)\n    prod = gx * gy\n    # We want a signed measure; negative average indicates dominant negative-slope diagonal strokes\n    return float(np.mean(prod))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Max continuous horizontal ink run length in the top third normalized by image width (detects top bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray)\n    border_mean = np.mean(np.concatenate([gray[0,:], gray[-1,:], gray[:,0], gray[:,-1]]))\n    ink_dark = border_mean > thr\n    if ink_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    top_band = ink[:max(1, h//3), :]\n    max_run = 0\n    for row in top_band:\n        # find longest run of True in row\n        length = 0\n        best = 0\n        for val in row:\n            if val:\n                length += 1\n            else:\n                if length > best:\n                    best = length\n                length = 0\n        if length > best:\n            best = length\n        if best > max_run:\n            max_run = best\n    return float(max_run / float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal offset of enclosed hole centroids from image center, normalized by width (0 if no holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # exterior fill\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal = (~ink) & (~exterior)\n    visited = np.zeros_like(internal, dtype=bool)\n    offsets = []\n    for i in range(h):\n        for j in range(w):\n            if internal[i, j] and not visited[i, j]:\n                # BFS\n                pts = []\n                q = deque()\n                q.append((i, j))\n                visited[i, j] = True\n                pts.append((i, j))\n                while q:\n                    ci, cj = q.popleft()\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and internal[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            pts.append((ni, nj))\n                            q.append((ni, nj))\n                pts = np.array(pts)\n                cx = float(np.mean(pts[:,1]))\n                offsets.append(abs(cx - (w-1)/2.0))\n    if len(offsets) == 0:\n        return 0.0\n    return float(np.mean(offsets) / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal gradient energy (sum|dI/dy| / (sum|dI/dx| + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    vert_energy = np.sum(np.abs(gy))\n    horz_energy = np.sum(np.abs(gx))\n    return float(vert_energy / (horz_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized distance from top to the first ink row (top gap / image height)'\n    import numpy as np\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    rows = np.where(mask.any(axis=1))[0]\n    if rows.size == 0:\n        return 1.0\n    top_row = rows.min()\n    return float(top_row / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center horizontal gap ratio: 1 - (ink in center row / max ink in any row) (higher => more central horizontal gap)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mean = np.mean(gray)\n    dark = (gray < mean).astype(np.uint8)\n    light = (gray > mean).astype(np.uint8)\n    if np.count_nonzero(dark) == 0 and np.count_nonzero(light) == 0:\n        return 0.0\n    binary = dark if np.count_nonzero(dark) <= np.count_nonzero(light) else light\n    row_counts = np.sum(binary, axis=1)\n    if row_counts.max() == 0:\n        return 0.0\n    center_row = h // 2\n    center_count = row_counts[center_row]\n    ratio = 1.0 - (center_count / (row_counts.max() + 1e-9))\n    return float(ratio)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal vs vertical edge energy in the top half of the image (hor / (ver + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top = gray[0:h//2, :]\n    # gradients (axis 0 -> vertical change, axis 1 -> horizontal change)\n    gy, gx = np.gradient(top)\n    hor_energy = np.sum(np.abs(gx))\n    ver_energy = np.sum(np.abs(gy))\n    eps = 1e-6\n    return float(hor_energy / (ver_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized diagonal gradient energy ratio: |dx - dy| energy / (|dx|+|dy| energy + eps) measures diagonal strokes'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients\n    gy, gx = np.gradient(gray)\n    # energy aligned with one diagonal vs the other\n    energy_diag = np.sum(np.abs(gx - gy))\n    energy_antidiag = np.sum(np.abs(gx + gy))\n    denom = energy_diag + energy_antidiag + 1e-8\n    return float(energy_diag / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Junction density: fraction of ink pixels that have 4 or more ink neighbors (stroke intersections)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    lo30, hi70 = np.percentile(gray, 30), np.percentile(gray, 70)\n    bg_light = gray.mean() > (gray.max() + gray.min()) / 2.0\n    if bg_light:\n        ink = (gray < lo30).astype(np.uint8)\n    else:\n        ink = (gray > hi70).astype(np.uint8)\n    total_ink = float(ink.sum())\n    if total_ink == 0:\n        return 0.0\n    padded = np.pad(ink, 1, mode='constant', constant_values=0)\n    neighbor_sum = np.zeros_like(ink, dtype=np.int32)\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            neighbor_sum += padded[1+dr:h+1+dr, 1+dc:w+1+dc]\n    junctions = float(((ink == 1) & (neighbor_sum >= 4)).sum())\n    return float(junctions / (total_ink + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical gradient energy on right half vs left half (captures vertical strokes primarily on one side)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    right_energy = np.sum(np.abs(gy[:, w//2:]))\n    left_energy = np.sum(np.abs(gy[:, :w//2]))\n    eps = 1e-6\n    return float((right_energy + eps) / (left_energy + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy (NW-SE) to (NE-SW) using gx and gy (helps detect diagonal stroke orientations)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    d1 = gx + gy  # NW-SE\n    d2 = gx - gy  # NE-SW\n    e1 = np.sum(np.abs(d1))\n    e2 = np.sum(np.abs(d2))\n    eps = 1e-6\n    return float((e1 + eps) / (e2 + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Size of background region reachable from bottom-right corner of the bottom-right quadrant (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn + 1e-9\n    norm = (gray - mn) / rng\n    low = norm < 0.5\n    high = ~low\n    ink = low if low.sum() <= high.sum() else high\n    ink = ink.astype(np.uint8)\n    # bottom-right quadrant coordinates\n    r0, c0 = h // 2, w // 2\n    quadrant = ink[r0:h, c0:w]\n    # background mask in quadrant\n    bg = (quadrant == 0)\n    if bg.size == 0:\n        return 0.0\n    # flood fill from bottom-right corner of the quadrant\n    H, W = bg.shape\n    visited = np.zeros_like(bg, dtype=np.bool_)\n    stack = []\n    # starting point is lower-right pixel in original image -> (H-1, W-1)\n    if bg[H-1, W-1]:\n        stack.append((H-1, W-1))\n        visited[H-1, W-1] = True\n    count = 0\n    while stack:\n        r, c = stack.pop()\n        count += 1\n        # 4-neighbors\n        if r > 0 and bg[r-1, c] and not visited[r-1, c]:\n            visited[r-1, c] = True; stack.append((r-1, c))\n        if r + 1 < H and bg[r+1, c] and not visited[r+1, c]:\n            visited[r+1, c] = True; stack.append((r+1, c))\n        if c > 0 and bg[r, c-1] and not visited[r, c-1]:\n            visited[r, c-1] = True; stack.append((r, c-1))\n        if c + 1 < W and bg[r, c+1] and not visited[r, c+1]:\n            visited[r, c+1] = True; stack.append((r, c+1))\n    # normalize by quadrant area\n    return float(count / float(max(1, bg.size)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest connected edge-component size (by pixels) inside the top-right quadrant normalized by quadrant area'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    # threshold edges relative to median\n    try:\n        thr = np.percentile(mag.flatten(), 70)\n    except Exception:\n        thr = np.mean(mag)\n    r0, r1 = 0, max(1, h // 2)\n    c0, c1 = max(0, w // 2), w\n    sub_mag = mag[r0:r1, c0:c1]\n    edge = sub_mag > max(1e-8, thr * 0.4)\n    H, W = edge.shape[:2]\n    if edge.size == 0:\n        return 0.0\n    visited = np.zeros_like(edge, dtype=bool)\n    max_comp = 0\n    for i in range(H):\n        for j in range(W):\n            if edge[i, j] and not visited[i, j]:\n                # BFS\n                stack = [(i, j)]\n                visited[i, j] = True\n                cnt = 0\n                while stack:\n                    y, x = stack.pop()\n                    cnt += 1\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if 0 <= ny < H and 0 <= nx < W and (dy != 0 or dx != 0):\n                                if edge[ny, nx] and not visited[ny, nx]:\n                                    visited[ny, nx] = True\n                                    stack.append((ny, nx))\n                if cnt > max_comp:\n                    max_comp = cnt\n    quad_area = float(max(1, H * W))\n    return float(max_comp) / quad_area\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of gradient angles (variation in stroke orientation); high for rounded digits'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    maxmag = mag.max() if mag.size else 0.0\n    if maxmag <= 1e-8:\n        return 0.0\n    # consider only significant gradients to reduce noise\n    thresh = max(1e-8, 0.15 * maxmag)\n    mask = mag > thresh\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # -pi..pi\n    return float(np.std(angles))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in an outer frame (border) to ink in the central box (higher for ring-like zeros)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    overall_mean = np.mean(gray)\n    cs = max(1, min(h, w) // 10)\n    corners = np.concatenate([\n        gray[:cs, :cs].ravel(),\n        gray[:cs, -cs:].ravel(),\n        gray[-cs:, :cs].ravel(),\n        gray[-cs:, -cs:].ravel()\n    ])\n    corner_mean = np.mean(corners) if corners.size > 0 else overall_mean\n    thresh = (overall_mean + corner_mean) / 2.0\n    ink_darker = overall_mean < corner_mean\n    if ink_darker:\n        mask = (gray < thresh).astype(np.uint8)\n    else:\n        mask = (gray > thresh).astype(np.uint8)\n    total_ink = np.count_nonzero(mask)\n    if total_ink == 0:\n        return 0.0\n    # define border frame as 10% wide around edges\n    bw_h = max(1, h // 8)\n    bw_w = max(1, w // 8)\n    top = mask[:bw_h, :]\n    bottom = mask[-bw_h:, :]\n    left = mask[:, :bw_w]\n    right = mask[:, -bw_w:]\n    border_ink = (np.count_nonzero(top) + np.count_nonzero(bottom) +\n                  np.count_nonzero(left) + np.count_nonzero(right))\n    # center box\n    ch0, ch1 = h // 4, w // 4\n    center = mask[ch0:3*ch0 if 3*ch0>ch0 else h, ch1:3*ch1 if 3*ch1>ch1 else w]\n    center_ink = np.count_nonzero(center)\n    # avoid division by zero\n    denom = float(center_ink) if center_ink > 0 else float(total_ink)\n    return float(border_ink) / denom\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight bounding box around the ink (1 is square, >1 is tall like 1, <1 is wide like 7)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 1.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        ys, xs = np.where(fg)\n        if ys.size == 0:\n            return 1.0\n        bh = float(ys.max() - ys.min() + 1)\n        bw = float(xs.max() - xs.min() + 1)\n        if bw <= 0:\n            return 1.0\n        return float(bh / bw)\n    except Exception:\n        return 1.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the foreground bounding box (width / height), 0.0 if no foreground found'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = gray_n < thr if np.mean(gray_n) > 0.5 else gray_n > thr\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(np.min(ys)), int(np.max(ys))\n    x0, x1 = int(np.min(xs)), int(np.max(xs))\n    bw = max(1, x1 - x0 + 1)\n    bh = max(1, y1 - y0 + 1)\n    return float(bw / bh)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest contiguous horizontal foreground run length in the central horizontal band normalized by image width'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape\n        top = max(h//2 - max(1, h//10), 0)\n        bottom = min(h//2 + max(1, h//10), h)\n        band = gray[top:bottom, :]\n        thr = np.mean(band) if band.size else np.mean(gray)\n        fg = (band < thr) if np.mean(band) > 0.5 else (band > thr)\n        longest = 0\n        for row in fg:\n            # find longest run in this row\n            if row.size == 0:\n                continue\n            # convert to int and find runs\n            r = np.concatenate([[0], row.astype(int), [0]])\n            dif = np.diff(r)\n            starts = np.where(dif == 1)[0]\n            ends = np.where(dif == -1)[0]\n            if starts.size:\n                runs = ends - starts\n                longest = max(longest, runs.max())\n        return float(longest / max(w, 1))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal edge strength in top third to bottom third (5 often has strong top horizontal stroke)'\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3:\n        return 0.0\n    grad_y, grad_x = np.gradient(gray)\n    horiz = np.abs(grad_y)  # horizontal edges where intensity changes top-bottom\n    third = max(1, h // 3)\n    top_sum = np.sum(horiz[:third, :])\n    bot_sum = np.sum(horiz[-third:, :])\n    eps = 1e-6\n    return float((top_sum + eps) / (bot_sum + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical ink runs per column in the right third (counts 0->1 transitions down each column)'\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    lo, hi = float(np.min(gray)), float(np.max(gray))\n    if hi == lo:\n        return 0.0\n    thr = (hi + lo) / 2.0\n    bin1 = gray < thr\n    ink = bin1 if np.sum(bin1) <= 0.6 * h * w else ~bin1\n    c0 = 2 * (w // 3)\n    region = ink[:, c0:w]\n    if region.size == 0:\n        return 0.0\n    diffs = np.diff(region.astype(np.int8), axis=0)\n    runs_per_col = np.sum(diffs == 1, axis=0)  # count 0->1 transitions\n    return float(np.mean(runs_per_col))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of left-third columns that contain any ink (indicates presence of a left vertical stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    left_w = max(1, w // 3)\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    left_block = ink[:, :left_w]\n    if left_block.size == 0:\n        return 0.0\n    cols_with_ink = np.sum(np.any(left_block, axis=0))\n    return float(cols_with_ink / left_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (mean abs vertical gradient / mean abs horizontal gradient)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    h_edge = np.mean(np.abs(gy)) if gy.size else 0.0\n    v_edge = np.mean(np.abs(gx)) if gx.size else 0.0\n    return float((h_edge + 1e-9) / (v_edge + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain no ink (indicates stroke breaks or disjoint strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    if h == 0:\n        return 0.0\n    empty_rows = np.sum(np.all(ink == 0, axis=1))\n    return float(empty_rows / (h + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain a contiguous ink run longer than 60% of the image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    p10, p90 = np.percentile(gray, (10, 90))\n    low_mean = float(np.mean(gray[gray <= p10])) if np.any(gray <= p10) else p10\n    high_mean = float(np.mean(gray[gray >= p90])) if np.any(gray >= p90) else p90\n    median = np.median(gray)\n    if low_mean < high_mean:\n        ink = (gray <= median).astype(np.uint8)\n    else:\n        ink = (gray >= median).astype(np.uint8)\n    threshold_len = max(1, int(0.6 * w))\n    long_row_count = 0\n    for i in range(h):\n        row = ink[i, :]\n        # find longest run of 1s in row\n        max_run = 0\n        run = 0\n        for val in row:\n            if val:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        if max_run >= threshold_len:\n            long_row_count += 1\n    return float(long_row_count) / float(h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry score: mean absolute column difference between left half and flipped right half (lower => more symmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # If halves differ in width, crop to smallest\n    min_w = min(left.shape[1], right_flipped.shape[1])\n    if min_w == 0:\n        return 0.0\n    diff = np.abs(left[:, :min_w] - right_flipped[:, :min_w])\n    # normalize by intensity scale\n    denom = np.mean(np.abs(gray)) + 1e-6\n    return float(np.mean(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between right-half and left-half ink density (right - left)'\n    import numpy as np\n    # Convert to grayscale float in [0,1]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    # Robust thresholding: median, determine if ink is darker than background by comparing border vs center\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h >=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    center_mean = float(center.mean()) if center.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > center_mean else (gray > thresh)\n    ink = ink.astype(np.float64)\n    total = ink.sum()\n    if total <= 1e-6:\n        return 0.0\n    left = ink[:, :w//2].sum()\n    right = ink[:, w//2:].sum()\n    return float((right - left) / (total + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Height (in pixels) of continuous background gap at top center before first ink (normalized by image height)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    b = max(1, min(h, w) // 10)\n    border = np.concatenate([gray[:b, :].ravel(), gray[-b:, :].ravel(), gray[:, :b].ravel(), gray[:, -b:].ravel()])\n    border_mean = float(np.mean(border)) if border.size else float(np.mean(gray))\n    if border_mean >= np.mean(gray):\n        thr = (border_mean + np.min(gray)) / 2.0\n        ink = ~(gray < thr)  # background True where gray >= thr\n        ink = ~ink\n        ink = gray < thr\n    else:\n        thr = (border_mean + np.max(gray)) / 2.0\n        ink = gray > thr\n    ink = ink.astype(np.uint8)\n    # examine a narrow vertical strip around center\n    cx = w // 2\n    halfw = max(1, w // 10)\n    strip = ink[:h//3, max(0, cx-halfw):min(w, cx+halfw)]\n    if strip.size == 0:\n        return 0.0\n    # for each column, find first ink row\n    top_gaps = []\n    for col in range(strip.shape[1]):\n        col_pixels = strip[:, col]\n        ink_rows = np.where(col_pixels)[0]\n        if ink_rows.size == 0:\n            top_gaps.append(strip.shape[0])\n        else:\n            top_gaps.append(int(ink_rows[0]))\n    # take median top gap\n    gap = float(np.median(top_gaps))\n    return float(gap / (h + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of left-third columns that contain any ink (indicates presence of a left vertical stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    left_w = max(1, w // 3)\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.uint8)\n    left_block = ink[:, :left_w]\n    if left_block.size == 0:\n        return 0.0\n    cols_with_ink = np.sum(np.any(left_block, axis=0))\n    return float(cols_with_ink / left_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of enclosed background connected components (holes) detected by border flood-fill'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.sum(ink) == 0 or np.sum(ink) > 0.6 * h * w:\n        ink = gray > thr\n    bg = ~ink\n    # Flood-fill external background starting from borders\n    external = np.zeros_like(bg, dtype=bool)\n    stack = []\n    # push border background pixels\n    top_row = np.where(bg[0, :])[0]\n    for c in top_row:\n        stack.append((0, c))\n        external[0, c] = True\n    bottom_row = np.where(bg[-1, :])[0]\n    for c in bottom_row:\n        if not external[h-1, c]:\n            stack.append((h-1, c)); external[h-1, c] = True\n    left_col = np.where(bg[:, 0])[0]\n    for r in left_col:\n        if not external[r, 0]:\n            stack.append((r, 0)); external[r, 0] = True\n    right_col = np.where(bg[:, -1])[0]\n    for r in right_col:\n        if not external[r, w-1]:\n            stack.append((r, w-1)); external[r, w-1] = True\n    # 4-neighborhood flood fill\n    while stack:\n        r, c = stack.pop()\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w and bg[nr, nc] and not external[nr, nc]:\n                external[nr, nc] = True\n                stack.append((nr, nc))\n    holes_mask = bg & (~external)\n    # Count hole connected components (4-connectivity)\n    visited = np.zeros_like(holes_mask, dtype=bool)\n    hole_count = 0\n    for r in range(h):\n        for c in range(w):\n            if holes_mask[r, c] and not visited[r, c]:\n                hole_count += 1\n                # BFS\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    rr, cc = q.pop()\n                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n                        nr, nc = rr+dr, cc+dc\n                        if 0 <= nr < h and 0 <= nc < w and holes_mask[nr, nc] and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n    return float(hole_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in the top third to the middle third of the image (top_density / (middle_density+eps))'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        meanv = float(np.mean(gray))\n        dark_mask = gray < meanv\n        light_mask = gray > meanv\n        ink = dark_mask if np.count_nonzero(dark_mask) <= np.count_nonzero(light_mask) else light_mask\n        if np.count_nonzero(ink) == 0:\n            return 1.0\n        t = h // 3\n        top = np.count_nonzero(ink[:t, :]) / max(1.0, (t * w))\n        mid = np.count_nonzero(ink[t:2*t, :]) / max(1.0, (t * w))\n        return float(top / (mid + 1e-6))\n    except Exception:\n        return 1.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of horizontal edges in the upper third: mean horizontal gradient in top band divided by global gradient'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    # horizontal gradient (differences along columns)\n    hg = np.abs(np.diff(gray, axis=1))\n    # average in upper third\n    top_rows = max(1, h // 3)\n    top_hg = hg[:top_rows, :]\n    mean_top = top_hg.mean() if top_hg.size else 0.0\n    mean_all = hg.mean() if hg.size else 0.0\n    denom = mean_all + 1e-8\n    return float(mean_top / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid offset of ink: distance between ink centroid and image center (y-axis) / height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    cy = float(np.mean(coords[:, 0]))\n    center_y = (h - 1) / 2.0\n    return float(abs(cy - center_y) / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center of mass of ink normalized to [0,1] (0 top, 1 bottom): 5 tends to have lower center than 0/8'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.5\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(float)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(float)\n    ink_sum = np.sum(ink)\n    if ink_sum <= 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    com_y = float(np.sum(rows * np.sum(ink, axis=1).reshape(h, 1)) / np.sum(ink))\n    # normalize to 0..1\n    return float(com_y / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation of ink strokes (angle normalized to [0,1], 0=horizontal, 0.5=vertical)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    ys, xs = np.nonzero(ink)\n    if ys.size < 2:\n        return 0.0\n    xc = xs.mean()\n    yc = ys.mean()\n    x = xs - xc\n    y = ys - yc\n    cov_xx = (x * x).mean()\n    cov_yy = (y * y).mean()\n    cov_xy = (x * y).mean()\n    # angle of principal eigenvector\n    theta = 0.5 * np.arctan2(2 * cov_xy, cov_xx - cov_yy)\n    # normalize to [0,1]\n    val = (theta + np.pi/2) / np.pi\n    return float(val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Primary stroke orientation: absolute angle of the first principal component normalized to [0,1] (0 = horizontal, 1 = vertical)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    coords = np.column_stack(np.where(mask))\n    if coords.shape[0] < 2:\n        return 0.0\n    # rows -> y, cols -> x; convert to (x,y) for covariance\n    ys = coords[:, 0].astype(float)\n    xs = coords[:, 1].astype(float)\n    mx, my = xs.mean(), ys.mean()\n    cov_xx = np.mean((xs - mx) * (xs - mx))\n    cov_xy = np.mean((xs - mx) * (ys - my))\n    cov_yy = np.mean((ys - my) * (ys - my))\n    cov = np.array([[cov_xx, cov_xy], [cov_xy, cov_yy]])\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n    except Exception:\n        return 0.0\n    # principal component is eigenvector of largest eigenvalue\n    idx = np.argmax(vals)\n    v = vecs[:, idx]\n    angle = float(np.abs(np.arctan2(v[1], v[0])))  # radians relative to x axis\n    # normalize to [0,1] where pi/2 maps to 1\n    return float(min(angle, np.pi/2) / (np.pi/2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink contained in a top-center circular region (detects upper loops typical of 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray.flatten(), 40)\n    mask = gray < thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray < np.mean(gray)\n    cy = max(h // 6, 1)\n    cx = w // 2\n    rad = max(min(h, w) // 6, 2)\n    ys, xs = np.ogrid[:h, :w]\n    circle = (ys - cy) ** 2 + (xs - cx) ** 2 <= rad * rad\n    ink_in_circle = float(np.count_nonzero(np.logical_and(mask, circle)))\n    total_ink = float(np.count_nonzero(mask))\n    return float(ink_in_circle / (total_ink + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the ink bounding box (indicates round vs tall/diagonal shapes)'\n    import numpy as np\n    eps = 1e-9\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gmin, gmax = gray.min(), gray.max()\n    denom = (gmax - gmin) + eps\n    norm = (gray - gmin) / denom\n    low_count = int(np.count_nonzero(norm < 0.5))\n    high_count = h * w - low_count\n    if low_count <= high_count:\n        ink = norm < 0.5\n    else:\n        ink = norm >= 0.5\n    ys, xs = np.where(ink)\n    if ys.size == 0:\n        return 0.0\n    min_y, max_y = ys.min(), ys.max()\n    min_x, max_x = xs.min(), xs.max()\n    bw = float(max_x - min_x + 1)\n    bh = float(max_y - min_y + 1)\n    return float(bw / (bh + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Circular variance of gradient orientations in the lower half (higher for loops/curves)'\n    # convert to grayscale float\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute gradients\n    gy, gx = np.gradient(gray)\n    orientation = np.arctan2(gy, gx)  # [-pi, pi]\n    # use lower half\n    lower = orientation[h//2:, :]\n    mag = np.hypot(gy[h//2:, :], gx[h//2:, :])\n    # mask by significant edge magnitude to avoid noise\n    thresh = np.percentile(mag, 50) if mag.size else 0.0\n    mask = mag > max(thresh * 0.3, 1e-6)\n    if not mask.any():\n        return 0.0\n    theta = lower[mask]\n    # orientation is axial (pi periodic), double angles for circular stats\n    doubled = 2.0 * theta\n    c = np.cos(doubled).mean()\n    s = np.sin(doubled).mean()\n    R = np.hypot(c, s)\n    circ_var = float(1.0 - R)\n    return circ_var\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength in the middle third rows (mean abs vertical differences) normalized by global edge'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h < 3:\n        return 0.0\n    # compute vertical differences (abs of diff along rows gives horizontal edges)\n    vert_diff = np.abs(np.diff(gray, axis=0))\n    mid0 = h // 3\n    mid1 = 2 * h // 3\n    if vert_diff.size == 0:\n        return 0.0\n    mid_region = vert_diff[mid0:mid1, :]\n    global_mean = vert_diff.mean() + 1e-9\n    return float(mid_region.mean() / global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous horizontal ink run length normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    mask_lo = gray < th\n    mask_hi = gray > th\n    mask = mask_lo if np.count_nonzero(mask_lo) <= np.count_nonzero(mask_hi) else mask_hi\n    max_run = 0\n    for r in range(h):\n        row = mask[r]\n        # fast run length scan\n        run = 0\n        # iterate over booleans\n        for val in row:\n            if val:\n                run += 1\n            else:\n                if run > max_run:\n                    max_run = run\n                run = 0\n        if run > max_run:\n            max_run = run\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal gradient magnitude in the middle third of the image (detects a central horizontal bar)'\n    import numpy as np\n    # convert to single-channel float in [0,1]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # normalize to [0,1] robustly\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        norm = (gray - mn) / (mx - mn)\n    else:\n        norm = gray - mn\n    # compute gradients\n    gy, gx = np.gradient(norm)\n    horiz_mag = np.abs(gx)\n    # middle third rows\n    r0, r1 = h // 3, (2 * h) // 3\n    region = horiz_mag[r0:r1, :]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Balance of ink near main diagonal vs anti-diagonal: (main - anti) / total, positive means more main-diagonal ink (useful for diagonal orientation)'\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    thr = (np.nanmin(gray) + np.nanmax(gray)) / 2.0\n    dark_count = np.count_nonzero(gray < thr)\n    ink = (gray < thr) if dark_count < gray.size / 2 else (gray > thr)\n    ink = np.asarray(ink, dtype=bool)\n    if not np.any(ink):\n        return 0.0\n    # distances to main diagonal (y ~= x scaled by aspect) and anti-diagonal (y ~= h-1-x)\n    ys, xs = np.nonzero(ink)\n    # scale x to y dimension to compare properly\n    xs_scaled = xs * (h / max(1.0, w))\n    main_dist = np.abs(ys - xs_scaled)\n    anti_dist = np.abs(ys - (h - 1 - xs_scaled))\n    tol = max(1.0, 0.05 * max(h, w))\n    near_main = np.count_nonzero(main_dist <= tol)\n    near_anti = np.count_nonzero(anti_dist <= tol)\n    total = near_main + near_anti\n    if total == 0:\n        return 0.0\n    return float(near_main - near_anti) / float(total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the right half divided by left half (detects right-side lobes like 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)  # gy: d/drow (vertical change -> horizontal edges), gx: d/dcol (vertical edges)\n    horiz_edge = np.abs(gy)\n    mid = w // 2\n    left_energy = np.mean(horiz_edge[:, :mid]) if mid > 0 else 0.0\n    right_energy = np.mean(horiz_edge[:, mid:]) if w - mid > 0 else 0.0\n    denom = left_energy + 1e-9\n    return float(right_energy / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of diagonal strokes: (45\u00b0 + -45\u00b0 energy) / (vertical + horizontal + diag) \u2014 higher for slanted strokes like 7'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        # compute gradients\n        gy, gx = np.gradient(gray)\n        # energies\n        vert_energy = np.sum(np.abs(gy))\n        horz_energy = np.sum(np.abs(gx))\n        diag1 = (gx + gy) / np.sqrt(2.0)\n        diag2 = (gx - gy) / np.sqrt(2.0)\n        diag_energy = np.sum(np.abs(diag1)) + np.sum(np.abs(diag2))\n        denom = vert_energy + horz_energy + diag_energy + 1e-8\n        return float(diag_energy / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of row-wise mean gradient magnitude in the middle band (captures how many distinct horizontal edges/bars are present)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < eps:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    gy, gx = np.gradient(norm)\n    grad_mag = np.sqrt(gx**2 + gy**2)\n    mid_start = h//3\n    mid_end = 2*h//3\n    band = grad_mag[mid_start:mid_end, :]\n    if band.size == 0:\n        return 0.0\n    row_means = np.mean(band, axis=1)\n    return float(np.std(row_means) / (np.mean(row_means) + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Angle (radians) of the first principal component of ink pixel coordinates (0 = horizontal, positive = down-right slope)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    thr = (p10 + p90) / 2.0\n    mask = (gray < thr) if (p10 < p90) else (gray > thr)\n    rows, cols = np.where(mask)\n    if rows.size < 2:\n        return 0.0\n    coords = np.vstack((cols.astype(float), rows.astype(float)))\n    cov = np.cov(coords)\n    eigvals, eigvecs = np.linalg.eig(cov + 1e-12 * np.eye(2))\n    principal = eigvecs[:, np.argmax(eigvals)]\n    angle = np.arctan2(principal[1], principal[0])\n    return float(angle)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of true cross-like pixels in the center box (pixel has up, down, left and right neighbors) \u2014 indicates a central crossing often present in \"4\")'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray.flatten(), 30))\n    mask = (gray < thr).astype(np.uint8)\n    if mask.sum() == 0:\n        thr = float(np.mean(gray))\n        mask = (gray < thr).astype(np.uint8)\n    # central box\n    r0, r1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    c0, c1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    box = mask[r0:r1, c0:c1]\n    if box.size == 0:\n        return 0.0\n    # pad to compute neighbors\n    pad = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1 + r0:1 + r1, 1 + c0:1 + c1]\n    up = pad[r0 + 0:r1 + 0, 1 + c0:1 + c1]\n    down = pad[r0 + 2:r1 + 2, 1 + c0:1 + c1]\n    left = pad[1 + r0:1 + r1, c0 + 0:c1 + 0]\n    right = pad[1 + r0:1 + r1, c0 + 2:c1 + 2]\n    crosses = np.logical_and.reduce((center == 1, up == 1, down == 1, left == 1, right == 1))\n    return float(np.count_nonzero(crosses) / max(1, box.size))\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength ratio of NW-SE diagonal gradient to NE-SW diagonal gradient (useful for slanted tails)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # diag1 approximates differences along top-left to bottom-right\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 1.0\n    diag1 = gray[:-1, :-1] - gray[1:, 1:]\n    diag2 = gray[1:, :-1] - gray[:-1, 1:]\n    s1 = np.sum(np.abs(diag1))\n    s2 = np.sum(np.abs(diag2))\n    eps = 1e-6\n    return float(s1 / (s2 + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized largest consecutive ink run length on the central row (0..1)'\n    img = np.array(image)\n    if img.size == 0:\n        return 0.0\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    mid = h // 2\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) / (h * w) > 0.6:\n        ink = gray > thr\n    row = ink[mid, :]\n    if w == 0:\n        return 0.0\n    max_run = 0\n    cur = 0\n    for v in row:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / max(1, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry score: average absolute column difference between left and flipped right'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # normalize to [0,1]\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    left = gray[:, :w // 2]\n    right = np.fliplr(gray[:, (w + 1) // 2:]) if w % 2 else np.fliplr(gray[:, w // 2:])\n    # match shapes\n    minw = min(left.shape[1], right.shape[1]) if left.size and right.size else 0\n    if minw == 0:\n        # trivial case: no symmetry information\n        return 0.0\n    diff = np.abs(left[:, :minw] - right[:, :minw])\n    # normalized by pixel count and intensity range\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a single long foreground run (>50% of height) (helps detect vertical sticks)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = float(np.min(gray)), float(np.max(gray))\n    norm = (gray - gmin) / (gmax - gmin) if gmax > gmin else np.zeros_like(gray)\n    thr = 0.5\n    less_count = np.count_nonzero(norm < thr)\n    greater_count = norm.size - less_count\n    fg = (norm < thr) if less_count <= greater_count else (norm > thr)\n    h, w = fg.shape\n    if w == 0:\n        return 0.0\n    long_count = 0\n    for c in range(w):\n        col = fg[:, c].astype(int)\n        if col.sum() == 0:\n            continue\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if lengths.size == 1 and lengths[0] >= 0.5 * h:\n            long_count += 1\n    return float(long_count / float(w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-left darkness fraction relative to lower-right (helps detect 4 which often has darker lower-left stem area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    dark = (np.max(gray) - gray)\n    # lower half split left/right\n    lower = dark[h // 2 :, :] if h // 2 < h else dark[-1:, :]\n    midc = w // 2\n    left = np.sum(lower[:, :midc]) if midc > 0 else 0.0\n    right = np.sum(lower[:, midc:]) if midc < w else 0.0\n    denom = (left + right + 1e-6)\n    return float(left / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of total mass that lies in the bottom half of the image (measures lower-loop prominence)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    total = np.sum(gray)\n    if total == 0:\n        return 0.0\n    bottom = np.sum(gray[h//2:, :])\n    return float(bottom / (total + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum foreground projection in top half to maximum in bottom half (top_peak / bottom_peak)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    proj = np.sum(fg.astype(np.int32), axis=1)  # per-row foreground count\n    mid = h // 2\n    top_peak = float(np.max(proj[:max(1, mid)])) if mid > 0 else float(np.max(proj))\n    bottom_peak = float(np.max(proj[mid:])) if mid < h else float(np.max(proj))\n    return float(top_peak / (bottom_peak + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Signed density difference between upper-right and lower-right quadrants (positive means more ink in upper-right)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn + 1e-9)\n    median = np.median(gray_n)\n    bottom10 = np.percentile(gray_n.flatten(), 10)\n    top10 = np.percentile(gray_n.flatten(), 90)\n    if bottom10 < top10:\n        ink = (gray_n <= median).astype(float)\n    else:\n        ink = (gray_n >= median).astype(float)\n    rx0 = int(w * 2 / 3)\n    ur = ink[0:h//2, rx0:w].sum() / ( (h//2) * max(1, w - rx0) )\n    lr = ink[h//2:h, rx0:w].sum() / ( (h - h//2) * max(1, w - rx0) )\n    denom = ur + lr + 1e-9\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized largest vertical gap (background) in the central column region (helps detect separation between lobes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    corner = min(5, h//2, w//2)\n    if corner > 0:\n        bg = np.mean(np.concatenate([gray[:corner,:corner].ravel(),\n                                     gray[:corner,-corner:].ravel(),\n                                     gray[-corner:,:corner].ravel(),\n                                     gray[-corner:,-corner:].ravel()]))\n    else:\n        bg = np.mean(gray)\n    if bg >= np.mean(gray):\n        thr = (bg + np.min(gray)) / 2.0\n        bin_img = (gray < thr).astype(np.uint8)\n    else:\n        thr = (bg + np.max(gray)) / 2.0\n        bin_img = (gray > thr).astype(np.uint8)\n    # choose a narrow central band\n    center = w // 2\n    band = max(1, w // 10)\n    cols = slice(max(0, center - band), min(w, center + band + 1))\n    col_band = np.any(bin_img[:, cols], axis=1).astype(int)  # 1 if any ink in band, else 0\n    # we want longest run of zeros (background)\n    if col_band.size == 0:\n        return 0.0\n    padded = np.concatenate(([0], col_band, [0]))\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    lengths = ends - starts\n    if lengths.size == 0:\n        # all background or all ink -> set accordingly\n        if np.all(col_band == 0):\n            return 1.0\n        else:\n            return 0.0\n    # background runs are where col_band == 0: compute from inverse\n    inv = 1 - col_band\n    padded_inv = np.concatenate(([0], inv, [0]))\n    diffs_inv = np.diff(padded_inv)\n    starts_inv = np.where(diffs_inv == 1)[0]\n    ends_inv = np.where(diffs_inv == -1)[0]\n    lengths_inv = ends_inv - starts_inv\n    max_gap = float(lengths_inv.max()) if lengths_inv.size else 0.0\n    return float(max_gap) / float(h)\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected ink components in the right half (separate right-side blobs), returns component count'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(np.float32)\n        else:\n            gray = image.astype(np.float32)\n        if gray.size == 0:\n            return 0.0\n        if gray.max() > 1.5:\n            gray = gray / 255.0\n        h, w = gray.shape[:2]\n        thr = np.percentile(gray, 40)\n        bg_bright = np.mean(gray) > 0.5\n        mask = ((gray < thr) if bg_bright else (gray > thr)).astype(np.uint8)\n        region = mask[:, w//2:]\n        H, W = region.shape\n        if region.sum() == 0:\n            return 0.0\n        visited = np.zeros_like(region, dtype=bool)\n        comps = 0\n        # simple flood-fill (4-connectivity)\n        for i in range(H):\n            for j in range(W):\n                if region[i, j] and not visited[i, j]:\n                    comps += 1\n                    stack = [(i, j)]\n                    visited[i, j] = True\n                    while stack:\n                        y, x = stack.pop()\n                        for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                            ny, nx = y+dy, x+dx\n                            if 0 <= ny < H and 0 <= nx < W and region[ny, nx] and not visited[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n        return float(comps)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom horizontal gradient strength: mean absolute horizontal gradient in bottom strip (detect bottom bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    gy, gx = np.gradient(gray.astype(np.float64))\n    horiz_abs = np.abs(gx)\n    bottom_h = max(1, h // 5)\n    region = horiz_abs[h - bottom_h:, :]\n    fg_region = fg[h - bottom_h:, :]\n    # weight by foreground presence to emphasize strokes\n    weighted = region * (fg_region.astype(np.float64))\n    mean_val = weighted.mean() if weighted.size else 0.0\n    return float(mean_val)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the tight ink bounding box (returns 1.0 if no ink)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top = gray[0:1, :]\n    bottom = gray[-1:, :]\n    left = gray[:, 0:1]\n    right = gray[:, -1:]\n    border_mean = float(np.mean(np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()])))\n    rng = float(gray.max() - gray.min())\n    if rng <= 0:\n        return 1.0\n    if border_mean > np.mean(gray):\n        ink = (gray < (border_mean - 0.15 * rng)).astype(np.uint8)\n    else:\n        ink = (gray > (border_mean + 0.15 * rng)).astype(np.uint8)\n    ys, xs = np.where(ink)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bw = maxx - minx + 1\n    bh = maxy - miny + 1\n    if bh == 0:\n        return float(bw)\n    return float(bw / bh)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal-to-vertical gradient ratio in the bottom-right quadrant (detects diagonal/horizontal strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    br = gray[h//2:h, w//2:w]\n    if br.size == 0:\n        return 0.0\n    gy, gx = np.gradient(br.astype(float))\n    mean_ax = float(np.mean(np.abs(gx)))\n    mean_ay = float(np.mean(np.abs(gy)))\n    return float(mean_ax / (mean_ay + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the tight ink bounding box (1.0 ~ square); distinguishes tall strokes from round loops'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = gray < thr\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = gray > thr\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n    bbox_h = max_r - min_r + 1\n    bbox_w = max_c - min_c + 1\n    if bbox_w <= 0:\n        return float(bbox_h)\n    return float(bbox_h) / float(bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in upper quarter vs lower quarter (upper_density / (lower_density + eps))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gm = np.mean(gray)\n    corner = np.mean(gray[:max(1,h//10), :max(1,w//10)])\n    ink = gray < gm if corner > gm else gray > gm\n    ink = np.asarray(ink, dtype=bool)\n    q = max(1, h // 4)\n    upper = ink[:q, :].sum() / float(max(1, q * w))\n    lower = ink[-q:, :].sum() / float(max(1, q * w))\n    return float(upper / (lower + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean stroke thickness in the central vertical band to the average of top and bottom thirds (lower for pinched/8)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.array(image, dtype=float)\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    rng = float(gray.max() - gray.min())\n    thr = float(np.mean(gray) - 0.15 * rng)\n    mask = gray < thr\n    if mask.sum() < 5 or mask.sum() > 0.95 * gray.size:\n        thr = float(np.median(gray))\n        mask = gray < thr\n    if mask.sum() > 0 and np.mean(gray[mask]) > np.mean(gray[~mask]):\n        mask = ~mask\n    # thickness per row = number of contiguous ink pixels in that row (we use sum across row as proxy)\n    row_sums = mask.sum(axis=1).astype(float)\n    top_mean = np.mean(row_sums[:max(1, h//3)])\n    bottom_mean = np.mean(row_sums[max(2*h//3, h//3):])\n    center_slice = mask[max(h//3 - 1, 0):min(2*h//3 + 1, h), max(w//2 - max(1, w//10),0):min(w, w//2 + max(1, w//10))]\n    center_thickness = float(np.sum(center_slice) / max(1, center_slice.shape[0]))\n    denom = (top_mean + bottom_mean) / 2.0\n    if denom <= 0:\n        return float(center_thickness)\n    return float(center_thickness / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average of the largest white run lengths across rows in the top 25% of the image, normalized by width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = float(np.percentile(gray.flatten(), 50))\n    bin_img = (gray <= thresh).astype(np.uint8)  # ink=1, white=0\n    top_h = max(1, h // 4)\n    top_region = bin_img[:top_h, :]\n    # for each row compute longest contiguous zeros (white)\n    max_runs = []\n    for r in range(top_region.shape[0]):\n        row = top_region[r, :]\n        # invert to runs of white\n        white = (row == 0).astype(np.uint8)\n        if white.sum() == 0:\n            max_runs.append(0)\n            continue\n        # compute run lengths\n        diffs = np.diff(np.concatenate(([0], white, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        runs = (ends - starts).tolist()\n        if runs:\n            max_runs.append(max(runs))\n        else:\n            max_runs.append(0)\n    if len(max_runs) == 0:\n        return 0.0\n    avg_max = float(np.mean(max_runs))\n    return float(avg_max / (w + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the top-right quadrant (upper-right density ratio)'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    thresh = np.mean(norm)\n    ink = (norm < thresh).astype(np.float32)\n    if np.mean(ink) < 1e-3:\n        ink = 1.0 - ink\n    mid_h, mid_w = h // 2, w // 2\n    top_right = ink[0:mid_h, mid_w:w]\n    total = ink.sum()\n    if total <= 0:\n        return 0.0\n    return float(top_right.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal vs anti-diagonal gradient energy: sum|gx+gy| / (sum|gx-gy| + eps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag = np.sum(np.abs(gx + gy))\n    antidiag = np.sum(np.abs(gx - gy))\n    eps = 1e-6\n    return float(diag / (antidiag + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in the left half to the right half (left/right), >1 means left-heavy'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # simple bimodal threshold\n    lo, hi = float(np.min(gray)), float(np.max(gray))\n    thresh = (lo + hi) / 2.0\n    ink = (gray < thresh)\n    left = np.sum(ink[:, :w//2])\n    right = np.sum(ink[:, w//2:])\n    eps = 1e-6\n    return float(left / (right + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge energy in the upper half vs lower half (upper_energy / (lower_energy + eps))'\n    eps = 1e-9\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    # horizontal gradient magnitude (differences along columns)\n    grad_h = np.abs(np.diff(norm, axis=1))\n    mid = h // 2\n    upper_energy = grad_h[:mid, :].sum()\n    lower_energy = grad_h[mid:, :].sum()\n    return float(upper_energy / (lower_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink mass in rightmost 25% strip to leftmost 25% strip (right_density / (left_density + eps))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    if mx - mn > 1e-8:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    h, w = gray.shape[:2]\n    ink = gray < 0.5\n    if np.mean(ink) > 0.5:\n        ink = ~ink\n    quarter = max(1, w // 4)\n    left = ink[:, :quarter]\n    right = ink[:, -quarter:]\n    left_sum = float(np.count_nonzero(left))\n    right_sum = float(np.count_nonzero(right))\n    return float(right_sum / (left_sum + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center gap fraction: fraction of central columns in the top quarter that are completely empty (useful to detect open tops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = gray.mean()\n    mask = (gray > thr)\n    if mask.mean() > 0.6 or mask.mean() < 0.001:\n        p30, p70 = np.percentile(gray.flatten(), [30, 70])\n        thr2 = (p30 + p70) / 2.0\n        mask = (gray > thr2)\n        if mask.mean() > 0.6:\n            mask = (gray < thr2)\n    mask = mask.astype(np.uint8)\n    top_h = max(1, h // 4)\n    c0 = w // 4\n    c1 = 3 * w // 4\n    central = mask[0:top_h, c0:c1]\n    if central.shape[1] == 0:\n        return 0.0\n    empty_cols = np.sum(np.all(central == 0, axis=0))\n    return float(empty_cols / (central.shape[1] + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average absolute horizontal gradient magnitude in the middle third of the image (captures middle bars like in \"4\")'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # compute horizontal gradient (difference along columns)\n    gx = np.abs(np.diff(gray, axis=1))\n    # pad to original width\n    gx = np.pad(gx, ((0,0),(0,1)), mode='constant', constant_values=0)\n    # middle third rows\n    r0 = h // 3\n    r1 = min(h, r0 * 2)\n    if r1 <= r0:\n        return float(np.mean(gx)) if gx.size else 0.0\n    mid_region = gx[r0:r1, :]\n    return float(np.mean(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median row index of the topmost ink in center third columns, normalized by height (captures approximate crossbar vertical position)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = gray.min(), gray.max()\n    norm = (gray - gmin) / (gmax - gmin + 1e-12)\n    if np.mean(norm) > 0.5:\n        ink = norm < 0.5\n    else:\n        ink = norm > 0.5\n    h, w = gray.shape\n    c0, c1 = w // 3, (2 * w) // 3\n    if c1 <= c0:\n        return 0.0\n    top_indices = []\n    for c in range(c0, c1):\n        col = ink[:, c]\n        ys = np.where(col)[0]\n        if ys.size:\n            top_indices.append(ys.min())\n    if len(top_indices) == 0:\n        return 0.0\n    med = float(np.median(top_indices))\n    return float(med / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient to horizontal gradient in the top-right quadrant (vertical/horizontal)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    r0, c0 = 0, w // 2\n    r1, c1 = max(1, h // 2), w\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mean_abs_gx = np.mean(np.abs(gx)) + 1e-9\n    mean_abs_gy = np.mean(np.abs(gy))\n    return float(mean_abs_gy / mean_abs_gx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest white (background) vertical gap in the center column normalized by height'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    center_col = w // 2\n    p = np.percentile(gray, 40)\n    ink = gray <= p\n    if not ink.any():\n        p = np.percentile(gray, 60)\n        ink = gray <= p\n    col = ink[:, center_col] if center_col < w else ink[:, -1]\n    # find longest run of False (background) in this column\n    padded = np.concatenate(([0], col.view(np.int8), [0]))\n    diffs = np.diff(padded)\n    starts = np.where(diffs == -1)[0]  # background run starts in padded representation\n    ends = np.where(diffs == 1)[0]\n    max_gap = 0\n    # because we inverted sign for padded, compute runs carefully\n    # alternative: compute runs directly\n    max_gap = 0\n    run = 0\n    for v in col:\n        if not v:\n            run += 1\n        else:\n            if run > max_gap:\n                max_gap = run\n            run = 0\n    if run > max_gap:\n        max_gap = run\n    result = float(max_gap) / max(1, h)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute diagonal-projected edge strength in the upper-right quadrant (captures diagonal strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mx = gray.max() if gray.max() != 0 else 1.0\n    gray = gray / mx\n    gy, gx = np.gradient(gray)\n    h, w = gray.shape[:2]\n    r_end = max(1, h//3)\n    c0 = w//2\n    gx_sub = gx[:r_end, c0:]\n    gy_sub = gy[:r_end, c0:]\n    if gx_sub.size == 0:\n        return 0.0\n    # project gradient onto the diagonal direction (1,-1)/sqrt(2) to detect strokes slanted down-right\n    proj = (gx_sub - gy_sub) / np.sqrt(2)\n    return float(np.mean(np.abs(proj)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical gradient energy concentrated in the central vertical third (distinguishes centered vertical strokes like 1)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        gy, gx = np.gradient(gray)\n        vert = np.abs(gy)\n        h, w = gray.shape\n        c0, c1 = w//3, 2*w//3\n        center_vert = np.sum(vert[:, c0:c1])\n        total = np.sum(vert) + 1e-8\n        return float(center_vert / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in lower-right half to ink in lower-left half (captures right-leaning bottoms vs left loops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    maxv = float(np.max(gray)) if np.max(gray) != 0 else 1.0\n    gray = gray / maxv\n    p_low = np.percentile(gray, 40)\n    p_high = np.percentile(gray, 60)\n    fg = (gray < p_low) if np.mean(gray) <= np.median(gray) else (gray > p_high)\n    h, w = gray.shape\n    lower = slice(h // 2, h)\n    left = slice(0, w // 2)\n    right = slice(w // 2, w)\n    ink_lr = np.count_nonzero(fg[lower, right])\n    ink_ll = np.count_nonzero(fg[lower, left])\n    eps = 1e-6\n    return float((ink_lr + eps) / (ink_ll + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink mass on the top-right side of the anti-diagonal (c + r < w-1), useful to distinguish strokes reaching top-right vs bottom-left'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = float(np.percentile(gray, 50))\n    binary = (gray > thresh).astype(np.uint8)\n    total = int(np.count_nonzero(binary))\n    if total == 0:\n        return 0.0\n    rows = np.arange(h)[:, None]\n    cols = np.arange(w)[None, :]\n    mask_top_right = (cols + rows) < (w - 1)\n    count = int(np.count_nonzero(np.logical_and(binary == 1, mask_top_right)))\n    return float(count) / float(total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of hole area that lies in the upper half of the image (holes detected as background components not connected to the image border)'\n    import numpy as np\n    from collections import deque\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    bg = np.median(border) if border.size > 0 else 0.0\n    diff = np.abs(gray - bg)\n    thr = max(0.05 * (gray.max() - gray.min()), 0.5 * np.std(gray), 1e-6)\n    binar = (diff > thr).astype(np.uint8)  # foreground=1, background=0\n    if h == 0 or w == 0:\n        return 0.0\n    # Mark outside background via flood fill from border for pixels that are background (0)\n    outside = np.zeros((h, w), dtype=bool)\n    q = deque()\n    for x in range(w):\n        if binar[0, x] == 0:\n            q.append((0, x)); outside[0, x] = True\n        if binar[h-1, x] == 0:\n            q.append((h-1, x)); outside[h-1, x] = True\n    for y in range(h):\n        if binar[y, 0] == 0:\n            q.append((y, 0)); outside[y, 0] = True\n        if binar[y, w-1] == 0:\n            q.append((y, w-1)); outside[y, w-1] = True\n    while q:\n        y, x = q.popleft()\n        for ny, nx in ((y-1,x),(y+1,x),(y,x-1),(y,x+1)):\n            if 0 <= ny < h and 0 <= nx < w and not outside[ny, nx] and binar[ny, nx] == 0:\n                outside[ny, nx] = True\n                q.append((ny, nx))\n    holes_mask = (~outside) & (binar == 0)\n    total_hole = int(np.count_nonzero(holes_mask))\n    if total_hole == 0:\n        return 0.0\n    upper_half = holes_mask[:h//2, :]\n    upper_area = int(np.count_nonzero(upper_half))\n    return float(upper_area / total_hole)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left/right (vertical) symmetry: normalized mean absolute difference between left half and mirrored right half (0 symmetric, larger = asymmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.0\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w-mid:][:, ::-1]  # mirrored right\n    # if halves mismatched shapes (odd width), pad smaller\n    if left.shape[1] != right.shape[1]:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    diff = np.abs(left - right)\n    # normalize by mean intensity range to make scale-invariant\n    denom = (np.mean(gray) + np.std(gray) + 1e-9)\n    score = np.mean(diff) / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge energy in the upper half vs lower half (upper_energy / (lower_energy + eps))'\n    eps = 1e-9\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    # horizontal gradient magnitude (differences along columns)\n    grad_h = np.abs(np.diff(norm, axis=1))\n    mid = h // 2\n    upper_energy = grad_h[:mid, :].sum()\n    lower_energy = grad_h[mid:, :].sum()\n    return float(upper_energy / (lower_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density ratio right-third / left-third of image (helps detect right-heavy digits like 9)'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = (gray_n < thr) if np.mean(gray_n) > 0.5 else (gray_n > thr)\n    third = max(1, w // 3)\n    left = fg[:, :third]\n    right = fg[:, -third:]\n    left_count = float(np.count_nonzero(left))\n    right_count = float(np.count_nonzero(right))\n    eps = 1e-6\n    return float(right_count / (left_count + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density ratio right-third / left-third of image (helps detect right-heavy digits like 9)'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gray_n = (gray - mn) / (mx - mn) if mx - mn > 1e-8 else np.zeros_like(gray)\n    thr = np.mean(gray_n)\n    fg = (gray_n < thr) if np.mean(gray_n) > 0.5 else (gray_n > thr)\n    third = max(1, w // 3)\n    left = fg[:, :third]\n    right = fg[:, -third:]\n    left_count = float(np.count_nonzero(left))\n    right_count = float(np.count_nonzero(right))\n    eps = 1e-6\n    return float(right_count / (left_count + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a bottom horizontal bar: mean abs horizontal gradient in bottom quarter divided by overall mean'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray); gx = np.zeros_like(gray)\n    overall = float(np.mean(np.abs(gx))) + 1e-9\n    bottom_slice = slice(max(0, 3*h//4), h)\n    bottom_strength = float(np.mean(np.abs(gx[bottom_slice, :])))\n    return float(bottom_strength / overall)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Topmost ink row normalized by image height (min row index of ink / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    mn, mx = float(gray.min()), float(gray.max())\n    if mx == mn:\n        return 0.0\n    grayn = (gray - mn) / (mx - mn)\n    thr = (grayn.mean() + np.median(grayn)) / 2.0\n    ink = ((grayn > thr) if np.sum(grayn > thr) < np.sum(grayn < thr) else (grayn < thr)).astype(np.uint8)\n    ys, _ = np.where(ink)\n    if ys.size == 0:\n        return 0.0\n    top = ys.min()\n    h = ink.shape[0]\n    return float(top) / float(h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset normalized by image height (positive means centroid is lower than center)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.count_nonzero(ink) > 0.6 * h * w:\n        ink = ~ink\n    coords = np.argwhere(ink)\n    if coords.size == 0:\n        return 0.0\n    yc = float(np.mean(coords[:, 0]))\n    offset_norm = (yc - (h / 2.0)) / max(1.0, h)\n    return float(offset_norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute top-bottom foreground mass difference normalized by total mass'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    minv = float(np.min(gray))\n    maxv = float(np.max(gray))\n    if maxv > minv:\n        gray = (gray - minv) / (maxv - minv)\n    else:\n        gray = gray * 0.0\n    thr = 0.5\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if mask_dark.sum() <= mask_bright.sum() else mask_bright\n    h, w = mask.shape\n    top = mask[:h//2, :].sum()\n    bottom = mask[h//2:, :].sum()\n    total = top + bottom\n    if total == 0:\n        return 0.0\n    return float(abs(top - bottom) / float(total))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) pixels in the right-middle region vs left-middle region (close to 1 => more empty on right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    rng = float(gray.max() - gray.min())\n    if rng == 0:\n        return 0.5\n    med = float(np.median(gray)); mean = float(np.mean(gray)); delta = rng * 0.05\n    if mean < med:\n        fg = (gray < (med - delta)).astype(int)\n    else:\n        fg = (gray > (med + delta)).astype(int)\n    y0, y1 = h // 3, max(h // 3 + 1, 2 * h // 3)\n    mid_x0, mid_x1 = w // 3, max(w // 3 + 1, 2 * w // 3)\n    band = fg[y0:y1, mid_x0:mid_x1]\n    if band.size == 0:\n        return 0.5\n    mid = band.shape[1] // 2\n    left_band = band[:, :mid]\n    right_band = band[:, mid:]\n    left_bg = float((left_band == 0).sum())\n    right_bg = float((right_band == 0).sum())\n    total = left_bg + right_bg\n    if total == 0:\n        return 0.5\n    return float(right_bg / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the top 20% rows (detect top bars)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.max() > 1.5:\n        gray = gray / 255.0\n    thr = np.mean(gray)\n    mask = gray < thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.median(gray)\n        mask = gray < thr\n    h, w = gray.shape[:2]\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    top_h = max(1, int(np.ceil(0.2 * h)))\n    top_mask = mask[:top_h, :]\n    return float(np.count_nonzero(top_mask) / max(1, np.count_nonzero(mask)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest vertical run of foreground pixels in the right third of the image, normalized by height (detects vertical strokes on the right)'\n    import numpy as np\n    eps = 1e-6\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray)\n    bw = (gray > thr).astype(np.uint8)\n    start_col = max(0, w * 2 // 3)\n    sub = bw[:, start_col:]\n    if sub.size == 0:\n        return 0.0\n    # compute longest run in each column\n    longest = 0\n    for c in range(sub.shape[1]):\n        col = sub[:, c]\n        # find consecutive ones runs\n        run = 0\n        max_run = 0\n        for val in col:\n            if val:\n                run += 1\n            else:\n                if run > max_run:\n                    max_run = run\n                run = 0\n        if run > max_run:\n            max_run = run\n        if max_run > longest:\n            longest = max_run\n    return float(longest / (h + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of gradient magnitude aligned with ~45\u00b0 diagonal (captures prominent slanted stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gx, gy = np.gradient(gray.astype(float), axis=1), np.gradient(gray.astype(float), axis=0)\n    mag = np.hypot(gx, gy)\n    total_mag = np.sum(mag) + 1e-9\n    ang = np.arctan2(gy, gx)  # radians\n    deg = np.degrees(ang)\n    # consider angles around +45 and -135 (same orientation)\n    mask45 = (deg >= 25) & (deg <= 65)\n    mask135 = (deg <= -115) & (deg >= -155)\n    aligned = np.sum(mag * (mask45 | mask135))\n    return float(aligned / total_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate average stroke thickness: ink pixel count divided by edge pixel count (higher = thicker strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    thr = np.percentile(norm, 50)\n    bin_img = (norm >= thr).astype(float)\n    ink = bin_img.sum()\n    # edge estimation via gradient magnitude\n    gy, gx = np.gradient(norm)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to percentile\n    p75 = np.percentile(grad, 75)\n    edge_mask = grad >= (p75 * 0.25 if p75 > 0 else 1e-6)\n    edge_count = np.sum(edge_mask & (bin_img > 0.0))\n    if edge_count < 1.0:\n        return float(ink)  # fallback: return raw ink count as proxy\n    return float(ink / edge_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Bias toward diagonal vs axis-aligned gradients: (diag_fraction - axis_fraction), in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    # compute gradients\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.hypot(gx, gy)\n    total = np.sum(mag)\n    if total <= 0:\n        return 0.0\n    angle = np.arctan2(gy, gx)  # -pi..pi\n    # classify angles: axis-aligned near 0,pi/2; diagonal near pi/4, -pi/4\n    ang_deg = np.abs(np.degrees(angle)) % 180.0\n    # axis if within 22.5 deg of 0 or 90\n    axis_mask = ((ang_deg <= 22.5) | (np.abs(ang_deg - 90) <= 22.5))\n    diag_mask = ((np.abs(ang_deg - 45) <= 22.5) | (np.abs(ang_deg - 135) <= 22.5))\n    axis_sum = float(np.sum(mag[axis_mask]))\n    diag_sum = float(np.sum(mag[diag_mask]))\n    return float((diag_sum - axis_sum) / (total + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal orientation of ink: Pearson correlation between x and y coordinates of ink pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    ys, xs = np.where(fg)\n    if ys.size < 2:\n        return 0.0\n    xs_f = xs.astype(np.float64)\n    ys_f = ys.astype(np.float64)\n    xs_c = xs_f - xs_f.mean()\n    ys_c = ys_f - ys_f.mean()\n    cov = np.mean(xs_c * ys_c)\n    sx = xs_c.std()\n    sy = ys_c.std()\n    if sx * sy < 1e-8:\n        return 0.0\n    corr = cov / (sx * sy)\n    return float(corr)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean radial projection of gradients (higher => edges point outward, circularity)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    # gradients\n    gy, gx = np.gradient(gray.astype(float))\n    # center coordinates\n    ys = np.arange(h)[:, None].repeat(w, axis=1)\n    xs = np.arange(w)[None, :].repeat(h, axis=0)\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    dx = xs - cx\n    dy = ys - cy\n    dist = np.sqrt(dx**2 + dy**2) + 1e-6\n    radial_proj = (gx * dx + gy * dy) / dist\n    # focus on strong edge areas (high gradient magnitude)\n    grad_mag = np.hypot(gx, gy)\n    thr = np.percentile(grad_mag.flatten(), 80)\n    mask = grad_mag >= thr\n    if np.sum(mask) == 0:\n        return 0.0\n    mean_proj = np.mean(np.abs(radial_proj[mask]))\n    norm = np.mean(grad_mag[mask]) + 1e-6\n    return float(mean_proj / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of a top horizontal stroke: proportion of ink in the top 20% rows'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    top_rows = max(1, h // 5)\n    top_count = float(np.count_nonzero(ink[:top_rows, :]))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient magnitude to horizontal gradient magnitude (large for vertical strokes); clipped to avoid div-by-zero'\n    import numpy as np\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute simple finite differences\n    gy = np.abs(np.diff(gray, axis=0))\n    gx = np.abs(np.diff(gray, axis=1))\n    # pad to original size using zeros\n    gy_sum = float(gy.mean() if gy.size else 0.0)\n    gx_sum = float(gx.mean() if gx.size else 0.0)\n    denom = gx_sum + 1e-12\n    return float(gy_sum / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left vs right ink imbalance: (left - right) / total_ink (negative = right-heavy)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gmin, gmax = float(np.min(gray)), float(np.max(gray))\n    if gmax == gmin:\n        return 0.0\n    thr = (gmin + gmax) / 2.0\n    low_count = np.sum(gray < thr)\n    high_count = np.sum(gray > thr)\n    ink = (gray < thr) if low_count < high_count else (gray > thr)\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    left = float(np.count_nonzero(ink[:, :w // 2]))\n    right = float(np.count_nonzero(ink[:, w // 2:]))\n    return float((left - right) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient strength to orthogonal gradient strength (diagonal prominence indicates slanted strokes like 4)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        # compute gradients\n        gy, gx = np.gradient(gray.astype(float))\n        abs_gx = np.abs(gx)\n        abs_gy = np.abs(gy)\n        diag1 = (gx + gy) / np.sqrt(2.0)\n        diag2 = (gx - gy) / np.sqrt(2.0)\n        mean_diag = (np.abs(diag1).mean() + np.abs(diag2).mean()) / 2.0\n        mean_hv = (abs_gx.mean() + abs_gy.mean()) / 2.0\n        return float(mean_diag / (mean_hv + 1e-12))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of stroke endpoints (ink pixels with <=1 ink neighbor) (0..1)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        if np.count_nonzero(ink) == 0:\n            return 0.0\n        pad = np.pad(ink, pad_width=1, mode='constant', constant_values=False)\n        neighbor_count = np.zeros_like(ink, dtype=int)\n        for dy in (-1, 0, 1):\n            for dx in (-1, 0, 1):\n                if dy == 0 and dx == 0:\n                    continue\n                neighbor_count += pad[1+dy : 1+dy+h, 1+dx : 1+dx+w]\n        endpoints = ink & (neighbor_count <= 1)\n        return float(np.count_nonzero(endpoints)) / float(np.count_nonzero(ink))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of total enclosed hole area to ink area (how big holes are relative to ink)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # Flood fill exterior background\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal_bg = (~ink) & (~exterior)\n    hole_area = float(np.sum(internal_bg))\n    ink_area = float(np.sum(ink))\n    if ink_area <= 0.0:\n        return 0.0\n    return float(hole_area / ink_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid (0..1) of hole pixels (0 if no hole); 0=left, 1=right'\n    import numpy as np\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    p20, p80 = np.percentile(gray, 20), np.percentile(gray, 80)\n    mid = 0.5 * (p20 + p80)\n    ink_darker = np.mean(gray) < mid\n    ink = (gray <= mid) if ink_darker else (gray >= mid)\n    bg = ~ink\n    visited = np.zeros((h, w), dtype=bool)\n    stack = []\n    for x in range(w):\n        if bg[0, x]:\n            stack.append((0, x)); visited[0, x] = True\n        if bg[h-1, x]:\n            stack.append((h-1, x)); visited[h-1, x] = True\n    for y in range(h):\n        if bg[y, 0] and not visited[y, 0]:\n            stack.append((y, 0)); visited[y, 0] = True\n        if bg[y, w-1] and not visited[y, w-1]:\n            stack.append((y, w-1)); visited[y, w-1] = True\n    while stack:\n        r, c = stack.pop()\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            rr, cc = r+dr, c+dc\n            if 0 <= rr < h and 0 <= cc < w and bg[rr, cc] and not visited[rr, cc]:\n                visited[rr, cc] = True\n                stack.append((rr, cc))\n    holes = bg & (~visited)\n    if not holes.any():\n        return 0.0\n    ys, xs = np.nonzero(holes)\n    cx = xs.mean() / max(1, w-1)\n    return float(cx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of prominent peaks in the horizontal (column) ink projection; helps separate wide loops from narrow strokes'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = gray < thr\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = gray > thr\n    ink = ink.astype(np.uint8)\n    col_sum = np.sum(ink, axis=0).astype(float)\n    if w < 3 or np.max(col_sum) <= 0:\n        return 0.0\n    smooth = np.convolve(col_sum, np.array([1.0, 1.0, 1.0]) / 3.0, mode='same')\n    mean_val = np.mean(smooth)\n    peaks = 0\n    for i in range(1, len(smooth) - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > 0.25 * mean_val:\n            peaks += 1\n    return float(peaks)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average ink density in a narrow vertical band between hole centroids (3-pixel wide). If no holes, use center column.'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gmax = gray.max()\n    if gmax > 1.5:\n        gray = gray / gmax\n    thresh = float(np.mean(gray))\n    dark_frac = float(np.mean(gray < thresh))\n    if 0.01 < dark_frac < 0.99:\n        ink = (gray < thresh) if dark_frac < 0.5 else (gray > thresh)\n    else:\n        ink = gray < thresh\n    bg = ~ink\n    h, w = gray.shape\n    visited = np.zeros_like(bg, dtype=bool)\n    neighbors = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n    holes = []\n    for r in range(h):\n        for c in range(w):\n            if visited[r, c] or not bg[r, c]:\n                continue\n            stack = [(r, c)]\n            visited[r, c] = True\n            touches_border = False\n            area = 0\n            sum_c = 0.0\n            while stack:\n                rr, cc = stack.pop()\n                area += 1\n                sum_c += cc\n                if rr == 0 or rr == h-1 or cc == 0 or cc == w-1:\n                    touches_border = True\n                for dr, dc in neighbors:\n                    nr, nc = rr + dr, cc + dc\n                    if 0 <= nr < h and 0 <= nc < w and (not visited[nr, nc]) and bg[nr, nc]:\n                        visited[nr, nc] = True\n                        stack.append((nr, nc))\n            if not touches_border and area > 0:\n                holes.append((area, sum_c/area))\n    if len(holes) >= 2:\n        # choose mid-column between two largest holes\n        holes.sort(reverse=True, key=lambda x: x[0])\n        x1 = holes[0][1]\n        x2 = holes[1][1]\n        center_col = int(round((x1 + x2) / 2.0))\n    elif len(holes) == 1:\n        center_col = int(round(holes[0][1]))\n    else:\n        center_col = w // 2\n    half_width = max(1, w // 100, 1)  # small band\n    c0 = max(0, center_col - half_width)\n    c1 = min(w, center_col + half_width + 1)\n    band = ink[:, c0:c1]\n    density = float(np.count_nonzero(band)) / float(band.size) if band.size > 0 else 0.0\n    return float(density)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal gradient energy (sum|dI/dy| / (sum|dI/dx| + eps))'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    vert_energy = np.sum(np.abs(gy))\n    horz_energy = np.sum(np.abs(gx))\n    return float(vert_energy / (horz_energy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink intensity (binary) in the central horizontal band to total ink (higher = strong middle stroke)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = gray.mean()\n    ink = (gray < thr).astype(np.uint8)\n    a = h // 3\n    b = (2 * h) // 3\n    center_band = ink[a:b, :]\n    total_ink = float(np.count_nonzero(ink))\n    if total_ink == 0.0:\n        return 0.0\n    center_ink = float(np.count_nonzero(center_band))\n    return center_ink / total_ink\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of long horizontal runs in the top third of the image (number of continuous ink segments wider than 40% of width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    top = ink[:max(1, h//3), :]\n    minlen = max(1, int(0.4 * w))\n    count = 0\n    for r in range(top.shape[0]):\n        row = top[r, :].astype(int)\n        # find run lengths\n        diffs = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        count += int(np.sum(lengths >= minlen))\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in top-right quadrant to bottom-left quadrant (helps detect 7-like top-right strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = (gray < thresh) if meanv > minv else (gray > thresh)\n    tr = np.sum(ink[0:h//2, w//2:w])\n    bl = np.sum(ink[h//2:h, 0:w//2])\n    return float((tr + 1e-6) / (bl + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in bottom-left quarter to bottom-right quarter (left/right), normalized with eps'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # binarize adaptively\n    thr = np.mean(gray) * 0.9 + np.min(gray) * 0.1\n    ink = (gray < thr).astype(float)  # assume darker ink has smaller values\n    bl = ink[(3*h)//4:h, 0:w//2].sum()\n    br = ink[(3*h)//4:h, w//2:w].sum()\n    eps = 1e-6\n    return float((bl + eps) / (br + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of ink in the bottom-left quadrant (normalized by quadrant area) - distinguishes bottom-left empty 7 from looped 3'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    meanv = gray.mean()\n    stdv = gray.std() if gray.std() > 1e-9 else 1.0\n    fg = (np.abs(gray - meanv) > 0.5 * stdv)\n    bl = fg[h//2:, :w//2]\n    denom = bl.size if bl.size else 1\n    return float(bl.sum() / float(denom))\n",
    "def feature(image: np.ndarray) -> float:\n    'Signed x-offset of the centroid of ink in the top third (normalized to [-0.5,0.5]); positive means centroid is to the right (useful to separate right-skewed 7)'\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    thr = (np.nanmin(gray) + np.nanmax(gray)) / 2.0\n    dark_count = np.count_nonzero(gray < thr)\n    ink = (gray < thr) if dark_count < gray.size / 2 else (gray > thr)\n    top_rows = max(1, h // 3)\n    top = ink[:top_rows, :]\n    ys, xs = np.nonzero(top)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(xs.mean()) / float(max(1, w))\n    # center is at 0.5, return signed offset in [-0.5,0.5]\n    return centroid_x - 0.5\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink above vs below the main diagonal (positive => more above)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    dark_count = np.count_nonzero(gray < thresh)\n    bright_count = np.count_nonzero(gray > thresh)\n    ink = (gray < thresh) if dark_count < bright_count else (gray > thresh)\n    rows = np.arange(h)[:, None]\n    cols = np.arange(w)[None, :]\n    # Above main diagonal: col > row*(w/h) approximate diagonal mapping if non-square\n    # Map row index to corresponding column index along diagonal scaled by aspect ratio\n    diag_cols = (cols.shape[1] - 1) * (rows / max(1, h - 1))\n    above = cols > diag_cols\n    below = cols < diag_cols\n    ink_above = np.count_nonzero(np.logical_and(ink, above))\n    ink_below = np.count_nonzero(np.logical_and(ink, below))\n    total = ink_above + ink_below\n    if total == 0:\n        return 0.0\n    return float((ink_above - ink_below) / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized number of binary transitions along the anti-diagonal (top-right to bottom-left)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.asarray(image, dtype=float)\n    h, w = arr.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    thresh = np.mean(gray)\n    band = (gray < thresh).astype(np.uint8)\n    if np.count_nonzero(band) == 0:\n        band = (gray > thresh).astype(np.uint8)\n    # sample along anti-diagonal from top-right to bottom-left\n    L = max(h, w)\n    transitions = 0\n    prev = None\n    for k in range(L):\n        # map k to a point on anti-diagonal: row = int(k * h / L), col = w-1 - int(k * w / L)\n        r = int(round(k * (h - 1) / max(1, L - 1)))\n        c = int(round((w - 1) - k * (w - 1) / max(1, L - 1)))\n        r = min(max(r, 0), h - 1)\n        c = min(max(c, 0), w - 1)\n        val = int(band[r, c])\n        if prev is None:\n            prev = val\n        else:\n            if val != prev:\n                transitions += 1\n            prev = val\n    return float(transitions) / float(max(1, L))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (vertical_vs_horizontal_stroke_strength)'\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    # gradients: gy along rows (vertical), gx along cols (horizontal)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gy))\n    horiz_energy = np.sum(np.abs(gx))\n    # avoid division by zero\n    if horiz_energy <= 1e-8:\n        return float(vert_energy)\n    return float(vert_energy / horiz_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of gradient magnitude oriented near-vertical (proportion of gradient vectors whose absolute angle from vertical < 15 degrees)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    # orientation relative to vertical: angle = arctan2(|dx|, |dy|)\n    # if dx small relative to dy -> near vertical edge\n    ang = np.arctan2(np.abs(gx), np.abs(gy) + 1e-9)  # 0 => vertical, pi/2 => horizontal\n    # count where angle < 15 degrees in radians\n    thresh = np.deg2rad(15)\n    strong_mask = (ang < thresh) & (np.hypot(gx, gy) > (np.percentile(np.hypot(gx, gy), 50) * 0.1 + 1e-9))\n    frac = float(np.count_nonzero(strong_mask)) / float(gx.size)\n    return float(frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative edge energy in a narrow horizontal band around the image center vs whole image (8 often has stronger edges at the waist)'\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 1:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gy * gy + gx * gx)\n    whole_mean = float(np.mean(grad_mag))\n    band_h = max(1, h // 10)\n    center = h // 2\n    band = grad_mag[max(0, center - band_h):min(h, center + band_h), :]\n    band_mean = float(np.mean(band))\n    if whole_mean <= 0:\n        return float(band_mean)\n    return float(band_mean / whole_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized row index of the densest horizontal slice (0 at top, 1 at bottom) \u2014 7 tends to have a very high-density row near top'\n    if image is None:\n        return 0.0\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    fg = (gray < thresh).astype(np.uint8)\n    if fg.sum() > 0.6 * fg.size:\n        fg = (gray > thresh).astype(np.uint8)\n    row_counts = fg.sum(axis=1)\n    if row_counts.max() == 0:\n        return 0.0\n    densest_row = int(np.argmax(row_counts))\n    return float(densest_row / max(1.0, h - 1))\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of positive Harris-like cornerness responses normalized by image area (more corners => larger)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    # gradients\n    gy, gx = np.gradient(gray)\n    Ixx = gx * gx\n    Iyy = gy * gy\n    Ixy = gx * gy\n    # local 3x3 sums via shifts\n    pad = lambda arr: np.pad(arr, ((1, 1), (1, 1)), mode='constant', constant_values=0.0)\n    Pxx = np.zeros_like(Ixx)\n    Pyy = np.zeros_like(Iyy)\n    Pxy = np.zeros_like(Ixy)\n    arrs_xx = pad(Ixx); arrs_yy = pad(Iyy); arrs_xy = pad(Ixy)\n    for dy in (-1, 0, 1):\n        for dx in (-1, 0, 1):\n            Pxx += arrs_xx[1+dy:1+dy+h, 1+dx:1+dx+w]\n            Pyy += arrs_yy[1+dy:1+dy+h, 1+dx:1+dx+w]\n            Pxy += arrs_xy[1+dy:1+dy+h, 1+dx:1+dx+w]\n    # Harris response\n    k = 0.04\n    R = (Pxx * Pyy - Pxy * Pxy) - k * (Pxx + Pyy) ** 2\n    Rpos = np.sum(R[R > 0])\n    return float(Rpos / (h * w + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-left ink density: ink fraction contained in the upper-left quadrant'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        thr = np.percentile(gray, 85)\n        ink = (gray < thr).astype(np.uint8)\n        total = float(np.sum(ink))\n        if total <= 0:\n            return 0.0\n        ul = float(np.sum(ink[:h//2, :w//2]))\n        return ul / (total + 1e-12)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of ink mass located in the top-right quadrant (helps detect digits with right-side strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 1.1:\n        gray = gray / mx\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[:3, :].ravel(), gray[-3:, :].ravel(), gray[:, :3].ravel(), gray[:, -3:].ravel()]) if h>=3 and w>=3 else gray.ravel()\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    border_mean = float(border.mean()) if border.size else 0.0\n    thresh = float(np.percentile(gray, 50)) if gray.size else 0.5\n    ink = (gray < thresh) if border_mean > (center.mean() if center.size else 0.0) else (gray > thresh)\n    ink = ink.astype(np.float64)\n    if ink.sum() <= 1e-9:\n        return 0.0\n    top = slice(0, h//2)\n    right = slice(w//2, w)\n    top_right = ink[top, right].sum()\n    return float(top_right / (ink.sum() + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top horizontal stroke strength: difference between top-row ink density and center density'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    top_h = max(1, h // 8)\n    top_density = np.mean(fg[:top_h, :]) if top_h > 0 else 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center_density = np.mean(fg[h//2 - ch//2:h//2 + ch//2, w//2 - cw//2:w//2 + cw//2])\n    return float(top_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative top-quarter left vs right ink density: (right - left) / (total in top quarter)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n    mask_dark = gray <= p40\n    mask_bright = gray >= p60\n    mask = mask_dark if mask_dark.sum() < mask_bright.sum() else mask_bright\n    top = slice(0, max(1, h//4))\n    left_count = mask[top, :w//2].sum()\n    right_count = mask[top, w//2:].sum()\n    total = left_count + right_count\n    if total == 0:\n        return 0.0\n    return float((right_count - left_count) / (total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in the top third vs bottom third (top_third / (bottom_third+eps)); 5s often have heavier bottom third'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 1.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(int)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(int)\n    t = max(1, h // 3)\n    top = np.sum(ink[:t, :])\n    bottom = np.sum(ink[-t:, :])\n    return float(top) / (float(bottom) + 1e-6)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimate of number of enclosed background components (holes) inside the ink strokes'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    bg = ~ink\n    # mark background reachable from borders\n    visited = np.zeros_like(bg, dtype=bool)\n    stack = []\n    # push border background pixels\n    for x in range(w):\n        if bg[0, x]:\n            stack.append((0, x))\n        if bg[h-1, x]:\n            stack.append((h-1, x))\n    for y in range(h):\n        if bg[y, 0]:\n            stack.append((y, 0))\n        if bg[y, w-1]:\n            stack.append((y, w-1))\n    while stack:\n        y, x = stack.pop()\n        if visited[y, x]:\n            continue\n        visited[y, x] = True\n        # 4-neighbors\n        if y > 0 and bg[y-1, x] and not visited[y-1, x]:\n            stack.append((y-1, x))\n        if y+1 < h and bg[y+1, x] and not visited[y+1, x]:\n            stack.append((y+1, x))\n        if x > 0 and bg[y, x-1] and not visited[y, x-1]:\n            stack.append((y, x-1))\n        if x+1 < w and bg[y, x+1] and not visited[y, x+1]:\n            stack.append((y, x+1))\n    # Remaining background pixels that are not visited are enclosed -> find their connected components\n    enclosed = (bg & (~visited))\n    holes = 0\n    seen = np.zeros_like(enclosed, dtype=bool)\n    for y in range(h):\n        for x in range(w):\n            if enclosed[y, x] and not seen[y, x]:\n                # flood fill this hole\n                holes += 1\n                stack = [(y, x)]\n                while stack:\n                    yy, xx = stack.pop()\n                    if seen[yy, xx]:\n                        continue\n                    seen[yy, xx] = True\n                    if yy > 0 and enclosed[yy-1, xx] and not seen[yy-1, xx]:\n                        stack.append((yy-1, xx))\n                    if yy+1 < h and enclosed[yy+1, xx] and not seen[yy+1, xx]:\n                        stack.append((yy+1, xx))\n                    if xx > 0 and enclosed[yy, xx-1] and not seen[yy, xx-1]:\n                        stack.append((yy, xx-1))\n                    if xx+1 < w and enclosed[yy, xx+1] and not seen[yy, xx+1]:\n                        stack.append((yy, xx+1))\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a horizontal stroke across the middle third band (detects middle bar typical of 5)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray)\n    ink = (gray < thr)\n    top = h // 3\n    bottom = min(h, 2 * (h // 3) + (h % 3 > 0))\n    mid_band = ink[top:bottom, :]\n    if mid_band.size == 0:\n        return 0.0\n    # a column is counted if there is continuous ink across at least half of the vertical span of mid_band\n    vertical_span = mid_band.shape[0]\n    if vertical_span == 0:\n        return 0.0\n    counts_per_col = np.sum(mid_band, axis=0)\n    strong_cols = counts_per_col >= (vertical_span * 0.4)  # threshold\n    frac = float(np.count_nonzero(strong_cols)) / float(w)\n    return frac\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical stroke strength: mean absolute vertical gradient in right third divided by left third'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    right = slice(max(0, w - w // 3), w)\n    left = slice(0, max(1, w // 3))\n    right_strength = np.mean(np.abs(gy[:, right])) if np.size(gy[:, right]) > 0 else 0.0\n    left_strength = np.mean(np.abs(gy[:, left])) if np.size(gy[:, left]) > 0 else 0.0\n    if left_strength == 0:\n        return float(right_strength)\n    return float(right_strength / (left_strength + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shape eccentricity from second moments: 1 - (minor_axis / major_axis) (0=circle, ~1=elongated)'\n    import numpy as np\n    eps = 1e-9\n    if image is None:\n        return 0.0\n    arr = np.array(image)\n    if arr.size == 0:\n        return 0.0\n    gray = np.mean(arr, axis=2) if arr.ndim == 3 else arr.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    norm = (gray - mn) / (mx - mn + eps)\n    ink = (norm < 0.5).astype(np.float64)\n    ys, xs = np.nonzero(ink)\n    if ys.size < 3:\n        return 0.0\n    cy, cx = float(np.mean(ys)), float(np.mean(xs))\n    yc = ys - cy\n    xc = xs - cx\n    # covariance matrix of coordinates (weighted equally)\n    cov_xx = float(np.mean(xc * xc))\n    cov_yy = float(np.mean(yc * yc))\n    cov_xy = float(np.mean(xc * yc))\n    trace = cov_xx + cov_yy\n    det = cov_xx * cov_yy - cov_xy * cov_xy\n    # eigenvalues of 2x2 covariance matrix\n    disc = max(trace * trace / 4.0 - det, 0.0)\n    l1 = trace / 2.0 + np.sqrt(disc)\n    l2 = trace / 2.0 - np.sqrt(disc)\n    # ensure ordering\n    major = max(l1, l2)\n    minor = min(l1, l2)\n    if major < eps:\n        return 0.0\n    ecc = 1.0 - (minor + eps) / (major + eps)\n    return float(np.clip(ecc, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top-most ink row (min_row / height), lower values mean ink starts near top'\n    import numpy as np\n    if image is None:\n        return 1.0\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    if h == 0:\n        return 1.0\n    m = np.mean(gray)\n    dark_count = np.sum(gray < m)\n    bright_count = gray.size - dark_count\n    ink = (gray < m) if dark_count <= bright_count else (gray > m)\n    ys, _ = np.nonzero(ink)\n    if ys.size == 0:\n        return 1.0\n    minr = ys.min()\n    return float(minr) / float(max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of binary transitions along the image center row and center column normalized by perimeter'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr)\n    else:\n        ink = (gray > thr)\n    cr = h // 2\n    cc = w // 2\n    row = ink[cr, :]\n    col = ink[:, cc]\n    row_trans = float(np.sum(row[:-1] != row[1:]))\n    col_trans = float(np.sum(col[:-1] != col[1:]))\n    norm = float(w + h)\n    return float((row_trans + col_trans) / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in top-right quadrant to ink in top-left quadrant (large values indicate right-top heavy shapes like a 9 loop)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(gray.min()), float(gray.max())\n    grayn = (gray - mn) / (mx - mn + 1e-9)\n    ink = (grayn < 0.5)\n    top = slice(0, h//2)\n    left = slice(0, w//2)\n    right = slice(w//2, w)\n    top_right = np.count_nonzero(ink[top, right])\n    top_left = np.count_nonzero(ink[top, left])\n    return float(top_right) / (float(top_left) + 1e-6)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Eccentricity (0..1) of the largest enclosed hole: 0 for circle, closer to 1 for elongated; 0 if none'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy().astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = (np.min(gray) + np.max(gray)) / 2.0\n    ink = gray < thresh\n    background = ~ink\n    visited = np.zeros_like(background, dtype=bool)\n    best_e = 0.0\n    for r in range(h):\n        for c in range(w):\n            if background[r, c] and not visited[r, c]:\n                stack = [(r, c)]\n                comp = []\n                touches_border = False\n                visited[r, c] = True\n                while stack:\n                    y, x = stack.pop()\n                    comp.append((y, x))\n                    if y == 0 or y == h-1 or x == 0 or x == w-1:\n                        touches_border = True\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ny, nx = y+dy, x+dx\n                        if 0 <= ny < h and 0 <= nx < w and background[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n                if not touches_border and len(comp) >= 5:\n                    comp = np.array(comp, dtype=float)\n                    cy = comp[:,0].mean()\n                    cx = comp[:,1].mean()\n                    coords = comp - np.array([[cy, cx]])\n                    cov = np.dot(coords.T, coords) / coords.shape[0]\n                    # eigenvalues\n                    tr = cov[0,0] + cov[1,1]\n                    det = cov[0,0]*cov[1,1] - cov[0,1]*cov[1,0]\n                    # numerical robust eigenvalues\n                    disc = max(0.0, tr*tr/4.0 - det)\n                    l1 = tr/2.0 + np.sqrt(disc)\n                    l2 = tr/2.0 - np.sqrt(disc)\n                    if l1 > 1e-8:\n                        e = np.sqrt(max(0.0, 1.0 - max(0.0, l2)/max(1e-12, l1)))\n                        if e > best_e:\n                            best_e = e\n    return float(best_e)\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the ink (width / height), 0 if no ink'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    # estimate background from border\n    bw = max(1, min(h, w) // 10)\n    border = np.concatenate([\n        gray[:bw, :].ravel(),\n        gray[-bw:, :].ravel(),\n        gray[:, :bw].ravel(),\n        gray[:, -bw:].ravel()\n    ])\n    bg_mean = np.mean(border) if border.size else np.mean(gray)\n    bg_min = np.min(border) if border.size else np.min(gray)\n    thr = bg_mean - 0.25 * (bg_mean - bg_min + 1e-9)\n    mask = gray < thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray < np.percentile(gray, 50)\n    inds = np.argwhere(mask)\n    if inds.size == 0:\n        return 0.0\n    rows, cols = inds[:,0], inds[:,1]\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    bw_box = float(maxc - minc + 1)\n    bh_box = float(maxr - minr + 1)\n    if bh_box == 0:\n        return 0.0\n    return float(bw_box / bh_box)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of the largest hole centroid from image center normalized by width (positive -> hole to the right)'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray > thr  # True = ink, False = background\n    background = ~ink\n    # Flood fill external background starting from borders\n    seen = np.zeros_like(background, dtype=bool)\n    dq = deque()\n    # push all border background pixels\n    for x in range(w):\n        if background[0, x]:\n            dq.append((0, x)); seen[0, x] = True\n        if background[h - 1, x]:\n            dq.append((h - 1, x)); seen[h - 1, x] = True\n    for y in range(h):\n        if background[y, 0] and not seen[y, 0]:\n            dq.append((y, 0)); seen[y, 0] = True\n        if background[y, w - 1] and not seen[y, w - 1]:\n            dq.append((y, w - 1)); seen[y, w - 1] = True\n    while dq:\n        y, x = dq.popleft()\n        # 4-neighbors\n        if y > 0 and background[y - 1, x] and not seen[y - 1, x]:\n            seen[y - 1, x] = True; dq.append((y - 1, x))\n        if y < h - 1 and background[y + 1, x] and not seen[y + 1, x]:\n            seen[y + 1, x] = True; dq.append((y + 1, x))\n        if x > 0 and background[y, x - 1] and not seen[y, x - 1]:\n            seen[y, x - 1] = True; dq.append((y, x - 1))\n        if x < w - 1 and background[y, x + 1] and not seen[y, x + 1]:\n            seen[y, x + 1] = True; dq.append((y, x + 1))\n    # Holes are background pixels not reached by external fill\n    holes = background & (~seen)\n    hole_count = np.count_nonzero(holes)\n    if hole_count == 0:\n        return 0.0\n    ys, xs = np.where(holes)\n    cx = np.mean(xs)\n    center_x = (w - 1) / 2.0\n    return float((cx - center_x) / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized row index (0..1) where the row-sum of ink is maximal (top=0, bottom=1)'\n    import numpy as np\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img.astype(float)\n    m = np.mean(gray)\n    dark_count = np.sum(gray < m)\n    ink = (gray < m) if dark_count <= (h * w / 2) else (gray > m)\n    rowsum = np.sum(ink.astype(float), axis=1)\n    if np.all(rowsum == 0):\n        return 0.0\n    ridx = int(np.argmax(rowsum))\n    return float(ridx / max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal vs anti-diagonal gradient energy: sum|gx+gy| / (sum|gx-gy| + eps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag = np.sum(np.abs(gx + gy))\n    antidiag = np.sum(np.abs(gx - gy))\n    eps = 1e-6\n    return float(diag / (antidiag + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Alignment of local gradients with the down-right / up-left diagonal direction (score 0..1)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy) + eps\n    # direction vector for (1, -1) diagonal normalized\n    ux, uy = 1.0 / np.sqrt(2.0), -1.0 / np.sqrt(2.0)\n    # projection of normalized gradient onto diagonal direction\n    proj = (gx * ux + gy * uy) / mag\n    # weight by magnitude to focus on edges\n    score = np.mean(np.abs(proj))\n    # clamp 0..1\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom-right quadrant (useful to detect tails like 9)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    rng = np.max(gray) - np.min(gray)\n    thr = np.mean(gray) - 0.15 * (rng if rng > 0 else 1.0)\n    ink = gray < thr\n    if np.count_nonzero(ink) < 1:\n        ink = gray > thr\n    H, W = ink.shape\n    br = ink[H//2:, W//2:]\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    return float(np.count_nonzero(br)) / total\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of empty pixels in the central vertical band (center gap ratio)'\n    try:\n        h, w = image.shape[:2]\n    except Exception:\n        return 0.0\n    band_w = max(1, w // 8)\n    left = (w - band_w) // 2\n    right = left + band_w\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gm = gray.max()\n    norm = gray / float(gm) if gm != 0 else gray\n    thresh = np.mean(norm)\n    ink = (norm < thresh).astype(np.uint8)\n    if ink.sum() == 0:\n        ink = 1 - ink\n    band = ink[:, left:right]\n    gap_ratio = 1.0 - (band.sum() / float(band.size) if band.size > 0 else 0.0)\n    return float(gap_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Distance between centroid of largest internal hole (if any) and ink centroid, normalized by image diagonal; returns large value if no hole'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    fg = (gray < thresh)\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = (gray > thresh)\n    fg = fg.astype(bool)\n    eps = 1e-9\n    ink_coords = np.argwhere(fg)\n    if ink_coords.shape[0] == 0:\n        return float(max(h, w))\n    ink_centroid = ink_coords.mean(axis=0)\n    # find holes in background (components not touching border)\n    bg = ~fg\n    label = np.zeros_like(bg, dtype=np.int32)\n    cur = 0\n    best_hole_centroid = None\n    best_hole_area = 0\n    for r in range(h):\n        for c in range(w):\n            if bg[r, c] and label[r, c] == 0:\n                cur += 1\n                stack = [(r, c)]\n                label[r, c] = cur\n                pixels = []\n                touches_border = False\n                while stack:\n                    y, x = stack.pop()\n                    pixels.append((y, x))\n                    if y == 0 or x == 0 or y == h-1 or x == w-1:\n                        touches_border = True\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = y + dy, x + dx\n                            if 0 <= ny < h and 0 <= nx < w and bg[ny, nx] and label[ny, nx] == 0:\n                                label[ny, nx] = cur\n                                stack.append((ny, nx))\n                if not touches_border:\n                    area = len(pixels)\n                    if area > best_hole_area:\n                        best_hole_area = area\n                        best_hole_centroid = np.array(pixels).mean(axis=0)\n    if best_hole_centroid is None:\n        return float(max(h, w))\n    dist = np.linalg.norm(best_hole_centroid - ink_centroid)\n    diag = np.sqrt(float(h*h + w*w))\n    return float(dist) / (diag + eps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal orientation angle (radians) of ink pixels computed by PCA (range approx -pi/2..pi/2)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    t = (np.percentile(gray, 30) + np.percentile(gray, 70)) / 2.0\n    lower_mean = gray[gray <= t].mean() if np.any(gray <= t) else t\n    upper_mean = gray[gray > t].mean() if np.any(gray > t) else t\n    if lower_mean < upper_mean:\n        ink = (gray <= t)\n    else:\n        ink = (gray >= t)\n    coords = np.argwhere(ink)\n    if coords.shape[0] < 2:\n        return 0.0\n    # coords rows are (r, c) -> treat x = c, y = r\n    y = coords[:, 0].astype(float)\n    x = coords[:, 1].astype(float)\n    x = x - x.mean()\n    y = y - y.mean()\n    cov = np.array([[np.dot(x, x), np.dot(x, y)], [np.dot(y, x), np.dot(y, y)]]) / max(1.0, len(x) - 1)\n    eigvals, eigvecs = np.linalg.eigh(cov + 1e-12 * np.eye(2))\n    # principal eigenvector is last one\n    v = eigvecs[:, np.argmax(eigvals)]\n    angle = float(np.arctan2(v[1], v[0]))  # angle of principal axis\n    # normalize to [-pi/2, pi/2]\n    if angle > np.pi/2:\n        angle -= np.pi\n    if angle <= -np.pi/2:\n        angle += np.pi\n    return float(angle)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate circularity of ink regions: 4*pi*Area / (Perimeter^2); higher for round loops like 0'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    area = float(ink.sum())\n    if area == 0:\n        return 0.0\n    # approximate perimeter by gradient magnitude threshold\n    gy, gx = np.gradient(gray)\n    grad = np.hypot(gx, gy)\n    # emphasize edges by masking to ink boundaries: gradient on mean image masked by ink XOR eroded ink\n    padded = np.pad(ink.astype(np.uint8), 1, mode='constant', constant_values=0)\n    eroded = np.ones_like(ink, dtype=bool)\n    for dy, dx in [(-1,0),(1,0),(0,-1),(0,1)]:\n        eroded &= padded[1+dy:1+dy+h,1+dx:1+dx+w].astype(bool)\n    boundary = ink & (~eroded)\n    # perimeter approximation: count boundary pixels weighted by gradient\n    if np.any(boundary):\n        perim = float(boundary.sum())\n    else:\n        # fallback: use high-gradient pixels\n        thr = np.percentile(grad, 75) if grad.size > 0 else 0.0\n        perim = float(np.count_nonzero(grad > thr))\n    if perim <= 0.0:\n        return 0.0\n    circ = 4.0 * np.pi * area / (perim * perim + 1e-9)\n    return float(circ)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical foreground runs per column in the central third of the image'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 75))\n    mask = gray >= thr\n    if mask.sum() > 0.6 * (h * w):\n        mask = ~mask\n    mask = mask.astype(int)\n    c1 = w // 3\n    c2 = w - c1\n    if c2 <= c1:\n        cols = mask\n    else:\n        cols = mask[:, c1:c2]\n    # For each column count vertical runs of 1s\n    runs_per_col = []\n    for col in range(cols.shape[1]):\n        colarr = cols[:, col]\n        if colarr.size == 0:\n            runs_per_col.append(0)\n            continue\n        # transitions from 0->1 indicate start of run\n        starts = np.sum((colarr == 1) & (np.pad(colarr, (1, 0), mode='constant')[:-1] == 0))\n        runs_per_col.append(int(starts))\n    # return average runs per column\n    return float(np.mean(runs_per_col))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry score: average absolute column difference between left and flipped right'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    # compare left half to flipped right half\n    mid = w // 2\n    left = norm[:, :mid]\n    right = norm[:, w - mid:]\n    right_flipped = right[:, ::-1]\n    # resize if they mismatch due to odd width\n    if left.shape[1] != right_flipped.shape[1]:\n        minc = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minc]\n        right_flipped = right_flipped[:, :minc]\n    score = np.mean(np.abs(left - right_flipped))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid of ink mass (0=left, 1=right)'\n    import numpy as np\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # simple threshold between min and mean to find ink (robust for dark-on-light)\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = gray < thresh if meanv > minv else gray > thresh\n    ys, xs = np.nonzero(ink)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs)) / float(w)\n    return float(cx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-region mean intensity minus global mean (positive when center is lighter -> possible loop/hole)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    global_mean = float(np.mean(gray))\n    ch0, cw0 = max(1, h // 6), max(1, w // 6)\n    cy0, cx0 = h // 2 - ch0, w // 2 - cw0\n    cy1, cx1 = h // 2 + ch0 + 1, w // 2 + cw0 + 1\n    cy0, cx0 = max(0, cy0), max(0, cx0)\n    cy1, cx1 = min(h, cy1), min(w, cx1)\n    center = gray[cy0:cy1, cx0:cx1]\n    if center.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    return float(center_mean - global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance of distances of ink pixels to image center (low when ink concentrated centrally)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh)\n    ys, xs = np.nonzero(ink)\n    if ys.size == 0:\n        return 0.0\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    dy = ys.astype(float) - cy\n    dx = xs.astype(float) - cx\n    d2 = dx*dx + dy*dy\n    var = np.var(d2)\n    # normalize by maximum possible squared distance (corner)\n    maxd2 = ((cx)**2 + (cy)**2)\n    if maxd2 <= 0:\n        return float(var)\n    return float(var / maxd2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous horizontal ink run length in the central third rows (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    # robust binarization using border heuristic\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = np.mean(border) if border.size else np.mean(gray)\n    if border_mean > np.mean(gray):\n        thresh = np.percentile(gray, 40)\n        ink = gray < thresh\n    else:\n        thresh = np.percentile(gray, 60)\n        ink = gray > thresh\n    # central third rows and full width\n    r0, r1 = h // 3, (2 * h) // 3\n    center_region = ink[r0:r1, :]\n    if center_region.size == 0:\n        return 0.0\n    max_run = 0\n    # compute longest contiguous True in each center row\n    for row in center_region:\n        # find runs\n        # pad to handle edges\n        padded = np.concatenate([[0], row.astype(int), [0]])\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, int(np.max(runs)))\n    return float(max_run / max(1, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized vertical symmetry score: average absolute column difference between left and flipped right'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    # compare left half to flipped right half\n    mid = w // 2\n    left = norm[:, :mid]\n    right = norm[:, w - mid:]\n    right_flipped = right[:, ::-1]\n    # resize if they mismatch due to odd width\n    if left.shape[1] != right_flipped.shape[1]:\n        minc = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minc]\n        right_flipped = right_flipped[:, :minc]\n    score = np.mean(np.abs(left - right_flipped))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical gradient magnitude in the central horizontal band (detects middle bars like in 5)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3:\n        return 0.0\n    gx, gy = np.gradient(gray)\n    band_top = max(0, h//2 - h//8)\n    band_bottom = min(h, h//2 + h//8)\n    band = gy[band_top:band_bottom, :]\n    return float(np.mean(np.abs(band)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance of radial distances of ink pixels from their centroid (lower = more circular/central symmetry).'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    ink = (gray < thresh)\n    ys, xs = np.nonzero(ink)\n    if ys.size == 0:\n        return 0.0\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    d2 = (ys - cy)**2 + (xs - cx)**2\n    var = float(np.var(np.sqrt(d2)))\n    # normalize by maximum possible radius (~ diagonal)\n    maxr = np.sqrt((h-1)**2 + (w-1)**2)\n    return float(var / (maxr + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal gradient energy (sum of abs differences along the two diagonal directions, normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute diagonal differences\n    d1 = np.abs(gray[1:, 1:] - gray[:-1, :-1])  # NW-SE\n    d2 = np.abs(gray[1:, :-1] - gray[:-1, 1:])  # NE-SW\n    e1 = np.sum(d1)\n    e2 = np.sum(d2)\n    total = e1 + e2 + 1e-9\n    # return normalized difference (signed): positive means more NW-SE energy\n    return float((e1 - e2) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous horizontal ink run in the top third normalized by image width (0..1)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p30, p70 = np.percentile(gray, 30), np.percentile(gray, 70)\n    dark_mask = gray < p30\n    light_mask = gray > p70\n    ink = dark_mask if dark_mask.sum() >= light_mask.sum() else light_mask\n    h, w = ink.shape\n    top = ink[:max(1, h//3), :]\n    if top.size == 0 or top.sum() == 0:\n        return 0.0\n    max_run = 0\n    # compute runs per row\n    for row in top:\n        # convert bool row to int and find max consecutive ones\n        r = row.astype(np.uint8)\n        # find edges\n        if r.sum() == 0:\n            continue\n        # run-length via diff\n        diff = np.diff(np.concatenate(([0], r, [0])))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, runs.max())\n    return float(max_run / float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal (main) symmetry score: mean absolute difference between center square and its transpose (0=perfect)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    s = min(h, w)\n    if s == 0:\n        return 0.0\n    r0 = (h - s) // 2\n    c0 = (w - s) // 2\n    square = gray[r0:r0+s, c0:c0+s]\n    # normalize by dynamic range\n    rng = float(np.max(square) - np.min(square))\n    if rng == 0:\n        return 0.0\n    diff = np.abs(square - square.T)\n    score = float(np.mean(diff) / rng)\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy (around \u00b145\u00b0) to total gradient energy - detects strong diagonal strokes like in 7'\n    # Robust grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    theta = np.arctan2(gy, gx)  # [-pi, pi]\n    # Mask for orientations near +45deg or -45deg (\u00b122.5\u00b0)\n    band = np.pi / 8.0\n    mask = (np.abs(theta - (np.pi/4)) <= band) | (np.abs(theta + (np.pi/4)) <= band)\n    diag_energy = np.sum(mag * mask)\n    total_energy = np.sum(mag)\n    eps = 1e-8\n    return float(diag_energy / (total_energy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of vertical gradient energy that lies in the right half (captures vertical components concentrated on the right as in 3)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gx, gy = np.gradient(gray)\n    vert_energy = np.abs(gy)\n    total_energy = np.sum(vert_energy) + 1e-8\n    right_energy = np.sum(vert_energy[:, w//2:])\n    return float(right_energy) / float(total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels in the upper-right quadrant (helps detect 7 which often has ink in top-right)'\n    try:\n        import numpy as np\n        # grayscale conversion\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        if gray.size == 0:\n            return 0.0\n        # normalize to ~0-1\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        # estimate background polarity from corners\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        # region: upper-right quadrant\n        ur = fg[:h//2, w//2:]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(ur) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude on the right half minus left half (positive if right half has stronger edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    left_mag = np.mean(mag[:, :w//2]) if w//2 > 0 else 0.0\n    right_mag = np.mean(mag[:, w//2:]) if w - w//2 > 0 else 0.0\n    return float(right_mag - left_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient (vertical strokes produce higher horizontal gradient)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mean_abs_gx = float(np.mean(np.abs(gx)))\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    return float((mean_abs_gx + 1e-9) / (mean_abs_gy + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-right vs upper-right ink density ratio (helps detect lower loop on right side)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    mid_col = w // 2\n    mid_row = h // 2\n    upper_right = fg[:mid_row, mid_col:]\n    lower_right = fg[mid_row:, mid_col:]\n    ur = float(np.count_nonzero(upper_right))\n    lr = float(np.count_nonzero(lower_right))\n    denom = ur + 1e-6\n    return float(lr / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink/background transitions per row (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv = float(np.min(gray))\n    meanv = float(np.mean(gray))\n    if meanv == minv:\n        return 0.0\n    thresh = (minv + meanv) / 2.0\n    ink = ((gray < thresh) if meanv > minv else (gray > thresh)).astype(int)\n    # transitions per row equals number of 0<->1 changes\n    row_trans = np.sum(np.abs(np.diff(ink, axis=1)), axis=1)\n    # normalize by width to get fraction per row\n    avg_trans_per_row = float(np.mean(row_trans) / max(1.0, w))\n    return avg_trans_per_row\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference of radial spread between lower-half and upper-half foreground pixels normalized by overall radial std'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    ys, xs = np.where(fg)\n    if xs.size == 0:\n        return 0.0\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    upper_mask = ys < cy\n    lower_mask = ~upper_mask\n    if np.count_nonzero(upper_mask) < 2 or np.count_nonzero(lower_mask) < 2:\n        return 0.0\n    upper_std = float(np.std(dists[upper_mask]))\n    lower_std = float(np.std(dists[lower_mask]))\n    overall_std = float(np.std(dists)) + 1e-6\n    return float((lower_std - upper_std) / overall_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area proxy (circularity): (perimeter^2) / area -- higher for complex / loop-rich shapes'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = ((gray <= thr) if ink_dark else (gray >= thr)).astype(np.float64)\n    area = fg.sum()\n    if area < 1e-6:\n        return 0.0\n    gy, gx = np.gradient(fg)\n    perimeter_est = np.sum(np.abs(gy)) + np.sum(np.abs(gx))\n    circ = (perimeter_est * perimeter_est) / (area + 1e-6)\n    return float(circ)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in top-right quadrant to bottom-left quadrant (helps find top-right loops)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 1.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    tr = ink[:h//2, w//2:]\n    bl = ink[h//2:, :w//2]\n    tr_density = float(np.count_nonzero(tr)) / max(1, tr.size)\n    bl_density = float(np.count_nonzero(bl)) / max(1, bl.size)\n    return float((tr_density + 1e-9) / (bl_density + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink density in right third to left third (helps detect 4 which often has heavier right-side vertical stroke)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        flat = gray.flatten()\n        t1 = np.percentile(flat, 30)\n        t2 = np.percentile(flat, 70)\n        cand1 = gray < t1\n        cand2 = gray > t2\n        total = h * w\n        if 0 < cand1.sum() <= total // 2:\n            ink = cand1\n        elif 0 < cand2.sum() <= total // 2:\n            ink = cand2\n        else:\n            med = np.median(flat)\n            ink = gray < med\n        left = ink[:, :max(1, w // 3)].sum()\n        right = ink[:, max(1, 2 * w // 3):].sum()\n        return float(right / (left + 1e-12))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset of ink relative to image center (negative means top, positive means bottom)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        coords = np.argwhere(ink)\n        if coords.size == 0:\n            return 0.0\n        y_mean = coords[:, 0].mean()\n        h = ink.shape[0]\n        return float((y_mean / max(1.0, h)) - 0.5)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Radial spread of ink: standard deviation of distances of ink pixels to ink centroid normalized by image diagonal (lower for ring-like shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    ys, xs = np.nonzero(ink)\n    if xs.size <= 1:\n        return 0.0\n    cx = xs.mean()\n    cy = ys.mean()\n    d = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = d.std()\n    diag = np.sqrt(h * h + w * w)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-right quadrant ink fraction (top-right density) normalized by total ink'\n    import numpy as np\n    img = np.asarray(image)\n    h, w = img.shape[:2]\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img.astype(float)\n    med = np.median(gray)\n    prop = float(np.mean(gray < med))\n    thr = np.percentile(gray, 20) if prop > 0.5 else med\n    bw = (gray < thr).astype(np.uint8)\n    if bw.sum() == 0:\n        bw = (gray > thr).astype(np.uint8)\n    top = slice(0, max(1, h//3))\n    right = slice((2*w)//3, w)\n    ur = bw[top, right].sum()\n    total = max(1.0, bw.sum())\n    return float(ur / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical gradient energy in the right third (indicates strong vertical strokes on right side)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy = np.abs(np.gradient(gray, axis=0))\n    total = gy.sum() + 1e-9\n    right = gy[:, max(0, w - w//3):].sum()\n    return float(right / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of horizontal ink runs per row (transitions 0->1) normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    mid = (p10 + p90) / 2.0\n    mask_hi = gray > mid\n    mask_lo = gray < mid\n    ink = (mask_hi if np.count_nonzero(mask_hi) < np.count_nonzero(mask_lo) else mask_lo).astype(np.uint8)\n    if w == 0:\n        return 0.0\n    # count 0->1 transitions across each row\n    padded = np.pad(ink, ((0, 0), (1, 0)), mode='constant', constant_values=0)\n    transitions = (padded[:, 1:] > padded[:, :-1]) & (padded[:, 1:] == 1)\n    runs_per_row = np.sum(transitions, axis=1)\n    mean_runs = np.mean(runs_per_row) if runs_per_row.size else 0.0\n    return float(mean_runs / max(1.0, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy (|gx*gy|) concentrated in anti-diagonal (gx*gy < 0) to total diagonal energy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag_energy = np.abs(gx * gy)\n    if np.sum(diag_energy) == 0:\n        return 0.0\n    anti_diag_energy = np.sum(diag_energy[gx * gy < 0])\n    return float(anti_diag_energy / (np.sum(diag_energy) + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of internal background pixels (holes) normalized by ink area using border flood fill'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    dark_mask = gray < thresh\n    ink = dark_mask if dark_mask.sum() <= (h * w) / 2 else ~dark_mask\n    bg = ~ink\n    # border-reachable background initialization\n    reachable = np.zeros_like(bg, dtype=bool)\n    reachable[0, :] = bg[0, :]\n    reachable[-1, :] = bg[-1, :]\n    reachable[:, 0] = reachable[:, 0] | bg[:, 0]\n    reachable[:, -1] = reachable[:, -1] | bg[:, -1]\n    # iterative expansion using 8-neighborhood until stable or iteration cap\n    pad = lambda arr: np.pad(arr, 1, mode='constant', constant_values=False)\n    hcap = h * w\n    for _ in range(min(1000, hcap)):\n        old = reachable.copy()\n        p = pad(reachable)\n        neigh = (\n            p[0:h, 0:w] | p[0:h, 1:w+1] | p[0:h, 2:w+2] |\n            p[1:h+1, 0:w] | p[1:h+1, 2:w+2] |\n            p[2:h+2, 0:w] | p[2:h+2, 1:w+1] | p[2:h+2, 2:w+2]\n        )\n        reachable = reachable | (bg & neigh)\n        if reachable.sum() == old.sum():\n            break\n    holes = bg & (~reachable)\n    hole_area = float(holes.sum())\n    ink_area = float(ink.sum())\n    if ink_area == 0:\n        return 0.0\n    return float(hole_area / (ink_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal edge energy in top third normalized by overall horizontal edge energy (detects top bars)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 2:\n        return 0.0\n    dx = np.abs(np.diff(gray, axis=1))\n    top_dx = dx[0:max(1, h//3), :]\n    total = dx.sum() + 1e-8\n    return float(top_dx.sum() / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal run length of ink in the top 20% of rows, normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n    dark = gray < p40\n    light = gray > p60\n    dcount = np.count_nonzero(dark)\n    lcount = np.count_nonzero(light)\n    if dcount == 0 and lcount == 0:\n        thr = np.mean(gray)\n        dark = gray < thr\n        dcount = np.count_nonzero(dark)\n        if dcount == 0:\n            return 0.0\n    mask = dark if (0 < dcount <= max(lcount, 1)) else light\n    top_k = max(1, h // 5)\n    top_region = mask[:top_k, :]\n    max_run = 0\n    for r in range(top_region.shape[0]):\n        row = top_region[r, :].astype(int)\n        if row.sum() == 0:\n            continue\n        # compute runs by difference trick\n        padded = np.concatenate([[0], row, [0]])\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, runs.max())\n    return float(max_run / max(1, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-quarter horizontal edge strength: average absolute horizontal gradient magnitude in top 25% of image'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = gray[:top_h, :]\n    # horizontal gradient: difference along columns\n    horiz_grad = np.abs(np.diff(top_region, axis=1))\n    # average normalized by intensity range\n    denom = max(1.0, float(np.ptp(gray)))\n    score = float(horiz_grad.mean()) / denom\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-region mean intensity minus global mean (positive when center is lighter -> possible loop/hole)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    global_mean = float(np.mean(gray))\n    ch0, cw0 = max(1, h // 6), max(1, w // 6)\n    cy0, cx0 = h // 2 - ch0, w // 2 - cw0\n    cy1, cx1 = h // 2 + ch0 + 1, w // 2 + cw0 + 1\n    cy0, cx0 = max(0, cy0), max(0, cx0)\n    cy1, cx1 = min(h, cy1), min(w, cx1)\n    center = gray[cy0:cy1, cx0:cx1]\n    if center.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    return float(center_mean - global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of gradient (edge) energy in lower half to upper half (captures lower loops vs top strokes)'\n    if image is None:\n        return 0.0\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    top = grad[:h//2, :]\n    bot = grad[h//2:, :]\n    top_sum = float(np.sum(top))\n    bot_sum = float(np.sum(bot))\n    return float(bot_sum) / (top_sum + 1e-9)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of negative-slope diagonal gradient energy to positive-slope diagonal gradient energy (high for strokes sloping down-left like in many 7s)'\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # diag1 approximates gradient along top-right -> bottom-left (negative slope)\n    diag1 = gray[:-1, 1:] - gray[1:, :-1]\n    # diag2 approximates gradient along top-left -> bottom-right (positive slope)\n    diag2 = gray[:-1, :-1] - gray[1:, 1:]\n    e1 = float(np.sum(np.abs(diag1)))\n    e2 = float(np.sum(np.abs(diag2)))\n    eps = 1e-8\n    return e1 / (e2 + eps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong gradient pixels whose orientation lies between -70 and -20 degrees (targeting downward-left diagonals common in 7)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    maxmag = float(np.max(mag)) + 1e-12\n    # consider only reasonably strong gradients\n    strong = mag > (0.2 * maxmag)\n    # angle: arctan2(y, x), but we want negative gy to be \"down\" consistent with image coords\n    angles = np.arctan2(-gy, gx) * (180.0 / np.pi)  # degrees\n    mask = strong & (angles >= -70.0) & (angles <= -20.0)\n    denom = float(np.count_nonzero(strong)) + 1e-12\n    return float(np.count_nonzero(mask) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of distinct ink connected components (separate islands), useful to spot digits with multiple disconnected loops'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 50.0)\n    ink = gray < thr\n    if np.mean(ink) > 0.6:\n        ink = gray > thr\n    if np.mean(ink) < 0.01:\n        thr = np.mean(gray)\n        ink = gray < thr\n    visited = np.zeros((h, w), dtype=bool)\n    from collections import deque\n    q = deque()\n    islands = 0\n    for i in range(h):\n        for j in range(w):\n            if ink[i, j] and not visited[i, j]:\n                islands += 1\n                visited[i, j] = True\n                q.append((i, j))\n                while q:\n                    x, y = q.popleft()\n                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < h and 0 <= ny < w and ink[nx, ny] and not visited[nx, ny]:\n                            visited[nx, ny] = True\n                            q.append((nx, ny))\n    return float(islands)\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical-strip left-right L1 symmetry score (lower = more symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    if arr.size == 0:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    c0 = w // 3\n    c1 = w - c0\n    region = gray[:, c0:c1]\n    if region.size == 0:\n        return 0.0\n    # normalize region intensity\n    mn, mx = float(np.min(region)), float(np.max(region))\n    if mx <= mn:\n        return 0.0\n    regn = (region - mn) / (mx - mn)\n    mid = regn.shape[1] // 2\n    left = regn[:, :mid]\n    right = regn[:, -mid:] if mid > 0 else regn[:, :mid]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally and compute mean absolute difference\n    right_flipped = np.flip(right, axis=1)\n    # if shapes mismatch due to odd width, crop to min width\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    diff = np.mean(np.abs(left - right_flipped))\n    # invert so higher -> more symmetric\n    return float(1.0 - diff)\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the largest ink component (height / width), returns 1.0 if no ink'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    thresh = np.mean(gray)\n    ink = gray < thresh\n    if np.mean(ink) > 0.75:\n        ink = ~ink\n    coords = np.column_stack(np.nonzero(ink))\n    if coords.size == 0:\n        return 1.0\n    minr = int(np.min(coords[:, 0])); maxr = int(np.max(coords[:, 0]))\n    minc = int(np.min(coords[:, 1])); maxc = int(np.max(coords[:, 1]))\n    bw = maxc - minc + 1\n    bh = maxr - minr + 1\n    if bw <= 0:\n        return 1.0\n    return float(bh / bw)\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-left vs top-right ink fraction in the top quarter: top_right / (top_left + top_right) (higher => top-right heavy)'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mn, mx = float(gray.min()), float(gray.max())\n    if mx == mn:\n        return 0.0\n    mid = 0.5 * (mn + mx)\n    if np.mean(gray) < mid:\n        ink = (gray < mid).astype(np.uint8)\n    else:\n        ink = (gray > mid).astype(np.uint8)\n    top_h = max(1, h // 4)\n    left_w = w // 2\n    tl = float(ink[:top_h, :left_w].sum())\n    tr = float(ink[:top_h, left_w:].sum())\n    tot = tl + tr\n    if tot < 1e-6:\n        return 0.0\n    return float(tr / tot)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background (empty) pixels in the bottom-center region (bottom 20% rows, center third columns); higher means open bottom'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = np.mean(border) if border.size else np.mean(gray)\n    thresh = (border_mean + np.mean(gray)) / 2.0\n    fg = gray < thresh if border_mean > np.mean(gray) else gray > thresh\n    bottom_start = int(h * 0.8)\n    left = w // 3\n    right = max(left + 1, 2 * w // 3)\n    region = fg[bottom_start:h, left:right]\n    region_size = region.size\n    if region_size == 0:\n        return 0.0\n    bg_fraction = 1.0 - (np.count_nonzero(region) / region_size)\n    return float(bg_fraction)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative ink density in the left-middle quadrant vs the whole left half (low for digits like 3 which avoid the left center)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=float)\n    if len(arr.shape) == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    denom = mx - mn if mx != mn else 1.0\n    ink = (((mx - gray) / denom) > 0.2).astype(np.float32)\n    top = h // 4\n    bottom = (3 * h) // 4\n    mid_left = ink[top:bottom, 0:w//2]\n    left_half = ink[:, 0:w//2]\n    area_mid = float(max(1, mid_left.size))\n    area_left = float(max(1, left_half.size))\n    density_mid = float(np.sum(mid_left) / area_mid)\n    density_left = float(np.sum(left_half) / area_left)\n    eps = 1e-8\n    return float(density_mid / (density_left + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Right-to-left ink density ratio (sum of ink on right half divided by left half, >1 means more ink on right)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    left_sum = float(np.count_nonzero(ink[:, :w//2]))\n    right_sum = float(np.count_nonzero(ink[:, w//2:]))\n    if left_sum + right_sum == 0:\n        return 1.0\n    ratio = right_sum / (left_sum + 1e-8)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative ink density in the top-left quadrant compared to overall density (helps detect top-left hooks or strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    meanv = np.mean(gray)\n    if np.std(gray) < 1e-6:\n        return 0.0\n    dark_count = np.sum(gray < meanv)\n    if dark_count <= (gray.size / 2):\n        ink = gray < meanv\n    else:\n        ink = gray > meanv\n    mid_h = max(1, h // 2)\n    mid_w = max(1, w // 2)\n    tl = ink[0:mid_h, 0:mid_w]\n    overall = ink\n    denom = np.sum(overall)\n    if denom == 0:\n        return 0.0\n    return float(np.sum(tl) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal edge strength difference between left and right in the top third (detects whether the top bar is centered or biased)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 3)\n    Gx, Gy = np.gradient(gray)\n    horiz_edge = np.abs(Gx)  # horizontal edges respond to horizontal intensity changes\n    left_energy = np.sum(horiz_edge[0:top_h, :w//2])\n    right_energy = np.sum(horiz_edge[0:top_h, w//2:])\n    denom = left_energy + right_energy + 1e-8\n    return float(right_energy - left_energy) / float(denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in ink density between the top-right and top-left quadrants (positive = more ink top-right)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    mid_h = max(1, h // 2)\n    mid_w = max(1, w // 2)\n    top_left = gray[:mid_h, :mid_w]\n    top_right = gray[:mid_h, mid_w:]\n    # produce masks similarly in each quadrant\n    def quad_mask(q):\n        p40 = np.percentile(q, 40)\n        p60 = np.percentile(q, 60)\n        return (q <= p40) if np.count_nonzero(q <= p40) <= max(1, np.count_nonzero(q >= p60)) else (q >= p60)\n    ml = quad_mask(top_left)\n    mr = quad_mask(top_right)\n    ink_l = ml.sum()\n    ink_r = mr.sum()\n    denom = (ink_l + ink_r + 1e-9)\n    return float((ink_r - ink_l) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink pixels in a horizontal mid-band (captures mid-bars as in 4 or 5)'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        if gray.size == 0:\n            return 0.0\n        maxv = gray.max() if gray.max() != 0 else 1.0\n        if maxv > 1.1:\n            gray = gray / 255.0\n        h, w = gray.shape\n        corner = np.concatenate([\n            gray[:max(1, h//16), :max(1, w//16)].ravel(),\n            gray[-max(1, h//16):, :max(1, w//16)].ravel(),\n            gray[:max(1, h//16), -max(1, w//16):].ravel(),\n            gray[-max(1, h//16):, -max(1, w//16):].ravel()\n        ])\n        corner_mean = float(np.mean(corner)) if corner.size else 0.0\n        thresh = float(np.percentile(gray, 40))\n        if corner_mean > 0.5:\n            fg = gray < thresh\n        else:\n            fg = gray > thresh\n        mid_h = h // 2\n        band = max(1, h // 8)\n        mid_region = fg[mid_h-band:mid_h+band+1, :]\n        total_fg = float(np.count_nonzero(fg)) + 1e-8\n        return float(np.count_nonzero(mid_region) / total_fg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-right and lower-right ink densities normalized by right-half ink (positive if top-right heavier)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink = gray < thr\n    if np.count_nonzero(ink) > 0.9 * h * w:\n        ink = gray > thr\n    right = ink[:, w//2:]\n    ur = np.count_nonzero(right[:h//2, :])\n    lr = np.count_nonzero(right[h//2:, :])\n    denom = float(ur + lr) if (ur + lr) > 0 else 1.0\n    return float((ur - lr) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right L1 normalized symmetry score: average absolute column difference between left and flipped right (lower = more symmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Compare left half and mirrored right half\n    mid = w // 2\n    left = gray[:, :mid]\n    right = np.fliplr(gray[:, w - mid: w]) if mid > 0 else np.zeros_like(left)\n    # If sizes mismatch, trim\n    min_cols = min(left.shape[1], right.shape[1]) if left.size and right.size else 0\n    if min_cols == 0:\n        return 0.0\n    left = left[:, :min_cols]\n    right = right[:, :min_cols]\n    diff = np.abs(left - right)\n    denom = np.mean(np.abs(gray)) + 1e-9\n    score = np.mean(diff) / denom\n    return float(score)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical edge energy in the middle third of the image (vertical stroke prominence in mid-region)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    vert_edge = np.abs(gx)\n    r0 = h // 3\n    r1 = 2 * h // 3\n    mid_energy = np.mean(vert_edge[r0:r1, :]) if r1 > r0 else np.mean(vert_edge)\n    total_energy = np.mean(vert_edge) + 1e-9\n    return float(mid_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between ink density in the right half and left half (positive = more ink on right)'\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # robust binarization: assume ink is darker than background\n    med = np.median(gray)\n    bw = gray < med\n    if np.count_nonzero(bw) == 0:\n        bw = gray > med\n    left = np.count_nonzero(bw[:, :w//2])\n    right = np.count_nonzero(bw[:, w//2:])\n    total = left + right\n    if total == 0:\n        return 0.0\n    return float((right - left) / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Peak diagonal projection: largest bin count when projecting ink onto i+j diagonal axis normalized by ink count'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mask = gray < np.mean(gray)\n    rows, cols = np.nonzero(mask)\n    if rows.size == 0:\n        return 0.0\n    diag_idx = rows + cols\n    min_idx = diag_idx.min()\n    bins = np.bincount(diag_idx - min_idx)\n    peak = float(bins.max())\n    return float(peak / (np.sum(mask) + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of neighbor relationships that are diagonal vs total (captures diagonal tails)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy().astype(float)\n    gray = gray.astype(float)\n    t = np.mean(gray)\n    mask1 = gray < t\n    mask2 = gray > t\n    mask = mask1 if mask1.sum() <= mask2.sum() else mask2\n    mask = mask.astype(np.uint8)\n    if mask.sum() == 0:\n        return 0.0\n    pad = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    # diagonal neighbors\n    nw = pad[:-2, :-2]\n    ne = pad[:-2, 2:]\n    sw = pad[2:, :-2]\n    se = pad[2:, 2:]\n    diag_count = (nw + ne + sw + se).astype(np.int64)\n    # orthogonal neighbors\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    ortho_count = (up + down + left + right).astype(np.int64)\n    # Only count neighbor links for foreground pixels\n    diag_sum = np.sum(diag_count[mask == 1])\n    ortho_sum = np.sum(ortho_count[mask == 1])\n    total_links = diag_sum + ortho_sum\n    if total_links == 0:\n        return 0.0\n    return float(diag_sum) / float(total_links)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude on the right half minus left half (positive if right half has stronger edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    left_mag = np.mean(mag[:, :w//2]) if w//2 > 0 else 0.0\n    right_mag = np.mean(mag[:, w//2:]) if w - w//2 > 0 else 0.0\n    return float(right_mag - left_mag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-cross gradient product: product of mean absolute vertical and horizontal gradients in the center region (high for digit-4 intersection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image, dtype=np.float64)\n    h, w = arr.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    ch0, ch1 = h // 4, w // 4\n    cen = gray[ch0:3 * ch0 if 3 * ch0 > ch0 else h, ch1:3 * ch1 if 3 * ch1 > ch1 else w]\n    if cen.size == 0:\n        return 0.0\n    # gradients\n    gx = np.abs(np.diff(cen, axis=1))\n    gy = np.abs(np.diff(cen, axis=0))\n    mean_gx = float(np.mean(gx)) if gx.size else 0.0\n    mean_gy = float(np.mean(gy)) if gy.size else 0.0\n    # scale to avoid huge numbers\n    denom = (np.max(gray) - np.min(gray)) + 1e-9\n    return float((mean_gx * mean_gy) / (denom + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized column-wise average of vertical gradient magnitude in the center third (helps detect round loops vs straight vertical strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gmin, gmax = float(np.min(gray)), float(np.max(gray))\n    if gmax > gmin:\n        gray = (gray - gmin) / (gmax - gmin)\n    else:\n        gray = gray * 0.0\n    # compute vertical gradient magnitude\n    gy = np.gradient(gray, axis=0)\n    mag = np.abs(gy)\n    h, w = mag.shape\n    r0, r1 = h // 3, (2 * h) // 3\n    center_mag = mag[r0:r1, :]\n    if center_mag.size == 0:\n        return 0.0\n    # normalize by max to be scale-invariant\n    maxv = float(np.max(center_mag))\n    if maxv == 0:\n        return 0.0\n    score = float(np.mean(center_mag) / (maxv + 1e-12))\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative prevalence difference between descending and ascending diagonal gradients (-1..1); positive means more descending-diagonal structure'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.hypot(gx, gy)\n    if mag.max() <= 0:\n        return 0.0\n    # threshold to ignore noise\n    thr = max(np.percentile(mag, 60), mag.max() * 0.1)\n    ang = np.degrees(np.arctan2(gy, gx))\n    # descending diagonal: angle around -45 degrees (top-right to bottom-left or vice versa depending on coordinate system)\n    desc_mask = (mag >= thr) & (ang >= -70) & (ang <= -20)\n    asc_mask = (mag >= thr) & (ang >= 20) & (ang <= 70)\n    desc = desc_mask.sum()\n    asc = asc_mask.sum()\n    denom = float(desc + asc + 1e-6)\n    return float((desc - asc) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of radial distances of foreground pixels from centroid (normalized) \u2014 \"0\" tends to have larger circular spread'\n    import numpy as np\n    arr = np.array(image, dtype=float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    fg = gray < th\n    if np.count_nonzero(fg) > gray.size / 2:\n        fg = ~fg\n    ys, xs = np.nonzero(fg)\n    if xs.size == 0:\n        return 0.0\n    cx, cy = np.mean(xs), np.mean(ys)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    std = np.std(dists)\n    # normalize by image diagonal\n    diag = np.sqrt(w * w + h * h)\n    return float(std / (diag + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of strong orthogonal crossings in the central box where both horizontal and vertical gradients are strong'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if h < 3 or w < 3:\n            return 0.0\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        gy, gx = np.gradient(gray)\n        mag_h = np.abs(gx)\n        mag_v = np.abs(gy)\n        # central box (middle third)\n        r0, r1 = h//3, (2*h)//3\n        c0, c1 = w//3, (2*w)//3\n        box_h = mag_h[r0:r1, c0:c1]\n        box_v = mag_v[r0:r1, c0:c1]\n        if box_h.size == 0:\n            return 0.0\n        thr_h = np.percentile(box_h, 65)\n        thr_v = np.percentile(box_v, 65)\n        crossings = np.logical_and(box_h >= thr_h, box_v >= thr_v)\n        return float(np.count_nonzero(crossings) / box_h.size)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain at least one foreground pixel in the leftmost third (measures left vertical stroke continuity typical of \"5\")'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # simple adaptive binarization\n    rng = gray.max() - gray.min()\n    if rng <= 0:\n        return 0.0\n    thresh = gray.min() + 0.2 * rng\n    binm = gray > thresh\n    c = max(1, w // 3)\n    left_block = binm[:, :c]\n    row_has_left = np.any(left_block, axis=1)\n    return float(np.sum(row_has_left) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside a small central circular region (higher for digits with centered hole like 0)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    fg = gray < thr\n    if np.count_nonzero(fg) > 0.6 * fg.size:\n        fg = ~fg\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    r = max(1, min(h, w) // 6)\n    ys = np.arange(h)[:, None]\n    xs = np.arange(w)[None, :]\n    mask = ((ys - cy) ** 2 + (xs - cx) ** 2) <= (r ** 2)\n    bg = ~fg\n    region = bg & mask\n    denom = float(np.count_nonzero(mask)) + 1e-6\n    return float(np.count_nonzero(region) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous vertical ink run in the right third of the image, normalized by image height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 50)\n    ink_dark = np.mean(gray.flatten()[:max(1, int(0.05*h*w))]) < np.mean(gray.flatten()[-max(1, int(0.05*h*w)):])\n    if ink_dark:\n        ink = gray < thresh\n    else:\n        ink = gray > thresh\n    start_col = max(0, 2*w // 3)\n    region = ink[:, start_col:w]\n    # compute longest vertical run per column, take max\n    longest = 0\n    for c in range(region.shape[1]):\n        col = region[:, c]\n        cur = 0\n        maxc = 0\n        for v in col:\n            if v:\n                cur += 1\n                if cur > maxc: maxc = cur\n            else:\n                cur = 0\n        if maxc > longest: longest = maxc\n    return float(longest / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated count of stroke endpoints (pixels with exactly one ink neighbor) normalized by sqrt(ink count)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = (gray < thr).astype(int)\n    else:\n        ink = (gray > thr).astype(int)\n    ink_cnt = int(np.count_nonzero(ink))\n    if ink_cnt == 0:\n        return 0.0\n    p = np.pad(ink, 1, mode='constant', constant_values=0)\n    center = p[1:-1, 1:-1]\n    neighbors = (\n        p[0:-2, 0:-2] + p[0:-2, 1:-1] + p[0:-2, 2:] +\n        p[1:-1, 0:-2] + p[1:-1, 2:] +\n        p[2:, 0:-2] + p[2:, 1:-1] + p[2:, 2:]\n    )\n    endpoints = np.sum((center == 1) & (neighbors == 1))\n    return float(endpoints) / (np.sqrt(float(ink_cnt)) + 1e-9)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of positive-slope diagonal strokes vs negative-slope diagonals (range approximately [-1,1])'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    bw = (norm > 0.5).astype(float)\n    h, w = bw.shape\n    # compute max summed intensity along diagonals (positive slope = diag of fliplr)\n    pos_sums = []\n    neg_sums = []\n    for k in range(-w + 1, h):\n        neg_diag = np.diagonal(bw, offset=k)\n        pos_diag = np.diagonal(np.fliplr(bw), offset=k)\n        neg_sums.append(float(np.sum(np.abs(neg_diag))))\n        pos_sums.append(float(np.sum(np.abs(pos_diag))))\n    max_neg = max(neg_sums) if neg_sums else 0.0\n    max_pos = max(pos_sums) if pos_sums else 0.0\n    eps = 1e-8\n    return float((max_pos - max_neg) / (max_pos + max_neg + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of ink bounding box (width / height). Returns 0.0 if no ink present.'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = gray.min(), gray.max()\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    bw = (norm > 0.5).astype(np.uint8)\n    ys, xs = np.where(bw)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    width = maxx - minx + 1\n    height = maxy - miny + 1\n    if height == 0:\n        return float(width)\n    return float(width / height)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean vertical gradient magnitude in the right third to the left third (captures right-side curvature)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h <= 1:\n        return 0.0\n    vgrad = np.abs(np.diff(gray, axis=0))\n    left = vgrad[:, : max(1, w//3)]\n    right = vgrad[:, (2*w)//3 : ] if (2*w)//3 < w else vgrad[:, -1:]\n    left_mean = float(np.mean(left)) if left.size else 0.0\n    right_mean = float(np.mean(right)) if right.size else 0.0\n    if left_mean == 0.0:\n        return float(right_mean)\n    return float(right_mean / (left_mean + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean diagonal-gradient (\\\\ direction) to the other diagonal-gradient (/ direction) magnitudes (detects diagonal stroke bias)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        if h == 0 or w == 0:\n            return 0.0\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        gy, gx = np.gradient(gray)\n        diag1 = np.mean(np.abs(gx + gy))\n        diag2 = np.mean(np.abs(gx - gy))\n        return float((diag1 + 1e-9) / (diag2 + 1e-9))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient in right quarter to left quarter (detects right-side vertical strokes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    gy, gx = np.gradient(gray)\n    abs_v = np.abs(gy)\n    midc = w // 2\n    left = abs_v[:, :midc]\n    right = abs_v[:, midc:]\n    mean_left = np.mean(left) + 1e-9\n    mean_right = np.mean(right)\n    return float(mean_right / mean_left)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom horizontal gradient strength: mean absolute horizontal gradient in bottom strip (detect bottom bar)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    low_mean = np.mean(gray[gray <= p10]) if np.any(gray <= p10) else p10\n    high_mean = np.mean(gray[gray >= p90]) if np.any(gray >= p90) else p90\n    ink_dark = low_mean < high_mean\n    thr = np.percentile(gray, 50)\n    fg = (gray <= thr) if ink_dark else (gray >= thr)\n    gy, gx = np.gradient(gray.astype(np.float64))\n    horiz_abs = np.abs(gx)\n    bottom_h = max(1, h // 5)\n    region = horiz_abs[h - bottom_h:, :]\n    fg_region = fg[h - bottom_h:, :]\n    # weight by foreground presence to emphasize strokes\n    weighted = region * (fg_region.astype(np.float64))\n    mean_val = weighted.mean() if weighted.size else 0.0\n    return float(mean_val)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels that lie in the right half of the image (right density ratio)'\n    import numpy as np\n    # Grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    # Robust threshold estimation\n    p40, p60 = np.percentile(gray, 40), np.percentile(gray, 60)\n    left_vals = gray[gray <= p40]\n    right_vals = gray[gray >= p60]\n    if left_vals.size == 0: left_mean = gray.min()\n    else: left_mean = left_vals.mean()\n    if right_vals.size == 0: right_mean = gray.max()\n    else: right_mean = right_vals.mean()\n    thr = (left_mean + right_mean) / 2.0\n    ink_is_dark = left_mean < right_mean\n    ink = (gray < thr) if ink_is_dark else (gray > thr)\n    if np.count_nonzero(ink) == 0:\n        return 0.0\n    right_half = ink[:, w//2:]\n    result = float(np.count_nonzero(right_half) / (np.count_nonzero(ink) + 1e-9))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative mid-bar strength: mean horizontal gradient magnitude in the middle third rows divided by overall horizontal gradient'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # Compute horizontal gradient (dx)\n    dy, dx = np.gradient(gray)\n    abs_dx = np.abs(dx)\n    mid_start = h // 3\n    mid_end = (2 * h) // 3\n    mid_mean = np.mean(abs_dx[mid_start:mid_end, :])\n    overall_mean = np.mean(abs_dx) + 1e-6\n    return float(mid_mean / overall_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of ink \"endpoints\": ink pixels with only one ink neighbor (8-connected). Loops like 0/8 have few endpoints; open strokes like 5 have endpoints'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    border_mean = float(np.mean(border)) if border.size > 0 else float(np.mean(gray))\n    if border_mean > np.median(gray):\n        thr = (border_mean + float(np.min(gray))) / 2.0\n        ink = (gray < thr).astype(np.uint8)\n    else:\n        thr = (border_mean + float(np.max(gray))) / 2.0\n        ink = (gray > thr).astype(np.uint8)\n    if np.sum(ink) == 0:\n        return 0.0\n    padded = np.pad(ink, pad_width=1, mode='constant', constant_values=0)\n    endpoints = 0\n    for r in range(1, h + 1):\n        row_slice = padded[r - 1:r + 2, :]\n        for c in range(1, w + 1):\n            if padded[r, c]:\n                neigh = row_slice[:, c - 1:c + 2].flatten()\n                neigh_count = int(np.sum(neigh)) - 1  # exclude center\n                if neigh_count == 1:\n                    endpoints += 1\n    return float(endpoints)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the upper half of the image (upper density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    foreground_is_dark = float(np.mean(gray)) < thr\n    if foreground_is_dark:\n        ink = gray < thr\n    else:\n        ink = gray > thr\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    upper = float(np.count_nonzero(ink[:h//2, :]))\n    return float(upper / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1 normalized horizontal symmetry score: average absolute row difference between top and flipped bottom'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gray = (gray - gray.min()) / max(1e-8, (gray.max() - gray.min()))\n    top = gray[:h // 2, :]\n    bottom = np.flipud(gray[(h + 1) // 2:, :]) if h % 2 else np.flipud(gray[h // 2:, :])\n    minh = min(top.shape[0], bottom.shape[0]) if top.size and bottom.size else 0\n    if minh == 0:\n        return 0.0\n    diff = np.abs(top[:minh, :] - bottom[:minh, :])\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate branch-point count: fraction of ink pixels with 4 or more neighbors in 8-connectivity'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        th = np.mean(gray)\n        ink = (gray < th).astype(np.uint8)\n        if ink.sum() == 0:\n            ink = (gray > th).astype(np.uint8)\n        if ink.sum() == 0:\n            return 0.0\n        padded = np.pad(ink, 1, mode='constant', constant_values=0)\n        # sum of 8-neighbors\n        neigh = (\n            padded[:-2, :-2] + padded[:-2, 1:-1] + padded[:-2, 2:] +\n            padded[1:-1, :-2] +                 0 + padded[1:-1, 2:] +\n            padded[2:, :-2] +  padded[2:, 1:-1] + padded[2:, 2:]\n        )\n        # restrict to original ink pixels\n        neigh = neigh * ink\n        branch_points = np.count_nonzero(neigh >= 4)\n        return float(branch_points / (ink.sum() + 1e-9))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-left quadrant ink density: fraction of ink pixels located in the bottom-left quadrant'\n    try:\n        import numpy as np\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        th = np.mean(gray)\n        ink = gray < th\n        if np.count_nonzero(ink) == 0:\n            ink = gray > th\n        total = np.count_nonzero(ink)\n        if total == 0:\n            return 0.0\n        lower_half = np.s_[h//2: h, 0: w//2]\n        lower_left = ink[lower_half]\n        return float(np.count_nonzero(lower_left) / (total + 1e-9))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio: boundary pixel count divided by ink pixel count (higher = more perimeter relative to area)'\n    try:\n        if len(image.shape) == 3:\n            gray = image.mean(axis=2)\n        else:\n            gray = image.astype(float)\n        g = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n        border = np.concatenate([g[0:1, :].ravel(), g[-1:, :].ravel(), g[:, 0:1].ravel(), g[:, -1:].ravel()])\n        border_mean = float(np.mean(border)) if border.size else 0.5\n        if border_mean > 0.5:\n            ink = g < max(0.0, border_mean - 0.15)\n        else:\n            ink = g > min(1.0, border_mean + 0.15)\n        h, w = ink.shape\n        if np.count_nonzero(ink) == 0:\n            return 0.0\n        pad = np.pad(ink, pad_width=1, mode='constant', constant_values=False)\n        eroded = np.ones_like(ink, dtype=bool)\n        for dy, dx in ((0,0),(1,0),(-1,0),(0,1),(0,-1)):\n            eroded &= pad[1+dy : 1+dy+h, 1+dx : 1+dx+w]\n        boundary = ink & (~eroded)\n        perim = float(np.count_nonzero(boundary))\n        area = float(np.count_nonzero(ink))\n        return float(perim / max(1e-9, area))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of columns that contain a continuous vertical ink run longer than 50% of image height, normalized by width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    low = gray[gray <= thresh]\n    high = gray[gray > thresh]\n    if low.size == 0 or high.size == 0:\n        ink = gray <= thresh\n    else:\n        ink = gray <= thresh if (low.mean() < high.mean()) else (gray >= thresh)\n    count_cols = 0\n    min_len = max(1, h // 2)\n    for j in range(w):\n        col = ink[:, j]\n        # find longest contiguous True run\n        max_run = 0\n        run = 0\n        for val in col:\n            if val:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        if max_run >= min_len:\n            count_cols += 1\n    return float(count_cols / float(max(1, w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical separation between two largest enclosed hole centroids normalized by image height (0 if fewer than 2 holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # exterior fill\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal = (~ink) & (~exterior)\n    visited = np.zeros_like(internal, dtype=bool)\n    centroids = []\n    for i in range(h):\n        for j in range(w):\n            if internal[i, j] and not visited[i, j]:\n                # BFS\n                q = deque()\n                q.append((i, j))\n                visited[i, j] = True\n                pts = [(i, j)]\n                while q:\n                    ci, cj = q.popleft()\n                    for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n                        ni, nj = ci+di, cj+dj\n                        if 0 <= ni < h and 0 <= nj < w and internal[ni, nj] and not visited[ni, nj]:\n                            visited[ni, nj] = True\n                            pts.append((ni, nj))\n                            q.append((ni, nj))\n                pts = np.array(pts)\n                centroids.append((float(np.mean(pts[:,0])), float(np.mean(pts[:,1])), pts.shape[0]))\n    if len(centroids) < 2:\n        return 0.0\n    # sort by area desc and take two largest\n    centroids.sort(key=lambda x: x[2], reverse=True)\n    y1 = centroids[0][0]\n    y2 = centroids[1][0]\n    return float(abs(y1 - y2) / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected ink components (1 for single blob), returns as float'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray)\n    bin_ink = (gray < thresh)\n    if np.count_nonzero(bin_ink) == 0:\n        bin_ink = (gray > thresh)\n    bin_ink = bin_ink.astype(bool)\n    visited = np.zeros((h, w), dtype=bool)\n    components = 0\n    for y in range(h):\n        for x in range(w):\n            if bin_ink[y, x] and not visited[y, x]:\n                components += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)):\n                        ny, nx = cy+dy, cx+dx\n                        if 0 <= ny < h and 0 <= nx < w and bin_ink[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n    return float(components)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in the bottom quarter of the image (lower density ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gmax = gray.max()\n    if gmax > 1.5:\n        gray = gray / gmax\n    thresh = float(np.mean(gray))\n    dark_frac = float(np.mean(gray < thresh))\n    if 0.01 < dark_frac < 0.99:\n        ink = (gray < thresh) if dark_frac < 0.5 else (gray > thresh)\n    else:\n        ink = gray < thresh\n    h, w = gray.shape\n    if h < 4:\n        return float(np.count_nonzero(ink) / max(1.0, h*w))\n    bottom_start = (3 * h) // 4\n    bottom_count = float(np.count_nonzero(ink[bottom_start:h, :]))\n    total = float(np.count_nonzero(ink))\n    if total == 0.0:\n        return 0.0\n    return float(bottom_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude in the center region (stroke orientation cue)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    h, w = norm.shape\n    ch0 = max(0, h // 4)\n    ch1 = min(h, 3 * h // 4)\n    cw0 = max(0, w // 4)\n    cw1 = min(w, 3 * w // 4)\n    center = norm[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    if mean_vert < 1e-8:\n        return float(mean_horiz / (mean_vert + 1e-8))\n    return float(mean_horiz / mean_vert)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'L1-normalized 180-degree rotational asymmetry: mean absolute difference between image and rotated 180'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    rot = np.rot90(gray, 2)\n    diff = np.abs(gray - rot)\n    denom = float(np.mean(np.abs(gray)) + 1e-6)\n    return float(np.mean(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Radial spread: standard deviation of distances of ink pixels to their centroid normalized by image diagonal (0..1)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    ink_mask = (gray < thr)\n    ys, xs = np.where(ink_mask)\n    if ys.size == 0:\n        return 0.0\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dists = np.hypot(ys - cy, xs - cx)\n    std = float(np.std(dists))\n    diag = np.hypot(h, w) + 1e-8\n    return float(std / diag)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink pixels located in a central square region (middle half) to indicate center occlusion vs hole'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    ch0, ch1 = h // 4, 3 * h // 4\n    cw0, cw1 = w // 4, 3 * w // 4\n    # ensure indices valid\n    ch0 = max(0, min(h, ch0)); ch1 = max(0, min(h, ch1))\n    cw0 = max(0, min(w, cw0)); cw1 = max(0, min(w, cw1))\n    center_region = ink[ch0:ch1, cw0:cw1]\n    center_ink = float(np.sum(center_region))\n    total_ink = float(np.sum(ink))\n    if total_ink <= 0.0:\n        return 0.0\n    return float(center_ink / total_ink)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of total enclosed hole area to ink area (how big holes are relative to ink)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray))\n    cand = gray < thr\n    if np.sum(cand) > gray.size / 2:\n        ink = ~cand\n    else:\n        ink = cand\n    ink = ink.astype(bool)\n    # Flood fill exterior background\n    exterior = np.zeros_like(ink, dtype=bool)\n    from collections import deque\n    q = deque()\n    for i in range(h):\n        for j in (0, w-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    for j in range(w):\n        for i in (0, h-1):\n            if not ink[i, j] and not exterior[i, j]:\n                exterior[i, j] = True\n                q.append((i, j))\n    while q:\n        i, j = q.popleft()\n        for di, dj in ((1,0),(-1,0),(0,1),(0,-1)):\n            ni, nj = i+di, j+dj\n            if 0 <= ni < h and 0 <= nj < w and (not ink[ni, nj]) and (not exterior[ni, nj]):\n                exterior[ni, nj] = True\n                q.append((ni, nj))\n    internal_bg = (~ink) & (~exterior)\n    hole_area = float(np.sum(internal_bg))\n    ink_area = float(np.sum(ink))\n    if ink_area <= 0.0:\n        return 0.0\n    return float(hole_area / ink_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of ink in a central vertical band (width = ~1/6 of image width) capturing vertical strokes'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.array(image, dtype=float)\n    if gray.ndim == 3:\n        gray = np.mean(gray, axis=2)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    rng = mx - mn + 1e-9\n    gray = (gray - mn) / rng\n    h, w = gray.shape\n    bw = max(1, w // 6)\n    start = max(0, (w - bw) // 2)\n    end = start + bw\n    thresh = np.mean(gray)\n    fg1 = gray < thresh\n    fg2 = gray > thresh\n    fg = fg1 if np.count_nonzero(fg1) <= np.count_nonzero(fg2) else fg2\n    total = np.count_nonzero(fg)\n    if total == 0:\n        return 0.0\n    center_band = fg[:, start:end]\n    return float(np.count_nonzero(center_band) / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box fill ratio: foreground area divided by area of its tight bounding box (0..1)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 75))\n    mask = gray >= thr\n    if mask.sum() > 0.6 * (h * w):\n        mask = ~mask\n    mask = mask.astype(bool)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    fg_area = float(mask.sum())\n    if bbox_area <= 0:\n        return 0.0\n    return float(fg_area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of detected ink pixels located in the right half of the image (0..1)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    th = np.mean(gray)\n    ink = gray < th\n    total = np.count_nonzero(ink)\n    if total == 0:\n        return 0.0\n    right = np.count_nonzero(ink[:, w//2:])\n    return float(right / (total + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of ink in the left third of the image (left mass / total ink mass)'\n    import numpy as np\n    # Normalize to grayscale\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.max() > 1.0:\n        img = img / 255.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    # Determine ink as minority of pixels relative to mean\n    thr = gray.mean()\n    cand1 = gray < thr\n    cand2 = gray > thr\n    mask = cand1 if cand1.sum() <= cand2.sum() else cand2\n    total = float(mask.sum())\n    if total == 0.0:\n        return 0.0\n    left = float(mask[:, :max(1, w // 3)].sum())\n    return float(left / (total + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative energy of gradients aligned near -45 degrees (normalized 0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gx, gy = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    total_energy = mag.sum()\n    if total_energy <= 0:\n        return 0.0\n    orient = np.arctan2(gy, gx)\n    target = -np.pi / 4.0\n    # angular difference in [-pi, pi]\n    diff = np.arctan2(np.sin(orient - target), np.cos(orient - target))\n    angle_tol = np.pi / 8.0  # 22.5 degrees tolerance\n    mask = np.abs(diff) <= angle_tol\n    energy_aligned = mag[mask].sum()\n    return float(energy_aligned / (total_energy + 1e-12))\n\n"
  ]
}