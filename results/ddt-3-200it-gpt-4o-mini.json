{"used_features": ["def feature(board: chess.Board) -> float:\n    \"Computes the total number of defending pieces each side has.\"\n    defending_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material balance of pieces (based on standard values).\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Proportion of the entire board that is attacked by pieces of each color.\"\n    total_attacked = 0\n    attacked_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares) / 64)", "def feature(board: chess.Board) -> float:\n    \"Computes the total value of pieces for each side and returns the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both sides.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that have more than one piece attacking them.\"\n    double_attacked_squares = sum(1 for square in chess.SQUARES if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    result = float(double_attacked_squares)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the mobility of each side, defined as the number of legal moves available.\"\n    white_mobility = len(list(board.legal_moves))\n    board.turn = chess.BLACK\n    black_mobility = len(list(board.legal_moves))\n    board.turn = chess.WHITE\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are unprotected.\"\n    unprotected_enemy_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            unprotected_enemy_count += 1\n    return float(unprotected_enemy_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board based on a weighted material count.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that are defended versus those that are attacked.\"\n    defended = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    attacked = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(piece.color, square))\n    return float(defended - attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are out of play (not on the board).\"\n    total_pieces = 32  # 16 pieces for each side\n    total_present = len(board.piece_map())\n    return float(total_pieces - total_present)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of each side's remaining pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_pieces = len(board.piece_map())\n    return (white_value - black_value) / (total_pieces if total_pieces > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with a potential to promote.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7,\n                         chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    promotion_count = sum(1 for square in promotion_squares if board.piece_at(square) and \n                          board.piece_at(square).piece_type == chess.PAWN)\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces for each side.\"\n    total_pieces = len(board.piece_map())\n    active_white_pieces = len([1 for m in board.legal_moves if board.piece_at(m.from_square).color == chess.WHITE])\n    active_black_pieces = len([1 for m in board.legal_moves if board.piece_at(m.from_square).color == chess.BLACK])\n    ratio = (active_white_pieces / total_pieces) - (active_black_pieces / total_pieces) if total_pieces > 0 else 0.0\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pieces to the opponent's king.\"\n    opponent_king = chess.KING if board.turn == chess.WHITE else chess.KING\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == opponent_king and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    distance_sum = sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of pawns to the back rank of the opposite side.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                distance_sum += (7 - chess.square_rank(square))\n            else:\n                distance_sum += chess.square_rank(square)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of each side's pieces to the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked from two or more different directions.\"\n    double_attacked_count = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) > 1:\n            double_attacked_count += 1\n        if board.is_attacked_by(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) > 1:\n            double_attacked_count += 1\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of material values of pieces on the back ranks of each side.\"\n    back_rank_values = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) == 0) or (piece.color == chess.BLACK and chess.square_rank(square) == 7):\n            back_rank_values += (1 if piece.piece_type == chess.PAWN else\n                                 3 if piece.piece_type in (chess.KNIGHT, chess.BISHOP) else\n                                 5 if piece.piece_type == chess.ROOK else\n                                 9 if piece.piece_type == chess.QUEEN else\n                                 0)\n    return float(back_rank_values)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces to the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn:\n            total_distance += chess.square_distance(square, opponent_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for both sides; higher rank means more influence.\"\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square) + 1  # +1 for 1-8 rank representation\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of protected pieces for the current player.\"\n    protected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if not attackers:\n                protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    isolated_pawns = 0\n    for sq in board.piece_map():\n        piece = board.piece_map()[sq]\n        if piece.piece_type == chess.PAWN:\n            if not (board.piece_at(sq - 1) and board.piece_at(sq - 1).color == piece.color) and \\\n               not (board.piece_at(sq + 1) and board.piece_at(sq + 1).color == piece.color):\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of squares that have more than one piece attacking them.\"\n    multi_attacked_squares = sum(1 for square in chess.SQUARES if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    return float(multi_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked but not protected by any piece.\"\n    attacked_unprotected = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not any(board.is_attacked_by(chess.BLACK, square) for piece in board.piece_map().values() if piece.color == chess.WHITE):\n            attacked_unprotected += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not any(board.is_attacked_by(chess.WHITE, square) for piece in board.piece_map().values() if piece.color == chess.BLACK):\n            attacked_unprotected += 1\n    return float(attacked_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have the potential to deliver check.\"\n    check_potential_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_map()[square].piece_type != chess.KING)\n    return float(check_potential_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pawns on the board.\"\n    pawn_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN)\n    return float(pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces to the opponent's king.\"\n    opponent_king_square = [sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color != board.turn]\n    if not opponent_king_square:\n        return 0.0\n    \n    king_square = opponent_king_square[0]\n    total_distance = sum(chess.square_distance(sq, king_square) for sq in board.piece_map() if board.piece_map()[sq].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances from each player's pieces to the opponent's back rank.\"\n    value = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                distance = 7 - chess.square_rank(square)\n            else:\n                distance = chess.square_rank(square)\n            value += distance\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece distance to the opponent's king, giving higher values to pieces that are farther away.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn]\n    return float(sum(distances))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks available to the side to move.\"\n    checks_available = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for promotion by counting the number of pawns within striking distance of promotion.\"\n    player_color = board.turn\n    promotion_squares = chess.square_rank(chess.A7) if player_color == chess.WHITE else chess.square_rank(chess.A2)\n    return float(sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == promotion_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective back ranks.\"\n    distance_sum = 0\n    for sq, piece in board.piece_map().items():\n        rank_distance = 7 - chess.square_rank(sq) if piece.color == chess.WHITE else chess.square_rank(sq)\n        distance_sum += rank_distance\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    total_distance = sum(chess.square_distance(sq, king_square) for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board that are in their initial positions.\"\n    initial_positions = [chess.PAWN, chess.ROOK, chess.KNIGHT, chess.BISHOP, chess.QUEEN, chess.KING]\n    initial_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type in initial_positions and piece.color == board.turn)\n    return float(initial_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares where a player's pieces can move.\"\n    total_controlled_squares = sum(len(board.attacks(sq)) for sq in board.piece_map().keys())\n    return float(total_controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pieces.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of double-attack opportunities on the board.\"\n    double_attacks = sum(1 for square in range(64) if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on a player's first two ranks; more pieces can support development and influence the game.\"\n    count = sum(1 for square in range(16) if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns to the promotion rank.\"\n    total_distance = 0\n    for sq in board.piece_map():\n        if board.piece_at(sq).piece_type == chess.PAWN:\n            distance_to_promotion = 7 - chess.square_rank(sq) if board.piece_at(sq).color == chess.WHITE else chess.square_rank(sq)\n            total_distance += distance_to_promotion\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to the back ranks of their respective sides.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares where attacking pieces are located for current player.\"\n    attacking_squares = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of mobile pieces to total pieces for each side.\"\n    mobile_white = len(list(board.legal_moves)) if board.turn else 0\n    mobile_black = len(list(board.legal_moves)) if not board.turn else 0\n    total_pieces = len(board.piece_map())\n    return float(mobile_white / total_pieces if total_pieces > 0 else 0) - float(mobile_black / total_pieces if total_pieces > 0 else 0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by each color.\"\n    controlled_squares_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_squares_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the ratio of defended squares to attacked squares for the current player.\"\n    attacked_count = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square))\n    defended_count = sum(1 for square in range(64) if board.is_attacked_by(not board.turn, square))\n    return (defended_count / (attacked_count + 1))  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available to the side to move.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of all pieces to their closest opponent piece.'\n    total_distance = 0\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            opponent_pieces = [s for s in board.piece_map() if board.piece_at(s).color == opponent_color]\n            if opponent_pieces:\n                distances = [chess.square_distance(square, op) for op in opponent_pieces]\n                total_distance += min(distances)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are protected (i.e., controlled by multiple pieces).\"\n    protected_squares = sum(1 for square in chess.SQUARES if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    return float(protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently on their original squares.\"\n    original_positions = {\n        chess.WHITE: 0,\n        chess.BLACK: 0\n    }\n    start_positions = {\n        chess.WHITE: [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1, chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7, chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8],\n    }\n    for square, piece in board.piece_map().items():\n        if square in start_positions[piece.color]:\n            original_positions[piece.color] += 1\n    return float(original_positions[chess.WHITE] - original_positions[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by pieces of each color.\"\n    controlled_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all non-pawn pieces on the board for both sides.\"\n    non_pawn_ranks_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_ranks_sum)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares completely controlled by the current player.'\n    # Count controlled squares not attacked by the opponent\n    controlled_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square):\n            continue\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board compared to the initial setup.\"\n    initial_pieces_count = 32  # Starting pieces count for both sides\n    current_pieces_count = len(board.piece_map())\n    return float(current_pieces_count - initial_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are simultaneously attacked by both players.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        if board.is_attacked_by(chess.WHITE, square):\n            attacked_squares.add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns to the opponent's back rank.\"\n    total_distance = sum(7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are controlled by more than one piece for each side.\"\n    controlled_squares = {square: 0 for square in chess.SQUARES}\n    for piece in board.piece_map().values():\n        for move in board.legal_moves:\n            if piece.color == chess.WHITE and move.from_square in controlled_squares:\n                controlled_squares[move.from_square] += 1\n            elif piece.color == chess.BLACK and move.from_square in controlled_squares:\n                controlled_squares[move.from_square] += 1\n    return float(sum(1 for count in controlled_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked but not defended by the opponent.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not any(board.is_attacked_by(chess.BLACK, sq) for sq in board.attackers(chess.BLACK, square)):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pawns on the board; higher ranks mean closer to promotion.\"\n    return float(sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN))", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are occupied by pieces that are not in their optimal positions (non-development positions).\"\n    misplaced_pieces_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if (piece.color == chess.WHITE and chess.square_rank(square) < 4) or (piece.color == chess.BLACK and chess.square_rank(square) > 5):\n            misplaced_pieces_count += 1\n    return float(misplaced_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces beyond the 5th rank for both players.\"\n    pieces_behind_rank_5 = sum(1 for square, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(square) < 4) or (piece.color == chess.BLACK and chess.square_rank(square) > 3))\n    return float(pieces_behind_rank_5)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of ranks of pawns for each player; higher rank means closer to promotion.\"\n    white_pawn_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() \n                              if board.piece_at(square).color == chess.WHITE and \n                              board.piece_at(square).piece_type == chess.PAWN)\n    black_pawn_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() \n                              if board.piece_at(square).color == chess.BLACK and \n                              board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawn_rank_sum - black_pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Compares the sum of the ranks of all pieces for both sides, giving more weight to pieces that are advanced.\"\n    white_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces attacking the opponent's king.\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.parse_square('e8')))  # Assuming e8 is the black king's position\n    black_attacks = len(board.attackers(chess.BLACK, chess.parse_square('e1')))  # Assuming e1 is the white king's position\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in ranks of pieces in play for both sides.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in distance of the king from opposing pieces; indicates safety.\"\n    my_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == board.turn), None)\n    opponent_pieces = [sq for sq in board.piece_map() if board.piece_at(sq).color != board.turn]\n    distance_sum = sum(chess.square_distance(my_king, sq) for sq in opponent_pieces)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares from which the current player's pieces can directly threaten the opponent's king.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    threat_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color and returns the difference.\"\n    controlled_squares_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return controlled_squares_white - controlled_squares_black", "def feature(board: chess.Board) -> float:\n    'Measures the potential for promotion, counting pawns in the opponent\\'s half.'\n    pawn_promotion_count = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    return float(pawn_promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank of each player for potential control.\"\n    back_rank_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and (chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7)):\n            back_rank_pieces += 1\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares where either player can check the opponent's king.\"\n    checks = 0\n    for move in board.legal_moves:\n        if board.is_check():  # Capture check positions \n            checks += 1\n        board.push(move)\n        if board.is_check():\n            checks += 1\n        board.pop()\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks for pieces controlled by the player to move, with a focus on potential promotion.\"\n    rank_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            rank_sum += chess.square_rank(square) + 1  # Ranks are 0-indexed\n    return float(rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of unprotected opposing pieces.\"\n    unprotected_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by at least two pieces for the current player.\"\n    attack_map = {}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    target_square = move.to_square\n                    attack_map[target_square] = attack_map.get(target_square, 0) + 1\n    return float(sum(1 for count in attack_map.values() if count >= 2))", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility difference, calculated as the difference in the number of legal moves for both players.\"\n    white_moves = len(list((move for move in board.legal_moves if board.turn)))\n    black_moves = len(list((move for move in board.legal_moves if not board.turn)))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total distance of all pawns from their respective promotion ranks.\"\n    distance_sum = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    occupied_squares = len([square for square in board.piece_map()])\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by the current player's pieces in the opponent's half.\"\n    occupied_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) > 3)\n    return float(occupied_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all unprotected pieces for the current player.\"\n    unprotected_rank_sum = sum(chess.square_rank(square) + 1 \n                                for square in board.piece_map() \n                                if board.piece_at(square).color == board.turn and \n                                   not board.attackers(not board.turn, square))\n    return float(unprotected_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the current player\u2019s pawns to the opponent's back rank.\"\n    total_distance = 0\n    for square in range(8):\n        for file in range(8):\n            square_index = chess.square(file, square)\n            piece = board.piece_at(square_index)\n            if piece and piece.color == board.turn and piece.piece_type == chess.PAWN:\n                total_distance += 7 - chess.square_rank(square_index)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking moves available for the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board beyond the 4th rank.\"\n    pieces_beyond_fourth = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if chess.square_rank(square) > 3:\n            pieces_beyond_fourth[piece.color] += 1\n    return float(pieces_beyond_fourth[chess.WHITE] - pieces_beyond_fourth[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks of all pawns on the board; higher rank means closer to promotion.\"\n    pawn_rank_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_rank_sum += chess.square_rank(square) + 1  # +1 to convert to 1-based rank\n    return float(pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares that are controlled by pawns for the current player.'\n    controlled_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are currently unprotected.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(piece.color, square) for square in board.attackers(not piece.color, square)))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the enemy king.\"\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type == chess.KING:\n            enemy_king_square = square\n            break\n    if enemy_king_square is None:\n        return 0.0\n    \n    attacking_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and board.is_attacked_by(chess.WHITE, enemy_king_square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 7th rank (for White) or 2nd rank (for Black).\"\n    rank = 7 if board.turn else 1\n    pieces_on_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == rank)\n    return float(pieces_on_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares from which the opponent's king can be attacked by the current player's pieces.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    return float(len([square for square in board.legal_moves if board.is_attacked_by(board.turn, opponent_king_square)])) if opponent_king_square else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of the board that is controlled by each color's pieces.\"\n    total_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) or board.is_attacked_by(chess.BLACK, sq))\n    controlled_by_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    controlled_by_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(controlled_by_white) / (total_controlled or 1) - float(controlled_by_black) / (total_controlled or 1)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board that are located on the second rank.\"\n    second_rank_value = sum(piece.piece_type for square, piece in board.piece_map().items() if (\n        (piece.color == chess.WHITE and chess.square_rank(square) == 1) or \n        (piece.color == chess.BLACK and chess.square_rank(square) == 6)\n    ))\n    return float(second_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by the opponent but not defended.\"\n    attacked_not_defended = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square))\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in ranks of the pawns for each player to assess advancement.'\n    white_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if (board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE))\n    black_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if (board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK))\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    'Evaluates the sum of the distances from all pieces to the back rank.'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        distance_to_back_rank = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n        total_distance += distance_to_back_rank\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    shared_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(shared_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of uncovered squares (not attacked or defended) for both colors.\"\n    total_uncovered = 0\n    for rank in range(8):\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is None:\n                if not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n                    total_uncovered += 1\n    return float(total_uncovered)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces placed in the back rank for both players.\"\n    back_rank_count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and (piece.color == chess.WHITE and chess.square_rank(square) == 0 or \n                      piece.color == chess.BLACK and chess.square_rank(square) == 7):\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks of all pieces for both players, giving higher importance to advanced pieces.\"\n    white_rank_sum = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are doubled pawns for both players.\"\n    doubles = 0\n    files = {}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if file_index in files:\n                doubles += 1\n            else:\n                files[file_index] = []\n            files[file_index].append(square)\n    return float(doubles)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available for each side and returns the difference.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    black_moves = len(list(board.legal_moves) if not board.turn else [])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pawns are doubled for each player\"\n    white_doubled = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 1)).color == chess.WHITE and board.piece_at(chess.square(file, 2)) and board.piece_at(chess.square(file, 2)).color == chess.WHITE)\n    black_doubled = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) and board.piece_at(chess.square(file, 6)).color == chess.BLACK and board.piece_at(chess.square(file, 5)) and board.piece_at(chess.square(file, 5)).color == chess.BLACK)\n    \n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the density of pieces in the center of the board for both players.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5, chess.E3, chess.E6, chess.D3, chess.D6]\n    white_density = sum(1 for square in center_squares if board.piece_at(square) and \n                        board.piece_at(square).color == chess.WHITE)\n    black_density = sum(1 for square in center_squares if board.piece_at(square) and \n                        board.piece_at(square).color == chess.BLACK)\n    \n    return float(white_density - black_density)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of controlled squares by both players and returns the difference.\"\n    controlled_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    controlled_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked but not defended by any piece of the current player.\"\n    attacked_unprotected = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square) and \n                                not any(board.is_attacked_by(not board.turn, square) for square in board.attackers(not board.turn, square)))\n    return float(attacked_unprotected)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces across the 4th rank for both players to assess control of the board.'\n    pieces_on_fourth_rank = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and chess.square_rank(square) == 3:  # 4th rank, zero-indexed\n            pieces_on_fourth_rank += 1\n    return float(pieces_on_fourth_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns to their respective promotion ranks.\"\n    total_pawn_distance = sum(7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_pawn_distance)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of protected pieces for the current player.'\n    protected_count = sum(1 for sq, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK)\n                          and len(board.attackers(piece.color, sq)) > 0)\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by pieces of each color.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their respective back ranks, emphasizing advancement.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            total_distance += (7 - rank)  # Distance to back rank for White\n        else:\n            total_distance += rank  # Distance to back rank for Black\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are attacked but not defended by either side.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if (board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square)) or \\\n           (board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square)):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares in each player's attacking range that are unoccupied.\"\n    unoccupied_attacks = sum(1 for move in board.legal_moves if not board.piece_at(move.to_square))\n    return float(unoccupied_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently unprotected by their own pieces, indicating vulnerability.\"\n    unprotected_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            piece_protected = any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(not board.turn, square))\n            if not piece_protected:\n                unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pawns on the board; higher ranks indicate advancement potential.\"\n    pawn_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can deliver check on the opponent's king.\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not board.turn, board.king(not board.turn)):\n                    count += 1\n                    break\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces to the opposing side's back rank for both players.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) - (0 if piece.color == chess.WHITE else 7)\n        total_distance += abs(distance)\n        piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the seventh rank for both sides.\"\n    seventh_rank_count = 0\n    for square in range(48, 56):  # Squares a7-h7 (seventh rank for White)\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            seventh_rank_count += 1\n    for square in range(8, 16):  # Squares a2-h2 (seventh rank for Black)\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            seventh_rank_count += 1\n    return float(seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are closer to the opponent's king than their own king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_opponent_king = sum(\n        chess.square_distance(square, black_king_square) for square in board.piece_map()\n    )\n    distance_to_own_king = sum(\n        chess.square_distance(square, white_king_square) for square in board.piece_map()\n    )\n    return float(distance_to_opponent_king - distance_to_own_king)", "def feature(board: chess.Board) -> float:\n    'Calculates the cumulative rank of pieces that are in their advanced positions (past the 4th rank).'\n    advanced_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) > 3)\n    return float(advanced_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total ranks of pieces for both colors.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of total checks a player can deliver on their next turn.\"\n    check_count = sum(1 for move in board.legal_moves if board.is_check() == False and board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of each side\u2019s pawns to their respective back ranks.'\n    white_pawn_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in the first three ranks for each player.\"\n    rank_count = sum(1 for square in range(0, 24) if board.piece_at(square) is not None)\n    return float(rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to their respective back ranks.\"\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map().keys())\n    piece_count = len(board.piece_map())\n    return total_distance / (piece_count + 1)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available for each color and returns their difference.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    legal_moves_black = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for the current player; higher ranks indicate greater advancement.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the closest opponent's king to all pieces of the current player.\"\n    current_player = chess.WHITE if board.turn else chess.BLACK\n    opponent_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != current_player)\n    distances = [chess.square_distance(sq, opponent_king_square) for sq, p in board.piece_map().items() if p.color == current_player]\n    return float(sum(distances))", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the ranks of pawns for both sides to assess promotion potential.\"\n    white_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the current player that are also attacked by the opponent.\"\n    controlled_squares = [square for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.is_attacked_by(board.turn, square)]\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 7th rank for both players.\"\n    white_seventh_rank = sum(1 for sq in chess.SQUARES[56:64] if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_seventh_rank = sum(1 for sq in chess.SQUARES[48:56] if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure quality by counting the number of pawn pairs (pawns on adjacent files).\"\n    pawn_files = [0] * 8\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n            \n    pawn_pairs = sum(1 for count in pawn_files if count > 1)\n    return float(pawn_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces from their respective back ranks.\"\n    distance_from_back_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_from_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are both attacked and defended by the current player's pieces.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and board.piece_map().get(square) is not None)\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the current player\u2019s pieces to the opponent\u2019s back rank.'\n    opponent_back_rank = chess.A8 if board.turn == chess.WHITE else chess.A1\n    distance_sum = sum(chess.square_distance(square, opponent_back_rank) \n                       for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances from each piece to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK) if board.turn else next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of checks available for the opponent on the next move.\"\n    opponent_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            opponent_checks += 1\n        board.pop()\n\n    return float(opponent_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of times pieces move towards one player's back rank versus the other.\"\n    movement_towards_back_rank = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            movement_towards_back_rank += chess.square_rank(square)\n    return float(movement_towards_back_rank)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in distances of each side\u2019s pawns from their respective back ranks.'\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances from the center of the board for all pieces.\"\n    center_square = [chess.D4, chess.D5, chess.E4, chess.E5]\n    def center_distance(color):\n        return sum(chess.square_distance(sq, center_sq) for sq in board.piece_map() if board.piece_map()[sq].color == color for center_sq in center_square)\n\n    white_distance = center_distance(chess.WHITE)\n    black_distance = center_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the balance of total material values between both sides.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces occupying the back ranks, indicating defensive capabilities.'\n    pieces_on_back_rank = sum(1 for square, piece in board.piece_map().items() \n                               if (piece.color == chess.WHITE and chess.square_rank(square) == 0) or \n                               (piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    )\n    return float(pieces_on_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by subtracting the total value of the opponent's pieces from the current player's pieces.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for both sides.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces positioned on squares that can promote.\"\n    promote_squares = [chess.parse_square(sq) for sq in ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']]\n    promote_count = 0\n\n    for square, piece in board.piece_map().items():\n        if square in promote_squares:\n            promote_count += 1\n\n    return float(promote_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    occupied_squares = set(square for square in board.piece_map().keys())\n    return float(len(occupied_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has on the opponent's side of the board.\"\n    white_pawns = sum(1 for sq, piece in board.piece_map().items() \n                      if piece.color == chess.WHITE and chess.square_rank(sq) >= 5)\n    black_pawns = sum(1 for sq, piece in board.piece_map().items() \n                      if piece.color == chess.BLACK and chess.square_rank(sq) <= 2)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value comparison excluding pawns for both sides.\"\n    material_value = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n    }\n    white_material = sum(material_value.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_material = sum(material_value.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    if opponent_king_square is None:\n        return 0.0\n\n    attack_count = sum(1 for square in board.piece_map() if (\n        board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, opponent_king_square)))\n\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the back ranks of each player.\"\n    white_back_rank_attacks = 0\n    black_back_rank_attacks = 0\n    for square in range(56, 64):  # Back rank squares (8th rank for White)\n        if board.is_attacked_by(chess.WHITE, square):\n            white_back_rank_attacks += 1\n    for square in range(0, 8):  # Back rank squares (1st rank for Black)\n        if board.is_attacked_by(chess.BLACK, square):\n            black_back_rank_attacks += 1\n    return float(white_back_rank_attacks - black_back_rank_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by multiple opponents.\"\n    multiple_attacks = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.is_attacked_by(chess.WHITE, square):\n            if len(board.attackers(chess.WHITE, square)) > 1:\n                multiple_attacks += 1\n        elif board.piece_at(square) and board.is_attacked_by(chess.BLACK, square):\n            if len(board.attackers(chess.BLACK, square)) > 1:\n                multiple_attacks += 1\n    return float(multiple_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board that are in their optimal development squares.\"\n    optimal_squares = {\n        chess.WHITE: [chess.B1, chess.C1, chess.F1, chess.G1, chess.E1, chess.E2, chess.D2, chess.C2, chess.B2, chess.A2],\n        chess.BLACK: [chess.B8, chess.C8, chess.F8, chess.G8, chess.E8, chess.E7, chess.D7, chess.C7, chess.B7, chess.A7]\n    }\n    \n    optimal_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and square in optimal_squares[piece.color]:\n            optimal_count += 1\n    \n    return float(optimal_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the sum of distances of all pieces to the opponent's king as an indicator of threat level.\"\n    opponent_king_square = board.king(not board.turn)\n    distance_sum = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces each side has on the board.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not board.turn, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance from all pieces to the opponent's king.\"\n    distance_sum = sum(chess.square_distance(square, chess.parse_square('e8' if board.turn == chess.WHITE else 'e1')) for square, piece in board.piece_map().items() if piece.color != board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns to the promotion ranks.\"\n    distance_sum = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            distance_sum += 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by both the current player and the opponent.\"\n    controlled_by_both = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            controlled_by_both += 1\n    return float(controlled_by_both)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces attacking the opponent's king to total pieces on the board.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    total_pieces = len(board.piece_map())\n    return float(attacking_pieces) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares controlled by pieces of each color.\"\n    controlled_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each side's pieces.\"\n    white_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_squares - black_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the sum of ranks of all pieces for both sides as a measure of activity.'\n    total_rank_sum = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) is not None)\n    return float(total_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the opponent's pieces are positioned, but not attacked by any of the current player's pieces.\"\n    unattacked_opponent_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            unattacked_opponent_squares += 1\n            \n    return float(unattacked_opponent_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in piece mobility for both sides based on the number of legal moves available.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns from their respective promotion ranks.\"\n    white_pawn_distance = sum(8 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks for each piece's position for both players, where higher ranks suggest advanced pieces.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by both sides' pieces.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces on the second rank for both players.\"\n    material_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and (chess.square_rank(square) == 1 or chess.square_rank(square) == 6):\n            material_value += piece_values[piece.piece_type]\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pawns from their respective promotion ranks.\"\n    total_distance = sum(chess.square_distance(square, chess.square_rank(7 if piece.color == chess.WHITE else 0)) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of remaining pieces for both sides.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value_white = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    'Counts the number of forks possible by each player based on their pieces positions.'\n    forks_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        attacked_squares = []\n        for target_move in board.legal_moves:\n            attacked_squares.append(target_move.to_square)\n        if len(set(attacked_squares)) > 1:\n            forks_count += 1\n        board.pop()\n    return float(forks_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can directly attack the opponent's king.\"\n    attacking_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == (chess.WHITE if board.turn else chess.BLACK) and board.is_attacked_by((chess.WHITE if board.turn else chess.BLACK), chess.KING))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece activity by summing the possible legal moves for all pieces.\"\n    total_legal_moves = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's pieces.\"\n    attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pieces facing off against each other.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        if board.piece_at(square):\n            controlled_squares.update(board.attackers(board.piece_at(square).color, square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces can deliver a check against the opponent's king.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_at(move.from_square).color == chess.WHITE)\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces locked in positions, indicating potential for exchange.\"\n    locked_pieces = sum(1 for sq in board.piece_map() if len(board.attackers(board.piece_at(sq).color, sq)) > 0)\n    return float(locked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for piece_square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(piece_square, opponent_king_square)\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to their closest pawn for both players.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_distance_to_pawn = min([chess.square_distance(white_king_square, sq) for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE], default=0)\n    black_distance_to_pawn = min([chess.square_distance(black_king_square, sq) for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK], default=0)\n    return float(white_distance_to_pawn - black_distance_to_pawn)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pieces' ranks to assess the distribution of pieces across the board.\"\n    rank_difference = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE:\n            rank_difference += chess.square_rank(square)\n        else:\n            rank_difference -= chess.square_rank(square)\n    return rank_difference", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective back ranks.\"\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the density of pieces on the board by counting the number of pieces per rank.'\n    pieces_count_per_rank = [sum(1 for square in range(rank * 8, (rank + 1) * 8) if board.piece_at(square) is not None) for rank in range(8)]\n    return float(sum(pieces_count_per_rank) / 8)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares where a pawn can potentially promote for both players.'\n    white_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces that are on the board versus those off.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    current_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(current_material - opponent_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the ranks of both players' pieces to assess advancement.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares from which the current player can threaten the opponent\u2019s king.'\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    threat_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            threatened_squares = board.legal_moves\n            for move in threatened_squares:\n                if move.to_square == king_square:\n                    threat_squares.add(square)\n    return float(len(threat_squares))", "def feature(board: chess.Board) -> float:\n    'Measures the total cumulative rank of pieces that are in advanced positions (4th rank or beyond).'\n    total_rank = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_rank(square) >= 3:\n            total_rank += chess.square_rank(square) + 1  # To convert 0-7 to 1-8\n\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    'Measures the total distance of all pieces to their respective nearest back rank.'\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the current player\u2019s pieces to the opponent\u2019s king'\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    \n    if opponent_king_square is None:\n        return 0.0\n\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_distance(square, opponent_king_square)\n\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of defending squares for the current player's pieces.\"\n    defending_squares_count = 0\n    piece_defense_positions = {}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    defended_square = move.to_square\n                    piece_defense_positions[defended_square] = piece_defense_positions.get(defended_square, 0) + 1\n                \n    defending_squares_count = len(piece_defense_positions.keys())\n    return float(defending_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by the current player's pieces that are not in their optimal squares.\"\n    mispositioned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) < 4:\n            mispositioned_count += 1\n    return float(mispositioned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns to the promotion square for each player.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the advanced ranks between both players' pieces.\"\n    white_advanced_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced_ranks - black_advanced_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the average ranks of the pieces for both players.\"\n    white_avg_rank = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE) / max(1, len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE]))\n    black_avg_rank = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK) / max(1, len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK]))\n    return float(white_avg_rank - black_avg_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are directly adjacent to the enemy king.\"\n    enemy_king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING and piece.color == (not board.turn):\n            enemy_king_square = square\n            break\n    if enemy_king_square is None:\n        return 0.0\n    adjacent_squares_count = sum(1 for sq in chess.SQUARES if chess.square_distance(sq, enemy_king_square) == 1)\n    return float(adjacent_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opposing pieces that are attacking blocks to the current player.\"\n    opposing_threat_count = 0\n    for square in range(64):\n        if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is None:\n            opposing_threat_count += 1\n    return float(opposing_threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by the current player's pawns.\"\n    controlled_by_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            controlled_by_pawns += len(list(board.attackers(piece.color, square)))\n    return float(controlled_by_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the 2nd rank (for White) or 7th rank (for Black).\"\n    pieces_on_second_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 1 and board.piece_at(square).color == chess.WHITE)\n    pieces_on_seventh_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 6 and board.piece_at(square).color == chess.BLACK)\n    return pieces_on_second_rank - pieces_on_seventh_rank", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the distance of all pawns from their respective promotion ranks.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the sum of ranks of all pieces for both players.\"\n    rank_sum_white = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    rank_sum_black = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(rank_sum_white - rank_sum_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in play that are obstructing each other's movement.\"\n    obstructed_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for square_two in board.piece_map():\n                if square != square_two and piece.color == board.piece_map()[square_two].color:\n                    if chess.square_distance(square, square_two) == 1:\n                        obstructed_count += 1\n    return float(obstructed_count // 2)  # Each obstruction counted twice", "def feature(board: chess.Board) -> float:\n    \"Counts the number of vulnerable pieces (attacked but unprotected).\"\n    vulnerable_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square) and not any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(not board.turn, square)):\n                vulnerable_count += 1\n    return float(vulnerable_count)"], "all_features": ["def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for both sides.\"\n    material_count = sum(1 for piece in board.piece_map().values())\n    return float(material_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures on the board.\"\n    pawn_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    double_pawns = sum(1 for file in range(8) if len([p for p in pawn_positions if chess.square_file(p) == file]) > 1)\n    return float(double_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of defending pieces each side has.\"\n    defending_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if either player's king is in check.\"\n    in_check = float(board.is_check())\n    return in_check", "def feature(board: chess.Board) -> float:\n    \"Calculates the distribution of pieces across the board based on ranks.\"\n    rank_distribution = [0] * 8\n    for square, piece in board.piece_map().items():\n        rank_distribution[chess.square_rank(square)] += 1\n    return float(max(rank_distribution))", "def feature(board: chess.Board) -> float:\n    \"Analyzes the safety of the king based on the number of squares it can escape to.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    escape_squares = sum(1 for move in board.legal_moves if chess.square_distance(king_square, move.to_square) == 1)\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of backward pawns present on the board.\"\n    backward_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if (chess.square_rank(square) < 7 and \n                    (board.piece_at(chess.square(chess.square_file(square), chess.square_rank(square) + 1)) is None) and \n                    any(board.piece_at(chess.square(f, chess.square_rank(square))) for f in range(chess.square_file(square) - 1, chess.square_file(square) + 2) if f >= 0 and f <= 7)):\n                    backward_pawn_count += 1\n            else:\n                if (chess.square_rank(square) > 0 and \n                    (board.piece_at(chess.square(chess.square_file(square), chess.square_rank(square) - 1)) is None) and \n                    any(board.piece_at(chess.square(f, chess.square_rank(square))) for f in range(chess.square_file(square) - 1, chess.square_file(square) + 2) if f >= 0 and f <= 7)):\n                    backward_pawn_count += 1\n    return float(backward_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of pieces each side has.\"\n    result = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE) - \\\n             sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of pawns each side has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player to move.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of threats to the player's pieces.\"\n    threats = sum(len(board.attackers(not board.turn, square)) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the count of isolated pawns for the player to move.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    isolated_count = sum(1 for sq in pawns if (chess.square_file(sq) == 0 or board.piece_at(sq - 1) is None) and \n                                                  (chess.square_file(sq) == 7 or board.piece_at(sq + 1) is None))\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the player's king is in check or checkmate.\"\n    if board.is_checkmate():\n        return -1.0\n    elif board.is_check():\n        return 0.5\n    return 1.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces for each color.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by each color.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacks on pieces.\"\n    double_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            attacking_squares = board.attackers(not piece.color, square)\n            if len(attacking_squares) > 1:\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Scores the number of pieces pinned to a king.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and board.is_attacked_by(not piece.color, square):\n            if board.is_check() or board.is_checkmate():\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting potential legal moves.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map())\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently undefended.\"\n    undefended_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and not board.attackers(piece.color, square):\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of attackers near the king.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    return float(black_king_attacks - white_king_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for each side.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            return all(board.piece_at(front_square) is None for front_square in range(square + 8, 64) if chess.square_file(square) == chess.square_file(front_square))\n        else:\n            return all(board.piece_at(back_square) is None for back_square in range(square - 8, -1, -8) if chess.square_file(square) == chess.square_file(back_square))\n\n    white_passed = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and is_passed_pawn(square, chess.WHITE))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and is_passed_pawn(square, chess.BLACK))\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of legal moves available to each color.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return white_moves - black_moves", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_map()[sq].color == board.turn)\n    piece_count = len([sq for sq in board.piece_map() if board.piece_map()[sq].color == board.turn])\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of defending pieces surrounding the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    defenders = sum(1 for sq in board.attackers(board.turn, opponent_king_square))\n    return float(defenders)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the board for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the player's pieces.\"\n    attacked_squares = sum(1 for sq in range(64) if board.is_attacked_by(board.turn, sq))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of the player's king to the center of the board.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_distance = min(chess.square_distance(king_square, sq) for sq in center_squares)\n    return float(8 - center_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of piece types on the board for the current player.\"\n    piece_types = set(piece.piece_type for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(len(piece_types))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal checkmate threats for the current player.\"\n    threats = sum(1 for move in board.legal_moves if board.is_checkmate() is False and board.is_check() is False)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material balance of pieces (based on standard values).\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by each side's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled (attacked) by each color.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        attackers = board.attackers(board.piece_map()[square].color, square)\n        controlled_squares.update(attackers)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn else 0\n    opponent_piece_count = sum(1 for square in range(8) if board.piece_at(chess.square(square, opponent_back_rank)) is not None)\n    return float(opponent_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces that are currently pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if board.is_attacked_by(not piece.color, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK))\n    center_distance = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('d4'))\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn structure by counting isolated pawns.\"\n    isolated_pawn_count = 0\n    for square in range(8):\n        if board.piece_at(chess.square(square, 1)) == chess.PAWN and (board.piece_at(chess.square(square - 1, 1)) is None and board.piece_at(chess.square(square + 1, 1)) is None):\n            isolated_pawn_count += 1\n        if board.piece_at(chess.square(square, 6)) == chess.PAWN and (board.piece_at(chess.square(square - 1, 6)) is None and board.piece_at(chess.square(square + 1, 6)) is None):\n            isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within two ranks of the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == (chess.WHITE if not board.turn else chess.BLACK))\n    count = sum(1 for square in board.piece_map() if chess.square_rank(square) in range(chess.square_rank(opponent_king_square) - 1, chess.square_rank(opponent_king_square) + 2))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks each side can deliver this turn.\"\n    checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            checks += 1\n        board.pop()\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by both kings.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_attacks + black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of queens from the opposing king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_queen_square = next((square for square, piece in board.piece_map().items() \n                                if piece.piece_type == chess.QUEEN and piece.color == chess.WHITE), None)\n    black_queen_square = next((square for square, piece in board.piece_map().items() \n                                if piece.piece_type == chess.QUEEN and piece.color == chess.BLACK), None)\n    white_distance = chess.square_distance(white_queen_square, black_king_square) if white_queen_square else 0\n    black_distance = chess.square_distance(black_queen_square, white_king_square) if black_queen_square else 0\n    return float(white_distance + black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates mobility as the total number of legal moves available to both sides.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Proportion of the entire board that is attacked by pieces of each color.\"\n    total_attacked = 0\n    attacked_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares) / 64)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king on both sides.\"\n    pinned = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square):\n            pinned += 1\n        elif piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square):\n            pinned += 1\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the ratio of pieces actively participating in offense vs total pieces.\"\n    offensive_pieces = sum(1 for square, piece in board.piece_map().items()\n                            if piece.color == board.turn and piece.piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT})\n    total_pieces = len(board.piece_map())\n    return float(offensive_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of all pieces that are currently not defending other pieces.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    undefended_value = 0.0\n    for square, piece in board.piece_map().items():\n        if not any(board.is_attacked_by(board.turn, attacked_square)\n                   for attacked_square in board.attackers(piece.color, square)):\n            undefended_value += piece_values.get(piece.piece_type, 0)\n    return undefended_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's pieces.\"\n    attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and board.is_attacked_by(board.turn, square):\n            attacks += 1\n    return float(attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player's pieces.\"\n    controlled_squares = set()\n    for (square, piece) in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the nearest opponent's king.\"\n    own_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    return float(chess.square_distance(own_king_square, opponent_king_square))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks each player can deliver in one move.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each side has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the total value of pieces for each side and returns the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered checks available.\"\n    discovered_checks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type in {chess.ROOK, chess.BISHOP, chess.QUEEN}:\n            for target_square in chess.SQUARES:\n                if target_square != square and board.is_attacked_by(not board.turn, target_square):\n                    discovered_checks += 1\n                    break\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in {chess.ROOK, chess.QUEEN}:\n                    if board.is_attacked_by(not board.turn, square):\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Returns 1.0 if the board is in a vulnerable position (like check or checkmate), otherwise 0.0.\"\n    if board.is_check() or board.is_checkmate():\n        return 1.0\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting the number of adjacent squares that are not attacked.\"\n    own_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    safe_squares = 0\n    for offset in chess.SQUARES:  # Considering the 8 surrounding squares\n        if 0 <= own_king_square + offset < 64 and not board.is_attacked_by(not board.turn, own_king_square + offset):\n            safe_squares += 1\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both sides.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all opponent pieces to the king of the current player.\"\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    \n    opponent_pieces = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn]\n    distances = [chess.square_distance(king_square, sq) for sq in opponent_pieces]\n    \n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both sides.\"\n    def is_isolated_pawn(square):\n        file = chess.square_file(square)\n        return (board.piece_at(square) == chess.PAWN and\n                (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                 board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None))\n\n    white_isolated = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and is_isolated_pawn(sq))\n    black_isolated = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and is_isolated_pawn(sq))\n    \n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the material advantage based on piece types excluding kings.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900}  # King is not counted\n    white_value = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_value = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    \n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of passing pawns for both sides.\"\n    def is_passing_pawn(square, color):\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if color == chess.WHITE:\n            return (board.piece_at(square) == chess.PAWN and\n                    all(board.piece_at(chess.square(file, r)) is None for r in range(rank + 1, 8)) and\n                    all(board.piece_at(chess.square(file - 1, r)) is None for r in range(0, 8)) and\n                    all(board.piece_at(chess.square(file + 1, r)) is None for r in range(0, 8)))\n        else:\n            return (board.piece_at(square) == chess.PAWN and\n                    all(board.piece_at(chess.square(file, r)) is None for r in range(0, rank)) and\n                    all(board.piece_at(chess.square(file - 1, r)) is None for r in range(0, 8)) and\n                    all(board.piece_at(chess.square(file + 1, r)) is None for r in range(0, 8)))\n\n    white_passing = sum(1 for sq in board.piece_map() if is_passing_pawn(sq, chess.WHITE))\n    black_passing = sum(1 for sq in board.piece_map() if is_passing_pawn(sq, chess.BLACK))\n    \n    return float(white_passing - black_passing)", "def feature(board: chess.Board) -> float:\n    \"Computes the threat level measured by pieces attacking the opponent's pieces.\"\n    threat_level = sum(1 for sq in board.piece_map() if board.attackers(not board.turn, sq) != set())\n    return float(threat_level)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by each side's pieces.\"\n    white_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_squares - black_squares)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacked squares by each side's pieces.\"\n    attacked_by_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    attacked_by_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = float(attacked_by_white - attacked_by_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the distance (in squares) of the closest king to the opponent's pieces.\"\n    my_king_square = [sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == board.turn]\n    opponent_pieces = [sq for sq, p in board.piece_map().items() if p.color != board.turn]\n\n    if not my_king_square or not opponent_pieces:\n        return 0.0\n\n    min_distance = min(chess.square_distance(my_king_square[0], sq) for sq in opponent_pieces)\n    result = float(min_distance)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are certain types (e.g., rooks) remaining on the board.\"\n    total_rooks = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.ROOK)\n    result = float(total_rooks)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value for pieces on the board.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_material = sum(material_values[p.piece_type] for p in board.piece_map().values())\n    result = float(total_material)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks each player can deliver with their current pieces.\"\n    checks_by_white = sum(1 for move in board.legal_moves if board.is_check() and board.turn == chess.WHITE)\n    checks_by_black = sum(1 for move in board.legal_moves if board.is_check() and board.turn == chess.BLACK)\n    result = float(checks_by_white - checks_by_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the control of critical squares (like the center of the board) by pieces of each color.\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    result = float(white_control - black_control)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that have more than one piece attacking them.\"\n    double_attacked_squares = sum(1 for square in chess.SQUARES if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    result = float(double_attacked_squares)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential mating sequences based on available legal moves.\"\n    mating_sequences = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            mating_sequences += 1\n        board.pop()\n    return float(mating_sequences)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control between both sides.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in central_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in central_squares)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of isolated pawns for each side.\"\n    def is_isolated_pawn(square):\n        file = chess.square_file(square)\n        return not (board.piece_at(square - 1) and chess.square_file(square - 1) == file - 1) and \\\n               not (board.piece_at(square + 1) and chess.square_file(square + 1) == file + 1)\n\n    isolated_white = sum(1 for sq in chess.SQUARES if board.piece_at(sq) == chess.PAWN and board.piece_at(sq).color == chess.WHITE and is_isolated_pawn(sq))\n    isolated_black = sum(1 for sq in chess.SQUARES if board.piece_at(sq) == chess.PAWN and board.piece_at(sq).color == chess.BLACK and is_isolated_pawn(sq))\n    return float(isolated_white - isolated_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the mobility of each side, defined as the number of legal moves available.\"\n    white_mobility = len(list(board.legal_moves))\n    board.turn = chess.BLACK\n    black_mobility = len(list(board.legal_moves))\n    board.turn = chess.WHITE\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces to the opponent's back rank.\"\n    def distance_to_back_rank(color):\n        total_distance = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                total_distance += (7 - chess.square_rank(square)) if color == chess.WHITE else chess.square_rank(square)\n        return total_distance\n\n    white_distance = distance_to_back_rank(chess.WHITE)\n    black_distance = distance_to_back_rank(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on both sides that are pinned.\"\n    def is_pinned(piece_color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == piece_color:\n                for opponent_square in board.attackers(not piece_color, square):\n                    if board.piece_at(opponent_square).piece_type == chess.KING:\n                        continue\n                    if board.is_attacked_by(piece_color, opponent_square):\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    pinned_white = is_pinned(chess.WHITE)\n    pinned_black = is_pinned(chess.BLACK)\n    return float(pinned_white - pinned_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the board.\"\n    piece_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        piece_counts[piece.color] += 1\n    return float(piece_counts[chess.WHITE] - piece_counts[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the stability of the king positions based on the number of surrounding pieces.\"\n    def king_stability(color):\n        king_sq = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        surrounding_piece_count = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and chess.square_distance(king_sq, sq) == 1)\n        return surrounding_piece_count\n\n    white_stability = king_stability(chess.WHITE)\n    black_stability = king_stability(chess.BLACK)\n    return float(white_stability - black_stability)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            total_distance += chess.square_distance(square, king_square)\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Computes the difference in material value between attackers and defenders.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                       chess.ROOK: 500, chess.QUEEN: 900}\n    attackers_value = sum(material_values.get(piece.piece_type, 0) \n                           for square, piece in board.piece_map().items() \n                           if piece.color != board.turn and board.is_attacked_by(board.turn, square))\n    defenders_value = sum(material_values.get(piece.piece_type, 0) \n                           for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and board.is_attacked_by(board.turn, square))\n    return float(attackers_value - defenders_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage based on the side that has more pieces.\"\n    white_material = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_material = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares protected by each color's pieces.\"\n    protected_squares = set()\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square:\n                protected_squares.add(move.to_square)\n    return float(len(protected_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure between both sides.\"\n    white_pawn_structure = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'{chr(97 + square)}2')) == chess.PAWN)\n    black_pawn_structure = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'{chr(97 + square)}7')) == chess.PAWN)\n    return float(white_pawn_structure - black_pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are double-attacked.\"\n    double_attacked_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            double_attacked_count += 1\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are unprotected.\"\n    unprotected_enemy_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            unprotected_enemy_count += 1\n    return float(unprotected_enemy_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns each side has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of king safety positions, defined as squares not attacked by opponent pieces.\"\n    safe_squares = 0\n    for square in range(64):\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING:\n            if not board.is_attacked_by(not board.piece_at(square).color, square):\n                safe_squares += 1\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are attacking the opponent's king.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has that are undefended.\"\n    undefended_pieces = 0\n    for square, piece in board.piece_map().items():\n        if not board.attackers(piece.color, square):\n            undefended_pieces += 1\n    return float(undefended_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board based on a weighted material count.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the fifth rank for both sides.\"\n    white_count = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 4 and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_count = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 4 and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the center control based on the number of pieces on d4, e4, d5, and e5.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    control_score = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE) - \\\n                    sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the symmetry of pieces on the board as a measure of imbalance.\"\n    white_positions = [chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE]\n    black_positions = [chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK]\n    symmetry_score = abs(len(set(white_positions)) - len(set(black_positions)))\n    return float(symmetry_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the kings to each other.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is None or black_king is None:\n        return 0.0\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each side has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total potential mobility of all pieces based on their possible moves.\"\n    total_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(total_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that are defended versus those that are attacked.\"\n    defended = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    attacked = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(piece.color, square))\n    return float(defended - attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are controlled by both sides.\"\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the relative attacking potential based on the pieces attacking the enemy king.\"\n    white_attacks = len(board.attackers(chess.WHITE, board.king(chess.BLACK))) if board.king(chess.BLACK) else 0\n    black_attacks = len(board.attackers(chess.BLACK, board.king(chess.WHITE))) if board.king(chess.WHITE) else 0\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their respective kings.\"\n    pinned = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square) and (board.is_check() or board.is_attacked_by(chess.WHITE, board.king(chess.WHITE))):\n            pinned += 1\n        elif piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square) and (board.is_check() or board.is_attacked_by(chess.BLACK, board.king(chess.BLACK))):\n            pinned += 1\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    \"Measures the development of pieces based on their distance from the back rank.\"\n    developed_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) > 5:\n            developed_pieces += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) < 2:\n            developed_pieces += 1\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by pawns for each side.\"\n    white_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None and board.piece_map().get(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    black_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None and board.piece_map().get(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the King to the center of the board for each side.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        white_distance = chess.square_distance(white_king_square, chess.E4)\n        black_distance = chess.square_distance(black_king_square, chess.E4)\n        return float(black_distance - white_distance)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of undefended pieces for both sides.\"\n    white_undefended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and all(not board.is_attacked_by(chess.BLACK, square) for attacker in board.attackers(chess.BLACK, square)))\n    black_undefended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and all(not board.is_attacked_by(chess.WHITE, square) for attacker in board.attackers(chess.WHITE, square)))\n    return float(white_undefended - black_undefended)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by the pieces of each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are out of play (not on the board).\"\n    total_pieces = 32  # 16 pieces for each side\n    total_present = len(board.piece_map())\n    return float(total_pieces - total_present)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on open files for each side.\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None and board.piece_at(chess.square(file, rank)).color == chess.WHITE))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None and board.piece_at(chess.square(file, rank)).color == chess.BLACK))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are double-attacked.\"\n    double_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(double_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have more than one square of movement available.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) > 1)\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of knights that are positioned on third rank or higher for both sides.\"\n    white_knights = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT and chess.square_rank(sq) >= 2)\n    black_knights = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT and chess.square_rank(sq) >= 2)\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of each side's remaining pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_pieces = len(board.piece_map())\n    return (white_value - black_value) / (total_pieces if total_pieces > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both sides and returns the difference.\"\n    def count_doubled_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            files[file] = files.get(file, 0) + 1\n        return sum(1 for count in files.values() if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of central control squares occupied by each side.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where pieces are pinned by the opponent.\"\n    pinned_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only check pieces of the current player\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type in [chess.ROOK, chess.QUEEN]: \n                    # Check if the attacker is in line with piece and king\n                    if board.is_attacked_by(piece.color, attacker):\n                        pinned_squares += 1\n                        break\n    return float(pinned_squares)", "def feature(board: chess.Board) -> float:\n    \"Computes the potential pawn promotion chances for both sides.\"\n    def promotion_squares(color):\n        if color == chess.WHITE:\n            return [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n        else:\n            return [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    \n    white_promotions = len([sq for sq in promotion_squares(chess.WHITE) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE])\n    black_promotions = len([sq for sq in promotion_squares(chess.BLACK) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK])\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of pawn structures for both sides.\"\n    pawn_structure = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                pawn_structure += 1 if square < chess.A7 else -1  # Favor more pawns in enemy territory\n            else:\n                pawn_structure += 1 if square > chess.A2 else -1\n    return float(pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of rooks by counting open files controlled.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files) * 100  # Weight the feature heavily based on open files for rooks", "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with a potential to promote.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7,\n                         chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    promotion_count = sum(1 for square in promotion_squares if board.piece_at(square) and \n                          board.piece_at(square).piece_type == chess.PAWN)\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of hanging pieces for both sides.\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            hanging_pieces += 1\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king from the center of the board.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            king_square = square\n            break\n    center_distance = chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.E5)\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by all pieces of each color.\"\n    control_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            color = board.piece_at(square).color\n            control_count[color] += len(list(board.attackers(not color, square)))\n    return float(control_count[chess.WHITE] - control_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of piece types for each side.\"\n    piece_types = [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]\n    white_count = sum(len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == pt]) for pt in piece_types)\n    black_count = sum(len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == pt]) for pt in piece_types)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns for each side.\"\n    white_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN)\n    black_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the piece coordination based on attacking pairs.\"\n    coordination_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            color = board.piece_at(square).color\n            for attacker in board.attackers(not color, square):\n                if board.piece_at(attacker) is not None and board.piece_at(attacker).color == color:\n                    coordination_count += 1\n    return float(coordination_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king's safety by counting the number of squares around the king that are attacked.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING)\n    unsafe_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.piece_at(king_square).color, square) and chess.square_distance(king_square, square) <= 1)\n    return float(unsafe_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of potential checks available.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each side has that are not currently defended.\"\n    white_unprotected = sum(board.piece_at(sq).piece_type for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and len(board.attackers(chess.BLACK, sq)) == 0)\n    black_unprotected = sum(board.piece_at(sq).piece_type for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and len(board.attackers(chess.WHITE, sq)) == 0)\n    return float(white_unprotected - black_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both sides.\"\n    attacked_squares = set()\n    for sq in range(64):\n        if board.is_attacked_by(chess.WHITE, sq) and board.is_attacked_by(chess.BLACK, sq):\n            attacked_squares.add(sq)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    total_distance = 0.0\n    piece_count = 0\n    for sq in board.piece_map():\n        total_distance += chess.square_distance(sq, chess.parse_square('e4'))  # center roughly e4\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of 'pinned' pieces for both players.\"\n    pinned = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == chess.WHITE:\n            for target in board.legal_moves:\n                if target.from_square == sq and board.is_check():\n                    pinned += 1\n        else:\n            for target in board.legal_moves:\n                if target.from_square == sq and board.is_check():\n                    pinned += 1\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces for each side.\"\n    total_pieces = len(board.piece_map())\n    active_white_pieces = len([1 for m in board.legal_moves if board.piece_at(m.from_square).color == chess.WHITE])\n    active_black_pieces = len([1 for m in board.legal_moves if board.piece_at(m.from_square).color == chess.BLACK])\n    ratio = (active_white_pieces / total_pieces) - (active_black_pieces / total_pieces) if total_pieces > 0 else 0.0\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential pawn promotions for both sides.\"\n    white_promotions = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    black_promotions = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 1)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the average piece mobility based on potential moves of all pieces on the board.\"\n    total_moves = 0\n    piece_count = 0\n    for piece in board.piece_map().values():\n        moves = len(list(board.legal_moves))\n        total_moves += moves\n        piece_count += 1\n    return total_moves / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Computes the number of squares that have a higher number of attacking pieces than defending pieces.\"\n    imbalance_squares = 0\n    for sq in range(64):\n        attacker_count = len(board.attackers(chess.WHITE, sq)) + len(board.attackers(chess.BLACK, sq))\n        defender_count = len(board.attackers(chess.WHITE, sq)) if board.is_attacked_by(chess.BLACK, sq) else 0\n        if attacker_count > defender_count:\n            imbalance_squares += 1\n    return float(imbalance_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pieces to the opponent's king.\"\n    opponent_king = chess.KING if board.turn == chess.WHITE else chess.KING\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == opponent_king and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    distance_sum = sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are one move away from promotion.\"\n    promotable_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                           (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                           (piece.color == chess.BLACK and chess.square_rank(square) == 1))\n    return float(promotable_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares occupied by pawns for each side.\"\n    white_pawn_positions = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE)\n    black_pawn_positions = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pawn_positions - black_pawn_positions)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attackers = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of the pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = sum(chess.square_distance(square, cs) for square in board.piece_map() for cs in center_squares)\n    piece_count = len(board.piece_map())\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the concentration of pieces by calculating the number of pieces in the central 16 squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5, chess.C4, chess.C5, chess.F4, chess.F5, chess.D3, chess.D6, chess.E3, chess.E6, chess.C3, chess.C6, chess.F3, chess.F6]\n    central_piece_count = sum(1 for square in central_squares if square in board.piece_map())\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are in position to deliver a check next move.\"\n    check_potential = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_potential)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces threatening the opponent's pieces to total pieces on the board.\"\n    total_threats = sum(1 for square in board.piece_map() if board.attackers(board.piece_map()[square].color, square))\n    total_pieces = len(board.piece_map())\n    return float(total_threats / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces safely positioned versus those in danger.\"\n    safe_pieces = sum(1 for square in board.piece_map() if not board.is_attacked_by(not board.piece_map()[square].color, square))\n    threatened_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_map()[square].color, square))\n    return float(safe_pieces - threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material difference, assigning higher weights to pieces closer to promotion.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opponent's king.\"\n    king_square = None\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.KING and piece.color == chess.WHITE and board.turn:\n            king_square = square\n        elif piece.piece_type == chess.KING and piece.color == chess.BLACK and not board.turn:\n            king_square = square\n    if king_square is None:\n        return 0.0\n    attack_count = len(board.attackers(not board.turn, king_square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in ranks of the highest pieces for each side.\"\n    white_highest = -1\n    black_highest = -1\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_highest = max(white_highest, chess.square_rank(square))\n        else:\n            black_highest = max(black_highest, chess.square_rank(square))\n    return float(white_highest - black_highest)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each side and returns the difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of pawns to the back rank of the opposite side.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                distance_sum += (7 - chess.square_rank(square))\n            else:\n                distance_sum += chess.square_rank(square)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each side's pieces.\"\n    white_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_squares - black_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares controlled by each side's pieces.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially reach the opponent's back rank.\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if (piece.piece_type == chess.PAWN and\n                ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or\n                 (piece.color == chess.BLACK and chess.square_rank(square) == 1))) or \\\n               (piece.piece_type in [chess.ROOK, chess.QUEEN] and \n                (chess.square_rank(square) == 7 or chess.square_rank(square) == 0)):\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces not contributing to attack.\"\n    inactive_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            inactive_count += 1\n    return float(inactive_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only consider the pieces of the side to move\n            if any(board.is_attacked_by(not piece.color, target_square) for target_square in board.attackers(piece.color, square)):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of each side's pieces to the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are only defended by a single piece.\"\n    single_defense_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) == 1:\n            single_defense_count += 1\n    return float(single_defense_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available to the opposing side.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the potential for promotion by counting pawns that are one move away.\"\n    pawn_count = 0\n    for square in range(8):  # Check only the second rank for white and seventh for black\n        if board.piece_at(chess.square(square, 1)) == chess.PAWN:\n            pawn_count += 1\n        if board.piece_at(chess.square(square, 6)) == chess.PAWN:\n            pawn_count += 1\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unguarded squares adjacent to the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    undefended_count = 0\n    for square in chess.SQUARES:\n        if chess.square_distance(square, king_square) == 1 and not board.is_attacked_by(board.turn, square):\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by their own pieces.\"\n    controlled_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn and any(board.is_attacked_by(piece.color, target_square) for target_square in board.attackers(piece.color, square)):\n            controlled_count += 1\n    return float(controlled_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are placed on their optimal ranks (for pawns).\"\n    optimal_ranks = {chess.WHITE: 6, chess.BLACK: 1}\n    optimal_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) == optimal_ranks[piece.color])\n    return float(optimal_count) ", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of discovered attacks available.\"\n    discovered_attack_count = 0\n    for move in board.legal_moves:\n        if board.gives_check(move):\n            discovered_attack_count += 1\n    return float(discovered_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks given by pieces on the board.\"\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece attacks without counting duplicates.\"\n    attacked_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their respective back ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)\n        else:\n            total_distance += 7 - chess.square_rank(square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces placed in the opponent's territory.\"\n    opponent_territory = {square for square in range(56, 64)} if board.turn else {square for square in range(0, 8)}\n    piece_count = sum(1 for square in opponent_territory if board.piece_at(square) is not None)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of the total number of pieces to the total moves available.\"\n    total_pieces = len(board.piece_map())\n    total_moves = len(list(board.legal_moves))\n    return float(total_pieces) / (total_moves if total_moves > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked from two or more different directions.\"\n    double_attacked_count = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) > 1:\n            double_attacked_count += 1\n        if board.is_attacked_by(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) > 1:\n            double_attacked_count += 1\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the average value of pieces on the board based on standard values.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    total_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values())\n    return float(total_value) / (len(board.piece_map()) if board.piece_map() else 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board that are attacking enemy pieces.\"\n    attacking_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attacking_piece_count += 1\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between defended squares for both colors.\"\n    defended_white = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is not None)\n    defended_black = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is not None)\n    return float(defended_white - defended_black)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on squares that are controlled by the opponent.\"\n    opponent_controlled_count = 0\n    for square in range(64):\n        if board.is_attacked_by(not board.turn, square) and board.piece_at(square):\n            opponent_controlled_count += 1\n    return float(opponent_controlled_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each side and returns the difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares occupied by pieces of each color.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of all knights on the board.\"\n    knight_value = sum(3 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    return float(knight_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of checks given by both players at the current position.\"\n    white_checks = 1.0 if board.is_check() and board.turn else 0.0\n    black_checks = 1.0 if board.is_check() and not board.turn else 0.0\n    return white_checks + black_checks", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the first two ranks.\"\n    white_pieces_on_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) < 2)\n    black_pieces_on_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) > 5)\n    return float(white_pieces_on_ranks - black_pieces_on_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of squares controlled by the side to move.\"\n    total_squares = 64.0\n    controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square))\n    return controlled_squares / total_squares", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within three squares of the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    close_pieces = sum(1 for square in board.piece_map() if chess.square_distance(square, opponent_king_square) <= 3)\n    return float(close_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unguarded enemy pieces on the board.\"\n    unguarded_enemy_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and not board.attackers(board.turn, square))\n    return float(unguarded_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's half of the board.\"\n    opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_rank(square) > 3)\n    return float(opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of material values of pieces on the back ranks of each side.\"\n    back_rank_values = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) == 0) or (piece.color == chess.BLACK and chess.square_rank(square) == 7):\n            back_rank_values += (1 if piece.piece_type == chess.PAWN else\n                                 3 if piece.piece_type in (chess.KNIGHT, chess.BISHOP) else\n                                 5 if piece.piece_type == chess.ROOK else\n                                 9 if piece.piece_type == chess.QUEEN else\n                                 0)\n    return float(back_rank_values)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the number of squares surrounding the king that are attacked.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    safety_score = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) <= 1:\n            safety_score += 1\n    return float(8 - safety_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces to the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn:\n            total_distance += chess.square_distance(square, opponent_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are threatened by enemy pieces.\"\n    attacked_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against their own king.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn:\n            for attacker_square in board.attackers(not board.turn, square):\n                if board.piece_at(attacker_square).piece_type in [chess.ROOK, chess.QUEEN]:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the opponent by summing the legal moves for all their pieces.\"\n    opponent_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == (not board.turn))\n    return float(opponent_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance weighted by the distances to the center of the board.\"\n    material_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            distance_to_center = abs(chess.square_file(square) - 3.5) + abs(chess.square_rank(square) - 3.5)\n            piece_value = 1 if piece.piece_type == chess.PAWN else 3 if piece.piece_type in [chess.KNIGHT, chess.BISHOP] else 5 if piece.piece_type == chess.ROOK else 9\n            material_count += piece_value / (1 + distance_to_center) * (1 if piece.color == board.turn else -1)\n    return float(material_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of different piece types for each side that are present on the board.\"\n    white_types = set()\n    black_types = set()\n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_types.add(piece.piece_type)\n        else:\n            black_types.add(piece.piece_type)\n    return float(len(white_types) - len(black_types))", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for both sides; higher rank means more influence.\"\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square) + 1  # +1 for 1-8 rank representation\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each side has on the 7th and 8th ranks, indicating potential promotion.\"\n    promotion_threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) == 6:\n            promotion_threats += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) == 7:\n            promotion_threats += 1\n    return float(promotion_threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available for the side to move, indicating mobility.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by opponent's pieces, indicating control of the board.\"\n    occupied_squares = sum(1 for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares in the opponent's zone (ranks 7 and 8 for the opponent), which can indicate threats.\"\n    zone_squares = sum(1 for square in board.piece_map() \n                       if (board.turn == chess.WHITE and chess.square_rank(square) >= 6) or\n                          (board.turn == chess.BLACK and chess.square_rank(square) <= 1))\n    return float(zone_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares controlled by each color, indicating board presence.\"\n    control_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_count += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control_count -= 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can potentially block checks, indicative of king safety.\"\n    blocking_pieces = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(not board.turn, square):\n            blocking_pieces += 1\n    return float(blocking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Checks for potential immediate threats (pieces directly attacking the opponent's king).\"\n    king_square = board.king(not board.turn)\n    threats = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in piece types, favoring higher value pieces for strong positions.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            score += piece_values[piece.piece_type]\n        else:\n            score -= piece_values[piece.piece_type]\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance based on the difference in values between pieces on the board.\"\n    material_values = {\n        chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_material - black_material\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can deliver a check to the opponent's king.\"\n    checkers = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checkers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of protected pieces for the current player.\"\n    protected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if not attackers:\n                protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares a player's pawns can potentially promote from based on their ranking.\"\n    promotion_squares = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (chess.square_rank(square) == 7 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) == 0))\n    return float(promotion_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each side and returns the difference.\"\n    white_controlled = len([m for m in board.legal_moves if m.from_square != m.to_square and m.to_square in board.attackers(chess.WHITE, m.to_square)])\n    black_controlled = len([m for m in board.legal_moves if m.from_square != m.to_square and m.to_square in board.attackers(chess.BLACK, m.to_square)])\n    result = white_controlled - black_controlled\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest piece of each color to the opponent's back rank.\"\n    white_distance = min((8 - chess.square_rank(square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE) if board.piece_map() else float('inf')\n    black_distance = min((chess.square_rank(square) + 1) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK) if board.piece_map() else float('inf')\n    result = white_distance - black_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacked but not defended.\"\n    unprotected_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if attackers and not board.attackers(piece.color, square):\n                unprotected_attacks += 1\n    return float(unprotected_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces to total pieces for the current player.\"\n    total_pieces = len([piece for piece in board.piece_map() if board.piece_at(piece).color == board.turn])\n    active_pieces = len([move for move in board.legal_moves if board.piece_at(move.from_square).color == board.turn])\n    ratio = active_pieces / total_pieces if total_pieces > 0 else 0.0\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy pieces and are themselves protected.\"\n    safe_attackers = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if attackers and board.is_attacked_by(piece.color, square):\n                safe_attackers += 1\n    return float(safe_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    average_distance = total_distance / piece_count if piece_count > 0 else 0.0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has in the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_pieces = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_center_pieces = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_center_pieces - black_center_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pawns to their promotion ranks.\"\n    white_pawns = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE)\n    black_pawns = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible checks for each side.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in control of open files for rooks.\"\n    open_files = [file for file in range(8) if all(board.piece_at(sq) is None for sq in range(file, 64, 8))]\n    white_rooks = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.ROOK and chess.square_file(sq) in open_files and board.piece_map()[sq].color == chess.WHITE)\n    black_rooks = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.ROOK and chess.square_file(sq) in open_files and board.piece_map()[sq].color == chess.BLACK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    isolated_pawns = 0\n    for sq in board.piece_map():\n        piece = board.piece_map()[sq]\n        if piece.piece_type == chess.PAWN:\n            if not (board.piece_at(sq - 1) and board.piece_at(sq - 1).color == piece.color) and \\\n               not (board.piece_at(sq + 1) and board.piece_at(sq + 1).color == piece.color):\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of backward pawns for each side.\"\n    backward_pawns = 0\n    for sq in board.piece_map():\n        piece = board.piece_map()[sq]\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(sq)\n            if piece.color == chess.WHITE and rank < 6 and board.piece_at(sq + 8):\n                if not (board.piece_at(sq + 7) and board.piece_at(sq + 7).color == chess.WHITE) and not (board.piece_at(sq + 9) and board.piece_at(sq + 9).color == chess.WHITE):\n                    backward_pawns += 1\n            elif piece.color == chess.BLACK and rank > 1 and board.piece_at(sq - 8):\n                if not (board.piece_at(sq - 7) and board.piece_at(sq - 7).color == chess.BLACK) and not (board.piece_at(sq - 9) and board.piece_at(sq - 9).color == chess.BLACK):\n                    backward_pawns -= 1\n    return float(backward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of sieges on opponent's pieces.\"\n    siege_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_map()[sq]\n        if piece.color != board.turn:\n            attackers = board.attackers(board.turn, sq)\n            if len(attackers) > 1:\n                siege_count += 1 if piece.color == chess.WHITE else -1\n    return float(siege_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both queens on the board.\"\n    squares_occupied = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.QUEEN)\n    return float(squares_occupied)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all rooks to the opponent's king in terms of squares.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    rook_distances = sum(chess.square_distance(square, opponent_king_square) for square, piece in board.piece_map().items() if piece.piece_type == chess.ROOK)\n    return float(rook_distances)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has that are positioned on the 7th rank.\"\n    white_seventh_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seventh_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of defended squares for each color.\"\n    white_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and any(board.piece_at(s) and board.piece_at(s).color == chess.WHITE for s in board.attackers(chess.WHITE, square)))\n    black_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and any(board.piece_at(s) and board.piece_at(s).color == chess.BLACK for s in board.attackers(chess.BLACK, square)))\n    return float(white_defended_squares - black_defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the same file as the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    same_file_count = sum(1 for square, piece in board.piece_map().items() if chess.square_file(square) == chess.square_file(opponent_king_square))\n    return float(same_file_count)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of squares that have more than one piece attacking them.\"\n    multi_attacked_squares = sum(1 for square in chess.SQUARES if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    return float(multi_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are adjacent to opponent's pieces.\"\n    adjacent_pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and any(board.piece_at(adj_square) for adj_square in board.attacks(square) if board.piece_at(adj_square) and board.piece_at(adj_square).color != piece.color))\n    return float(adjacent_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are attacked but not defended by a piece of the same color.\"\n    attacked_not_defended = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and not any(board.piece_at(s) for s in board.attackers(chess.WHITE, square)) or board.is_attacked_by(chess.BLACK, square) and not any(board.piece_at(s) for s in board.attackers(chess.BLACK, square)))\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all knights from the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    total_knight_distance = sum(chess.square_distance(square, opponent_king_square) for square, piece in board.piece_map().items() if piece.piece_type == chess.KNIGHT)\n    return float(total_knight_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the piece values of the pieces on the back rank for each side.\"\n    back_rank_piece_values = 0\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.WHITE else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    value_map = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for square in back_rank_squares:\n        piece = board.piece_at(square)\n        if piece:\n            back_rank_piece_values += value_map[piece.piece_type]\n    \n    return float(back_rank_piece_values)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked but not protected by any piece.\"\n    attacked_unprotected = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not any(board.is_attacked_by(chess.BLACK, square) for piece in board.piece_map().values() if piece.color == chess.WHITE):\n            attacked_unprotected += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not any(board.is_attacked_by(chess.WHITE, square) for piece in board.piece_map().values() if piece.color == chess.BLACK):\n            attacked_unprotected += 1\n    return float(attacked_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board that are on the 7th and 8th ranks.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    value_on_back_rank = 0\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) >= 6:  # 7th (rank 6) and 8th (rank 7) ranks\n            value_on_back_rank += piece_values[piece.piece_type]\n    return float(value_on_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the tension by counting the number of pieces attacking more than one opponent's piece.\"\n    tension_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            attackers = board.attackers(chess.WHITE, square) if board.piece_at(square).color == chess.WHITE else board.attackers(chess.BLACK, square)\n            if len(attackers) > 1:\n                tension_count += 1\n    return float(tension_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both sides have potential access.\"\n    contested_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            contested_squares += 1\n    return float(contested_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by counting excess moves available for one side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces that are pinned against the king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square):\n            pinned_count += 1\n        elif piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pieces from their respective back ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)\n        else:\n            total_distance += (7 - chess.square_rank(square))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces directly attackable in one move.\"\n    attackable_enemy_pieces = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None and board.piece_at(square).color != board.turn:\n            if board.is_attacked_by(board.turn, square):\n                attackable_enemy_pieces += 1\n    return float(attackable_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of ranks for all pieces of the current player; higher ranks indicate better position.\"\n    total_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of kings on the board.\"\n    return float(len([piece for piece in board.piece_map().values() if piece.piece_type == chess.KING]))", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are placed on the back rank of each player.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) is not None)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) is not None)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns to their promotion ranks.\"\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for both players and their difference.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by enemy pieces that are attacked but not defended.\"\n    attacked_unprotected_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and not board.attackers(board.turn, square))\n    return float(attacked_unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled exclusively by either side.\"\n    controlled_white = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq) and not board.is_attacked_by(chess.BLACK, sq))\n    controlled_black = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq) and not board.is_attacked_by(chess.WHITE, sq))\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have the potential to deliver check.\"\n    check_potential_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_map()[square].piece_type != chess.KING)\n    return float(check_potential_count)", "def feature(board: chess.Board) -> float:\n    \"Determines the average distance from all pieces to the nearest enemy piece.\"\n    total_distance = 0\n    pieces = list(board.piece_map().keys())\n    for piece_square in pieces:\n        nearest_distance = min(chess.square_distance(piece_square, enemy_square) for enemy_square in pieces if board.piece_map()[enemy_square].color != board.piece_map()[piece_square].color)\n        total_distance += nearest_distance\n    return float(total_distance / len(pieces) if pieces else 0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of piece types on the board.\"\n    piece_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for piece in board.piece_map().values():\n        piece_count[piece.piece_type] += 1\n    imbalance = (piece_count[chess.QUEEN] + piece_count[chess.ROOK]) - (piece_count[chess.KNIGHT] + piece_count[chess.BISHOP])\n    return float(imbalance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pawns on the board.\"\n    pawn_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN)\n    return float(pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board.\"\n    center_square = chess.parse_square('d4')\n    total_distance = sum(chess.square_distance(square, center_square) \n                         for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on squares protected by the opposing side.\"\n    protection_count = sum(1 for square, piece in board.piece_map().items() \n                           if board.is_attacked_by(not piece.color, square))\n    return float(protection_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pawns of each color.\"\n    white_control = sum(1 for square in chess.SQUARES \n                        if board.piece_at(square) and board.piece_at(square).color == chess.WHITE \n                        and chess.square_rank(square) < 7)\n    black_control = sum(1 for square in chess.SQUARES \n                        if board.piece_at(square) and board.piece_at(square).color == chess.BLACK \n                        and chess.square_rank(square) > 0)\n    return float(white_control + black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the 7th rank between both sides.\"\n    white_seventh_rank = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 6 \n                              and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 1 \n                              and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of hanging pieces for each side.\"\n    hanging_pieces_count = sum(1 for square, piece in board.piece_map().items() \n                                if len(board.attackers(not piece.color, square)) == 0 \n                                and piece.color == board.turn)\n    return float(hanging_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rook and queen pieces on the board.\"\n    heavy_piece_count = sum(1 for piece in board.piece_map().values() \n                             if piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(heavy_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces to the opponent's king.\"\n    opponent_king_square = [sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color != board.turn]\n    if not opponent_king_square:\n        return 0.0\n    \n    king_square = opponent_king_square[0]\n    total_distance = sum(chess.square_distance(sq, king_square) for sq in board.piece_map() if board.piece_map()[sq].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the last two ranks for each side.\"\n    last_two_ranks = [6, 7] if board.turn == chess.WHITE else [0, 1]\n    piece_count = sum(1 for sq in board.piece_map() if chess.square_rank(sq) in last_two_ranks)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that can move to the eighth rank.\"\n    promotable_pieces = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and chess.square_rank(sq) in (6, 1))\n    return float(promotable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned.\"\n    pinned_count = 0\n    for sq in board.piece_map():\n        if board.is_attacked_by(not board.piece_map()[sq].color, sq):\n            # A piece is pinned if it cannot move without putting the king in check\n            piece_color = board.piece_map()[sq].color\n            for move in board.legal_moves:\n                if move.from_square == sq:\n                    break\n            else:\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece types each side has on the board.\"\n    white_piece_types = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE}\n    black_piece_types = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK}\n    type_difference = len(white_piece_types) - len(black_piece_types)\n    return float(type_difference)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pieces from the nearest piece of the opponent.\"\n    total_distance = 0\n    for sq in board.piece_map():\n        distance = min((chess.square_distance(sq, opponent_sq) for opponent_sq in board.piece_map() if board.piece_map()[opponent_sq].color != board.piece_map()[sq].color), default=0)\n        total_distance += distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks that can be given in one move by pieces.\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their ideal starting positions.\"\n    total_distance = 0\n    ideal_square = {chess.PAWN: [(1, 0), (6, 0)], chess.ROOK: [(0, 0), (7, 0)], chess.KNIGHT: [(0, 1), (7, 1)], chess.BISHOP: [(0, 2), (7, 2)], chess.QUEEN: [(0, 3), (7, 3)], chess.KING: [(0, 4), (7, 4)]}\n    for sq, piece in board.piece_map().items():\n        piece_type = piece.piece_type\n        start_position = ideal_square.get(piece_type, [])\n        distances = [chess.square_distance(sq, chess.parse_square(chess.square_name(x))) for x, y in start_position]\n        total_distance += min(distances, default=0)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares controlled by each player's pieces.\"\n    white_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the edge of the board for each player.\"\n    edge_squares = [chess.A1, chess.A2, chess.A3, chess.A4, chess.A5, chess.A6, chess.A7, chess.A8,\n                    chess.H1, chess.H2, chess.H3, chess.H4, chess.H5, chess.H6, chess.H7, chess.H8]\n    white_edge = sum(1 for sq in edge_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_edge = sum(1 for sq in edge_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_edge - black_edge)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with a direct attacking line to the opponent's king.\"\n    white_king_square = next(sq for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king_square = next(sq for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    attacking_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.WHITE:\n            if square in board.attackers(chess.BLACK, black_king_square):\n                attacking_pieces += 1\n        elif piece and piece.color == chess.BLACK:\n            if square in board.attackers(chess.WHITE, white_king_square):\n                attacking_pieces += 1\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on their starting squares for both players.\"\n    starting_positions = [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2,\n                          chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    white_starting = sum(1 for sq in starting_positions if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_starting = sum(1 for sq in starting_positions if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_starting - black_starting)", "def feature(board: chess.Board) -> float:\n    \"Counts how many rooks each player has on the open files (files without pawns).\"\n    open_files = [file for file in range(8) if not any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN for rank in range(8))]\n    white_rooks = sum(1 for file in open_files for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    black_rooks = sum(1 for file in open_files for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are undefended by their own side.\"\n    undefended_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            attackers = board.attackers(piece.color, square)\n            if not attackers:\n                undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances from each player's pieces to the opponent's back rank.\"\n    value = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                distance = 7 - chess.square_rank(square)\n            else:\n                distance = chess.square_rank(square)\n            value += distance\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of discovered attacks for both sides.\"\n    discovered_attacks = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in (chess.ROOK, chess.QUEEN):\n            for target in chess.SQUARES:\n                if board.is_attacked_by(not piece.color, target) and not board.is_attacked_by(piece.color, target):\n                    discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares around the enemy king that are attacked by the player's pieces.\"\n    enemy_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    attacked_squares = sum(1 for sq in board.attackers(board.turn, enemy_king_square))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between the two sides.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.turn)\n    black_mobility = sum(1 for move in board.legal_moves if not board.turn)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board adjusted by their distance to the opposing back rank.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        distance_to_back_rank = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n        total_value += piece_values[piece.piece_type] - distance_to_back_rank\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player that are adjacent to enemy pieces.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                controlled_squares.add(move.to_square)\n    \n    adjacent_to_enemy_pieces = sum(1 for square in controlled_squares if any(board.is_attacked_by(piece.color, square) for piece in board.piece_map().values()))\n    return float(adjacent_to_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each side has that are visible (not blocked) towards the opposing king.\"\n    total_visible_white = total_visible_black = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            distance_to_king = chess.square_distance(square, next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != piece.color))\n            if distance_to_king < 7:  # visible if within 7 squares\n                if piece.color == chess.WHITE:\n                    total_visible_white += 1\n                else:\n                    total_visible_black += 1\n    return float(total_visible_white - total_visible_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece distance to the opponent's king, giving higher values to pieces that are farther away.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn]\n    return float(sum(distances))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opposing pieces that threaten the player's king.\"\n    player_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    threatened_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_at(square).color != board.turn)\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of defended squares for the player's pieces.\"\n    defended_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target_square in board.attackers(not board.turn, square):\n                defended_squares.add(target_square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of all pieces that are actively controlling the center squares (d4, e4, d5, e5).\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_central_value = 0\n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            total_central_value += piece_values[piece.piece_type]\n    return float(total_central_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens) for both sides.\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    \n    white_ratio = minor_pieces_white / (major_pieces_white + 1e-5)  # prevent division by zero\n    black_ratio = minor_pieces_black / (major_pieces_black + 1e-5)  # prevent division by zero\n    return float(white_ratio - black_ratio)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by the player's pieces.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that have advanced to the 5th rank or higher.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and \n                         piece.color == board.turn and \n                         chess.square_rank(square) >= 4)\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks available to the side to move.\"\n    checks_available = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each color.\"\n    back_rank_count = sum(1 for square, piece in board.piece_map().items()\n                          if piece.color == board.turn and chess.square_rank(square) == (0 if board.turn == chess.WHITE else 7))\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece safety by counting the number of pieces attacked.\"\n    attacked_pieces = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(attacked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of d4, d5 squares (central control) occupied by each side.\"\n    center_control = sum(1 for square in [chess.D4, chess.D5] if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within two ranks of the opponent's king.\"\n    proximity_to_king = sum(1 for square, piece in board.piece_map().items() \n                            if piece.color == board.turn and \n                            chess.square_distance(square, chess.parse_square(chess.square_name(board.turn))) <= 2)\n    return float(proximity_to_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are both attacked and protected by pieces of the current player.\"\n    protected_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and any(board.is_attacked_by(board.turn, square) for sq in board.attackers(not board.turn, square)))\n    return float(protected_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest opponent piece to the player's king.\"\n    player_king_pos = board.king(board.turn)\n    opponent_pieces = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    distances = [chess.square_distance(player_king_pos, square) for square in opponent_pieces]\n    return min(distances) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible checks available to the side to move.\"\n    return float(sum(1 for move in board.legal_moves if board.gives_check(move)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of piece values between the two sides.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each side that are on their respective 4th rank.\"\n    white_pawns_on_4th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 3)\n    black_pawns_on_4th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 4)\n    return float(white_pawns_on_4th - black_pawns_on_4th)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe squares available for pieces of each side.\"\n    safe_white_squares = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    safe_black_squares = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(safe_white_squares - safe_black_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected enemy pieces.\"\n    return float(sum(1 for square in board.piece_map() if board.piece_at(square).color != board.turn and not board.is_attacked_by(board.turn, square)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each piece to the nearest opponent piece and averages it.\"\n    opponent_pieces = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    if not opponent_pieces:\n        return float('inf')\n    distances = []\n    for square in board.piece_map():\n        distances.append(min(chess.square_distance(square, opponent) for opponent in opponent_pieces))\n    return float(sum(distances) / len(distances))", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for promotion by counting the number of pawns within striking distance of promotion.\"\n    player_color = board.turn\n    promotion_squares = chess.square_rank(chess.A7) if player_color == chess.WHITE else chess.square_rank(chess.A2)\n    return float(sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == promotion_squares))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential control of the center squares (d4, d5, e4, e5) by counting the number of pieces that can control them.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can deliver check to the opponent.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns each side has on the 7th rank, indicating promotion potential.\"\n    white_pawns_on_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns_on_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective back ranks.\"\n    distance_sum = 0\n    for sq, piece in board.piece_map().items():\n        rank_distance = 7 - chess.square_rank(sq) if piece.color == chess.WHITE else chess.square_rank(sq)\n        distance_sum += rank_distance\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both sides.\"\n    attacked_squares = set()\n    for sq in range(64):\n        if board.is_attacked_by(chess.WHITE, sq) or board.is_attacked_by(chess.BLACK, sq):\n            attacked_squares.add(sq)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average mobility of pieces for each side.\"\n    white_mobility = len(list(board.legal_moves))\n    black_board = board.copy()\n    black_board.turn = chess.BLACK\n    black_mobility = len(list(black_board.legal_moves))\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered attacks on the opponent's king.\"\n    discovered_attack_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                board.push(move)\n                if board.is_check() and piece.piece_type in [chess.ROOK, chess.QUEEN]:\n                    discovered_attack_count += 1\n                board.pop()\n    return float(discovered_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns on both sides.\"\n    isolated_pawn_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            is_isolated = not any(board.piece_at(chess.square(file + dx, chess.square_rank(sq))) for dx in [-1, 1] if 0 <= file + dx < 8)\n            if is_isolated:\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that can be attacked by pieces of each color on the back rank.\"\n    white_attacking_squares = sum(1 for sq in range(8) if board.is_attacked_by(chess.WHITE, chess.square(sq, 0)))\n    black_attacking_squares = sum(1 for sq in range(8) if board.is_attacked_by(chess.BLACK, chess.square(sq, 7)))\n    return float(white_attacking_squares - black_attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces controlled by each side in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    result = white_control - black_control\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    attackers = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    total_distance = sum(chess.square_distance(sq, king_square) for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces near the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn else 0\n    pieces_near_back_rank = sum(1 for sq in range(opponent_back_rank * 8, (opponent_back_rank + 1) * 8) if board.piece_at(sq) is not None and board.piece_at(sq).color == (chess.WHITE if not board.turn else chess.BLACK))\n    return float(pieces_near_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the current side.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attackers = board.attackers(piece.color, square)\n            if not attackers:\n                unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece captures available for the current player.\"\n    legal_moves = sum(1 for move in board.legal_moves if board.is_capture(move))\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available for pieces on the back ranks.\"\n    back_rank = 0 if board.turn else 7\n    back_rank_moves = sum(1 for sq in range(back_rank * 8, (back_rank + 1) * 8) if board.piece_at(sq) is not None and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK) for move in board.legal_moves if move.from_square == sq)\n    return float(back_rank_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can deliver a check to the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    check_potential = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK) and chess.Move(sq, king_square) in board.legal_moves)\n    return float(check_potential)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawn promotions possible for each side.\"\n    promotion_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and ((square // 8 == 6 and board.piece_at(square).color == chess.WHITE) or (square // 8 == 1 and board.piece_at(square).color == chess.BLACK)))\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material difference of pieces within the center four squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    score = 0\n    for square in center_squares:\n        piece = board.piece_at(square)\n        if piece:\n            score += material_value[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where a pawn can promote.\"\n    promotion_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    count = sum(1 for sq in promotion_squares if board.piece_at(sq) is None)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces threatened by the opponent's pieces.\"\n    threatened_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each side's king to the closest opponent piece.\"\n    white_king = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n\n    def min_distance(king_square):\n        return min(chess.square_distance(king_square, sq) for sq, piece in board.piece_map().items() if piece.color != board.turn)\n\n    return float(min_distance(white_king) + min_distance(black_king))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with mobility (pieces that have legal moves).\"\n    mobile_pieces = sum(1 for move in board.legal_moves)\n    return float(mobile_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of undefended pieces for each side.\"\n    white_undefended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    black_undefended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(white_undefended - black_undefended)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each side.\"\n    white_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total value of pieces attacking the opponent's back rank.\"\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    attacking_value = sum(piece.piece_type for square, piece in board.piece_map().items() if square in back_rank_squares and piece.color == board.turn)\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board that are in their initial positions.\"\n    initial_positions = [chess.PAWN, chess.ROOK, chess.KNIGHT, chess.BISHOP, chess.QUEEN, chess.KING]\n    initial_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type in initial_positions and piece.color == board.turn)\n    return float(initial_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distances = [min(chess.square_distance(square, center_sq) for center_sq in center_squares) for square in board.piece_map() if board.piece_at(square).color == board.turn]\n    return float(sum(distances) / (len(distances) if distances else 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available for each side and computes the difference.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares where a player's pieces can move.\"\n    total_controlled_squares = sum(len(board.attacks(sq)) for sq in board.piece_map().keys())\n    return float(total_controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the king's position to the opponent's back rank.\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    distance_to_back_rank = (7 - chess.square_rank(white_king_sq)) + (0 - chess.square_rank(black_king_sq))\n    return float(distance_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces have been developed past the third rank for each side.\"\n    white_developed = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 3)\n    black_developed = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 4)\n    return float(white_developed - black_developed)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces each side has.\"\n    unprotected = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not piece.color, square):\n            unprotected += 1\n    return float(unprotected)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the total values of pieces that are attacking the opposing king.\"\n    white_attacking_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacking_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacking_value - black_attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces for each side that are located on the back rank.\"\n    white_back_rank_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 0)\n    black_back_rank_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 7)\n    return float(white_back_rank_pieces - black_back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                # Check if the piece cannot move without exposing the king\n                for move in board.legal_moves:\n                    if move.from_square == square and not board.is_check():\n                        pinned_count += 1\n                        break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of the pawns to their respective promotion ranks.\"\n    def average_pawn_distance(color):\n        squares = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == color]\n        if not squares:\n            return 0.0\n        total_distance = sum(chess.square_rank(sq) - (0 if color == chess.WHITE else 7) for sq in squares)\n        return total_distance / len(squares)\n\n    white_distance = average_pawn_distance(chess.WHITE)\n    black_distance = average_pawn_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pieces.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pieces of each color.\"\n    controlled_squares_white = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE))\n    controlled_squares_black = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Determines if any player's king is in danger of being captured next move.\"\n    white_king_in_danger = board.is_check() and board.turn == chess.WHITE\n    black_king_in_danger = board.is_check() and board.turn == chess.BLACK\n    return float(white_king_in_danger - black_king_in_danger)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the rook activity based on their distance to the opponent's back rank.\"\n    def rook_activity(color):\n        rooks = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and piece.color == color]\n        if not rooks:\n            return 0.0\n        total_distance = sum(chess.square_rank(sq) - (0 if color == chess.WHITE else 7) for sq in rooks)\n        return total_distance / len(rooks)\n\n    white_activity = rook_activity(chess.WHITE)\n    black_activity = rook_activity(chess.BLACK)\n    return float(white_activity - black_activity)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board that are out of play (captured).\"\n    captured_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            captured_count += 1\n    return float(captured_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of pieces in their attacking positions relative to the opponent.\"\n    value_map = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    attacked_value = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if board.is_attacked_by(not piece.color, square):\n            attacked_value += value_map[piece.piece_type]\n    return float(attacked_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each side has attacking the opponent's king.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Computes the center control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlled_center = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(controlled_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of double-attack opportunities on the board.\"\n    double_attacks = sum(1 for square in range(64) if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance to the opponent's king for all pieces.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map())\n    num_pieces = len(board.piece_map())\n    return float(total_distance / num_pieces) if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the ideal positioning of pieces based on their ranks.\"\n    rank_sum = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces near their promotion squares.\"\n    promotion_squares = {chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7} if board.turn else {chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2}\n    near_promotions = sum(1 for square in board.piece_map() if chess.square_rank(square) in [6, 1] and board.piece_at(square).piece_type == chess.PAWN)\n    return float(near_promotions)", "def feature(board: chess.Board) -> float:\n    \"Determines the safety of the kings by counting attackers around each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_safety = len(board.attackers(chess.BLACK, white_king_square))\n    black_safety = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_safety - white_safety)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces developed in the game.\"\n    developed_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 1)\n    developed_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 6)\n    return float(developed_white - developed_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in ranks of the kings; higher difference may indicate stronger position.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is not None and black_king is not None:\n        result = chess.square_rank(white_king) - chess.square_rank(black_king)\n    else:\n        result = 0.0\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks currently available for both players; a higher count may indicate a more dynamic position.\"\n    white_checks = len(list(board.legal_moves) if board.turn else [])\n    black_checks = len(list(board.legal_moves) if not board.turn else [])\n    return float(white_checks + black_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of defending pieces in a player's back rank; more defenders are typically better.\"\n    back_rank = chess.H8 if board.turn else chess.H1\n    count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and chess.square_rank(square) == chess.square_rank(back_rank))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on a player's first two ranks; more pieces can support development and influence the game.\"\n    count = sum(1 for square in range(16) if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns in the second rank for each player, as they are crucial for promotion.\"\n    white_pawns_in_second_rank = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 1)) == chess.PAWN)\n    black_pawns_in_second_rank = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 6)) == chess.PAWN)\n    return float(white_pawns_in_second_rank - black_pawns_in_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns to the promotion rank.\"\n    total_distance = 0\n    for sq in board.piece_map():\n        if board.piece_at(sq).piece_type == chess.PAWN:\n            distance_to_promotion = 7 - chess.square_rank(sq) if board.piece_at(sq).color == chess.WHITE else chess.square_rank(sq)\n            total_distance += distance_to_promotion\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares with potential for checkmate threats based on king positions.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    threatened_squares = set()\n\n    for move in board.legal_moves:\n        if move.from_square == white_king or move.from_square == black_king:\n            threatened_squares.add(move.to_square)\n\n    return float(len(threatened_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are both attacked and occupied by a player's pieces.\"\n    attacking_defended_squares = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq) and sq in board.piece_map())\n    return float(attacking_defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are defending the king.\"\n    defending_pieces = 0\n    for attacker_sq in board.attackers(board.turn, board.king(board.turn)):\n        if board.piece_at(attacker_sq) is not None:\n            defending_pieces += 1\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the last two ranks, indicating development.\"\n    pieces_on_last_two_ranks = 0\n    for sq in board.piece_map():\n        if chess.square_rank(sq) in (6, 7) or chess.square_rank(sq) in (0, 1):\n            pieces_on_last_two_ranks += 1\n    return float(pieces_on_last_two_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of attacking pieces to total pieces for both sides.\"\n    white_attacking_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq))\n    black_attacking_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq))\n    total_white_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    total_black_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    \n    if total_white_pieces == 0 or total_black_pieces == 0:\n        return 0.0\n    \n    return float(white_attacking_pieces / total_white_pieces - black_attacking_pieces / total_black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for rook activity, counting how many are on open files.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces one square away from the opponent's king.\"\n    opponent_king = board.king(not board.turn)\n    adjacent_squares = [chess.square_file(opponent_king) + dx + 8 * (chess.square_rank(opponent_king) + dy) for dx in (-1, 0, 1) for dy in (-1, 0, 1)]\n    pieces_near_king = sum(1 for sq in board.piece_map() if sq in adjacent_squares)\n    return float(pieces_near_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently on squares with potential for a promotion.\"\n    promotion_squares = [chess.square(file, 0) for file in range(8)] + [chess.square(file, 7) for file in range(8)]\n    pieces_on_promotion_squares = sum(1 for sq in board.piece_map() if sq in promotion_squares)\n    return float(pieces_on_promotion_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board that can potentially promote.\"\n    promoting_pawns = sum(1 for square, piece in board.piece_map().items() \n                           if piece.piece_type == chess.PAWN and (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                           (piece.color == chess.BLACK and chess.square_rank(square) == 1))\n    return float(promoting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the current player.\"\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between players based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of ranks of all non-pawn pieces; higher rank means more influence.\"\n    total_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN)\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked but not defended.\"\n    attacked_squares = set()\n    defended_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            attacked_squares.add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            defended_squares.add(square)\n    return float(len(attacked_squares - defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both sides.\"\n    shared_attacked_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            shared_attacked_squares.add(square)\n    return float(len(shared_attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to the back ranks of their respective sides.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in their optimal positions for the current stage of the game.\"\n    optimal_positions = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) == 7:\n            optimal_positions += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) == 0:\n            optimal_positions += 1\n    return float(optimal_positions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares where attacking pieces are located for current player.\"\n    attacking_squares = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal double checks in the position.\"\n    double_checks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.KING and \n                        len(list(board.attacks(move.to_square))) > 1)\n    return float(double_checks)", "def feature(board: chess.Board) -> float:\n    \"Checks for potential back rank weaknesses, counting unprotected back rank squares.\"\n    back_rank = 0\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else \\\n                        [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    for square in back_rank_squares:\n        if board.piece_at(square) is None and not board.is_attacked_by(not board.turn, square):\n            back_rank += 1\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn structure by counting doubled and isolated pawns.\"\n    doubled_isolated_count = 0\n    for file in range(8):\n        pawn_count = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN)\n        if pawn_count > 1:\n            doubled_isolated_count += 1\n    return float(doubled_isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (cannot move without exposing the king).\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square) and \n                       any(board.is_attacked_by(not board.turn, target) for target in board.attackers(not board.turn, square)))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control over the center squares (d4, d5, e4, e5) for each player.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for sq in center_squares if board.is_attacked_by(board.turn, sq))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy piece to the player's king.\"\n    player_king_square = next((square for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn), None)\n    if player_king_square is None:\n        return float('inf')\n    \n    closest_distance = float('inf')\n    for square in board.piece_map():\n        if board.piece_at(square).color != board.turn:\n            distance = chess.square_distance(player_king_square, square)\n            closest_distance = min(closest_distance, distance)\n\n    return float(closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of pieces controlled by each color.\"\n    controlled_white = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map())\n    controlled_black = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map())\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the threatened squares by both sides that are not occupied by any pieces.\"\n    total_threatened = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square)) \n    total_occupied = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None)\n    return float(total_threatened - total_occupied)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns in play for both sides.\"\n    pawns_white = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    pawns_black = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(pawns_white - pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of mobile pieces to total pieces for each side.\"\n    mobile_white = len(list(board.legal_moves)) if board.turn else 0\n    mobile_black = len(list(board.legal_moves)) if not board.turn else 0\n    total_pieces = len(board.piece_map())\n    return float(mobile_white / total_pieces if total_pieces > 0 else 0) - float(mobile_black / total_pieces if total_pieces > 0 else 0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each side has within their opponent's territory.\"\n    opponent_territory_white = sum(1 for square in range(0, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    opponent_territory_black = sum(1 for square in range(48, 64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(opponent_territory_white - opponent_territory_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting double pawns near the promotion rank.\"\n    double_pawn_white = sum(1 for square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7] if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    double_pawn_black = sum(1 for square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2] if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(double_pawn_white - double_pawn_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces based on the number of pieces within the center squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    density_white = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    density_black = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(density_white - density_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available to the player whose turn it is.\"\n    checks_available = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are placed next to the opponent's king.\"\n    count = 0\n    opponent_king_square = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)]\n    if opponent_king_square:\n        king_sq = opponent_king_square[0]\n        for sq in chess.SQUARES:\n            if board.piece_at(sq) is not None and sq != king_sq and chess.square_distance(sq, king_sq) == 1:\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by each color.\"\n    controlled_squares_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_squares_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are safe (not attacked) for each side.\"\n    safe_white = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, sq))\n    safe_black = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, sq))\n    return float(safe_white - safe_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pawns from their starting positions.\"\n    distance_sum = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                distance_sum += chess.square_rank(sq)  # Distance for white pawns\n            else:\n                distance_sum += 7 - chess.square_rank(sq)  # Distance for black pawns\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the back ranks for both sides.\"\n    back_rank_white = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has in enemy territory (last two ranks).\"\n    enemy_territory_white = sum(1 for sq in range(chess.A7, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    enemy_territory_black = sum(1 for sq in range(chess.A1, chess.H2 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(enemy_territory_white - enemy_territory_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of the number of pieces in the center (d4, d5, e4, e5) to total pieces.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    center_pieces_white = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    center_pieces_black = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    total_pieces = len(board.piece_map())\n    return float(center_pieces_white + center_pieces_black) / (total_pieces if total_pieces > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently in their initial positions for each side.\"\n    initial_positions = {chess.ROOK: [chess.A1, chess.H1], chess.KNIGHT: [chess.B1, chess.G1], chess.BISHOP: [chess.C1, chess.F1], chess.QUEEN: [chess.D1], chess.KING: [chess.E1]}\n    initial_white_pieces = sum(1 for p, sqs in initial_positions.items() for sq in sqs if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    \n    initial_positions = {chess.ROOK: [chess.A8, chess.H8], chess.KNIGHT: [chess.B8, chess.G8], chess.BISHOP: [chess.C8, chess.F8], chess.QUEEN: [chess.D8], chess.KING: [chess.E8]}\n    initial_black_pieces = sum(1 for p, sqs in initial_positions.items() for sq in sqs if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n\n    return float(initial_white_pieces - initial_black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the current player's pawns.\"\n    result = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == board.turn:\n            attacked_squares = {square + 7, square + 9} if piece.color == chess.WHITE else {square - 7, square - 9}\n            result += sum(1 for sq in attacked_squares if 0 <= sq < 64 and board.is_attacked_by(not piece.color, sq))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the potential advancement of pawns by counting the number of pawns that can move forward without obstruction.\"\n    result = 0.0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and square < 56 and board.piece_at(square + 8) is None:\n                result += 1.0\n            elif piece.color == chess.BLACK and square > 7 and board.piece_at(square - 8) is None:\n                result += 1.0\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of checks available to the side to move.\"\n    result = len(list(board.legal_moves)) - len(list(board.legal_moves))  # Placeholder for better check calculations\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            result += 1\n        board.pop()\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked but not protected by any piece.\"\n    result = 0.0\n    attacked_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    \n    for square in attacked_squares:\n        if not any(board.is_attacked_by(board.turn, sq) for sq in range(64) if board.piece_at(sq) is not None):\n            result += 1.0\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares where a player's pieces can move.\"\n    result = sum(1 for move in board.legal_moves)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of aggressive pieces for the current player, defined as pieces that can attack.\"\n    result = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            result += len(list(board.attackers(not piece.color, square)))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Analyzes the ratio of defended squares to attacked squares for the current player.\"\n    attacked_count = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square))\n    defended_count = sum(1 for square in range(64) if board.is_attacked_by(not board.turn, square))\n    return (defended_count / (attacked_count + 1))  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the back ranks for both sides.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are positioned in the last two ranks, indicating possible promotion.\"\n    promotion_zone_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and ((piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \n                       (piece.color == chess.BLACK and chess.square_rank(square) <= 1)):\n            promotion_zone_count += 1\n    return float(promotion_zone_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king directly.\"\n    attackers_to_king = sum(1 for square in board.piece_map() if board.piece_at(square).color != board.turn and \n                             board.is_attacked_by(board.turn, chess.KING))\n    return float(attackers_to_king)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pawns to the promotion rank.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and \n                               board.piece_at(sq).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and \n                               board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available to the side to move.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that can be attacked by pieces of the current player.\"\n    attacked_squares = len(set(move.to_square for move in board.legal_moves))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available to each player based on their current position.\"\n    total_checks = board.is_check() + sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(total_checks)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares controlled by attacking pieces of the current player.'\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    'Counts the total number of threats made by each player on their opponent\u2019s pieces.'\n    threats = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            threats += len(board.attackers(board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of all pieces to their closest opponent piece.'\n    total_distance = 0\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            opponent_pieces = [s for s in board.piece_map() if board.piece_at(s).color == opponent_color]\n            if opponent_pieces:\n                distances = [chess.square_distance(square, op) for op in opponent_pieces]\n                total_distance += min(distances)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces each player has that are lining up to deliver check or checkmate.'\n    check_delivers = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                check_delivers += 1\n    return float(check_delivers)", "def feature(board: chess.Board) -> float:\n    'Measures the total potential mobility of the pieces of the current player.'\n    potential_moves = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            potential_moves += len(list(board.legal_moves))\n    return float(potential_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces controlled by the current player that are on the opponent\u2019s side of the board.'\n    opponent_side_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if chess.square_rank(square) > 4:  # Assuming ranks 0-3 are home ranks for White\n                opponent_side_count += 1\n    return float(opponent_side_count)", "def feature(board: chess.Board) -> float:\n    'Measures the distribution of pieces across the board by calculating their rank sum for the current player.'\n    rank_sum = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            rank_sum += chess.square_rank(square)\n    return float(rank_sum)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces to the back rank for the current player.'\n    total_distance = 0\n    piece_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            total_distance += chess.square_rank(square)  # Rank 0 is closest to the back rank\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Counts squares that have pieces from both sides to measure competition for control.'\n    contested_squares = 0\n    for square in board.piece_map():\n        if square in board.attackers(chess.WHITE, square) and square in board.attackers(chess.BLACK, square):\n            contested_squares += 1\n    return float(contested_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares from which the current player can attack the opponent's king.\"\n    attackers = sum(board.is_attacked_by(board.turn, square) for square in chess.SQUARES)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can defend their own squares.\"\n    defending_pieces = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is not None)\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares occupied by each color.\"\n    white_occ = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_occ = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_occ - black_occ)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are protected (i.e., controlled by multiple pieces).\"\n    protected_squares = sum(1 for square in chess.SQUARES if len(board.attackers(chess.WHITE, square)) > 1 or len(board.attackers(chess.BLACK, square)) > 1)\n    return float(protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of each side by counting legal moves.\"\n    white_mobility = len(list(board.legal_moves))\n    board.push(chess.Move.null())  # Skip a move to analyze the other side\n    black_mobility = len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces to the opponent's back rank.\"\n    total_distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            if piece.color == chess.WHITE:\n                total_distance += chess.square_distance(square, chess.A8)\n            else:\n                total_distance += chess.square_distance(square, chess.A1)\n    return total_distance / len(board.piece_map()) if board.piece_map() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces each side has on their respective first two ranks.\"\n    white_count = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) < 2)\n    black_count = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) > 5)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares where one side can deliver a check.\"\n    check_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.KING)\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently on their original squares.\"\n    original_positions = {\n        chess.WHITE: 0,\n        chess.BLACK: 0\n    }\n    start_positions = {\n        chess.WHITE: [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1, chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7, chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8],\n    }\n    for square, piece in board.piece_map().items():\n        if square in start_positions[piece.color]:\n            original_positions[piece.color] += 1\n    return float(original_positions[chess.WHITE] - original_positions[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance between the kings of both sides.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING), None)\n    if white_king_square and black_king_square:\n        return float(chess.square_distance(white_king_square, black_king_square))\n    return float('inf')  # If one of the kings does not exist, return infinity for unusual positions", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacks against the opponent's king.\"\n    # Assuming kings exist, this will count attackers against the kings\n    white_king_square = next((square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING), None)\n    attacks = 0.0\n    if white_king_square:\n        attacks += len(board.attackers(chess.BLACK, white_king_square))\n    if black_king_square:\n        attacks += len(board.attackers(chess.WHITE, black_king_square))\n    return attacks", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's pawns.\"\n    attacks_on_pawns = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            attacks_on_pawns += len(board.attackers(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square))\n    return attacks_on_pawns", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for threats by counting pieces that can reach the opponent's home ranks.\"\n    threats_to_home_rank = 0.0\n    home_ranks = [0, 7]  # White's home rank is 0, Black's is 7\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) == 1:\n            if piece.piece_type in {chess.ROOK, chess.QUEEN}:\n                threats_to_home_rank += 1\n        if piece.color == chess.BLACK and chess.square_rank(square) == 6:\n            if piece.piece_type in {chess.ROOK, chess.QUEEN}:\n                threats_to_home_rank += 1\n    return threats_to_home_rank", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board that can attack the opponent's pieces next move.\"\n    potential_attackers = 0.0\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square and board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, move.to_square):\n                potential_attackers += 1\n    return potential_attackers", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each side has on the opponent's side of the board.\"\n    white_pieces_on_black_side = 0.0\n    black_pieces_on_white_side = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) >= 4:\n            white_pieces_on_black_side += 1\n        if piece.color == chess.BLACK and chess.square_rank(square) <= 3:\n            black_pieces_on_white_side += 1\n    return white_pieces_on_black_side - black_pieces_on_white_side", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by pieces of each color.\"\n    controlled_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent pieces that are pinned against their king.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square) and square != board.king(piece.color):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of a player's pieces to the opponent's king.\"\n    king_square = board.king(not board.turn)\n    if king_square is None:\n        return 0.0\n    distance_sum = 0\n    piece_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            distance_sum += chess.square_distance(square, king_square)\n            piece_count += 1\n    return float(distance_sum / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential promotion opportunities for pawns.\"\n    promotion_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotion_count += 1\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of currently non-pinned pieces to total pieces.\"\n    non_pinned_count = 0\n    total_pieces = len(board.piece_map())\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if not board.is_attacked_by(not piece.color, square):\n                non_pinned_count += 1\n    return float(non_pinned_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance of pieces on the same rank and evaluates control.\"\n    rank_control = 0\n    for rank in range(8):\n        white_pieces = sum(1 for square in chess.SQUARES if chess.square_rank(square) == rank and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n        black_pieces = sum(1 for square in chess.SQUARES if chess.square_rank(square) == rank and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n        rank_control += white_pieces - black_pieces\n    return float(rank_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that protect more than one piece.\"\n    protected_squares = set()\n    for square in chess.SQUARES:\n        attackers = board.attackers(board.turn, square)\n        if len(attackers) > 1:\n            protected_squares.add(square)\n    return float(len(protected_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total count of all defined pawn structures (connected, isolated).\"\n    pawn_structures = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            adjacent = (chess.square_name(square - 1) in board.piece_map() or \n                         chess.square_name(square + 1) in board.piece_map())\n            isolated = not adjacent\n            if adjacent:\n                pawn_structures += 1\n            if isolated:\n                pawn_structures += 1\n    return float(pawn_structures)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are threatened by opponent pieces.\"\n    threatened_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all non-pawn pieces on the board for both sides.\"\n    non_pawn_ranks_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_ranks_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of threatened squares that are not occupied by a piece.\"\n    threatened_empty_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is None)\n    return float(threatened_empty_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are two squares away from promotion.\"\n    two_squares_to_promote = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and ((board.turn == chess.WHITE and chess.square_rank(square) == 5) or (board.turn == chess.BLACK and chess.square_rank(square) == 2)))\n    return float(two_squares_to_promote)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by the pieces on the back rank.\"\n    back_rank_control = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) == (0 if board.turn == chess.WHITE else 7) and board.is_attacked_by(not board.turn, square))\n    return float(back_rank_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unique squares that can be attacked by the current player's pieces.\"\n    attacking_squares = set(move.to_square for move in board.legal_moves)\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces controlled by both players that are attacking the opponent's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    attackers_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and board.piece_at(square) and board.piece_at(square).color == board.turn and board.is_attacked_by(not board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are on the opponent's back rank versus the player's.\"\n    player_back_rank_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) == (0 if board.turn == chess.WHITE else 7))\n    opponent_back_rank_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color != board.turn and chess.square_rank(square) == (0 if board.turn == chess.BLACK else 7))\n    return float(player_back_rank_count - opponent_back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the penalty for each player based on the number of pieces not developed from the back ranks.\"\n    undeveloped_pieces = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and (chess.square_rank(square) == (0 if board.turn == chess.WHITE else 1)))\n    return float(undeveloped_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares currently occupied by the opponent's pieces within distance three of the player's king.\"\n    player_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    opponent_square_count = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_distance(player_king_square, square) <= 3)\n    return float(opponent_square_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of zugzwang scenarios possible for the player to move.'\n    # Evaluate potential zugzwang for the side to move\n    opponent_squares = set()\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_stalemate() or board.is_checkmate():\n            opponent_squares.add(move.to_square)\n        board.pop()\n    return float(len(opponent_squares))", "def feature(board: chess.Board) -> float:\n    'Measures the number of potential promotion squares for the current player.'\n    # Count squares where a pawn can promote\n    promotion_squares = 0\n    for square in range(8):\n        if (board.piece_at(chess.parse_square(f'b{square + 1}')) == chess.PAWN and\n            board.piece_at(chess.parse_square(f'b{square + 1}')).color == board.turn):\n            promotion_squares += 1\n    return float(promotion_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares completely controlled by the current player.'\n    # Count controlled squares not attacked by the opponent\n    controlled_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square):\n            continue\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the overall central control by counting pieces in central squares.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = 0\n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            control_count += 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of forks currently available to the player to move.'\n    # A fork is when one piece attacks two or more pieces at once\n    forks_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        threats = set()\n        for target_move in board.legal_moves:\n            if target_move.to_square != move.to_square:\n                target_piece = board.piece_at(target_move.to_square)\n                if target_piece and target_piece.color != board.turn:\n                    threats.add(target_piece)\n        if len(threats) >= 2:\n            forks_count += 1\n        board.pop()\n    return float(forks_count)", "def feature(board: chess.Board) -> float:\n    'Counts pieces protected by other pieces for the current player.'\n    protected_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target_square in board.attackers(not board.turn, square):\n                if board.piece_at(target_square) and board.piece_at(target_square).color != board.turn:\n                    protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the mobility of pawns for each side, comparing both.'\n    white_pawn_moves = len([move for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.WHITE])\n    black_pawn_moves = len([move for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.BLACK])\n    mobility_difference = white_pawn_moves - black_pawn_moves\n    return float(mobility_difference)", "def feature(board: chess.Board) -> float:\n    'Measures the danger of the current position by counting check opportunities.'\n    check_opportunities = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_opportunities += 1\n        board.pop()\n    return float(check_opportunities)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pinned pieces for the current player.'\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target_square in board.attackers(not board.turn, square):\n                if board.piece_at(target_square) and board.piece_at(target_square).piece_type == chess.KING:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the last two ranks for each color.\"\n    white_last_two_ranks = sum(1 for square in range(chess.A7, chess.H8) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_last_two_ranks = sum(1 for square in range(chess.A1, chess.H2) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_last_two_ranks - black_last_two_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pawns to the opponent's promotion rank.\"\n    total_distance = sum(chess.square_rank(chess.parse_square(chess.square_name(square))) for square in range(chess.A2, chess.H7) if board.piece_at(square) == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent pieces that are on the back rank.\"\n    opponent_back_rank = chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1\n    count = sum(1 for square in opponent_back_rank if board.piece_at(square) and board.piece_at(square).color != board.turn)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available to the player in check.\"\n    if board.is_check():\n        return float(len(list(board.legal_moves)))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board compared to the initial setup.\"\n    initial_pieces_count = 32  # Starting pieces count for both sides\n    current_pieces_count = len(board.piece_map())\n    return float(current_pieces_count - initial_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are completely unoccupied.\"\n    unoccupied_count = sum(1 for square in range(chess.A1, chess.H8) if not board.piece_at(square))\n    return float(unoccupied_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by only one side.\"\n    controlled_squares = {square: 0 for square in range(chess.A1, chess.H8)}\n    for square in controlled_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[square] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[square] += 1\n    return float(sum(1 for count in controlled_squares.values() if count == 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces attacking the opponent's king.\"\n    opponent_king_square = [square for square in range(chess.A1, chess.H8) if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn]\n    if opponent_king_square:\n        return float(len(board.attackers(board.turn, opponent_king_square[0])))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pawns defined as pawns able to advance to promotion.\"\n    pawn_mobility = sum(1 for square in range(chess.A2, chess.H7) if board.piece_at(square) == chess.PAWN and board.is_attacked_by(chess.BLACK, square + 8))\n    return float(pawn_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked but not defended by the current player's pieces.\"\n    attacking_defended = 0\n    for square in range(chess.A1, chess.H8):\n        if board.is_attacked_by(board.turn, square) and not any(board.is_attacked_by(board.turn, attacked_square) for attacked_square in board.attackers(not board.turn, square)):\n            attacking_defended += 1\n    return float(attacking_defended)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially check the opponent's king.\"\n    check_potential = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(check_potential)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are simultaneously attacked by both players.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        if board.is_attacked_by(chess.WHITE, square):\n            attacked_squares.add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where a piece can move and deliver a check.\"\n    check_squares = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent pieces that are one square away from being attacked.\"\n    danger_squares = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square) and \n                         any(square in board.attackers(not board.turn, sq) for sq in board.attackers(board.turn, square)))\n    return float(danger_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by more than one defender.\"\n    defended_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square):\n            attackers = len(board.attackers(board.turn, square))\n            if attackers > 1:\n                defended_squares += 1\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are restricted to a single square.\"\n    restricted_pieces = sum(1 for square in board.piece_map() if len(list(board.legal_moves)) == 1)\n    return float(restricted_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have no legal moves.\"\n    no_move_pieces = sum(1 for square in board.piece_map() if len(list(board.legal_moves)) == 0)\n    return float(no_move_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for both players.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's king to their respective back rank.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_distance = chess.square_rank(white_king)\n    black_distance = 7 - chess.square_rank(black_king)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares occupied by pawns for both players.\"\n    occupied_pawn_squares = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(occupied_pawn_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the player's king is currently located.\"\n    white_king_squares = 1 if board.king(chess.WHITE) is not None else 0\n    black_king_squares = 1 if board.king(chess.BLACK) is not None else 0\n    return float(white_king_squares + black_king_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of ranks occupied by pawns for both players.\"\n    white_pawn_ranks = {chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE}\n    black_pawn_ranks = {chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK}\n    return float(len(white_pawn_ranks) - len(black_pawn_ranks))", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns to the opponent's back rank.\"\n    total_distance = sum(7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all non-pawn pieces for both players.\"\n    non_pawn_ranks = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN]\n    if not non_pawn_ranks:\n        return 0.0\n    return float(sum(non_pawn_ranks) / len(non_pawn_ranks))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of ranks fully occupied by pieces for each color.\"\n    white_ranks = [0] * 8\n    black_ranks = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_ranks[chess.square_rank(square)] += 1\n        else:\n            black_ranks[chess.square_rank(square)] += 1\n    white_fully_occupied = sum(1 for count in white_ranks if count > 0) \n    black_fully_occupied = sum(1 for count in black_ranks if count > 0) \n    return float(white_fully_occupied - black_fully_occupied)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential double attacks available for both players.\"\n    double_attack_count = 0\n    for square in board.piece_map():\n        attackers = board.attackers(chess.WHITE, square)\n        if len(attackers) > 1:\n            double_attack_count += 1\n        attackers = board.attackers(chess.BLACK, square)\n        if len(attackers) > 1:\n            double_attack_count -= 1\n    return float(double_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the absolute difference in the number of pieces remaining for both sides.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(abs(white_pieces - black_pieces))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for both sides and returns the difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are controlled by more than one piece for each side.\"\n    controlled_squares = {square: 0 for square in chess.SQUARES}\n    for piece in board.piece_map().values():\n        for move in board.legal_moves:\n            if piece.color == chess.WHITE and move.from_square in controlled_squares:\n                controlled_squares[move.from_square] += 1\n            elif piece.color == chess.BLACK and move.from_square in controlled_squares:\n                controlled_squares[move.from_square] += 1\n    return float(sum(1 for count in controlled_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have the potential to attack the opponent's king.\"\n    attacking_pieces = 0\n    opponent_king_square = chess.square_name(board.king(chess.BLACK) if board.turn else board.king(chess.WHITE))\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if board.is_attacked_by(not piece.color, square):\n                attacking_pieces += 1\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (cannot move without exposing the king to check).\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker) and board.is_check():\n                    pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking pieces that can potentially reach the back rank of the opponent.\"\n    attacking_back_rank = 0\n    back_rank = 0 if board.turn else 7\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(square) == back_rank:\n            attacking_back_rank += 1\n    return float(attacking_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of direct threats to the opponent's pieces that are unprotected.\"\n    unprotected_threats = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if board.is_attacked_by(not piece.color, square) and not any(board.is_attacked_by(piece.color, attack_square) for attack_square in board.attackers(not piece.color, square)):\n                unprotected_threats += 1\n    return float(unprotected_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proximity of both players' pawns to the promotion ranks.\"\n    pawn_proximity = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                pawn_proximity[chess.WHITE] += 7 - rank\n            else:\n                pawn_proximity[chess.BLACK] += rank\n    return float(pawn_proximity[chess.WHITE] - pawn_proximity[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Analyses the number of squares currently occupied by friendly pieces around both kings.\"\n    friendly_near_king = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE:\n            friendly_near_king += 1\n    return float(friendly_near_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each side has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces for the current player.\"\n    defending_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked but not defended by the opponent.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not any(board.is_attacked_by(chess.BLACK, sq) for sq in board.attackers(chess.BLACK, square)):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Measures the level of piece activity by counting non-pawn pieces that have legal moves.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN and board.legal_moves)\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the center squares (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in the player's first three ranks.\"\n    player_start_ranks = [0, 1, 2] if board.turn == chess.WHITE else [5, 6, 7]\n    piece_count = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) in player_start_ranks)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are on the back rank for each side.\"\n    white_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pawns on the board; higher ranks mean closer to promotion.\"\n    return float(sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by the current player but not defended.\"\n    attacked_squares = set()\n    defended_squares = set()\n    \n    for sq in chess.SQUARES:\n        if board.is_attacked_by(board.turn, sq):\n            attacked_squares.add(sq)\n        if board.is_attacked_by(not board.turn, sq):\n            defended_squares.add(sq)\n\n    return float(len(attacked_squares - defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by two pieces of the same type for the current player.\"\n    piece_control = {}\n    \n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_type = piece.piece_type\n            if piece_type not in piece_control:\n                piece_control[piece_type] = set()\n            piece_control[piece_type].add(sq)\n    \n    return float(sum(1 for sqs in piece_control.values() if len(sqs) > 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are completely protected by the current player's pieces.\"\n    protected_squares = set()\n    \n    for sq in chess.SQUARES:\n        if board.is_attacked_by(board.turn, sq):\n            if all(not board.is_attacked_by(not board.turn, sq_adj) for sq_adj in chess.SQUARES):\n                protected_squares.add(sq)\n\n    return float(len(protected_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all rooks from their ideal positions on the back rank.\"\n    rook_positions = [chess.A8, chess.B8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.G1, chess.H1]\n    rooks = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.ROOK]\n    \n    if not rooks:\n        return 0.0\n    \n    distances = [chess.square_distance(sq, pos) for sq in rooks for pos in rook_positions]\n    return float(sum(distances) / len(distances))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are pinned against the opposing king.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for target_square in board.attackers(not piece.color, chess.KING):\n                if board.is_attacked_by(piece.color, target_square) and board.is_attacked_by(piece.color, square):\n                    pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting how many squares each piece can potentially move to.\"\n    mobility = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            mobility += len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently in danger (attacked but not defended).\"\n    threatened_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and board.is_attacked_by(not piece.color, square) and not board.attackers(piece.color, square):\n            threatened_pieces += 1\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) based on the number of pieces controlling each.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in center_squares:\n        control[chess.WHITE] += len(board.attackers(chess.WHITE, square))\n        control[chess.BLACK] += len(board.attackers(chess.BLACK, square))\n    return float(control[chess.WHITE] - control[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares controlled by the current player, excluding those that would directly put the king in check.\"\n    controlled_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(not board.turn, square):\n            controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares that are attacked versus defended by each side.\"\n    attack_defense_difference = 0\n    for square in chess.SQUARES:\n        attack_count = len(board.attackers(board.turn, square))\n        defense_count = len(board.attackers(not board.turn, square))\n        attack_defense_difference += (attack_count - defense_count)\n    return float(attack_defense_difference)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are occupied by pieces that are not in their optimal positions (non-development positions).\"\n    misplaced_pieces_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if (piece.color == chess.WHITE and chess.square_rank(square) < 4) or (piece.color == chess.BLACK and chess.square_rank(square) > 5):\n            misplaced_pieces_count += 1\n    return float(misplaced_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that could potentially check the opponent's king next move.\"\n    check_threats = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if board.piece_at(move.to_square) is chess.KING and move.promotion == chess.KING and move.from_square:\n                    check_threats += 1\n    return float(check_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are not attacked or occupied by either color.\"\n    unattacked_squares = sum(1 for square in range(64) if not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None)\n    return float(unattacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the concentration of pieces by counting the number of squares with more than two pieces.\"\n    crowded_squares = sum(1 for square in range(64) if board.piece_at(square) is not None and len(board.attackers(chess.WHITE, square)) + len(board.attackers(chess.BLACK, square)) > 2)\n    return float(crowded_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available to the player with the turn.\"\n    legal_moves_count = sum(1 for move in board.legal_moves)\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of the total number of pieces to the total number of squares controlled by pieces of the current player.\"\n    controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square))\n    total_pieces = len([piece for piece in board.piece_map().values() if piece.color == board.turn])\n    return float(total_pieces / (controlled_squares + 1e-6))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares controlled by each side.\"\n    white_controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can capture an enemy piece next turn.\"\n    capturable_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and any(board.is_attacked_by(board.turn, attacked_square) for attacked_square in board.attackers(piece.color, square)))\n    return float(capturable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in their optimal development squares based on piece type.\"\n    optimal_positions = {\n        chess.KNIGHT: [chess.B1, chess.C1, chess.G1, chess.F1, chess.B8, chess.C8, chess.G8, chess.F8],\n        chess.BISHOP: [chess.C1, chess.F1, chess.C8, chess.F8]\n    }\n    developed_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and square in optimal_positions.get(piece.piece_type, []))\n    return float(developed_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces beyond the 5th rank for both players.\"\n    pieces_behind_rank_5 = sum(1 for square, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(square) < 4) or (piece.color == chess.BLACK and chess.square_rank(square) > 3))\n    return float(pieces_behind_rank_5)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by pieces that are currently in a defensive position.\"\n    defending_squares = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(defending_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where pieces can attack more than one enemy piece.\"\n    multiple_attack_squares = sum(1 for square in board.piece_map() \n                                   if len(board.attackers(not board.turn, square)) > 1)\n    return float(multiple_attack_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unprotected enemy pieces.\"\n    unprotected_enemy_pieces = sum(1 for square, piece in board.piece_map().items() \n                                    if piece.color != board.turn and \n                                    not any(board.is_attacked_by(board.turn, enemy_square) \n                                            for enemy_square in board.attackers(not board.turn, square)))\n    return float(unprotected_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks available for the next move.\"\n    potential_forks = sum(1 for move in board.legal_moves \n                          if len(board.attackers(not board.turn, move.to_square)) > 1)\n    return float(potential_forks)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of ranks of pawns for each player; higher rank means closer to promotion.\"\n    white_pawn_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() \n                              if board.piece_at(square).color == chess.WHITE and \n                              board.piece_at(square).piece_type == chess.PAWN)\n    black_pawn_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() \n                              if board.piece_at(square).color == chess.BLACK and \n                              board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawn_rank_sum - black_pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the back rank for both players.\"\n    back_rank_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE and chess.square_rank(square) == 0:\n            back_rank_value += piece.piece_type\n        elif piece.color == chess.BLACK and chess.square_rank(square) == 7:\n            back_rank_value -= piece.piece_type\n    return float(back_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of hanging pieces for each player.\"\n    white_hanging = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    black_hanging = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(white_hanging - black_hanging)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    white_doubled = sum(1 for file in range(8) if len([p for p in board.pieces(chess.PAWN, chess.WHITE) if chess.square_file(p) == file]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([p for p in board.pieces(chess.PAWN, chess.BLACK) if chess.square_file(p) == file]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available to both players.\"\n    white_checks = len([move for move in board.legal_moves if board.is_check()])\n    board.turn = not board.turn  # Switch turn to check for black moves\n    black_checks = len([move for move in board.legal_moves if board.is_check()])\n    board.turn = not board.turn  # Revert to original turn\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that would be pinned if the current player moved.\"\n    pinned_pieces = sum(1 for square in board.piece_map() \n                        if board.piece_at(square).color == board.turn and \n                        any(board.is_attacked_by(not board.turn, target) for target in board.attackers(board.turn, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each side's pieces at the moment.\"\n    white_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of each side, specifically comparing the number of legal moves each player has.\"\n    white_mobility = len(list(board.legal_moves))\n    board.turn = not board.turn\n    black_mobility = len(list(board.legal_moves))\n    board.turn = not board.turn  # revert the turn\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board that are in advanced positions (beyond the 5th rank).\"\n    advanced_white = sum(1 for piece in board.pieces(chess.PAWN, chess.WHITE) if chess.square_rank(piece) > 4)\n    advanced_black = sum(1 for piece in board.pieces(chess.PAWN, chess.BLACK) if chess.square_rank(piece) > 4)\n    return float(advanced_white - advanced_black)", "def feature(board: chess.Board) -> float:\n    \"Compares the sum of the ranks of all pieces for both sides, giving more weight to pieces that are advanced.\"\n    white_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the degree of control over the center squares (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_control - black_center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces attacking the opponent's king.\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.parse_square('e8')))  # Assuming e8 is the black king's position\n    black_attacks = len(board.attackers(chess.BLACK, chess.parse_square('e1')))  # Assuming e1 is the white king's position\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_check():\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's king.\"\n    total_distance = 0\n    count = 0\n    opponent_king_square = chess.KING\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        distance = chess.square_distance(square, opponent_king_square)\n        total_distance += distance\n        count += 1\n    return float(total_distance / count) if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that control the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = 0\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_count += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control_count -= 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the board to total possible squares.\"\n    total_pieces = len(board.piece_map())\n    total_squares = 64.0\n    return float(total_pieces) / total_squares", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential captures available for the current player.\"\n    potential_captures = len(list(board.legal_moves))\n    return float(potential_captures)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are developed (pieces not on the back rank).\"\n    developed_pieces = sum(1 for square in board.piece_map() if chess.square_rank(square) > 1 and board.piece_at(square).color == board.turn)\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each side has on the board.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total threats against the king for both sides.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_threats = len(list(board.attackers(chess.BLACK, white_king_square)))\n    black_threats = len(list(board.attackers(chess.WHITE, black_king_square)))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in ranks of pieces in play for both sides.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the disparity in control of center squares (e4, d4, e5, d5).\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each color has on their second rank.\"\n    white_second_rank = sum(1 for square in range(chess.A2, chess.H2 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_second_rank = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_second_rank - black_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are pinned (unable to move without exposing a king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if any(board.is_check() and board.is_attacked_by(piece.color, a) for a in attackers):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of each player's squares attacked compared to the total available.\"\n    total_squares = 64\n    white_attacked = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked / total_squares - black_attacked / total_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king compared to all pieces on the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_attacks = len([m for m in board.legal_moves if m.to_square == black_king_square])\n    black_attacks = len([m for m in board.legal_moves if m.to_square == white_king_square])\n    \n    total_pieces = len(board.piece_map())\n    \n    if total_pieces == 0:\n        return 0.0\n    \n    return float(white_attacks / total_pieces - black_attacks / total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered checks available; indicates tactical opportunities.\"\n    potential_checks = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(potential_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns to the opponent's back rank, indicating promotion potential.\"\n    pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN)\n    return float(pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered checks possible for both colors.\"\n    attacking_moves = [move for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square)]\n    return float(len(attacking_moves))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in distance of the king from opposing pieces; indicates safety.\"\n    my_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == board.turn), None)\n    opponent_pieces = [sq for sq in board.piece_map() if board.piece_at(sq).color != board.turn]\n    distance_sum = sum(chess.square_distance(my_king, sq) for sq in opponent_pieces)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have potential for forks (attacking two or more pieces at once).\"\n    forks = 0\n    for sq in board.piece_map():\n        legal_moves = [move.to_square for move in board.legal_moves if move.from_square == sq]\n        if len(legal_moves) > 1:  # If the piece can move to two or more squares\n            for move in legal_moves:\n                if len(board.attackers(not board.turn, move)) > 1:  # Being attacked by two or more of the opponent's pieces\n                    forks += 1\n    return float(forks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces for the current player; pinned pieces are less flexible.\"\n    pinned_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.turn, sq) and board.is_check())\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the influence of major pieces (rooks and queens) by counting their control over files and ranks.\"\n    control = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type in [chess.ROOK, chess.QUEEN])\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where opposing pieces can be potentially trapped; indicates tactical disadvantage.\"\n    trapped_squares = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.turn, sq) and len(board.attackers(board.turn, sq)) > 1)\n    return float(trapped_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns present on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    distances = [chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_map()[sq].color == board.turn]\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by pieces that are pinned against the king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(not board.turn, chess.KING):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of pieces in active squares (ranks 5-8 for White, 1-4 for Black).\"\n    active_square_count = sum(1 for square, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or (piece.color == chess.BLACK and chess.square_rank(square) <= 3))\n    total_piece_count = len(board.piece_map())\n    return float(active_square_count) / total_piece_count if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially attack the opponent's king.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value difference based on varying weights for piece positions.\"\n    piece_weight = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_white = sum(piece_weight[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    material_black = sum(piece_weight[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(material_white - material_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares from which the current player's pieces can directly threaten the opponent's king.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    threat_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses the total number of opponent pieces that are not recently moved (original squares).\"\n    original_positions = {chess.square_name(i): 1 for i in range(8, 16)}  # Black pieces initial squares\n    original_positions.update({chess.square_name(i): 1 for i in range(48, 56)})  # White pieces initial squares\n    original_piece_count = sum(1 for square in board.piece_map() if chess.square_name(square) in original_positions and board.piece_map()[square].color != board.turn)\n    return float(original_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by both players simultaneously.\"\n    mutual_attack_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            mutual_attack_count += 1\n    return float(mutual_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color and returns the difference.\"\n    controlled_squares_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return controlled_squares_white - controlled_squares_black", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each side's pawns to their respective promotion ranks.\"\n    white_pawn_distances = [7 - chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE]\n    black_pawn_distances = [chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK]\n    return (sum(white_pawn_distances) / (len(white_pawn_distances) or 1)) - (sum(black_pawn_distances) / (len(black_pawn_distances) or 1))", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pieces that can move to those that are currently blocked.\"\n    mobile_pieces = sum(1 for move in board.legal_moves)\n    blocked_pieces = sum(1 for square in chess.SQUARES if board.piece_at(square) and not board.is_attacked_by(board.piece_at(square).color, square))\n    return (mobile_pieces / (blocked_pieces + 1e-5))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with direct lines to the opponent\u2019s king.\"\n    attacking_pieces = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return attacking_pieces", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of ranks occupied by each side\u2019s pieces.\"\n    occupied_ranks_white = {chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE}\n    occupied_ranks_black = {chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK}\n    return len(occupied_ranks_white) - len(occupied_ranks_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of each king by counting the number of squares around them that are attacked or occupied.\"\n    def king_safety(color):\n        king_square = next(square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == color)\n        attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not color, square))\n        return attacked_squares\n    \n    return king_safety(chess.WHITE) - king_safety(chess.BLACK)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential threats each side can execute against the opponent\u2019s king.\"\n    potential_threats_white = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    potential_threats_black = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return potential_threats_white - potential_threats_black", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that can deliver a check in the current position.'\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    'Measures the total value of pieces that are attacking the opponent\\'s king.'\n    king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    attackers = board.attackers(board.turn, king_square)\n    total_value = sum(piece.piece_type for square in attackers for piece in (board.piece_at(square),))\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of all pieces to the opponent\\'s back rank.'\n    back_rank = 0 if board.turn else 7\n    distances = [chess.square_distance(square, chess.parse_square(f'{chr(97 + chess.square_file(square))}{back_rank + 1}')) \n                 for square in board.piece_map()]\n    return sum(distances) / len(distances) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of central squares controlled by each color.'\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Measures the potential for promotion, counting pawns in the opponent\\'s half.'\n    pawn_promotion_count = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    return float(pawn_promotion_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the density of pieces controlled on the central files (d and e).'\n    central_density = sum(1 for square in [chess.D2, chess.D3, chess.E2, chess.E3] \n                          if board.piece_at(square) is not None) / 4.0\n    return float(central_density)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of potential discovered checks the current player can achieve.'\n    discovered_check_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for target_square in board.legal_moves:\n                board.push(target_square)\n                if board.is_check():\n                    discovered_check_count += 1\n                board.pop()\n    return float(discovered_check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are controlled by fewer than two pieces.\"\n    controlled_squares = set()\n    for piece in board.piece_map().values():\n        for move in board.legal_moves:\n            controlled_squares.add(chess.square_name(move.to_square))\n    return float(len([sq for sq in controlled_squares if len(board.attackers(board.turn, chess.parse_square(sq))) < 2]))", "def feature(board: chess.Board) -> float:\n    \"Measures the amount of 'over-protection' by counting how many pieces are defending a square.\"\n    over_protected_squares = 0\n    for square in chess.SQUARES:\n        num_defenders = len(board.attackers(not board.turn, square))\n        if num_defenders > 1:\n            over_protected_squares += 1\n    return float(over_protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility loss by counting how many pieces are blocked.\"\n    total_blocked = 0\n    for piece in board.piece_map().values():\n        if not board.legal_moves:\n            total_blocked += 1\n    return float(total_blocked)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank of each player for potential control.\"\n    back_rank_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and (chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7)):\n            back_rank_pieces += 1\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of currently unprotected squares for each player.\"\n    unprotected_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(not board.turn, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the difference in the number of moves available to the current player versus the opponent.\"\n    current_moves = len(list(board.legal_moves))\n    opponent_board = board.copy()\n    opponent_board.turn = not board.turn\n    opponent_moves = len(list(opponent_board.legal_moves))\n    return float(current_moves - opponent_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the influence of the player on the center squares (d4, e4, d5, e5) by counting piece control.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    influence_count = sum(1 for sq in center_squares if board.is_attacked_by(board.turn, sq))\n    return float(influence_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board.\"\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares where either player can check the opponent's king.\"\n    checks = 0\n    for move in board.legal_moves:\n        if board.is_check():  # Capture check positions \n            checks += 1\n        board.push(move)\n        if board.is_check():\n            checks += 1\n        board.pop()\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can promote on the next move.\"\n    promotions = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                     (chess.square_rank(square) == 6 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) == 1))\n    return float(promotions)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the enemy pieces within a two-square radius of the opponent's king.\"\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            enemy_king_square = square\n            break\n    if enemy_king_square is None:\n        return 0.0\n    controlled_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square):\n            distance = chess.square_distance(square, enemy_king_square)\n            if distance <= 2:\n                controlled_squares.add(square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    isolated_pawns = 0\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn]\n    for pawn in pawns:\n        if not any(board.piece_at(pawn + direction) for direction in [1, -1]):  # Check left and right files\n            isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces to their respective kings.\"\n    total_distance = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == piece.color), None)\n            if king_square is not None:\n                total_distance += chess.square_distance(square, king_square)\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy pieces and are themselves unprotected.\"\n    unprotected_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(piece.color, square)\n            if attackers and not any(board.is_attacked_by(piece.color, square) for square in attackers):\n                unprotected_attacks += 1\n    return float(unprotected_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pieces that can move to attack enemy pieces next turn.\"\n    attacking_squares = 0\n    for move in board.legal_moves:\n        potential_square = move.to_square\n        if board.is_attacked_by(not board.turn, potential_square):\n            attacking_squares += 1\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares where two pieces defend each other, indicating strong piece coordination.\"\n    mutual_defense = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            defending_squares = board.attackers(piece.color, square)\n            if any(defending_square in defending_squares for defending_square in defending_squares):\n                mutual_defense += 1\n    return float(mutual_defense)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that can deliver check to the opponent's king.\"\n    check_count = 0\n    current_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    for move in board.legal_moves:\n        if board.is_check():\n            check_count += 1\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the current player's pieces to the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, opponent_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between pieces on the board, with priority on major pieces.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    material_value = 0.0\n    for square, piece in board.piece_map().items():\n        value = piece_values.get(piece.piece_type, 0)\n        material_value += value if piece.color == board.turn else -value\n    return material_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are completely undefended by either side.\"\n    undefended_squares = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is None and not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            undefended_squares += 1\n    return float(undefended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks for pieces controlled by the player to move, with a focus on potential promotion.\"\n    rank_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            rank_sum += chess.square_rank(square) + 1  # Ranks are 0-indexed\n    return float(rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of available promotion paths for pawns in the opponent's half.\"\n    promotion_paths = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) in [5, 6, 7]:  # Pawn promotion ranks\n                for dest in board.legal_moves:\n                    if dest.from_square == square and (dest.to_square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8,\n                                                                         chess.F8, chess.G8, chess.H8]):\n                        promotion_paths += 1\n    return float(promotion_paths)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under attack by the current player.\"\n    attacked_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square):\n            attacked_squares += 1\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking the opponent's king.\"\n    attacking_piece_count = 0\n    opponent_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(board.turn, opponent_king_square):\n            attacking_piece_count += 1\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player's pieces as a ratio of available legal moves to total pieces.\"\n    total_moves = len(list(board.legal_moves))\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_moves) / (total_pieces if total_pieces > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of direct threats to the current player's pieces.\"\n    threat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(board.turn, square)):\n                threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of potential promotions for both sides.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has in the 6th and 7th ranks.\"\n    white_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) >= 6)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by opposing pieces around the kings.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    \n    white_control = sum(1 for square in board.attackers(chess.WHITE, black_king_square))\n    black_control = sum(1 for square in board.attackers(chess.BLACK, white_king_square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in ranks from the kings to the nearest opposing piece.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    \n    nearest_white_distance = min((chess.square_distance(white_king_square, square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK), default=0)\n    nearest_black_distance = min((chess.square_distance(black_king_square, square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE), default=0)\n    return float(nearest_white_distance - nearest_black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are in a position to give check vs. those that are not.\"\n    checking_pieces = sum(1 for move in board.legal_moves if board.is_check())\n    total_pieces = len(board.piece_map())\n    return float(checking_pieces) / float(total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the first rank for both players.\"\n    white_first_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_first_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_first_rank - black_first_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of unprotected opposing pieces.\"\n    unprotected_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by both players that are adjacent to each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    \n    white_adjacent_control = sum(1 for square in chess.SQUARES if (adj := chess.square_distance(white_king_square, square) == 1 and board.is_attacked_by(chess.WHITE, square)))\n    black_adjacent_control = sum(1 for square in chess.SQUARES if (adj := chess.square_distance(black_king_square, square) == 1 and board.is_attacked_by(chess.BLACK, square)))\n    return float(white_adjacent_control - black_adjacent_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pawns from their respective promotion ranks.\"\n    white_pawns_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_distance - black_pawns_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the closest king to the center of the board.\"\n    center_square = chess.parse_square('e4')\n    white_king = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    white_distance = chess.square_distance(white_king, center_square) if white_king is not None else float('inf')\n    black_distance = chess.square_distance(black_king, center_square) if black_king is not None else float('inf')\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 7th rank (promoting rank) for both sides.\"\n    white_seventh = len([square for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE])\n    black_seventh = len([square for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK])\n    return float(white_seventh - black_seventh)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (cannot move due to being attacked).\"\n    pinned = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attacking_moves = [move for move in board.legal_moves if move.from_square == square and board.piece_at(move.to_square) is not None]\n            if not attacking_moves or (len(attacking_moves) == 1 and attacking_moves[0].to_square == square):\n                pinned += 1\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by at least two pieces for the current player.\"\n    attack_map = {}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    target_square = move.to_square\n                    attack_map[target_square] = attack_map.get(target_square, 0) + 1\n    return float(sum(1 for count in attack_map.values() if count >= 2))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of available moves for each side and returns the difference.\"\n    white_moves = len(list(board.legal_moves))\n    board.push(chess.Move.null())\n    black_moves = len(list(board.legal_moves))\n    board.pop()\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by both players' pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        controlled_squares.add(square)\n        for move in board.legal_moves:\n            if move.from_square == square:\n                controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 4th rank for both players and returns the difference.\"\n    white_pawns = sum(1 for square in range(chess.A4, chess.H4 + 1) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in range(chess.A4, chess.H4 + 1) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of enemy pieces that can be captured next turn.\"\n    capture_candidates = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and board.piece_at(move.to_square).color != board.turn)\n    return float(capture_candidates)", "def feature(board: chess.Board) -> float:\n    \"Measures the protection ratio by counting squares defended by more than one piece.\"\n    doubled_defenses = 0\n    defense_map = {}\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square and move.to_square not in defense_map:\n                defense_map[move.to_square] = 1\n            elif move.from_square == square:\n                defense_map[move.to_square] += 1\n    doubled_defenses = sum(1 for count in defense_map.values() if count > 1)\n    return float(doubled_defenses)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map().keys()]\n    return float(sum(distances)) / len(distances) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are on the 6th rank or further.\"\n    count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) >= 5)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by pieces of the current player.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by both players' pieces combined.\"\n    controlled_squares = set()\n    for square in board.piece_map().keys():\n        controlled_squares.add(square)\n        for move in board.legal_moves:\n            if move.from_square == square:\n                controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can participate in a discovered attack.\"\n    count = sum(1 for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and piece.piece_type != chess.KING and board.is_attacked_by(piece.color, square))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that are on their optimal squares vs total pieces.\"\n    optimal_positions = sum(1 for square, piece in board.piece_map().items() if (piece.piece_type == chess.PAWN and chess.square_rank(square) in [6, 7]) or (piece.piece_type in {chess.ROOK, chess.QUEEN} and chess.square_rank(square) == 7) or (piece.piece_type == chess.KNIGHT and chess.square_rank(square) in [5, 6]) or (piece.piece_type == chess.BISHOP and chess.square_file(square) in [2, 5]) or (piece.piece_type == chess.KING and chess.square_rank(square) == 7))\n    total_pieces = len(board.piece_map())\n    return float(optimal_positions) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker_square in board.attackers(board.turn, square):\n                if board.piece_at(attacker_square) and board.piece_at(attacker_square).piece_type == chess.ROOK:\n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the cumulative value of pieces that are hanging (not adequately protected).\"\n    hanging_value = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by((chess.WHITE if piece.color == chess.BLACK else chess.BLACK), square) and chess.square_rank(square) < 7:\n            hanging_value += piece.piece_type\n    return float(hanging_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility difference, calculated as the difference in the number of legal moves for both players.\"\n    white_moves = len(list((move for move in board.legal_moves if board.turn)))\n    black_moves = len(list((move for move in board.legal_moves if not board.turn)))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of mobile pieces to total pieces for each side.\"\n    white_moves = len(list(board.legal_moves))\n    total_pieces = len(board.piece_map())\n    return float(white_moves) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of checks available to the player to move.\"\n    return float(len([m for m in board.legal_moves if board.gives_check(m)]))", "def feature(board: chess.Board) -> float:\n    \"Counts the total distance of all pawns from their respective promotion ranks.\"\n    distance_sum = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of double threats, where pieces threaten multiple opponent pieces.\"\n    count = 0\n    for square in board.piece_map().keys():\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be reached by the current player's next move.\"\n    reachable_squares = set()\n    for move in board.legal_moves:\n        reachable_squares.add(move.to_square)\n    return float(len(reachable_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces for both sides, as a ratio.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves))\n    total_moves = white_moves + black_moves\n    return float(white_moves) / total_moves if total_moves > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates how many of the opponent's pieces are under direct attack.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the pawns in advanced positions (above the 4th rank).\"\n    advanced_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    return float(advanced_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pawns for each side.\"\n    white_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    occupied_squares = len([square for square in board.piece_map()])\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of defending pieces around the kings for both sides.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_defenders = len(board.attackers(chess.WHITE, white_king_square))\n    black_defenders = len(board.attackers(chess.BLACK, black_king_square))\n    return float(white_defenders - black_defenders)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential back rank checkmating threats for each side.\"\n    rank_seven = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    rank_one = [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    black_threats = sum(1 for square in rank_one if board.piece_at(square) is None and len(board.attackers(chess.BLACK, square)) > 0)\n    white_threats = sum(1 for square in rank_seven if board.piece_at(square) is None and len(board.attackers(chess.WHITE, square)) > 0)\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of distinct squares attacked by pieces of the current player.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    attacked_squares = set(square for move in board.legal_moves for square in [move.to_square])\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each color that occupy central squares.\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    white_central = len([square for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE])\n    black_central = len([square for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK])\n    return float(white_central - black_central)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the opponent's king.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != color)\n    distances = [chess.square_distance(piece_square, opponent_king_square) for piece_square in board.piece_map() if board.piece_at(piece_square).color == color]\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces not participating in the central square control.\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    non_participating = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and square not in central_squares)\n    return float(non_participating)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total count of available captures for both sides.\"\n    white_captures = len([move for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color != chess.WHITE])\n    black_captures = len([move for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color != chess.BLACK])\n    return float(white_captures - black_captures)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the enemy king is in check.\"\n    check_count = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares adjacent to the enemy king that are attacked.\"\n    enemy_king_square = next((sq for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    if enemy_king_square is not None:\n        adjacent_squares = [square for square in chess.SQUARES if chess.square_distance(enemy_king_square, square) == 1]\n        attacked_count = sum(1 for sq in adjacent_squares if board.is_attacked_by(chess.WHITE, sq))\n        return float(attacked_count)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    enemy_king_square = next((sq for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    if enemy_king_square is not None:\n        attackers_count = len(board.attackers(chess.WHITE, enemy_king_square))\n        return float(attackers_count)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target_square in chess.SQUARES:\n                if board.is_attacked_by(board.turn, target_square) and board.piece_at(target_square) and board.piece_at(target_square).piece_type == chess.KING and board.piece_at(target_square).color == piece.color:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by the current player's pieces in the opponent's half.\"\n    occupied_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) > 3)\n    return float(occupied_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checkmates in one move for the current player.\"\n    checkmate_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            checkmate_count += 1\n        board.pop()\n    return float(checkmate_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces involved in attacking sequences (double attacks).\"\n    double_attack_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square):\n            attackers = len(board.attackers(board.turn, square))\n            if attackers > 1:\n                double_attack_count += 1\n    return float(double_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the back rank of the opponent.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    attacking_pieces = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and board.is_attacked_by(board.turn, opponent_back_rank))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total influence of pieces on the opponent's half of the board.\"\n    influence_score = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) > 3)\n    return float(influence_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of critical squares near the opponent's king that are not defended.\"\n    enemy_king_square = next((sq for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    if enemy_king_square is not None:\n        adjacent_squares = [square for square in chess.SQUARES if chess.square_distance(enemy_king_square, square) == 1]\n        undefended_count = sum(1 for sq in adjacent_squares if board.is_attacked_by(chess.WHITE, sq) == False and board.piece_at(sq) is None)\n        return float(undefended_count)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces each side has on the back rank.\"\n    back_rank_white = sum(1 for sq in range(56, 64) if board.piece_at(sq))\n    back_rank_black = sum(1 for sq in range(0, 8) if board.piece_at(sq))\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the current player's pieces that are also occupied by opponent's pieces.\"\n    attacking_squares = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.turn, sq))\n    occupied_attacking_squares = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.turn, sq) and board.piece_at(sq).color != board.turn)\n    return float(occupied_attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces of the current player to the opponent's pieces.\"\n    distance_sum = sum(chess.square_distance(square, opponent_square) \n                       for square in board.piece_map() \n                       for opponent_square in board.piece_map() \n                       if board.piece_at(square).color == board.turn and board.piece_at(opponent_square).color != board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially check the opponent's king.\"\n    checking_pieces = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all unprotected pieces for the current player.\"\n    unprotected_rank_sum = sum(chess.square_rank(square) + 1 \n                                for square in board.piece_map() \n                                if board.piece_at(square).color == board.turn and \n                                   not board.attackers(not board.turn, square))\n    return float(unprotected_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential promotions for pawns that are currently within two squares of the promotion rank.\"\n    promoting_pawns = sum(1 for sq in board.piece_map() \n                          if board.piece_at(sq).piece_type == chess.PAWN and \n                          ((board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 6) or \n                           (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 1)))\n    return float(promoting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the opponent's king is not protected.\"\n    king_square = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn]\n    if not king_square:\n        return 0.0\n    king_square = king_square[0]\n    unprotected_king_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq) and not board.is_attacked_by(not board.turn, sq))\n    return float(unprotected_king_squares)", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of pieces whose legal moves are entirely restricted.\"\n    restricted_pieces_count = sum(1 for sq in board.piece_map() \n                                   if board.piece_at(sq).color == board.turn and \n                                   not any(move.from_square == sq for move in board.legal_moves))\n    return float(restricted_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent pieces that are currently pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares in the opponent's territory controlled by the current player.\"\n    controlled_squares = 0\n    for square in range(64):\n        if board.is_attacked_by(board.turn, square) and chess.square_rank(square) > 4:\n            controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces currently in the center (squares d4, d5, e4, e5).\"\n    center_value = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for square in center_squares:\n        piece = board.piece_at(square)\n        if piece:\n            piece_value_map = {\n                chess.PAWN: 100,\n                chess.KNIGHT: 300,\n                chess.BISHOP: 300,\n                chess.ROOK: 500,\n                chess.QUEEN: 900,\n                chess.KING: 0,\n            }\n            center_value += piece_value_map[piece.piece_type] if piece.piece_type in piece_value_map else 0\n    return float(center_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of backward pawns for the current player.\"\n    backward_pawn_count = 0\n    current_color = board.turn\n    for square in range(8):\n        for file in range(8):\n            square_index = chess.square(file, square)\n            piece = board.piece_at(square_index)\n            if piece and piece.color == current_color and piece.piece_type == chess.PAWN:\n                if (square < 7 and board.piece_at(square_index + 8) is None) and (\n                    any(board.piece_at(chess.square(file, rank)) is None for rank in range(square + 1, 8))):\n                    backward_pawn_count += 1\n    return float(backward_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of ranks of all enemy pieces that are currently attacking the current player's king.\"\n    attack_rank_sum = 0\n    king_square = board.king(board.turn)\n    for attacker in board.attackers(not board.turn, king_square):\n        attacker_piece = board.piece_at(attacker)\n        attack_rank_sum += chess.square_rank(attacker) + 1 if attacker_piece else 0\n    return float(attack_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that have pieces from both colors, representing contested areas.\"\n    contested_squares = 0\n    for square in range(64):\n        if board.piece_at(square) is not None and len(board.attackers(board.turn, square)) > 0 and len(board.attackers(not board.turn, square)) > 0:\n            contested_squares += 1    \n    return float(contested_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces directly defending the opponent's king.\"\n    defending_count = 0\n    king_square = board.king(not board.turn)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and chess.square_distance(square, king_square) <= 1:\n            defending_count += 1\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the current player\u2019s pawns to the opponent's back rank.\"\n    total_distance = 0\n    for square in range(8):\n        for file in range(8):\n            square_index = chess.square(file, square)\n            piece = board.piece_at(square_index)\n            if piece and piece.color == board.turn and piece.piece_type == chess.PAWN:\n                total_distance += 7 - chess.square_rank(square_index)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    isolated_count = 0\n    current_color = board.turn\n    for file in range(8):\n        has_left_neighbor = board.piece_at(chess.square(file - 1, chess.square_rank(chess.A1))) if file > 0 else None\n        has_right_neighbor = board.piece_at(chess.square(file + 1, chess.square_rank(chess.A1))) if file < 7 else None\n        for rank in range(8):\n            square_index = chess.square(file, rank)\n            piece = board.piece_at(square_index)\n            if piece and piece.color == current_color and piece.piece_type == chess.PAWN:\n                if (not has_left_neighbor or has_left_neighbor.color != current_color) and (not has_right_neighbor or has_right_neighbor.color != current_color):\n                    isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the opponent has pieces but the current player does not.\"\n    occupied_squares = set(board.piece_map().keys())\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    opponent_squares = {sq for sq, piece in board.piece_map().items() if piece.color == opponent_color}\n    return float(len(opponent_squares - occupied_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks.\"\n    total_distance = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)\n        else:\n            total_distance += (7 - chess.square_rank(square))\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players simultaneously.\"\n    attacking_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            attacking_squares.add(square)\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of pieces belonging to the current player.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            total_rank += chess.square_rank(square)\n            piece_count += 1\n    return float(total_rank / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking moves available for the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of back rank pieces for each side.\"\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if square >= chess.A1 and square <= chess.H1 and piece.color == chess.WHITE:\n            back_rank_count[chess.WHITE] += 1\n        elif square >= chess.A8 and square <= chess.H8 and piece.color == chess.BLACK:\n            back_rank_count[chess.BLACK] += 1\n    return float(back_rank_count[chess.WHITE] - back_rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures how many defending pieces are available for each side.\"\n    defending_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            defending_count[chess.WHITE] += len(board.attackers(chess.BLACK, square))\n        else:\n            defending_count[chess.BLACK] += len(board.attackers(chess.WHITE, square))\n    return float(defending_count[chess.WHITE] - defending_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by the current player's pieces in opponent's territory.\"\n    occupied_in_opponent_half = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(square) > 4:\n            occupied_in_opponent_half += 1\n    return float(occupied_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the opponent's half of the board.\"\n    opponent_half = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if (piece.color == chess.WHITE and chess.square_rank(square) > 4) or \\\n           (piece.color == chess.BLACK and chess.square_rank(square) < 4):\n            opponent_half += 1\n    return float(opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces that are protected by another piece.\"\n    protected_attacking_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            if any(board.piece_at(attacker).color == piece.color for attacker in attackers):\n                protected_attacking_pieces += 1\n    return float(protected_attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pawns from their promotion rank.\"\n    pawn_distance_to_promotion = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                pawn_distance_to_promotion += (7 - chess.square_rank(square))\n            else:\n                pawn_distance_to_promotion += (chess.square_rank(square))\n    return float(pawn_distance_to_promotion)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on their original squares, which may indicate underdeveloped positions.\"\n    original_position_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE and chess.square_rank(square) == 1 or \\\n           piece.color == chess.BLACK and chess.square_rank(square) == 6:\n            original_position_count += 1\n    return float(original_position_count)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces could potentially deliver a check within one move.\"\n    potential_checks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    potential_checks += 1\n                    break\n    return float(potential_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board beyond the 4th rank.\"\n    pieces_beyond_fourth = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if chess.square_rank(square) > 3:\n            pieces_beyond_fourth[piece.color] += 1\n    return float(pieces_beyond_fourth[chess.WHITE] - pieces_beyond_fourth[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks available to both sides combined.\"\n    total_checks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    total_checks += 1\n                    break\n    return float(total_checks)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of squares controlled exclusively by one side.\"\n    exclusive_control = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            exclusive_control += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            exclusive_control += 1\n    return float(exclusive_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both sides; higher values indicate a more active side.\"\n    white_mobility = sum(1 for _ in board.legal_moves if board.turn == chess.WHITE)\n    black_mobility = sum(1 for _ in board.legal_moves if board.turn == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the opponent's king for both sides.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = 0\n    piece_count = 0\n    for square in board.piece_map():\n        piece_count += 1\n        total_distance += chess.square_distance(square, opponent_king_square)\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces protected by other pieces for the current player.\"\n    protected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).color == board.turn:\n                    protected_count += 1\n                    break\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks of all pawns on the board; higher rank means closer to promotion.\"\n    pawn_rank_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_rank_sum += chess.square_rank(square) + 1  # +1 to convert to 1-based rank\n    return float(pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of double threats (attacks on two pieces simultaneously) on the board.\"\n    double_threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_by = board.attackers(not board.turn, square)  # pieces attacking this piece\n            if len(attacked_by) > 1:\n                double_threats += 1\n    return float(double_threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares completely controlled by the current player's pieces.\"\n    controlled_squares = 0\n    for file in range(8):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.is_attacked_by(board.turn, square) and not any(board.is_attacked_by(not board.turn, square) for square in board.attackers(not board.turn, square)):\n                controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces of each color that are currently on their last rank.\"\n    last_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) == (7 if piece.color == chess.WHITE else 0):\n            last_rank_count[piece.color] += 1\n    return float(last_rank_count[chess.WHITE] - last_rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for promotion by counting the number of pawns within striking distance of promotion (ranks 6 and 7).\"\n    promotion_potential = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 6) or (piece.color == chess.BLACK and chess.square_rank(square) <= 1):\n                promotion_potential += 1\n    return float(promotion_potential)", "def feature(board: chess.Board) -> float:\n    \"Measures the total influence of each side's pieces by summing the ranks of active pieces.\"\n    total_rank_sum = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank_sum[chess.WHITE] += (chess.square_rank(square) + 1)\n        else:\n            total_rank_sum[chess.BLACK] += (chess.square_rank(square) + 1)\n    return float(total_rank_sum[chess.WHITE] - total_rank_sum[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Counts the difference in material value between the two sides based on standard piece values.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares that are controlled by pawns for the current player.'\n    controlled_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of doubled pawns for both players.'\n    white_pawn_counts = {}\n    black_pawn_counts = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_pawn_counts[file] = white_pawn_counts.get(file, 0) + 1\n            else:\n                black_pawn_counts[file] = black_pawn_counts.get(file, 0) + 1\n    doubled_pawns = (sum(1 for count in white_pawn_counts.values() if count > 1) +\n                     sum(1 for count in black_pawn_counts.values() if count > 1))\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of potential forks available to each side.'\n    forks_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        attackers = board.attackers(board.turn, move.to_square)\n        if len(attackers) > 1:  # If more than one piece attacks the target\n            forks_count += 1\n        board.pop()\n    return float(forks_count)", "def feature(board: chess.Board) -> float:\n    'Measures the safety of each king based on the number of attacking pieces nearby.'\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n\n    white_king_threats = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and\n                              chess.square_distance(white_king, square) <= 1)\n    black_king_threats = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and\n                              chess.square_distance(black_king, square) <= 1)\n\n    return float(black_king_threats - white_king_threats)", "def feature(board: chess.Board) -> float:\n    'Counts the number of unprotected pieces for the current side.'\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and all(not board.is_attacked_by(not piece.color, sq) for sq in board.attackers(not piece.color, square)):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares controlled by multiple pieces for the current player.'\n    controlled_squares = {}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square):\n            controlled_squares[square] = controlled_squares.get(square, 0) + 1\n    return float(sum(1 for count in controlled_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    'Measures the total distance of all pieces to their respective back ranks.'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 7\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 0\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the opponent's half of the board.\"\n    white_in_opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_in_opponent_half - black_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = sum(chess.square_distance(square, center_square) for square in board.piece_map() for center_square in center_squares)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by pieces of each color.\"\n    white_attacked_squares = len(set(square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square)))\n    black_attacked_squares = len(set(square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square)))\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's closest pawn to the promotion rank.\"\n    white_pawns_distance = min((7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE), default=0)\n    black_pawns_distance = min((chess.square_rank(square) for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK), default=0)\n    return float(white_pawns_distance - black_pawns_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces in play that are on their optimal squares based on opening principles.\"\n    optimal_positions = {\n        chess.PAWN: [chess.A3, chess.B3, chess.C3, chess.D3, chess.E3, chess.F3, chess.G3, chess.H3, chess.A4, chess.B4, chess.C4, chess.D4, chess.E4, chess.F4, chess.G4, chess.H4],\n        chess.KNIGHT: [chess.B1, chess.G1, chess.B8, chess.G8],\n        chess.BISHOP: [chess.C1, chess.F1, chess.C8, chess.F8],\n        chess.ROOK: [chess.A1, chess.H1, chess.A8, chess.H8],\n        chess.QUEEN: [chess.D1, chess.D8],\n        chess.KING: [chess.E1, chess.E8]\n    }\n    pieces_in_optimal_positions = sum(1 for square, piece in board.piece_map().items() if square in optimal_positions.get(piece.piece_type, []) and piece.color == board.turn)\n    return float(pieces_in_optimal_positions)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are currently unprotected.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(piece.color, square) for square in board.attackers(not piece.color, square)))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for both sides combined.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map())\n    total_pieces = len(board.piece_map())\n    return float(total_rank / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both players simultaneously.\"\n    attacked_squares = set(square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by each side's major pieces.\"\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.QUEEN, chess.ROOK])\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.QUEEN, chess.ROOK])\n    return float(major_pieces_white - major_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the enemy king.\"\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK and piece.piece_type == chess.KING:\n            enemy_king_square = square\n            break\n    if enemy_king_square is None:\n        return 0.0\n    \n    attacking_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and board.is_attacked_by(chess.WHITE, enemy_king_square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that have enemy pieces attacking them.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.BLACK:\n            for attacker in board.attackers(chess.WHITE, square):\n                attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by pieces of the current player.\"\n    attacking_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for legal_move in board.legal_moves:\n                if legal_move.from_square == square:\n                    attacking_squares.add(chess.square_name(legal_move.to_square))\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the attacking capabilities (number of attacks) of each piece type.\"\n    attack_value = 0\n    for piece in board.piece_map().values():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attack_value += 1  # Simply counts each piece capable of attacking\n    return float(attack_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attacks on the opponent's king.\"\n    king_square = chess.square(4, 0) if board.turn else chess.square(4, 7)\n    return float(len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move two squares forward (e.g., pawns).\"\n    two_square_movers = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank == 1) or (piece.color == chess.BLACK and rank == 6):\n                two_square_movers += 1\n    return float(two_square_movers)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 7th rank (for White) or 2nd rank (for Black).\"\n    rank = 7 if board.turn else 1\n    pieces_on_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == rank)\n    return float(pieces_on_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that can lead to a double-check.\"\n    double_check_squares = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check() and len([m for m in board.legal_moves if board.is_check() and m.to_square != move.to_square]) > 0:\n            double_check_squares += 1\n        board.pop()\n    return float(double_check_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are placed on the back ranks (1st and 8th) for both players.\"\n    back_rank_count = sum(1 for square in board.piece_map() if chess.square_rank(square) == (0 if board.turn else 7))\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces that are located on the 7th rank (for White) or 2nd rank (for Black).\"\n    rank = 7 if board.turn else 1\n    attacking_on_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == rank and board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square))\n    return float(attacking_on_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks available, factoring in multi-piece checks.\"\n    checks_available = 0\n    for move in board.legal_moves:\n        if board.is_check():\n            checks_available += 1\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are adjacent to the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    return float(len(list(board.attackers(board.turn, opponent_king_square)))) if opponent_king_square else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares from which the opponent's king can be attacked by the current player's pieces.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    return float(len([square for square in board.legal_moves if board.is_attacked_by(board.turn, opponent_king_square)])) if opponent_king_square else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that can deliver check to the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    return float(len([move for move in board.legal_moves if board.is_attacked_by(board.turn, opponent_king_square)]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares each side controls within the opponent's half of the board.\"\n    controlled_white = len([sq for sq in chess.SquareSet(board.piece_map().keys()) if board.is_attacked_by(chess.WHITE, sq) and chess.square_rank(sq) >= 4])\n    controlled_black = len([sq for sq in chess.SquareSet(board.piece_map().keys()) if board.is_attacked_by(chess.BLACK, sq) and chess.square_rank(sq) <= 3])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defended squares in the opponent's half of the board.\"\n    return float(len([sq for sq in chess.SquareSet(board.piece_map().keys()) if board.is_attacked_by(board.turn, sq) and chess.square_rank(sq) <= 3]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attacking moves available for the current player, restricted to moves that can threaten the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    return float(len([move for move in board.legal_moves if move.to_square == opponent_king_square]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that contain both players' pieces.\"\n    occupied_squares = sum(1 for square in board.piece_map() if square)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where at least one piece can deliver a check.\"\n    check_squares = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces placed on the ranks closest to the opponent.\"\n    close_ranks = [rank for rank in range(2, 8) if (board.turn == chess.WHITE and rank == 7) or (board.turn == chess.BLACK and rank == 0)]\n    pieces_in_close_ranks = sum(1 for square in board.piece_map() if chess.square_rank(square) in close_ranks)\n    return float(pieces_in_close_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of pieces that are on the 7th rank for White or 2nd rank for Black.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    total_material = sum(material_values.get(board.piece_at(square).piece_type, 0) \n                          for square in board.piece_map() \n                          if (board.turn == chess.WHITE and chess.square_rank(square) == 7) or \n                             (board.turn == chess.BLACK and chess.square_rank(square) == 0))\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of free pieces not threatened by any enemy pieces.\"\n    unthreatened_pieces = sum(1 for square in board.piece_map() if not board.is_attacked_by(not board.turn, square))\n    return float(unthreatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces to the opponent's nearest piece.\"\n    distances = [min(chess.square_distance(square, enemy_square) \n                     for enemy_square in board.piece_map() if board.piece_at(enemy_square).color != board.turn) \n                 for square in board.piece_map()]\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of the board that is controlled by each color's pieces.\"\n    total_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) or board.is_attacked_by(chess.BLACK, sq))\n    controlled_by_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    controlled_by_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(controlled_by_white) / (total_controlled or 1) - float(controlled_by_black) / (total_controlled or 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are on their optimal squares.\"\n    optimal_positions = {chess.KING: [0, 1, 2, 3, 4, 5, 6, 7], chess.QUEEN: [0, 1, 2, 3, 4, 5, 6, 7],\n                         chess.ROOK: [0, 1], chess.BISHOP: [2, 5], chess.KNIGHT: [1, 6], chess.PAWN: [1, 6]}\n    optimal_piece_count = sum(1 for square in board.piece_map() \n                               if chess.square_rank(square) in optimal_positions.get(board.piece_at(square).piece_type, []))\n    return float(optimal_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for advancement based on the number of pieces on the 6th rank for White or on the 3rd rank for Black.\"\n    rank_translation = {chess.WHITE: 6, chess.BLACK: 1}\n    advancing_rank = rank_translation[board.turn]\n    advancing_pieces = sum(1 for square in board.piece_map()\n                            if chess.square_rank(square) == advancing_rank)\n    return float(advancing_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if (\n        board.is_attacked_by(board.turn, square) and \n        board.is_attacked_by(not board.turn, square)\n    ))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available that don't expose the current player's king.\"\n    check_moves = sum(1 for move in board.legal_moves if (\n        board.gives_check(move) and \n        not board.is_check()\n    ))\n    return float(check_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of diagonal attacking lines available for each side.\"\n    diagonal_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not board.turn, square)\n            diagonal_attacks += sum(1 for attacker in attackers if chess.square_file(attacker) != chess.square_file(square) and \n                                     abs(chess.square_rank(attacker) - chess.square_rank(square)) == abs(chess.square_file(attacker) - chess.square_file(square)))\n    return float(diagonal_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that both kings can move to safely.\"\n    safe_squares = 0\n    for square in [board.king(chess.WHITE), board.king(chess.BLACK)]:\n        if square is not None:\n            for move in board.legal_moves:\n                if move.to_square == square and not board.is_attacked_by(not board.turn, square):\n                    safe_squares += 1\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the overall piece safety by counting pieces not in a position where they can be captured next turn.\"\n    safe_pieces = sum(1 for square, piece in board.piece_map().items() if (\n        piece.color == board.turn and \n        not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square))\n    ))\n    return float(safe_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures how many of the enemy's pieces are currently undefended.\"\n    undefended_enemy_pieces = sum(1 for square, piece in board.piece_map().items() if (\n        piece.color != board.turn and \n        not any(board.is_attacked_by(board.turn, square) for square in board.attackers(board.turn, square))\n    ))\n    return float(undefended_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in central control between both sides.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_white = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board that are located on the second rank.\"\n    second_rank_value = sum(piece.piece_type for square, piece in board.piece_map().items() if (\n        (piece.color == chess.WHITE and chess.square_rank(square) == 1) or \n        (piece.color == chess.BLACK and chess.square_rank(square) == 6)\n    ))\n    return float(second_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total attacking potential by counting isolated pieces capable of immediate threat.\"\n    isolated_attacks = sum(1 for square, piece in board.piece_map().items() if (\n        piece.color == board.turn and \n        len(list(board.attackers(not board.turn, square))) == 0 and \n        len(list(board.attackers(board.turn, square))) > 0\n    ))\n    return float(isolated_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces on the back rank for both players.\"\n    back_rank_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if (\n        (piece.color == chess.WHITE and chess.square_rank(square) == 0) or \n        (piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    ))\n    return float(back_rank_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for each side, as pawns influence structure.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces located in the opponent's half of the board.\"\n    white_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_in_enemy_half - black_in_enemy_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the opponent's pieces to their respective back rank.\"\n    total_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by the opponent but not defended.\"\n    attacked_not_defended = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square))\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that are actively participating (not blocked) in the action.\"\n    white_active = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and board.legal_moves.count() > 0)\n    black_active = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and board.legal_moves.count() > 0)\n    return float(white_active - black_active)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that are pinned (unable to move due to threats) for the current player.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.piece_at(square) and board.is_attacked_by(not board.turn, square))\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(pinned_count) / max(1, total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where one piece can attack two of the opponent's pieces).\"\n    double_attacks = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            attacking_squares = [attacker for attacker in board.attackers(chess.WHITE, square)]\n            if len(attacking_squares) > 1:\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of pawns for each player as a feature of strength.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares occupied by the current player behind enemy lines.'\n    count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) > 4)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in ranks of the pawns for each player to assess advancement.'\n    white_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if (board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE))\n    black_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if (board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK))\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    'Measures the number of enemy pieces that are on the back rank of the opponent.'\n    count = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in mobility; defined as legal moves of both players.'\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    'Analyzes the count of direct attacking opportunities against the opponent\u2019s king.'\n    count = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total value of pieces on the board that are currently unprotected.'\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            total_value += piece.piece_type\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the nearest enemy piece for all of the current player\u2019s pieces.'\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_count += 1\n            nearest_enemy_distance = float('inf')\n            for enemy_square, enemy_piece in board.piece_map().items():\n                if enemy_piece.color != piece.color:\n                    distance = chess.square_distance(square, enemy_square)\n                    if distance < nearest_enemy_distance:\n                        nearest_enemy_distance = distance\n            total_distance += nearest_enemy_distance\n\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the board that are providing pins.'\n    pin_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if any(attackers):\n                for attacker in attackers:\n                    if board.is_attacked_by(piece.color, attacker):\n                        pin_count += 1\n                        break\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    'Measures the average rank of the current player\u2019s pawns.'\n    total_rank = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            total_rank += chess.square_rank(square)\n            pawn_count += 1\n\n    return total_rank / pawn_count if pawn_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of pieces with potential to develop.'\n    white_development = 0\n    black_development = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if chess.square_rank(square) == 0:  # Initial position for development\n                white_development += 1\n        elif piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if chess.square_rank(square) == 7:  # Initial position for development\n                black_development += 1\n\n    return float(white_development - black_development)", "def feature(board: chess.Board) -> float:\n    'Counts the potential check threats posed by each player on their next turn.'\n    potential_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            potential_checks += 1\n        board.pop()\n    return float(potential_checks)", "def feature(board: chess.Board) -> float:\n    'Measures the imbalance of pawn structure, counting doubled pawns for each side.'\n    white_doubled = 0\n    black_doubled = 0\n    white_files = {}\n    black_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                file = chess.square_file(square)\n                white_files[file] = white_files.get(file, 0) + 1\n            else:\n                file = chess.square_file(square)\n                black_files[file] = black_files.get(file, 0) + 1\n\n    for count in white_files.values():\n        if count > 1:\n            white_doubled += count\n    for count in black_files.values():\n        if count > 1:\n            black_doubled += count\n\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    'Evaluates the sum of the distances from all pieces to the back rank.'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        distance_to_back_rank = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n        total_distance += distance_to_back_rank\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares occupied by both players.\"\n    occupied_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    shared_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(shared_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of non-pawn pieces on the back ranks of each player.\"\n    back_rank_white = [square for square in chess.SQUARES[56:64] if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type != chess.PAWN]\n    back_rank_black = [square for square in chess.SQUARES[0:8] if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type != chess.PAWN]\n    return float(len(back_rank_white) + len(back_rank_black))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of double threats (two pieces attacking the same target).\"\n    double_threats = sum(1 for square in chess.SQUARES if len(board.attackers(board.turn, square)) > 1)\n    return float(double_threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on their optimal squares.\"\n    optimal_positions = [\n        chess.A1, chess.H1, chess.B1, chess.G1,  # Rooks\n        chess.C1, chess.F1,  # Knights\n        chess.D1,  # Queen\n        chess.E1,  # King\n        chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2,  # Pawns\n        chess.A8, chess.H8, chess.B8, chess.G8,  # Rooks\n        chess.C8, chess.F8,  # Knights\n        chess.D8,  # Queen\n        chess.E8   # King\n    ]\n    optimal_count = sum(1 for square in optimal_positions if board.piece_at(square) is not None)\n    return float(optimal_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces of each color that are in their essential positions.\"\n    essential_positions = [chess.A1, chess.H1, chess.B1, chess.G1, chess.A2, chess.H2, chess.B2, chess.G2]\n    white_essential = sum(1 for sq in essential_positions if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_essential = sum(1 for sq in essential_positions if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = float(white_essential - black_essential)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of uncovered squares (not attacked or defended) for both colors.\"\n    total_uncovered = 0\n    for rank in range(8):\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is None:\n                if not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n                    total_uncovered += 1\n    return float(total_uncovered)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the current player minus the opponent's controlled squares.\"\n    controlled_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    result = float(controlled_white - controlled_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Computes the sum of the ranks of all pieces attacking the opponent's king.\"\n    king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    total_ranks = sum(chess.square_rank(attacker) for square in board.attackers(board.turn, king_square) for attacker in chess.SQUARES if board.piece_at(square))\n    return float(total_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can attack two or more enemy pieces.\"\n    attacking_pairs = 0\n    for square in board.piece_map().keys():\n        if board.piece_at(square).color == board.turn:\n            attacks = list(board.attackers(board.turn, square))\n            for target in attacks:\n                if board.piece_at(target) and board.piece_at(target).color != board.turn:\n                    for other_square in attacks:\n                        if other_square != target and board.piece_at(other_square) and board.piece_at(other_square).color != board.turn:\n                            attacking_pairs += 1\n    return float(attacking_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of opponent's hanging pieces (pieces that are not defended).\"\n    hanging_pieces = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            hanging_pieces += 1\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares with two or more attackers for the current player's pieces.\"\n    multi_attacked_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) >= 2:\n            multi_attacked_squares.add(square)\n    return float(len(multi_attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of captured pieces relative to the starting position for both players.\"\n    initial_piece_count = {chess.WHITE: 16, chess.BLACK: 16}\n    captured_white = 16 - len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    captured_black = 16 - len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    result = float(captured_white - captured_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled exclusively by the active player.\"\n    controlled_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(not board.turn, square):\n            controlled_squares.add(square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces in the opponent's half of the board.\"\n    value = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn and chess.square_rank(square) > 4:\n            value += piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (unprotected pieces) for the current player.\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and len(board.attackers(not board.turn, square)) == 0:\n            hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discovered checks available to the current player.\"\n    discovered_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            discovered_checks += 1\n        board.pop()\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are protected by two or more pieces.\"\n    protected_squares = set()\n    for square in range(64):\n        if len(board.attackers(board.turn, square)) >= 2:\n            protected_squares.add(square)\n    return float(len(protected_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces placed in the back rank for both players.\"\n    back_rank_count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and (piece.color == chess.WHITE and chess.square_rank(square) == 0 or \n                      piece.color == chess.BLACK and chess.square_rank(square) == 7):\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the maximum distance of any piece from its respective back rank.\"\n    max_distance = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            distance = chess.square_rank(square) if piece.color == chess.BLACK else 7 - chess.square_rank(square)\n            max_distance = max(max_distance, distance)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares where a player's pieces can be developed (not on the first two ranks).\"\n    development_count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_rank(square) < 2:\n            development_count += 1\n    return float(development_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of the current player's pieces in optimal development positions (central squares).\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    optimal_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    total_pieces = len([piece for piece in board.piece_map().values() if piece.color == board.turn])\n    return optimal_count / (total_pieces if total_pieces > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opponent's king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are unable to move (blocked pieces).\"\n    blocked_pieces_count = sum(1 for piece in board.piece_map().values() if not list(board.legal_moves).count(piece))\n    return float(blocked_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the second rank for both players.\"\n    white_pawns_on_second = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 1)\n    black_pawns_on_second = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 6)\n    return float(white_pawns_on_second - black_pawns_on_second)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each player has on the last two ranks.\"\n    white_pieces_on_last_two = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_pieces_on_last_two = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_pieces_on_last_two - black_pieces_on_last_two)", "def feature(board: chess.Board) -> float:\n    \"Counts how many squares are controlled by more than one piece from either color.\"\n    controlled_squares = {}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            for attacker in board.attackers(piece.color, square):\n                if square not in controlled_squares:\n                    controlled_squares[square] = 0\n                controlled_squares[square] += 1\n    return float(sum(1 for count in controlled_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for the side to move that attack the opponent's king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attacking_moves_count = sum(1 for move in board.legal_moves if board.is_attacked_by(board.turn, move.to_square) and move.to_square == king_square)\n    return float(attacking_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest pawns to their opponent's back rank.\"\n    white_distances = [chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) == chess.PAWN]\n    black_distances = [7 - chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) == chess.PAWN]\n    return float(min(white_distances, default=8) - min(black_distances, default=8))", "def feature(board: chess.Board) -> float:\n    \"Counts how many controlled squares are also attacked by an opponent's piece.\"\n    controlled_and_attacked_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            controlled_and_attacked_count += 1\n    return float(controlled_and_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks of all pieces for both players, giving higher importance to advanced pieces.\"\n    white_rank_sum = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have immediate threats or can deliver a check to the opponent on the next move.\"\n    threatening_or_checking_count = sum(1 for move in board.legal_moves if board.is_check() or board.is_attacked_by(board.turn, move.to_square))\n    return float(threatening_or_checking_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are attacking the opponent's king.\"\n    king_square = None\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    return float(len(list(board.attackers(not board.turn, king_square))))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in the game that are currently pinned.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns promoted by both players.\"\n    white_promotions = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 0)\n    black_promotions = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 7)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of open files available for rooks of both sides.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for the current player, giving more weight to advanced pieces.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_rank += chess.square_rank(square)\n            piece_count += 1\n    return total_rank / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are located on the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    count = sum(1 for square in chess.SQUARES if board.piece_at(square) and chess.square_rank(square) == opponent_back_rank and board.piece_at(square).color != board.turn)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of threats to the opponent's pieces that are unprotected.\"\n    unprotected_threats = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            if not board.is_attacked_by(board.turn, square):\n                continue\n            if all(not board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(not piece.color, square)):\n                unprotected_threats += 1\n    return float(unprotected_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece activity by calculating the total number of squares that pieces can reach.\"\n    reachable_squares = set()\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    reachable_squares.add(move.to_square)\n    return float(len(reachable_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are doubled pawns for both players.\"\n    doubles = 0\n    files = {}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if file_index in files:\n                doubles += 1\n            else:\n                files[file_index] = []\n            files[file_index].append(square)\n    return float(doubles)", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of each color's pieces that are on their optimal squares for the opening phase.\"\n    optimal_positions = {chess.WHITE: [chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1],\n                         chess.BLACK: [chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]}\n    total_pieces = 0\n    optimal_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece and piece.color in optimal_positions:\n            total_pieces += 1\n            if square in optimal_positions[piece.color]:\n                optimal_pieces += 1\n    return optimal_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available for each side and returns the difference.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    black_moves = len(list(board.legal_moves) if not board.turn else [])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each type for each player\"\n    piece_counts = {chess.WHITE: {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0},\n                    chess.BLACK: {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}}\n    \n    for piece in board.piece_map().values():\n        piece_counts[piece.color][piece.piece_type] += 1\n    \n    return float(piece_counts[chess.WHITE][chess.QUEEN] - piece_counts[chess.BLACK][chess.QUEEN])", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks held by each player\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    \n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each player's pieces\"\n    white_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(white_squares - black_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares each player can move to\"\n    white_moves = sum(1 for move in board.legal_moves if board.turn)\n    black_moves = sum(1 for move in board.legal_moves if not board.turn)\n    \n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    \n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checks available for each side\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    \n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pawns are doubled for each player\"\n    white_doubled = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 1)).color == chess.WHITE and board.piece_at(chess.square(file, 2)) and board.piece_at(chess.square(file, 2)).color == chess.WHITE)\n    black_doubled = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) and board.piece_at(chess.square(file, 6)).color == chess.BLACK and board.piece_at(chess.square(file, 5)) and board.piece_at(chess.square(file, 5)).color == chess.BLACK)\n    \n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures how far the pawns are from promotion\"\n    white_distance = sum(7 - chess.square_rank(square) for square in board.pieces(chess.PAWN, chess.WHITE))\n    black_distance = sum(chess.square_rank(square) for square in board.pieces(chess.PAWN, chess.BLACK))\n    \n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has that are on the 7th rank\"\n    white_seventh = sum(1 for square in board.pieces(chess.PAWN, chess.WHITE) if chess.square_rank(square) == 6)\n    black_seventh = sum(1 for square in board.pieces(chess.PAWN, chess.BLACK) if chess.square_rank(square) == 1)\n    \n    return float(white_seventh - black_seventh)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that cannot move\"\n    white_stuck = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and not any(board.is_legal(move) for move in board.legal_moves))\n    black_stuck = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and not any(board.is_legal(move) for move in board.legal_moves))\n    \n    return float(white_stuck - black_stuck)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares in the opponent's half that are attacked by the current player's pieces.\"\n    attacking_squares = sum(1 for move in board.legal_moves \n                            if move.to_square >= chess.E7 and move.from_square < chess.E7)\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares each player controls that are adjacent to the opponent's king.\"\n    white_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                           any(chess.square_distance(square, opponent_square) == 1 \n                               for opponent_square in [chess.KING, chess.KING + 1, chess.KING - 1, \n                                                       chess.KING + 8, chess.KING - 8]))\n    \n    black_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                           any(chess.square_distance(square, opponent_square) == 1 \n                               for opponent_square in [chess.KING, chess.KING + 1, chess.KING - 1, \n                                                       chess.KING + 8, chess.KING - 8]))\n    \n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces to the opponent's king.\"\n    total_distance_white = sum(chess.square_distance(square, board.king(chess.BLACK)) \n                                for square in board.piece_map().keys() \n                                if board.piece_map()[square].color == chess.WHITE)\n    total_distance_black = sum(chess.square_distance(square, board.king(chess.WHITE)) \n                                for square in board.piece_map().keys() \n                                if board.piece_map()[square].color == chess.BLACK)\n    \n    count_white = sum(1 for square in board.piece_map().keys() \n                      if board.piece_map()[square].color == chess.WHITE)\n    count_black = sum(1 for square in board.piece_map().keys() \n                      if board.piece_map()[square].color == chess.BLACK)\n    \n    avg_distance_white = total_distance_white / count_white if count_white > 0 else 0\n    avg_distance_black = total_distance_black / count_black if count_black > 0 else 0\n    \n    return float(avg_distance_white - avg_distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on the back rank of each player and returns the difference.\"\n    white_back_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                          board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                          board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n    \n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the density of pieces in the center of the board for both players.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5, chess.E3, chess.E6, chess.D3, chess.D6]\n    white_density = sum(1 for square in center_squares if board.piece_at(square) and \n                        board.piece_at(square).color == chess.WHITE)\n    black_density = sum(1 for square in center_squares if board.piece_at(square) and \n                        board.piece_at(square).color == chess.BLACK)\n    \n    return float(white_density - black_density)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pinned pieces for each player.\"\n    pinned_white = sum(1 for square in board.piece_map().keys() \n                       if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    pinned_black = sum(1 for square in board.piece_map().keys() \n                       if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    \n    return float(pinned_white - pinned_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns remaining for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares adjacent to the opponent's king that are attacked.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_squares = sum(1 for move in board.legal_moves if chess.square_distance(move.from_square, opponent_king_square) == 1)\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces can attack the opponent\u2019s unprotected pieces.\"\n    unprotected_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.turn, sq) and \n                              all(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(board.turn, sq)))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available to pieces on the back rank for both players.\"\n    back_rank_moves = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and \n                          chess.square_rank(next(sq for sq in board.piece_map() if board.piece_at(sq) == piece)) == (0 if piece.color == chess.WHITE else 7) and \n                          len(list(board.legal_moves)) > 0)\n    return float(back_rank_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are currently attacking squares in the opponent's half of the board.\"\n    attacking_opponent_half = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.turn, sq) and chess.square_rank(sq) > 3)\n    return float(attacking_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of both players' queens to the opponent's king.\"\n    white_queen_dist = sum(chess.square_distance(sq, next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)) \n                            for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.QUEEN and board.piece_at(sq).color == chess.WHITE)\n    black_queen_dist = sum(chess.square_distance(sq, next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)) \n                            for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.QUEEN and board.piece_at(sq).color == chess.BLACK)\n    return float((white_queen_dist + black_queen_dist) / (2 if (white_queen_dist + black_queen_dist) > 0 else 1))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of controlled squares by both players and returns the difference.\"\n    controlled_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    controlled_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares protected by the current player's pieces.\"\n    protected_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    protected_squares.add(move.to_square)\n    return float(len(protected_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by at least two pieces of the current player.\"\n    attack_count = {}\n    for move in board.legal_moves:\n        if move.to_square not in attack_count:\n            attack_count[move.to_square] = 0\n        attack_count[move.to_square] += 1\n    double_attacked_squares = sum(1 for count in attack_count.values() if count >= 2)\n    return float(double_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal captures available for the current player.\"\n    legal_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None)\n    return float(legal_captures)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns to their respective promotion ranks.\"\n    pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    attacking_king_positions = sum(1 for square in board.attackers(not board.turn, chess.KING) if board.is_attacked_by(board.turn, square))\n    return float(attacking_king_positions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of isolated pawns for each player.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.parse_square(chess.square_name(square))) is not None and\n                (\n                    (file > 0 and board.piece_at(chess.parse_square(chess.square_name(square - 1))) is None) and \n                    (file < 7 and board.piece_at(chess.parse_square(chess.square_name(square + 1))) is None)\n                )):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are advanced for both sides.\"\n    advanced_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    advanced_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(advanced_white - advanced_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces to the opponent's king.\"\n    total_distance_white = sum(chess.square_distance(square, chess.parse_square(chess.square_name(board.king(chess.WHITE)))) \n                                for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    total_distance_black = sum(chess.square_distance(square, chess.parse_square(chess.square_name(board.king(chess.BLACK)))) \n                                for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    average_distance_white = total_distance_white / max(1, len([square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE]))\n    average_distance_black = total_distance_black / max(1, len([square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK]))\n    return float(average_distance_white - average_distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked but not defended by any piece of the current player.\"\n    attacked_unprotected = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square) and \n                                not any(board.is_attacked_by(not board.turn, square) for square in board.attackers(not board.turn, square)))\n    return float(attacked_unprotected)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares that are attacked but not defended by any piece.'\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            attacked_not_defended += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    'Counts the total value of pieces in enemy territory for both sides.'\n    total_value = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            if (piece.color == chess.WHITE and square >= chess.A7) or (piece.color == chess.BLACK and square <= chess.A2):\n                total_value += piece.piece_type\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of pieces that are on the back rank for both players.'\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of attacking moves available for pieces on the back rank.'\n    total_attacking_moves = 0\n    for square in range(chess.A1, chess.H1 + 1):\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            total_attacking_moves += len(list(board.legal_moves))   # count possible moves for attack\n    return float(total_attacking_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pieces that can reach the opponent king in one move.'\n    count = 0\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and board.is_attacked_by(piece.color, opponent_king_square):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    'Calculates the sum of the squares occupied by advanced pieces.'\n    advanced_piece_sum = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            if (piece.color == chess.WHITE and chess.square_rank(square) > 4) or (piece.color == chess.BLACK and chess.square_rank(square) < 3):\n                advanced_piece_sum += square\n    return float(advanced_piece_sum)", "def feature(board: chess.Board) -> float:\n    'Measures the potential threats created by pieces capable of attacking the opposing king.'\n    potential_threats = 0\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(piece.color, opponent_king_square):\n                potential_threats += 1\n    return float(potential_threats)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces across the 4th rank for both players to assess control of the board.'\n    pieces_on_fourth_rank = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and chess.square_rank(square) == 3:  # 4th rank, zero-indexed\n            pieces_on_fourth_rank += 1\n    return float(pieces_on_fourth_rank)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of pieces to their optimal development squares.'\n    total_distance = 0\n    piece_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            piece_count += 1\n            if piece.color == chess.WHITE:\n                if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    total_distance += min(chess.square_distance(square, chess.B1), chess.square_distance(square, chess.C1))\n            else:\n                if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    total_distance += min(chess.square_distance(square, chess.B8), chess.square_distance(square, chess.C8))\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on each player's last two ranks.\"\n    white_last_two_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_last_two_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_last_two_ranks - black_last_two_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of kings to pieces for both players.\"\n    white_king = 1 if board.piece_map().get(chess.parse_square('e1')) else 0\n    black_king = 1 if board.piece_map().get(chess.parse_square('e8')) else 0\n    total_pieces = len(board.piece_map())\n    white_ratio = white_king / total_pieces if total_pieces > 0 else 0\n    black_ratio = black_king / total_pieces if total_pieces > 0 else 0\n    return float(white_ratio - black_ratio)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares occupied by both players' pieces.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially be involved in a check or checkmate.\"\n    potential_checkers = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, move.to_square))\n    return float(potential_checkers)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns to their respective promotion ranks.\"\n    total_pawn_distance = sum(7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are directly next to each other.\"\n    adjacent_piece_count = 0\n    square_map = board.piece_map()\n    for square in square_map:\n        if square in square_map:\n            adjacents = [square + 1, square - 1, square + 8, square - 8]\n            for adj in adjacents:\n                if adj in square_map and square_map[adj].color == square_map[square].color:\n                    adjacent_piece_count += 1\n    return float(adjacent_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts unprotected pieces that can be taken on the next move.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if not board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the center of the board.\"\n    total_distance_from_center = sum(chess.square_distance(square, chess.E4) for square in board.piece_map())\n    return float(total_distance_from_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 2nd and 7th ranks.\"\n    second_rank_count = len([square for square in board.piece_map() if chess.square_rank(square) == 1])\n    seventh_rank_count = len([square for square in board.piece_map() if chess.square_rank(square) == 6])\n    return float(second_rank_count - seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the current player\u2019s king to the center of the board.'\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distances = [chess.square_distance(king_square, sq) for sq in center_squares]\n    return min(distances)", "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces within the enemy\u2019s pawn promotion zone.'\n    promotion_zone = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    enemy_color = chess.BLACK if board.turn else chess.WHITE\n    return float(sum(1 for sq in promotion_zone if board.piece_at(sq) and board.piece_at(sq).color == enemy_color))", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces currently attacking the opponent\u2019s king.'\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    return float(len(board.attackers(chess.WHITE if board.turn else chess.BLACK, opponent_king_square)))", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of non-pawn pieces on the board.'\n    piece_map = board.piece_map()\n    non_pawn_count = sum(1 for piece in piece_map.values() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in rank values of pieces remaining on the board.'\n    rank_values = {chess.KING: 0, chess.QUEEN: 9, chess.ROOK: 5, chess.BISHOP: 3, chess.KNIGHT: 3, chess.PAWN: 1}\n    white_score = sum(rank_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_score = sum(rank_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_score - black_score)", "def feature(board: chess.Board) -> float:\n    'Measures the mobility of the side to move by calculating the number of possible captures.'\n    moves = list(board.legal_moves)\n    capture_moves = sum(1 for move in moves if board.is_attacked_by(board.piece_at(move.from_square).color, move.to_square))\n    return float(capture_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the total distance of the king to the nearest enemy piece.'\n    current_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    enemy_pieces = [sq for sq, piece in board.piece_map().items() if piece.color != (chess.WHITE if board.turn else chess.BLACK)]\n    if not enemy_pieces:\n        return 0.0\n    return float(min(chess.square_distance(current_king_square, ep) for ep in enemy_pieces))", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of protected pieces for the current player.'\n    protected_count = sum(1 for sq, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK)\n                          and len(board.attackers(piece.color, sq)) > 0)\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces protected by more than one other piece.'\n    protected_squares = {}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attackers = board.attackers(piece.color, square)\n            if not attackers:\n                continue\n            for attacker in attackers:\n                if attacker not in protected_squares:\n                    protected_squares[attacker] = 0\n                protected_squares[attacker] += 1\n    return float(sum(1 for count in protected_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled by pieces of each color.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the back rank.\"\n    back_rank_white = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pawns to the opponent's back rank.\"\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares occupied by both players' pieces.\"\n    occupied_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in values of pieces placed on the 7th rank (for White) or 2nd rank (for Black).\"\n    white_seventh_rank_value = sum(board.piece_at(square).piece_type for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_second_rank_value = sum(board.piece_at(square).piece_type for square in range(chess.A2, chess.H2 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank_value - black_second_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from the opponent's king.\"\n    distance_to_king = sum(chess.square_distance(square, board.king(chess.BLACK)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    return float(distance_to_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double threats (pieces attacking the same square) on the board.\"\n    threatened_squares = {}\n    for move in board.legal_moves:\n        threatened_squares[move.to_square] = threatened_squares.get(move.to_square, 0) + 1\n    \n    double_threats = sum(1 for count in threatened_squares.values() if count > 1)\n    return float(double_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proximity of pieces to each other's positions.\"\n    total_distance = 0\n    piece_positions = [pos for pos in board.piece_map()]\n    for i in range(len(piece_positions)):\n        for j in range(i + 1, len(piece_positions)):\n            total_distance += chess.square_distance(piece_positions[i], piece_positions[j])\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in danger of being captured in the next turn.\"\n    danger_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            danger_count += 1\n    return float(danger_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their respective back ranks, emphasizing advancement.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE:\n            total_distance += (7 - rank)  # Distance to back rank for White\n        else:\n            total_distance += rank  # Distance to back rank for Black\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of possible checks for both players.\"\n    total_checks = len([move for move in board.legal_moves if board.gives_check(move)])\n    return float(total_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the 7th rank (for White) or 2nd rank (for Black); indicates advanced position.\"\n    advanced_pieces = sum(1 for square in board.piece_map() if \n                          (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6) or \n                          (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1))\n    return float(advanced_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns in enemy territory (5th rank for White, 4th rank for Black) as a measure of pressure.\"\n    pawn_pressure = sum(1 for square in board.piece_map() if \n                        (board.piece_at(square).piece_type == chess.PAWN and \n                         (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4) or \n                         (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)))\n    return float(pawn_pressure)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are completely trapped and cannot move.\"\n    trapped_count = 0\n    for square, piece in board.piece_map().items():\n        if len(list(board.legal_moves)) == 0:  # No legal moves means it's trapped\n            trapped_count += 1\n    return float(trapped_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of attacking pieces and defending pieces for the current player.\"\n    attackers = len([square for square in board.piece_map() if \n                     board.is_attacked_by(board.turn, square)])\n    defenders = len([square for square in board.piece_map() if \n                     board.is_attacked_by(not board.turn, square)])\n    return float(attackers - defenders)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are doubled for both players; more doubled pawns can indicate a weaker structure.\"\n    white_doubled = sum(1 for square in board.piece_map() if \n                        board.piece_at(square).color == chess.WHITE and \n                        board.piece_at(square).piece_type == chess.PAWN and \n                        len(board.attackers(chess.WHITE, square)) > 1)\n    black_doubled = sum(1 for square in board.piece_map() if \n                        board.piece_at(square).color == chess.BLACK and \n                        board.piece_at(square).piece_type == chess.PAWN and \n                        len(board.attackers(chess.BLACK, square)) > 1)\n    return float(white_doubled + black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the back rank; pivotal for control.\"\n    back_rank_count = sum(1 for square, piece in board.piece_map().items() if \n                          (piece.color == chess.WHITE and chess.square_rank(square) == 7) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) == 0))\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares in the center (d4, d5, e4, e5) controlled by the current player.\"\n    center_squares = {chess.parse_square('d4'), chess.parse_square('d5'),\n                      chess.parse_square('e4'), chess.parse_square('e5')}\n    controlled_center = sum(1 for square in center_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares on the board that are under attack.\"\n    attacked_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces neighboring the kings of both players.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    neighbors = 0\n    for square in chess.SQUARES:\n        if chess.square_distance(white_king_square, square) <= 1 and board.piece_at(square) is not None:\n            neighbors += 1\n        if chess.square_distance(black_king_square, square) <= 1 and board.piece_at(square) is not None:\n            neighbors += 1\n    return float(neighbors)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of protected pieces for each side.\"\n    protected_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attackers = board.attackers(not board.turn, square)\n            if not attackers:  # If there are no opposing attackers\n                protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unique squares occupied by different types of pieces for the current player.\"\n    occupied_squares = set()\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            occupied_squares.add(square)\n    return float(len(occupied_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the current player's king.\"\n    king_square = board.king(board.turn)\n    total_distance = 0\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            total_distance += chess.square_distance(king_square, square)\n            count += 1\n    return float(total_distance / count) if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of legal moves possible for the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are attacked but not defended by either side.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if (board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square)) or \\\n           (board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square)):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the opposite king.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                if piece.piece_type != chess.KING:\n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces still remaining for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            total_value += piece_values[piece.piece_type]\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can potentially be promoted.\"\n    promotion_candidates = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (chess.square_rank(square) == 6 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) == 1))\n    return float(promotion_candidates)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of direct attacks on the opponent's king.\"\n    opponent_king_square = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn]\n    if not opponent_king_square:\n        return 0.0\n    king_square = opponent_king_square[0]\n    attacks = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total rook and queen placement on the 7th and 2nd ranks respectively.\"\n    rooks_and_queens = sum(1 for square in board.piece_map() \n                            if (board.piece_at(square).piece_type in {chess.ROOK, chess.QUEEN} and \n                                (chess.square_rank(square) == 7 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) == 2)))\n    return float(rooks_and_queens)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares in each player's attacking range that are unoccupied.\"\n    unoccupied_attacks = sum(1 for move in board.legal_moves if not board.piece_at(move.to_square))\n    return float(unoccupied_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of captured opponent's pieces on the board.\"\n    captured_pieces = sum(1 for piece in board.piece_map().values() if piece.color != board.turn and piece.piece_type in {chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING})\n    return float(captured_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pawns, providing insight on pawn structure.\"\n    controlled_by_pawns = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq) and board.piece_at(sq) is None and board.is_attacked_by(board.turn, sq))\n    return float(controlled_by_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to the opponent's back rank, giving insight into offensive potential.\"\n    distances_to_back_rank = sum(chess.square_distance(square, chess.parse_square('a8' if board.turn == chess.WHITE else 'a1')) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(distances_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all the opponent's pawns for potential promotion threat.\"\n    opponent_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color != board.turn)\n    return float(opponent_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the opponent's king, indicating immediate threats.\"\n    attacking_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == board.turn and board.is_attacked_by(not board.turn, move.to_square))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board, considering their positions.\"\n    material_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    for piece in board.piece_map().values():\n        material_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are directly attacked by only one piece of either side.\"\n    unique_attacks = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            unique_attacks += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            unique_attacks += 1\n    return float(unique_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares under attack but not defended for the current player.\"\n    current_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(not board.turn, square))\n    return float(current_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting pieces on d4, d5, e4, e5.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in center_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for the current player.\"\n    pawns = [square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn]\n    file_counts = {}\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if file in file_counts:\n            file_counts[file] += 1\n        else:\n            file_counts[file] = 1\n    doubled_pawns = sum(1 for count in file_counts.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently unprotected by their own pieces, indicating vulnerability.\"\n    unprotected_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            piece_protected = any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(not board.turn, square))\n            if not piece_protected:\n                unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by pieces that are not in their optimal positions.\"\n    suboptimal_positions = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if (piece.piece_type == chess.PAWN and (chess.square_rank(square) < 3 if piece.color == chess.WHITE else chess.square_rank(square) > 4)) or \\\n               (piece.piece_type in [chess.ROOK, chess.QUEEN] and chess.square_rank(square) < 4):\n                suboptimal_positions += 1\n    return float(suboptimal_positions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are directly attacking the opponent's king.\"\n    attacking_squares = sum(1 for move in board.legal_moves if board.is_attacked_by(board.turn, move.to_square))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each type for the current player and normalizes to provide weight.\"\n    piece_counts = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    total_strength = sum(piece_counts.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_strength)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available for the player to move; higher values indicate stronger position.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pawns on the board; higher ranks indicate advancement potential.\"\n    pawn_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can deliver check on the opponent's king.\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not board.turn, board.king(not board.turn)):\n                    count += 1\n                    break\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the squares around the opponent's king that are controlled by the current player's pieces.\"\n    opponent_king_square = board.king(not board.turn)\n    control_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and chess.square_distance(square, opponent_king_square) <= 1)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total influence of the current player over the central squares of the board.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    influence = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(influence)", "def feature(board: chess.Board) -> float:\n    \"Measures the advancement of pawns by counting how many are on the opponent's side of the board.\"\n    advance_count = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and (square >> 3) > 4)\n    return float(advance_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pieces that are blocking the opponent's pieces.\"\n    block_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn and board.is_attacked_by(board.turn, square):\n            block_count += 1\n    return float(block_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discovered attacks available for each side.\"\n    discovered_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    board.push(move)\n                    if board.is_check():\n                        discovered_count += 1\n                    board.pop()\n    return float(discovered_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the connectivity of pieces by counting pairs that can support each other.\"\n    connectivity_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.piece_at(move.to_square):\n                    connectivity_count += 1\n                    break\n    return float(connectivity_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are positioned on the opponent's first three ranks.\"\n    opponent_first_three_ranks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(square) < 3:\n            opponent_first_three_ranks += 1\n    return float(opponent_first_three_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between the two players, calculated as the difference in available legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are attacking the keysquare of the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    attacking_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(piece.color, opponent_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are attacked by exactly one piece from either side.\"\n    single_attacking_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            single_attacking_squares += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            single_attacking_squares += 1\n    return float(single_attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pairs of pieces of the same type for the current player.\"\n    piece_counts = {}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_counts[piece.piece_type] = piece_counts.get(piece.piece_type, 0) + 1\n    pairs_count = sum(count // 2 for count in piece_counts.values())\n    return float(pairs_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the pieces not on the back rank compared to the total material value.\"\n    total_material = sum(piece.piece_type for piece in board.piece_map().values())\n    back_rank_material = sum(piece.piece_type for square, piece in board.piece_map().items() if chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7))\n    return float((total_material - back_rank_material) / total_material) if total_material != 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces to the opposing side's back rank for both players.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) - (0 if piece.color == chess.WHITE else 7)\n        total_distance += abs(distance)\n        piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares in the opponent's half of the board that are attacked but not defended.\"\n    defended_squares = {square for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and any(board.is_attacked_by(board.turn, square) for square in board.attackers(board.turn, square))}\n    attacked_opponent_half = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_rank(square) > 3 and square not in defended_squares)\n    return float(attacked_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Measuring the influence of each player's pieces over central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    influence_score = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(influence_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank for both sides.\"\n    back_rank_count = 0\n    for square in range(56, 64):  # Squares a8-h8 (back rank for White)\n        if board.piece_at(square):\n            back_rank_count += 1\n    for square in range(0, 8):  # Squares a1-h1 (back rank for Black)\n        if board.piece_at(square):\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares where each player can check the opponent's king.\"\n    check_squares = 0\n    for move in board.legal_moves:\n        if board.gives_check(move):\n            check_squares += 1\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of attacking pieces on the opponent's king.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the seventh rank for both sides.\"\n    seventh_rank_count = 0\n    for square in range(48, 56):  # Squares a7-h7 (seventh rank for White)\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            seventh_rank_count += 1\n    for square in range(8, 16):  # Squares a2-h2 (seventh rank for Black)\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            seventh_rank_count += 1\n    return float(seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are on the opponent's half of the board.\"\n    white_pieces_in_op_half = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pieces_in_op_half = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_op_half - black_pieces_in_op_half)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are closer to the opponent's king than their own king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_opponent_king = sum(\n        chess.square_distance(square, black_king_square) for square in board.piece_map()\n    )\n    distance_to_own_king = sum(\n        chess.square_distance(square, white_king_square) for square in board.piece_map()\n    )\n    return float(distance_to_opponent_king - distance_to_own_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns for each side.\"\n    advanced_pawns = sum(\n        1 for square in board.piece_map() \n        if board.piece_at(square).piece_type == chess.PAWN and \n        (square > chess.E7 if board.turn == chess.WHITE else square < chess.E2)\n    )\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(\n        1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq)\n    ) - sum(\n        1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq)\n    )\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest piece to the opponent's king.\"\n    nearest_distance = min(\n        (chess.square_distance(square, board.king(not board.turn)) for square in board.piece_map()), \n        default=8\n    )\n    return float(nearest_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are en prise (attacked but unprotected).\"\n    en_prise_count = sum(\n        1 for square in board.piece_map() \n        if board.is_attacked_by(not board.turn, square) and \n        len(board.attackers(board.turn, square)) == 0\n    )\n    return float(en_prise_count)", "def feature(board: chess.Board) -> float:\n    \"Quantifies the piece and pawn structure on the 7th rank.\"\n    seventh_rank_structure = sum(\n        1 for square in range(chess.A7, chess.H7 + 1)\n        if board.piece_at(square) is not None\n    )\n    return float(seventh_rank_structure)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces beyond the 6th rank for each side.\"\n    pieces_beyond_rank = {\n        chess.WHITE: sum(1 for square in range(chess.A7, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE),\n        chess.BLACK: sum(1 for square in range(chess.A1, chess.H2) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    }\n    return float(pieces_beyond_rank[chess.WHITE] - pieces_beyond_rank[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces that have no legal moves left.'\n    immobile_pieces = sum(1 for piece in board.piece_map().values() if not list(board.legal_moves) and piece.color == board.turn)\n    return float(immobile_pieces)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares that are attacked by only one piece for the current player.'\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) == 1)\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the cumulative rank of pieces that are in their advanced positions (past the 4th rank).'\n    advanced_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) > 3)\n    return float(advanced_rank_sum)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces in the opponent\u2019s half of the board (ranks 5-8 for White and 1-4 for Black).'\n    opponent_half_count = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and ((piece.color == chess.WHITE and chess.square_rank(square) > 3) or (piece.color == chess.BLACK and chess.square_rank(square) < 4)))\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of threats to the current player\u2019s king that are also protected by their own pieces.'\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.KING:\n            king_square = square\n            break\n    threats_protected = sum(1 for attacker in board.attackers(not board.turn, king_square) if board.is_attacked_by(board.turn, attacker))\n    return float(threats_protected)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces attacking the opponent\u2019s king.'\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    attacking_count = sum(1 for move in board.legal_moves if move.to_square == king_square and board.piece_at(move.from_square) and board.piece_at(move.from_square).color == board.turn)\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of supporting pieces, which can potentially defend each other\u2019s positions in the current player\u2019s camp.'\n    support_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacked_square in board.attackers(board.turn, square):\n                if board.piece_at(attacked_square) and board.piece_at(attacked_square).color == board.turn:\n                    support_count += 1\n    return float(support_count)", "def feature(board: chess.Board) -> float:\n    'Measures the total count of squares that are currently under attack and also contain your pieces.'\n    threatened_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(threatened_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in pawn structure between both players, focusing on the number of connected pawns.'\n    white_pawn_structure = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and (board.piece_at(square - 8) or board.piece_at(square + 8)))\n    black_pawn_structure = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and (board.piece_at(square - 8) or board.piece_at(square + 8)))\n    return float(white_pawn_structure - black_pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares attacked by pieces of both colors.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.from_square)\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total ranks of pieces for both colors.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where pieces are pinned (cannot move without exposing a higher-value piece).\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is None:\n            continue\n        for attacker_square in board.attackers(not piece.color, square):\n            attacker = board.piece_at(attacker_square)\n            if attacker and attacker.piece_type in (chess.QUEEN, chess.ROOK, chess.BISHOP):\n                # Check if the piece on the line is actually pinned\n                for line_square in board.pseudo_legal_moves:\n                    if line_square.from_square == square and line_square.to_square != attacker_square:\n                        pinned_count += 1    \n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discoveries that can be made by both players.\"\n    discovery_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is None or piece.piece_type == chess.KING:\n            continue\n        for move in board.legal_moves:\n            if move.from_square == square:\n                for attacked_square in board.attackers(not piece.color, move.to_square):\n                    if board.piece_at(attacked_square):\n                        discovery_count += 1\n    return float(discovery_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of all minor pieces (knights and bishops) for both players.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330}\n    white_minor_value = sum(material_value[piece.piece_type] for square, piece in board.piece_map().items() \n                             if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_minor_value = sum(material_value[piece.piece_type] for square, piece in board.piece_map().items() \n                             if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(white_minor_value - black_minor_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the 6th and 7th ranks for both players, indicating advancement.\"\n    advanced_pawn_count = sum(1 for square, piece in board.piece_map().items() \n                               if piece.piece_type == chess.PAWN and chess.square_rank(square) >= 5)\n    return float(advanced_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the sum of distances from all pieces to their closest attacking opponent piece.\"\n    distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            min_distance = float('inf')\n            for target_square in board.piece_map():\n                if board.is_attacked_by(not piece.color, target_square):\n                    distance = chess.square_distance(square, target_square)\n                    if distance < min_distance:\n                        min_distance = distance\n            distances.append(min_distance)\n    return float(sum(distances)) / float(len(distances) or 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces facing a directly attacking opponent's piece.\"\n    threatened_count = sum(1 for square, piece in board.piece_map().items() if \n                           piece.color == board.turn and any(board.is_attacked_by(not piece.color, square) \n                           for target_square in board.attackers(not piece.color, square)))\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both colors but not defended by any piece.\"\n    attacked_unprotected = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square) and not any(board.attackers(chess.WHITE, square)) and not any(board.attackers(chess.BLACK, square)))\n    return float(attacked_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of total checks a player can deliver on their next turn.\"\n    check_count = sum(1 for move in board.legal_moves if board.is_check() == False and board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares completely controlled by each player.\"\n    controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and not any(board.attackers(chess.BLACK, square))) + sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and not any(board.attackers(chess.WHITE, square)))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of critical squares that are protected by two or more pieces.\"\n    critical_protected = sum(1 for square in range(64) if len(board.attackers(chess.WHITE, square)) >= 2 or len(board.attackers(chess.BLACK, square)) >= 2)\n    return float(critical_protected)", "def feature(board: chess.Board) -> float:\n    'Measures the control of the center squares (d4, d5, e4, e5) by counting the pieces attacking them.'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(board.is_attacked_by(chess.WHITE, sq) for sq in center_squares)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces in play for each side and returns the difference.'\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of protected squares for both sides and returns the difference.'\n    protected_squares_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and any(board.is_attacked_by(chess.WHITE, sq) for p in board.piece_map().values() if p.color == chess.WHITE)])\n    protected_squares_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and any(board.is_attacked_by(chess.BLACK, sq) for p in board.piece_map().values() if p.color == chess.BLACK)])\n    return float(protected_squares_white - protected_squares_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of each side\u2019s pawns to their respective back ranks.'\n    white_pawn_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the aggregate material value of pieces on the back ranks for both sides.'\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_back_rank_value = sum(material_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) == 7)\n    black_back_rank_value = sum(material_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) == 0)\n    return float(white_back_rank_value - black_back_rank_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares that have two or more pieces attacking them for the current player.'\n    multi_attacked_squares = len([sq for sq in chess.SQUARES if len(board.attackers(chess.WHITE, sq)) >= 2])\n    return float(multi_attacked_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares currently attacked by the current player\u2019s pieces.'\n    attacked_squares = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)]) if board.turn else len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the overall difference in mobility based on the number of legal moves each side has.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces remaining that can move after the current player's turn.\"\n    movable_pieces = sum(1 for piece in board.piece_map().values() if board.legal_moves)\n    return float(movable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in the first three ranks for each player.\"\n    rank_count = sum(1 for square in range(0, 24) if board.piece_at(square) is not None)\n    return float(rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns present on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for the current player, giving an indication of advancement.\"\n    current_player = chess.WHITE if board.turn else chess.BLACK\n    rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == current_player)\n    return float(rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares attacked by the opponent's pieces.\"\n    attacked_squares = {chess.square_name(square) for square in range(64) if board.is_attacked_by(not board.turn, square)}\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares occupied by both players' pieces.\"\n    occupied_squares = sum(1 for square in range(64) if board.piece_at(square) is not None)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the center of the board (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    total_distance = sum(min(chess.square_distance(square, cs) for cs in center_squares) for square in board.piece_map())\n    return total_distance / len(board.piece_map()) if board.piece_map() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of squares in the final ranks where pieces can potentially promote.\"\n    promotion_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    promotion_count = sum(1 for square in promotion_squares if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files available for rooks.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by pieces that are within one square of the opponent's king.\"\n    opponent_king_square = [square for square in board.piece_map().keys() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn]\n    if not opponent_king_square:\n        return 0.0\n    opponent_king_pos = opponent_king_square[0]\n    count = sum(1 for square in board.piece_map().keys() if chess.square_distance(square, opponent_king_pos) == 1)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens) for the current player.\"\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(minor_pieces / (major_pieces + 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for each player.\"\n    count_white = sum(1 for square in board.piece_map().keys() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    count_black = sum(1 for square in board.piece_map().keys() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(count_white - count_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to their respective back ranks.\"\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map().keys())\n    piece_count = len(board.piece_map())\n    return total_distance / (piece_count + 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for both players.\"\n    pinned_count = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker_square in board.attackers(not piece.color, square):\n                if board.piece_at(attacker_square).piece_type == chess.QUEEN or board.piece_at(attacker_square).piece_type == chess.ROOK:\n                    if board.piece_at(square).piece_type != chess.KING:\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    back_rank_count = sum(1 for square in board.piece_map().keys() if chess.square_rank(square) == (0 if board.turn == chess.WHITE else 7))\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the maximum number of pieces attacking a single square.\"\n    max_attackers = 0\n    for square in range(64):\n        attackers_count = len(board.attackers(not board.turn, square))\n        max_attackers = max(max_attackers, attackers_count)\n    return float(max_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of square that are completely unoccupied and in attack range of either player's pieces.\"\n    unoccupied_attacked = sum(1 for square in range(64) if board.piece_at(square) is None and (board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square)))\n    return float(unoccupied_attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material score of pieces according to chess piece values for both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    score = 0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        score += value if piece.color == chess.WHITE else -value\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available for each color and returns their difference.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    legal_moves_black = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pairs of pieces that can attack the same target square.\"\n    attacking_pairs = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            attacking_pairs += 1\n            \n    return float(attacking_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces on the board.\"\n    unprotected_count = sum(1 for square in board.piece_map() if not board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces supporting each player's pawns.\"\n    white_support = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.attackers(chess.WHITE, square).intersection(board.attackers(chess.BLACK, square)))\n    black_support = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.attackers(chess.BLACK, square).intersection(board.attackers(chess.WHITE, square)))\n    return float(white_support - black_support)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opposing king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers_count = len(board.attackers(chess.WHITE, king_square)) + len(board.attackers(chess.BLACK, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for the current player; higher ranks indicate greater advancement.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of available checks for both players.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_map()[move.from_square].color == chess.WHITE)\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_checks + black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential forks that can be delivered by each player's pieces.\"\n    white_forks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_map()[move.from_square].piece_type in [chess.KNIGHT, chess.QUEEN])\n    black_forks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_map()[move.from_square].piece_type in [chess.KNIGHT, chess.QUEEN])\n    return float(white_forks - black_forks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each side has on the board.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available for each side's pieces.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the closest opponent's king to all pieces of the current player.\"\n    current_player = chess.WHITE if board.turn else chess.BLACK\n    opponent_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != current_player)\n    distances = [chess.square_distance(sq, opponent_king_square) for sq, p in board.piece_map().items() if p.color == current_player]\n    return float(sum(distances))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking pieces against the opponent's king.\"\n    opponent_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != board.turn)\n    attackers_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.turn, sq) and board.piece_at(sq).color == board.turn)\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that can be attacked from the current player's pieces.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of protected pieces that can move and attack in a single turn.\"\n    protected_attackers = sum(1 for sq, p in board.piece_map().items() \n                               if board.is_attacked_by(board.turn, sq) and \n                               any(move.to_square for move in board.legal_moves if move.from_square == sq))\n    return float(protected_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces remaining on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by pawns for each side.\"\n    white_control = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available for each side and returns the difference.\"\n    legal_moves_current_player = len(list(board.legal_moves))\n    board.turn = not board.turn\n    legal_moves_opponent = len(list(board.legal_moves))\n    board.turn = not board.turn\n    return float(legal_moves_current_player - legal_moves_opponent)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pieces on the back rank of both players, highlighting defense capabilities.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the current player's pieces that are also defended by their own pieces.\"\n    controlled_and_defended = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) > 0)\n    return float(controlled_and_defended)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the ranks of pawns for both sides to assess promotion potential.\"\n    white_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked simultaneously by both players' pieces.\"\n    simultaneous_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(simultaneous_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest enemy piece to the current player's king, indicating safety.\"\n    current_player_king_square = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn][0]\n    enemy_pieces = [square for square in board.piece_map() if board.piece_at(square).color != board.turn]\n    distances = [chess.square_distance(current_player_king_square, ep) for ep in enemy_pieces]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that can currently deliver check for both players.\"\n    white_check_count = len([move for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and board.is_check()])\n    black_check_count = len([move for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and board.is_check()])\n    return float(white_check_count - black_check_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential number of promotion threats by counting the number of pawns adjacent to the promotion rank.\"\n    threats = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (chess.square_rank(square) == 6 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) == 1))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces within the central four squares (d4, d5, e4, e5) for both sides.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are currently occupied by passed pawns for each player.\"\n    white_passed_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    black_passed_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) < 4)\n    return float(white_passed_pawns - black_passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are protected (defended) by at least one piece of the current player.\"\n    protected_enemy_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color != board.turn and any(board.is_attacked_by(board.turn, target) for target in board.attackers(not board.turn, square)))\n    return float(protected_enemy_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the current player's pieces to the opponent's king.\"\n    player_pieces = [square for square, piece in board.piece_map().items() if piece.color == board.turn]\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    distances = [chess.square_distance(square, king_square) for square in player_pieces]\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the current player that are also attacked by the opponent.\"\n    controlled_squares = [square for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.is_attacked_by(board.turn, square)]\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the player's pieces can move to that are unoccupied.\"\n    legal_moves = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None)\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of each side's pieces from their respective back ranks.\"\n    total_distance = 0.0\n    for square, piece in board.piece_map().items():\n        total_distance += abs(chess.square_rank(square) - (0 if piece.color == chess.WHITE else 7))\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 7th rank for both players.\"\n    white_seventh_rank = sum(1 for sq in chess.SQUARES[56:64] if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_seventh_rank = sum(1 for sq in chess.SQUARES[48:56] if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns within the opponent's territory (ranks 5-8 for White, 1-4 for Black).\"\n    if board.turn:  # White to move\n        pawns_in_enemy_territory = sum(1 for sq in chess.SQUARES[32:64] if board.piece_at(sq) == chess.PAWN)\n    else:  # Black to move\n        pawns_in_enemy_territory = sum(1 for sq in chess.SQUARES[0:32] if board.piece_at(sq) == chess.PAWN)\n    return float(pawns_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that can attack the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    attacking_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.is_attacked_by(board.piece_at(move.from_square).color, opponent_king_square))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns from their respective back ranks.\"\n    if board.turn:  # White to move\n        back_rank = 0\n    else:  # Black to move\n        back_rank = 7  \n    distances = []\n    for sq in chess.SQUARES:\n        if board.piece_at(sq) == chess.PAWN:\n            distance = chess.square_rank(sq) - back_rank\n            distances.append(abs(distance))\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the back ranks of both players; indicates game stability.\"\n    white_back_rank_count = sum(1 for sq in chess.SQUARES[56:64] if board.piece_at(sq) is not None)\n    black_back_rank_count = sum(1 for sq in chess.SQUARES[0:8] if board.piece_at(sq) is not None)\n    return float(white_back_rank_count + black_back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for both players.\"\n    isolated_pawns = 0\n    for sq in chess.SQUARES:\n        piece = board.piece_at(sq)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if (not board.piece_at(chess.parse_square(chess.square_name(sq)[0] + str(chess.square_rank(sq) + 1))) and\n                not board.piece_at(chess.parse_square(chess.square_name(sq)[0] + str(chess.square_rank(sq) - 1)))):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are completely controlled (neither attacked nor occupied) by each side.\"\n    controlled_squares = []\n    for sq in chess.SQUARES:\n        if board.is_attacked_by(board.turn, sq):\n            continue\n        if board.piece_at(sq) is None:\n            controlled_squares.append(sq)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns for both players on the board.\"\n    pawns_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    pawns_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(pawns_white - pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the endgame positions (pieces remaining are only kings, rooks, bishops, knights, and pawns).\"\n    valid_pieces = {chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING}\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in valid_pieces)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total squares controlled by each player, considering their pieces' positions.\"\n    controlled_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of half-open files for each side, which can indicate piece mobility and control.\"\n    file_control_white = len(set(chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square)))\n    file_control_black = len(set(chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square)))\n    return float(file_control_white - file_control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value difference considering only pieces on aggressive ranks (the 4th to 7th ranks).\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    aggressive_value_white = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 3)\n    aggressive_value_black = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 4)\n    return float(aggressive_value_white - aggressive_value_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance weighted by distance of pieces to the opponent's back rank.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    distance_weighted_white = sum(piece_values[board.piece_at(square).piece_type] * (7 - chess.square_rank(square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    distance_weighted_black = sum(piece_values[board.piece_at(square).piece_type] * chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(distance_weighted_white - distance_weighted_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by pieces on the 7th and 2nd ranks, indicating advanced position.\"\n    advanced_white = len([square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6])\n    advanced_black = len([square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1])\n    return float(advanced_white - advanced_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure quality by counting the number of pawn pairs (pawns on adjacent files).\"\n    pawn_files = [0] * 8\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n            \n    pawn_pairs = sum(1 for count in pawn_files if count > 1)\n    return float(pawn_pairs)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces with potential to attack during the next turn.\"\n    attacking_pieces_white = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, move.to_square))\n    attacking_pieces_black = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(attacking_pieces_white - attacking_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are attacked by only one piece for each player.\"\n    white_single_attack = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) == 1)\n    black_single_attack = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) == 1)\n    return float(white_single_attack - black_single_attack)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently placed on the opponent's side of the board.\"\n    opponent_rank = 6 if board.turn == chess.WHITE else 1\n    return float(sum(1 for square in chess.SQUARES if board.piece_at(square) and chess.square_rank(square) == opponent_rank))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in central control based on how many pieces each side has on the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces to the opponent's pawns.\"\n    opponent_pawns = [square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color != board.turn]\n    if not opponent_pawns:\n        return 0.0\n    total_distance = sum(chess.square_distance(square, pawn_square) for square in board.piece_map() for pawn_square in opponent_pawns)\n    return total_distance / len(opponent_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are only attacked by one piece.\"\n    return float(sum(1 for square in board.piece_map() if board.piece_map()[square].color != board.turn and len(board.attackers(board.turn, square)) == 1))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that both players have their pieces within.\"\n    occupied_squares = set(square for square in chess.SQUARES if board.piece_at(square))\n    return float(len(occupied_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for the current player compared to the opponent.\"\n    player_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    opponent_rank_sum = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color != board.turn)\n    return float(player_rank_sum - opponent_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled exclusively by the current player.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(board.turn ^ 1, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces from their respective back ranks.\"\n    distance_from_back_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_from_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces within three squares of the edge of the board for each player.\"\n    edge_rank_squares = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1,\n                         chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    player_edge_count = len([square for square in edge_rank_squares if board.piece_at(square) and board.piece_at(square).color == board.turn])\n    opponent_edge_count = len([square for square in edge_rank_squares if board.piece_at(square) and board.piece_at(square).color != board.turn])\n    return float(player_edge_count - opponent_edge_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for pawn promotion based on pawns in the opponent's half.\"\n    opponent_half = range(0, 4) if board.turn == chess.WHITE else range(4, 8)\n    promotion_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) in opponent_half)\n    return float(promotion_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are both attacked and defended by the current player's pieces.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and board.piece_map().get(square) is not None)\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both players and returns the total.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (not board.piece_at(chess.square(file - 1, chess.square_rank(square))) and \n                not board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the maximum distance of the closest friendly piece to the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    max_distance = max(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the 7th rank to assess advancement.\"\n    seventh_rank = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 6 and board.piece_at(square) is not None)\n    return float(seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares from which the current player's pieces can attack the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    attacking_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the difference in the number of pieces on the back rank for each player.\"\n    back_rank_white = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 0 and board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 7 and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that can attack the opponent\u2019s king.'\n    attacking_moves = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, move.to_square))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the distribution of pieces within the center four squares of the board.'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces that are on the back rank of each player.'\n    back_rank_squares_white = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    back_rank_squares_black = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    white_back_rank_count = sum(1 for square in back_rank_squares_white if board.piece_at(square) is not None)\n    black_back_rank_count = sum(1 for square in back_rank_squares_black if board.piece_at(square) is not None)\n    return float(white_back_rank_count - black_back_rank_count)", "def feature(board: chess.Board) -> float:\n    'Measures the potential for promotion by counting pawns in their 6th rank.'\n    sixth_rank_pawns = sum(1 for square in [chess.A6, chess.B6, chess.C6, chess.D6, chess.E6, chess.F6, chess.G6, chess.H6]\n                            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(sixth_rank_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the current player\u2019s pieces to the opponent\u2019s back rank.'\n    opponent_back_rank = chess.A8 if board.turn == chess.WHITE else chess.A1\n    distance_sum = sum(chess.square_distance(square, opponent_back_rank) \n                       for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    'Counts how many squares are currently occupied by pieces that block the path to the opponent\u2019s king.'\n    blocker_count = sum(1 for square in board.piece_map() \n                        if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square) and board.piece_map()[square].color == board.turn)\n    return float(blocker_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference between the number of pawns on their 7th rank and the opponent\u2019s 7th rank.'\n    pawns_on_seventh = sum(1 for square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n                           if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    opponent_pawns_on_seventh = sum(1 for square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n                                     if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawns_on_seventh - opponent_pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    'Measures how many squares are protected by pieces that have a potential to deliver check.'\n    protected_check_squares = sum(1 for square in board.piece_map()\n                                   if board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(protected_check_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the average rank of all pieces for the side to move, giving more weight to advanced positions.'\n    pieces = board.piece_map()\n    total_rank = sum(chess.square_rank(square) for square in pieces if pieces[square].color == board.turn)\n    count = sum(1 for square in pieces if pieces[square].color == board.turn)\n    return total_rank / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Counts the number of potentially dangerous squares (squares attacked by more than one piece).'\n    attacking_counts = {square: 0 for square in chess.SQUARES}\n    for move in board.legal_moves:\n        attacking_counts[move.to_square] += 1\n    dangerous_squares = sum(1 for count in attacking_counts.values() if count > 1)\n    return float(dangerous_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the current player's pieces can deliver check.\"\n    check_squares = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances from each piece to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK) if board.turn else next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of pawn structure by counting doubled and isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        if white_pawns > 1:\n            doubled_pawns += 1\n        if white_pawns == 1 and (file == 0 or board.piece_at(chess.square(file - 1, 0)) != chess.PAWN) and (file == 7 or board.piece_at(chess.square(file + 1, 0)) != chess.PAWN):\n            isolated_pawns += 1\n        if black_pawns > 1:\n            doubled_pawns += 1\n        if black_pawns == 1 and (file == 0 or board.piece_at(chess.square(file - 1, 7)) != chess.PAWN) and (file == 7 or board.piece_at(chess.square(file + 1, 7)) != chess.PAWN):\n            isolated_pawns += 1\n    return float(doubled_pawns - isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces on the board for the current player.\"\n    total_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    num_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_rank / num_pieces) if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares in the center (d4, e4, d5, e5) controlled by current player's pieces.\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    controlled_squares = sum(1 for square in center_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves that can potentially capture an opponent's piece.\"\n    capture_moves = sum(1 for move in board.legal_moves if board.is_capture(move))\n    return float(capture_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of unprotected pieces of the current player's side.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.is_attacked_by(not board.turn, square))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the opponent's pieces are currently pinned.\"\n    pinned_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            for attacker in board.attackers(board.turn, square):\n                if board.piece_at(attacker).piece_type == chess.QUEEN or board.piece_at(attacker).piece_type == chess.ROOK:\n                    pinned_squares += 1\n    return float(pinned_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that have limited mobility (less than 2 legal moves).\"\n    limited_mobility = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and len(list(board.legal_moves)) < 2)\n    return float(limited_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are completely protected by the current player's pieces.\"\n    fully_protected_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and all(board.is_attacked_by(not board.turn, target_square) for target_square in board.attackers(not board.turn, square)):\n            fully_protected_squares += 1\n    return float(fully_protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's back rank to assess potential threats.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    count = sum(1 for square in chess.SQUARES if board.piece_at(square) and chess.square_rank(square) == opponent_back_rank)\n    \n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of the current king to the center of the board; closer kings are typically safer.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    distance_to_center = chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.D4)\n    \n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of vacant squares in the center of the board to assess control.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    vacant_squares = sum(1 for square in center_squares if board.piece_at(square) is None)\n\n    return float(vacant_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of checks available for the opponent on the next move.\"\n    opponent_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            opponent_checks += 1\n        board.pop()\n\n    return float(opponent_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for each player, indicating promotion potential.\"\n    player_seventh_rank = 7 if board.turn == chess.WHITE else 1\n    count = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == player_seventh_rank)\n\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces with support from pawns for each side.\"\n    supported_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attack_square in board.attackers(board.turn, square):\n                if board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, attack_square):\n                    supported_pieces += 1\n\n    return float(supported_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 5th rank or beyond for both players.\"\n    count = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) >= 4)\n\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where a player can promote a pawn.\"\n    promotion_squares = 0\n    for file in range(8):\n        if board.piece_at(chess.square(file, 6)) == chess.PAWN and board.turn == chess.WHITE:\n            promotion_squares += 1\n        if board.piece_at(chess.square(file, 1)) == chess.PAWN and board.turn == chess.BLACK:\n            promotion_squares += 1\n    return float(promotion_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the home rank of the player to move.\"\n    home_rank = 0\n    for file in range(8):\n        piece = board.piece_at(chess.square(file, 7 if board.turn == chess.WHITE else 0))\n        if piece:\n            home_rank += 1\n    return float(home_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent pawns in the promotion zone of the current player.\"\n    opponent_pawns_in_promotion_zone = 0\n    for file in range(8):\n        if board.piece_at(chess.square(file, 6)) == chess.PAWN and board.turn == chess.WHITE:\n            opponent_pawns_in_promotion_zone += 1\n        if board.piece_at(chess.square(file, 1)) == chess.PAWN and board.turn == chess.BLACK:\n            opponent_pawns_in_promotion_zone += 1\n    return float(opponent_pawns_in_promotion_zone)", "def feature(board: chess.Board) -> float:\n    \"Computes the distance of all pieces from the closest pawn of the current player.\"\n    pieces = board.piece_map()\n    closest_distance = float('inf')\n    player_pawn_squares = [square for square in pieces if pieces[square].piece_type == chess.PAWN and pieces[square].color == board.turn]\n    \n    if not player_pawn_squares:\n        return 0.0\n    \n    for square in pieces:\n        if pieces[square].color != board.turn:\n            for pawn_square in player_pawn_squares:\n                distance = chess.square_distance(square, pawn_square)\n                if distance < closest_distance:\n                    closest_distance = distance\n    return float(closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves for pieces positioned on the 4th rank.\"\n    legal_moves_count = 0\n    for file in range(8):\n        piece = board.piece_at(chess.square(file, 3 if board.turn == chess.WHITE else 4))\n        if piece and piece.color == board.turn:\n            legal_moves_count += len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control; counts the number of pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.square(3, 3), chess.square(3, 4), chess.square(4, 3), chess.square(4, 4)]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares from which the current player's pieces can deliver check.\"\n    check_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.to_square in board.attackers(not board.turn, move.to_square):\n                    check_squares += 1\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces on the opponent's first two ranks.\"\n    defending_pieces = 0\n    for rank in range(2):\n        for file in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.color == (chess.WHITE if board.turn == chess.BLACK else chess.BLACK):\n                defending_pieces += 1\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of times pieces move towards one player's back rank versus the other.\"\n    movement_towards_back_rank = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            movement_towards_back_rank += chess.square_rank(square)\n    return float(movement_towards_back_rank)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the closest king to the opposing side\u2019s back rank.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n\n    if white_king_square is not None:\n        white_distance = chess.square_rank(white_king_square) \n    else:\n        white_distance = 8  # Not on the board\n\n    if black_king_square is not None:\n        black_distance = 7 - chess.square_rank(black_king_square) \n    else:\n        black_distance = 8  # Not on the board\n    \n    return float(min(white_distance, black_distance))", "def feature(board: chess.Board) -> float:\n    'Counts how many pieces can deliver a check on the next move.'\n    checks_available = 0\n    for move in board.legal_moves:\n        if board.gives_check(move):\n            checks_available += 1\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in distances of each side\u2019s pawns from their respective back ranks.'\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares under attack for both sides and returns their difference.'\n    white_squares_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_squares_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_squares_attacked - black_squares_attacked)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of uncovered squares near the kings that could be attacked.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    if white_king_square is None or black_king_square is None:\n        return float(0)  # If one king is not present, return 0\n\n    uncovered_squares = 0\n    for sq in chess.SQUARES:\n        if board.is_attacked_by(chess.BLACK, sq) and not board.is_attacked_by(chess.WHITE, sq):\n            uncovered_squares += 1\n        if board.is_attacked_by(chess.WHITE, sq) and not board.is_attacked_by(chess.BLACK, sq):\n            uncovered_squares += 1\n            \n    return float(uncovered_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pieces with only one piece defending them.'\n    one_defender = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece and len(board.attackers(piece.color, square)) == 1:\n            one_defender += 1\n    return float(one_defender)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of legal moves that are not protective in the current position.'\n    total_moves = len(list(board.legal_moves))\n    protective_moves = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(total_moves - protective_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the 7th rank for both players; indicates endgame influence.'\n    white_seventh_rank = len([sq for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE])\n    black_seventh_rank = len([sq for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK])\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    'Calculates the mobility difference based on potential future moves for both sides.'\n    mobility_white = len(list(board.legal_moves))\n    mobility_black = sum(1 for move in board.legal_moves if board.turn == chess.BLACK and board.gives_check(move))\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the ratio of squares that are attacked and defended for each color.'\n    attacked_and_defended_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    attacked_and_defended_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.WHITE, square))\n    return float(attacked_and_defended_white - attacked_and_defended_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces near the back ranks for both colors.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) is not None)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) is not None)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has that can promote in the next move.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are attacking enemy pieces for both colors.\"\n    white_attacks = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE for move in board.legal_moves if move.from_square == sq and board.is_attacked_by(chess.BLACK, move.to_square))\n    black_attacks = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK for move in board.legal_moves if move.from_square == sq and board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each side's king to the nearest enemy piece.\"\n    def distance_to_nearest_enemy_king(color):\n        own_king_sq = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == color)\n        enemy_pieces = (sq for sq in board.piece_map() if board.piece_map()[sq].color != color)\n        return min(chess.square_distance(own_king_sq, sq) for sq in enemy_pieces) if enemy_pieces else float('inf')\n\n    white_distance = distance_to_nearest_enemy_king(chess.WHITE)\n    black_distance = distance_to_nearest_enemy_king(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total rank of pawns and their potential to promote.\"\n    def pawn_rank_sum(color):\n        return sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == color)\n\n    white_rank_sum = pawn_rank_sum(chess.WHITE)\n    black_rank_sum = pawn_rank_sum(chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of hanging pieces for both sides.\"\n    def hanging_pieces(color):\n        return sum(1 for sq, piece in board.piece_map().items() if piece.color == color and not board.attackers(color, sq))\n\n    white_hanging = hanging_pieces(chess.WHITE)\n    black_hanging = hanging_pieces(chess.BLACK)\n    return float(white_hanging - black_hanging)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of pieces each player has on the 5th rank or beyond.\"\n    def pieces_on_5th_or_beyond(color):\n        return sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == color and chess.square_rank(sq) >= 4)\n\n    white_count = pieces_on_5th_or_beyond(chess.WHITE)\n    black_count = pieces_on_5th_or_beyond(chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances from the center of the board for all pieces.\"\n    center_square = [chess.D4, chess.D5, chess.E4, chess.E5]\n    def center_distance(color):\n        return sum(chess.square_distance(sq, center_sq) for sq in board.piece_map() if board.piece_map()[sq].color == color for center_sq in center_square)\n\n    white_distance = center_distance(chess.WHITE)\n    black_distance = center_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares from which a check can be delivered by player to move.\"\n    player_color = chess.WHITE if board.turn else chess.BLACK\n    return float(sum(1 for move in board.legal_moves if board.is_check()))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares not occupied by pieces.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the board that are pinned (unable to move due to attack on the king).\"\n    pinned_pieces = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and any(board.is_check() for move in board.legal_moves if board.piece_at(move.from_square) and move.from_square == square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the balance of total material values between both sides.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are under attack but not defended.\"\n    under_attack = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and not any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(board.turn, square)))\n    return float(under_attack)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pawns on the 7th rank.'\n    return float(sum(1 for square, piece in board.piece_map().items() \n                     if piece.piece_type == chess.PAWN and chess.square_rank(square) == 6))", "def feature(board: chess.Board) -> float:\n    'Measures the total number of checks that can be delivered in the next two moves by each player.'\n    check_candidates = sum(1 for move in board.legal_moves \n                            if board.is_check() or board.gives_check(move)\n    )\n    return float(check_candidates)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces occupying the back ranks, indicating defensive capabilities.'\n    pieces_on_back_rank = sum(1 for square, piece in board.piece_map().items() \n                               if (piece.color == chess.WHITE and chess.square_rank(square) == 0) or \n                               (piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    )\n    return float(pieces_on_back_rank)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces attacking the opponent\u2019s king to assess pressure.'\n    attacker_squares = set(board.attackers(chess.WHITE, chess.parse_square('e1'))) | set(board.attackers(chess.BLACK, chess.parse_square('e8')))\n    return float(len(attacker_squares))", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the nearest piece from the opponent\u2019s king.'\n    opponent_king_square = chess.parse_square('e8') if board.turn else chess.parse_square('e1')\n    nearest_distance = min(chess.square_distance(square, opponent_king_square) \n                            for square in board.piece_map() \n                            if board.piece_at(square) is not None\n    )\n    return float(nearest_distance)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in open files for both players.'\n    open_files_white = sum(1 for file in range(8) if \n                            all(board.piece_at(chess.A1 + file + i * 8) is None for i in range(1, 8)\n                            )\n    )\n    open_files_black = sum(1 for file in range(8) if \n                            all(board.piece_at(chess.A8 + file - i * 8) is None for i in range(1, 8)\n                            )\n    )\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares occupied by knight pieces indicating mobility and control.'\n    return float(sum(1 for square, piece in board.piece_map().items() \n                     if piece.piece_type == chess.KNIGHT\n    ))", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by subtracting the total value of the opponent's pieces from the current player's pieces.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board and returns it as a float.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player to move by counting the legal moves available for their pieces.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in their respective endgame positions.\"\n    endgame_positions = [(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (6, 0), (6, 1), (6, 2), (7, 0), (7, 1), (7, 2)]\n    count = 0\n    for square, piece in board.piece_map().items():\n        if (chess.square_rank(square), chess.square_file(square)) in endgame_positions:\n            count += 1\n    return count", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential pawn promotions for both players.\"\n    promotions = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotions += 1\n    return float(promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the 7th rank for both players.\"\n    rank_7_count = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) == 6)\n    return float(rank_7_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unique attacking squares per player.\"\n    white_attacks = set()\n    black_attacks = set()\n    \n    for square in board.legal_moves:\n        if board.turn:  # White's turn\n            white_attacks.add(square.to_square)\n        else:  # Black's turn\n            black_attacks.add(square.to_square)\n\n    return float(len(white_attacks) - len(black_attacks))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in play versus the original setup.\"\n    original_setup = 16  # 8 pawns + 2 rooks + 2 knights + 2 bishops + 1 queen + 1 king per side\n    pieces_in_play = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE or piece.color == chess.BLACK)\n    return float(pieces_in_play - original_setup * 2)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece rank for all pieces on the board.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map())\n    return total_rank / float(len(board.piece_map())) if board.piece_map() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for both sides.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total value of pieces on the board, summing only attackers.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    attacking_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attacking_value += material_value[piece.piece_type]\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each king to the opponent's pawns.\"\n    white_king = board.piece_map().get(chess.parse_square('e1'))\n    black_kings = [sq for sq, piece in board.piece_map().items() if piece and piece.piece_type == chess.KING]\n    pawn_squares = [sq for sq, piece in board.piece_map().items() if piece and piece.piece_type == chess.PAWN]\n    \n    distance_sum = 0\n    for pawn in pawn_squares:\n        for king in black_kings:\n            distance_sum += chess.square_distance(king, pawn)\n\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the squares occupied by the kings.\"\n    attacking_count = 0\n    king_squares = [square for square, piece in board.piece_map().items() if piece and piece.piece_type == chess.KING]\n    \n    for king_square in king_squares:\n        attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)\n        attacking_count += len(attackers)\n\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares around each king that are attacked.\"\n    king_squares = [square for square, piece in board.piece_map().items() if piece and piece.piece_type == chess.KING]\n    attacked_squares = set()\n    \n    for king_square in king_squares:\n        for move in board.legal_moves:\n            if move.from_square == king_square:\n                attacked_squares.add(move.to_square)\n\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the effective protection of the currently moving king.\"\n    king_square = [square for square, piece in board.piece_map().items() if piece and piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)]\n    \n    if king_square:\n        king_square = king_square[0]\n        attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)\n        defenders = board.attackers(chess.BLACK if board.turn else chess.BLACK, king_square)\n        return float(len(defenders) - len(attackers))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance from the king to the current player's advanced pawns.\"\n    king_square = [square for square, piece in board.piece_map().items() if piece and piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)]\n    \n    if king_square:\n        king_square = king_square[0]\n        advanced_pawns = [sq for sq, piece in board.piece_map().items() if piece and piece.piece_type == chess.PAWN and piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(sq) > 4]\n        if advanced_pawns:\n            return min(chess.square_distance(king_square, pawn) for pawn in advanced_pawns)\n    \n    return float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by each side's pieces on the 5th rank or higher.\"\n    count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(square) >= 4:\n            count += 1\n    \n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces positioned on squares that can promote.\"\n    promote_squares = [chess.parse_square(sq) for sq in ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']]\n    promote_count = 0\n\n    for square, piece in board.piece_map().items():\n        if square in promote_squares:\n            promote_count += 1\n\n    return float(promote_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are vulnerable to attack based on a piece's positions.\"\n    vulnerable_squares = set()\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == square]\n            for move_square in legal_moves:\n                if not board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, move_square):\n                    vulnerable_squares.add(move_square)\n    \n    return float(len(vulnerable_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the potential escape routes available to both kings.\"\n    king_squares = [square for square, piece in board.piece_map().items() if piece and piece.piece_type == chess.KING]\n    escape_routes = 0\n    \n    for king_square in king_squares:\n        legal_moves = [move.to_square for move in board.legal_moves if move.from_square == king_square]\n        for move_square in legal_moves:\n            if not board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, move_square):\n                escape_routes += 1\n\n    return float(escape_routes)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the current player's king to the nearest opposing piece.\"\n    my_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    nearest_opponent_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(my_king_square, square)\n            nearest_opponent_distance = min(nearest_opponent_distance, distance)\n    \n    return nearest_opponent_distance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that the current player's pieces can threaten in the opponent's half.\"\n    threatened_squares = set()\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    threatened_squares.add(move.to_square)\n                    \n    return float(len([sq for sq in threatened_squares if chess.square_rank(sq) >= 4]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pawns to their respective promotion ranks.\"\n    total_distance = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            distance = chess.square_rank(square) + (7 if piece.color == chess.WHITE else 0)\n            total_distance += distance\n            pawn_count += 1\n            \n    return total_distance / pawn_count if pawn_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    occupied_squares = set(square for square in board.piece_map().keys())\n    return float(len(occupied_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares in the opponent's half that are completely controlled by the current player.\"\n    controlled_squares = set()\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n\n    return float(len([sq for sq in controlled_squares if chess.square_rank(sq) >= 4]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected squares for the current player.\"\n    protected_squares = 0\n    attackers = {}\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    target_square = move.to_square\n                    if target_square not in attackers:\n                        attackers[target_square] = 0\n                    attackers[target_square] += 1\n                    \n    for square, count in attackers.items():\n        if count > 1:\n            protected_squares += 1\n            \n    return float(protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential check threats available for the current player.\"\n    check_threats = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    check_threats += 1\n    \n    return float(check_threats)", "def feature(board: chess.Board) -> float:\n    \"Computes the distance from the current player's pawns to the opponent's back rank.\"\n    total_distance = 0\n    pawn_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            total_distance += distance\n            pawn_count += 1\n            \n    return total_distance / pawn_count if pawn_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces positioned on the 7th rank (for White) or 2nd rank (for Black).\"\n    rank_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n            rank_pieces += 1\n            \n    return float(rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by the current player's pieces.\"\n    attacked_squares = set()\n\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from each other; closer distance indicates potential threats.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is None or black_king is None:\n        return 0.0\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces each player has that are on the back rank.\"\n    white_back_rank = sum(1 for sq, piece in board.piece_map().items() \n                           if piece.color == chess.WHITE and chess.square_rank(sq) == 0)\n    black_back_rank = sum(1 for sq, piece in board.piece_map().items() \n                           if piece.color == chess.BLACK and chess.square_rank(sq) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has on the opponent's side of the board.\"\n    white_pawns = sum(1 for sq, piece in board.piece_map().items() \n                      if piece.color == chess.WHITE and chess.square_rank(sq) >= 5)\n    black_pawns = sum(1 for sq, piece in board.piece_map().items() \n                      if piece.color == chess.BLACK and chess.square_rank(sq) <= 2)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total count of pieces each player has past the 4th rank.\"\n    white_advanced_pieces = sum(1 for sq, piece in board.piece_map().items() \n                                 if piece.color == chess.WHITE and chess.square_rank(sq) > 3)\n    black_advanced_pieces = sum(1 for sq, piece in board.piece_map().items() \n                                 if piece.color == chess.BLACK and chess.square_rank(sq) < 4)\n    return float(white_advanced_pieces - black_advanced_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are currently attacked by pawns for each player.\"\n    white_attacked_squares = sum(1 for sq in chess.SQUARES \n                                  if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq) == chess.PAWN)\n    black_attacked_squares = sum(1 for sq in chess.SQUARES \n                                  if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq) == chess.PAWN)\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces positioned on the seventh rank for both players.\"\n    white_seventh_rank = sum(1 for sq, piece in board.piece_map().items() \n                              if piece.color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_seventh_rank = sum(1 for sq, piece in board.piece_map().items() \n                              if piece.color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    def is_isolated_pawn(sq, color):\n        if color == chess.WHITE:\n            return board.piece_at(sq) == chess.PAWN and not (board.piece_at(sq - 1) and \n                  board.piece_at(sq + 1) and board.piece_at(sq - 8) and \n                  board.piece_at(sq - 9) and board.piece_at(sq - 7))\n        else:\n            return board.piece_at(sq) == chess.PAWN and not (board.piece_at(sq + 1) and \n                  board.piece_at(sq - 1) and board.piece_at(sq + 8) and \n                  board.piece_at(sq + 9) and board.piece_at(sq + 7))\n\n    white_isolated_pawns = sum(1 for sq in chess.SQUARES if is_isolated_pawn(sq, chess.WHITE))\n    black_isolated_pawns = sum(1 for sq in chess.SQUARES if is_isolated_pawn(sq, chess.BLACK))\n    return float(white_isolated_pawns - black_isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the opponent's side of the board (for each player).\"\n    white_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() \n                                      if piece.color == chess.WHITE and chess.square_rank(sq) > 3)\n    black_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() \n                                      if piece.color == chess.BLACK and chess.square_rank(sq) < 4)\n    return float(white_pieces_in_enemy_half - black_pieces_in_enemy_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of passed pawns for both players.\"\n    white_passed = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and all(board.piece_at(f) is None for f in range(sq + 1, chess.square_file(sq) + 8)))\n    black_passed = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and all(board.piece_at(f) is None for f in range(sq - 1, chess.square_file(sq) - 1, -1)))\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are not currently defended by any piece.\"\n    undefended_squares = sum(1 for sq in range(64) if board.piece_at(sq) is None and not (board.is_attacked_by(chess.WHITE, sq) or board.is_attacked_by(chess.BLACK, sq)))\n    return float(undefended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces for each side.\"\n    total_pieces = len(board.piece_map())\n    white_moves = len(list(board.legal_moves))  # Number of legal moves for White\n    black_moves = len(list(board.legal_moves))  # Number of legal moves for Black\n    if total_pieces == 0:\n        return 0.0\n    return float(white_moves / total_pieces if board.turn else black_moves / total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the density of pieces in the center of the board (files d and e).\"\n    center_density = sum(1 for sq in range(chess.parse_square('d4'), chess.parse_square('e5') + 1) if board.piece_at(sq) is not None)\n    return float(center_density)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value comparison excluding pawns for both sides.\"\n    material_value = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n    }\n    white_material = sum(material_value.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_material = sum(material_value.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average Manhattan distance of opponent's pieces to the current player's pieces.\"\n    current_player_color = chess.WHITE if board.turn else chess.BLACK\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    total_distance = 0\n    piece_count = 0\n\n    for own_square, own_piece in board.piece_map().items():\n        if own_piece.color == current_player_color:\n            for opponent_square, opponent_piece in board.piece_map().items():\n                if opponent_piece.color == opponent_color:\n                    total_distance += chess.square_distance(own_square, opponent_square)\n                    piece_count += 1\n\n    return total_distance / (piece_count if piece_count > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled jointly by both players.\"\n    controlled_squares = set()\n    \n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            controlled_squares.add(square)\n\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the degree of pawn structure (number of connected pawns).\"\n    pawn_groups = 0\n    visited = set()\n\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN:\n            if square not in visited:\n                pawn_groups += 1\n                queue = [square]\n                while queue:\n                    current = queue.pop()\n                    visited.add(current)\n                    file = chess.square_file(current)\n\n                    for d_file in [-1, 0, 1]:\n                        neighbor_square = chess.square(current // 8, file + d_file)\n                        if (0 <= chess.square_rank(neighbor_square) < 8 and\n                                board.piece_at(neighbor_square) is not None and\n                                board.piece_at(neighbor_square).piece_type == chess.PAWN and\n                                neighbor_square not in visited):\n                            queue.append(neighbor_square)\n\n    return float(pawn_groups)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    if opponent_king_square is None:\n        return 0.0\n\n    attack_count = sum(1 for square in board.piece_map() if (\n        board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, opponent_king_square)))\n\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of pieces on the opponents 7th rank compared to 2nd rank.\"\n    opponent_seventh_rank = sum(1 for square in chess.SQUARES if (\n        chess.square_rank(square) == 6 and board.piece_at(square) is not None and\n        board.piece_at(square).color == (chess.BLACK if board.turn else chess.WHITE)))\n\n    own_second_rank = sum(1 for square in chess.SQUARES if (\n        chess.square_rank(square) == 1 and board.piece_at(square) is not None and\n        board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK)))\n\n    return float(opponent_seventh_rank - own_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of piece values for the pieces that are currently under attack.\"\n    total_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, square):\n            total_value += piece_values.get(piece.piece_type, 0)\n\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in ranks of all pieces on the board, giving more weight to those on the 7th and 8th ranks.\"\n    rank_weight = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 1, 8: 2}\n\n    score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            piece_rank = chess.square_rank(square)\n            score += rank_weight.get(piece_rank, 0)\n\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pieces for the side to move.\"\n    current_color = chess.WHITE if board.turn else chess.BLACK\n    protected_count = 0\n\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == current_color:\n            attackers = board.attackers(current_color, square)\n            if not attackers:\n                protected_count += 1\n\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance in piece types between both players, score favoring pieces like queens and rooks.\"\n    type_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    current_total = 0\n    opponent_total = 0\n\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            piece_value = type_values.get(piece.piece_type, 0)\n            if piece.color == board.turn:\n                current_total += piece_value\n            else:\n                opponent_total += piece_value\n\n    return float(current_total - opponent_total)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of king safety threats, counting the number of attacking pieces near each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_threats = len(board.attackers(chess.BLACK, white_king_square))\n    black_threats = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the back ranks of each player.\"\n    white_back_rank_attacks = 0\n    black_back_rank_attacks = 0\n    for square in range(56, 64):  # Back rank squares (8th rank for White)\n        if board.is_attacked_by(chess.WHITE, square):\n            white_back_rank_attacks += 1\n    for square in range(0, 8):  # Back rank squares (1st rank for Black)\n        if board.is_attacked_by(chess.BLACK, square):\n            black_back_rank_attacks += 1\n    return float(white_back_rank_attacks - black_back_rank_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking key squares around each king.\"\n    key_squares = [chess.parse_square('e8'), chess.parse_square('e1')]  # Key squares around kings\n    white_attack_count = sum(1 for sq in key_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_attack_count = sum(1 for sq in key_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attack_count - black_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double checks available to each side.\"\n    double_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check() and len(board.attackers(board.color_at(move.to_square), board.king(board.color_at(move.to_square)))) > 1:\n            double_checks += 1\n        board.pop()\n    return float(double_checks)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the relative pawn structure, counting the number of pawn pairs on files.\"\n    white_pairs = sum(1 for file in range(8) if len([square for square in range(8) if board.piece_at(chess.square(file, square)) and board.piece_at(chess.square(file, square)).color == chess.WHITE]) == 2)\n    black_pairs = sum(1 for file in range(8) if len([square for square in range(8) if board.piece_at(chess.square(file, square)) and board.piece_at(chess.square(file, square)).color == chess.BLACK]) == 2)\n    return float(white_pairs - black_pairs)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by multiple opponents.\"\n    multiple_attacks = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.is_attacked_by(chess.WHITE, square):\n            if len(board.attackers(chess.WHITE, square)) > 1:\n                multiple_attacks += 1\n        elif board.piece_at(square) and board.is_attacked_by(chess.BLACK, square):\n            if len(board.attackers(chess.BLACK, square)) > 1:\n                multiple_attacks += 1\n    return float(multiple_attacks)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the number of squares where the current player can attack but not defend.\"\n    count = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and \n                not board.is_attacked_by(not board.turn, square))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total rank scores of pieces that are positioned to attack the opponent's king.\"\n    rank_score = 0\n    king_square = board.king(not board.turn)\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, king_square):\n                rank_score += chess.square_rank(square) + 1  # Rank scores are 1-8\n    return float(rank_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the exposure of the opponent's king to checks.\"\n    opposing_king_square = board.king(not board.turn)\n    attack_positions = [move.to_square for move in board.legal_moves \n                        if move.to_square == opposing_king_square]\n    return float(len(attack_positions))", "def feature(board: chess.Board) -> float:\n    \"Counts total pieces with potential to block checks for both players.\"\n    blockable_checks = 0\n    king_square = board.king(board.turn)\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).color == board.turn:\n            if board.is_attacked_by(not board.turn, king_square):\n                blockable_checks += 1\n    return float(blockable_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares near pieces that can deliver checks.\"\n    count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square):\n            if board.is_checkmate():\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the threat level based on how many pieces can deliver check that are 2 steps away.\"\n    threats = 0\n    king_square = board.king(not board.turn)\n    for square in chess.SQUARES:\n        dist = chess.square_distance(square, king_square)\n        if dist == 2 and board.is_attacked_by(board.turn, square):\n            threats += 1\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are attacked by pieces of the current player but not defended.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(not board.turn, square):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have a path to the opponent's back rank (for potential promotion).\"\n    pieces_with_path = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            target_rank = 0 if board.turn == chess.WHITE else 7\n            if (piece.piece_type == chess.PAWN and chess.square_rank(square) == (1 if board.turn == chess.WHITE else 6)) or \\\n               (piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]):\n                pieces_with_path += 1\n    return float(pieces_with_path)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by each side and returns the difference.\"\n    attacked_by_white = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    attacked_by_black = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(attacked_by_white - attacked_by_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are simultaneously attacked by both players.\"\n    simultaneous_attacks = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            simultaneous_attacks += 1\n    return float(simultaneous_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of legal moves available for each side and returns their difference.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    legal_moves_black = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are on their starting squares.\"\n    starting_positions = {\n        chess.WHITE: {\n            chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n            chess.ROOK: [chess.A1, chess.H1],\n            chess.KNIGHT: [chess.B1, chess.G1],\n            chess.BISHOP: [chess.C1, chess.F1],\n            chess.QUEEN: [chess.D1],\n            chess.KING: [chess.E1]\n        },\n        chess.BLACK: {\n            chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n            chess.ROOK: [chess.A8, chess.H8],\n            chess.KNIGHT: [chess.B8, chess.G8],\n            chess.BISHOP: [chess.C8, chess.F8],\n            chess.QUEEN: [chess.D8],\n            chess.KING: [chess.E8]\n        }\n    }\n    \n    starting_white = sum(1 for square in starting_positions[chess.WHITE].values() for position in square if board.piece_at(position) is not None)\n    starting_black = sum(1 for square in starting_positions[chess.BLACK].values() for position in square if board.piece_at(position) is not None)\n    \n    return float(starting_white - starting_black)", "def feature(board: chess.Board) -> float:\n    \"Assesses the balance of pawn structure by counting isolated pawns for each player and returning the difference.\"\n    def count_isolated_pawns(color):\n        isolated = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (file == 0 or board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + str(int(chess.square_rank(square) + 1)))) is None) and \\\n                   (file == 7 or board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + str(int(chess.square_rank(square) + 1)))) is None):\n                    isolated += 1\n        return isolated\n\n    isolated_white = count_isolated_pawns(chess.WHITE)\n    isolated_black = count_isolated_pawns(chess.BLACK)\n    return float(isolated_white - isolated_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board that are in their optimal development squares.\"\n    optimal_squares = {\n        chess.WHITE: [chess.B1, chess.C1, chess.F1, chess.G1, chess.E1, chess.E2, chess.D2, chess.C2, chess.B2, chess.A2],\n        chess.BLACK: [chess.B8, chess.C8, chess.F8, chess.G8, chess.E8, chess.E7, chess.D7, chess.C7, chess.B7, chess.A7]\n    }\n    \n    optimal_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and square in optimal_squares[piece.color]:\n            optimal_count += 1\n    \n    return float(optimal_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently positioned on squares that can promote.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7,\n                         chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    count = sum(1 for square in promotion_squares if board.piece_at(square) is not None)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board that are controlling promotion squares.\"\n    white_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 6)\n    black_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king, which indicates potential threats.\"\n    current_player_color = board.turn\n    opponent_king_square = board.king(not current_player_color)\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square and board.piece_at(move.from_square).color == current_player_color)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each player's pawns.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES if board.piece_at(square) == chess.PAWN)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES if board.piece_at(square) == chess.PAWN)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility difference for each player by counting the number of accessible squares from the pieces.\"\n    white_moves = sum(len(list(board.legal_moves)) if board.turn else 0 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_moves = sum(len(list(board.legal_moves)) if not board.turn else 0 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of discovered attacks for each player.\"\n    attacking_pairs = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                # Check if the move uncovers an attack\n                if board.is_attacked_by(not board.turn, move.to_square):\n                    attacking_pairs += 1\n    return float(attacking_pairs)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the sum of distances of all pieces to the opponent's king as an indicator of threat level.\"\n    opponent_king_square = board.king(not board.turn)\n    distance_sum = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by pieces that are not in their optimal positions.\"\n    misplaced_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) < 5) or (piece.color == chess.BLACK and chess.square_rank(square) > 2):\n                misplaced_count += 1\n        elif piece.piece_type in [chess.ROOK, chess.KNIGHT]:\n            if (piece.color == chess.WHITE and chess.square_rank(square) < 3) or (piece.color == chess.BLACK and chess.square_rank(square) > 5):\n                misplaced_count += 1\n    return float(misplaced_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of defended squares for the current player.\"\n    defended_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.is_attacked_by(board.piece_at(square).color, square))\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the kings are located within attacking range of each other.\"\n    king_pos_white = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE]\n    king_pos_black = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK]\n    \n    if king_pos_white and king_pos_black:\n        distance = chess.square_distance(king_pos_white[0], king_pos_black[0])\n        return float(distance < 2)  # Return 1.0 if in attacking range, 0.0 otherwise\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces within the 4 central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of ranks of all pawns for both players as an indication of advancement.\"\n    total_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with no legal moves.\"\n    no_move_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not list(board.legal_moves).count(square))\n    return float(no_move_count)", "def feature(board: chess.Board) -> float:\n    \"Measures mobility by evaluating pieces that cannot attack despite being free to move.\"\n    mobile_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and list(board.legal_moves).count(square) > 1 and not board.is_attacked_by(not board.turn, square))\n    return float(mobile_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of protected squares for pieces of the current player.\"\n    protected_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and any(board.is_attacked_by(board.turn, attack_square) for attack_square in board.attackers(not board.turn, square)))\n    return float(protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces each side has on the board.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not board.turn, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares where pawns can advance towards promotion.\"\n    white_pawn_promotion = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    black_pawn_promotion = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 1)\n    return float(white_pawn_promotion - black_pawn_promotion)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance from all pieces to the opponent's king.\"\n    distance_sum = sum(chess.square_distance(square, chess.parse_square('e8' if board.turn == chess.WHITE else 'e1')) for square, piece in board.piece_map().items() if piece.color != board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can contribute to controlling the center squares.\"\n    center_control = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            center_control -= 1\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares where the opponent's king can escape in its next move.\"\n    escape_squares = 0\n    for move in board.legal_moves:\n        if move.to_square in [chess.parse_square('e8'), chess.parse_square('d8')] if board.turn == chess.WHITE else [chess.parse_square('e1'), chess.parse_square('d1')]:\n            escape_squares += 1\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces that are defended by other pieces.\"\n    defended_count = sum(1 for square, piece in board.piece_map().items() if any(board.is_attacked_by(piece.color, neighbor) for neighbor in board.attackers(piece.color, square)))\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Counts how many squares are not attacked by any piece on the board.\"\n    all_squares = set(range(64))\n    attacked_squares = {move.to_square for move in board.legal_moves}\n    return float(len(all_squares - attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of unprotected opponent's pieces and their material value.\"\n    unprotected_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color != board.turn and not any(board.is_attacked_by(board.turn, square) for square in board.attackers(piece.color, square)))\n    return float(unprotected_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have potential to promote.\"\n    promotion_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (chess.square_rank(square) == 6 if piece.color == chess.WHITE else chess.square_rank(square) == 1))\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are controlled by both player's pieces.\"\n    controlled_squares = sum(1 for square in range(64) if len(board.attackers(chess.WHITE, square)) > 0 and len(board.attackers(chess.BLACK, square)) > 0)\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are one square away from promotion.\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN and ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1)):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are unoccupied or controlled by one player.\"\n    controlled_squares = set()\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square):\n            controlled_squares.add(square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on ranks 6 and 2 as an indicator of advancement.\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1)):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns to the promotion ranks.\"\n    distance_sum = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            distance_sum += 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are not on their optimal development squares.\"\n    count = 0\n    optimal_positions = {chess.B2, chess.C2, chess.D2, chess.E2, chess.B7, chess.C7, chess.D7, chess.E7}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and square not in optimal_positions:\n            count += 1\n        elif piece.color == chess.BLACK and square not in optimal_positions:\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the first two ranks for both players.\"\n    white_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) < 2)\n    black_count = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) > 5)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are currently attacking the opponent's king.\"\n    count = 0\n    opponent_king_square = board.king(chess.WHITE) if board.turn == chess.BLACK else board.king(chess.BLACK)\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == (chess.WHITE if board.turn == chess.BLACK else chess.BLACK):\n            if board.is_attacked_by(piece.color, opponent_king_square):\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in distances of pawns from their respective back ranks.\"\n    white_distance = sum(7 - chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can deliver check across ranks 6 and 2.\"\n    count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1)):\n            if board.is_attacked_by(piece.color, board.king(not piece.color)):\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the back rank positions for both players.\"\n    back_rank_count = 0\n    for square in range(56, 64):  # Ranks 7 for White and 2 for Black\n        piece = board.piece_at(square)\n        if piece is not None:\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings to the nearest edge of the board.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    distance_white = min(chess.square_rank(white_king), chess.square_file(white_king), \n                          7 - chess.square_rank(white_king), 7 - chess.square_file(white_king))\n    distance_black = min(chess.square_rank(black_king), chess.square_file(black_king), \n                          7 - chess.square_rank(black_king), 7 - chess.square_file(black_king))\n    return float(distance_white - distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where a player's pieces can escape to from checks.\"\n    escape_squares = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square):\n            if board.legal_moves == 0: \n                continue\n            for move in board.legal_moves:\n                if move.to_square == square:\n                    escape_squares += 1\n                    break\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacks on pieces by the opponent.\"\n    double_attacks = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == chess.BLACK:\n            attackers = board.attackers(chess.WHITE, square)\n            if len(attackers) > 1:\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by both the current player and the opponent.\"\n    controlled_by_both = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            controlled_by_both += 1\n    return float(controlled_by_both)", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for promotion by counting pawns in the opponent's half.\"\n    promotion_pawns = 0\n    for square in range(48, 64):  # Only the last two ranks for White's pawns\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n            promotion_pawns += 1\n    for square in range(0, 16):  # Only the first two ranks for Black's pawns\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n            promotion_pawns += 1\n    return float(promotion_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are solely responsible for defending another piece.\"\n    defending_count = 0\n    piece_map = board.piece_map()\n    for square, piece in piece_map.items():\n        for attack_square in board.attackers(piece.color, square):\n            if board.piece_at(attack_square) is not None and board.piece_at(attack_square).color != piece.color:\n                defending_count += 1\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the maximum distance any piece has from the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    max_distance = 0\n    for square in board.piece_map():\n        distance = chess.square_distance(square, opponent_king_square)\n        if distance > max_distance:\n            max_distance = distance\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of movable pieces that are on the back rank.\"\n    movable_pieces_back_rank = 0\n    for square in range(56, 64):  # Checking the last rank for White's pieces\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square):\n            movable_pieces_back_rank += sum(1 for move in board.legal_moves if move.from_square == square)\n    return float(movable_pieces_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be immediately captured by the opposing player.\"\n    attackers_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the current player's king to the opponent's pieces on the board.\"\n    own_king_square = board.king(board.turn)\n    opponent_pieces = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    avg_distance = sum(chess.square_distance(own_king_square, square) for square in opponent_pieces) / max(len(opponent_pieces), 1)\n    return float(avg_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the potential check scenarios where the opponent can check the current player's king.\"\n    potential_checks = 0\n    for move in board.legal_moves:\n        if board.is_check():\n            continue\n        temp_board = board.copy(stack=False)\n        temp_board.push(move)\n        if temp_board.is_check():\n            potential_checks += 1\n    return float(potential_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces attacking the opponent's king to total pieces on the board.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    total_pieces = len(board.piece_map())\n    return float(attacking_pieces) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the concentration of pieces in the center of the board (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are attacked but also protected by the same side's pieces.\"\n    attacked_and_protected = 0\n    for square in range(64):\n        if board.is_attacked_by(board.turn, square) and board.is_attacked_by(board.turn, square):\n            attacked_and_protected += 1\n    return float(attacked_and_protected)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares completely surrounded by the current player's pieces.\"\n    controlled_squares = 0\n    for sq in chess.SQUARES:\n        piece = board.piece_at(sq)\n        if piece and piece.color == board.turn:\n            attacking_squares = set(board.attackers(not board.turn, sq))\n            if len(attacking_squares) == 0:\n                controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares controlled by pieces of each color.\"\n    controlled_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to the same square as the opponent's king.\"\n    attack_on_king = 0\n    king_square = board.king(board.turn)\n    for move in board.legal_moves:\n        if move.to_square == king_square and board.piece_at(move.from_square).color == board.turn:\n            attack_on_king += 1\n    return float(attack_on_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their respective promotion ranks.\"\n    total_distance = 0\n    for sq in chess.SQUARES:\n        piece = board.piece_at(sq)\n        if piece and piece.piece_type == chess.PAWN:\n            rank_difference = chess.square_rank(sq) - (0 if piece.color == chess.WHITE else 7)\n            total_distance += abs(rank_difference)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that can deliver checkmate in one move.\"\n    checkmate_moves = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            checkmate_moves += 1\n        board.pop()\n    return float(checkmate_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by pieces from both colors that are also defended.\"\n    attacked_defended_count = 0\n    for sq in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, sq) and board.is_attacked_by(chess.BLACK, sq):\n            if board.is_attacked_by(chess.WHITE, sq) and board.is_attacked_by(chess.BLACK, sq):\n                attacked_defended_count += 1\n    return float(attacked_defended_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are within attacking range of a player's pieces.\"\n    attacking_range_count = 0\n    for sq in chess.SQUARES:\n        if board.is_attacked_by(board.turn, sq):\n            attackers = board.attackers(board.turn, sq)\n            if any(board.piece_at(attacker).color != board.turn for attacker in attackers):\n                attacking_range_count += 1\n    return float(attacking_range_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn chains for each player on the board.\"\n    pawn_chains = 0\n    for file in range(8):\n        last_pawn = None\n        for rank in range(8):\n            sq = chess.square(file, rank)\n            piece = board.piece_at(sq)\n            if piece and piece.piece_type == chess.PAWN:\n                if last_pawn is None or piece.color != last_pawn.color:\n                    pawn_chains += 1\n                last_pawn = piece\n    return float(pawn_chains)", "def feature(board: chess.Board) -> float:\n    \"Measures the influence of each side's strongest piece based on distance to the opponent's king.\"\n    strongest_distance = 0\n    for sq in chess.SQUARES:\n        piece = board.piece_at(sq)\n        if piece and piece.color == board.turn:\n            distance_to_opponent_king = chess.square_distance(sq, board.king(not board.turn))\n            if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                strongest_distance += distance_to_opponent_king\n    return float(strongest_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each side's pieces.\"\n    white_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_squares - black_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opposing pieces in the opponent's half of the board.\"\n    opponent_half = range(0, 4) if board.turn == chess.WHITE else range(4, 8)\n    opposing_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_rank(square) in opponent_half)\n    return float(opposing_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces within a knight's move of the king for each side.\"\n    knight_moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    current_king_square = board.king(board.turn)\n    attacking_squares = {chess.square_file(current_king_square) + dx + (chess.square_rank(current_king_square) + dy) * 8 for dx, dy in knight_moves}\n    nearby_enemy_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and square in attacking_squares)\n    return float(nearby_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares controlled in the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by the opponent that are not defended.\"\n    attacked_squares = set(square for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    undefended_squares = sum(1 for square in attacked_squares if not board.is_attacked_by(board.turn, square))\n    return float(undefended_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of enemy pieces that are unguarded or unprotected.\"\n    unguarded_count = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and len(board.attackers(board.turn, square)) == 0)\n    return float(unguarded_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of currently active pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    active_pieces = sum(1 for square, piece in board.piece_map().items() if square not in {chess.E1, chess.E8, chess.A1, chess.A8})  # excluding back rank positions\n    return float(active_pieces) / total_pieces", "def feature(board: chess.Board) -> float:\n    \"Measures the aggregate distance of all pieces from their respective nearest attacking piece.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            nearest_distance = float('inf')\n            for attacker_square in range(64):\n                if board.is_attacked_by(not piece.color, attacker_square):\n                    distance = chess.square_distance(square, attacker_square)\n                    nearest_distance = min(nearest_distance, distance)\n            total_distance += nearest_distance if nearest_distance != float('inf') else 0.0\n    return total_distance", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares that are attacked by only one piece.'\n    attacked_once = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) == 1) + \\\n                      sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) == 1)\n    return float(attacked_once)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pieces in danger of being captured on the next move.'\n    danger_count = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and board.is_attacked_by(not board.turn, square))\n    return float(danger_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares that are occupied by pawns for each side.'\n    white_pawn_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_squares + black_pawn_squares)", "def feature(board: chess.Board) -> float:\n    'Measures the number of isolated pawns for each side.'\n    isolated_pawns = 0\n    for file in range(8):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == board.turn:\n                if not any(board.piece_at(chess.square(file + d, rank)) == chess.PAWN for d in [-1, 1] if 0 <= file + d < 8):\n                    isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces on both sides that are supported by their own pieces.'\n    supported_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(not board.turn, square)):\n                supported_count += 1\n    return float(supported_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are on their best development squares (e.g., knights on f3/c3, bishops on c1/f1).'\n    optimal_positions = [\n        chess.square(1, 0), chess.square(6, 0),  # Knights (b1/g1 for White, b8/g8 for Black)\n        chess.square(2, 0), chess.square(5, 0),  # Bishops (c1/f1 for White, c8/f8 for Black)\n        chess.square(3, 0), chess.square(4, 0)   # Rooks (d1 and e1 for White, d8 and e8 for Black)\n    ]\n    count = 0\n    for square in optimal_positions:\n        if board.piece_at(square) is not None and board.piece_at(square).color == board.turn:\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    'Calculates the average piece value of the opponent\u2019s pieces currently attacking the current player\u2019s pieces.'\n    opponent_piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    total_value = 0\n    attacking_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                attacker_piece = board.piece_at(attacker)\n                total_value += opponent_piece_values[attacker_piece.piece_type]\n                attacking_count += 1\n    return total_value / attacking_count if attacking_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Calculates the sum of ranks of all pieces for both sides as a measure of activity.'\n    total_rank_sum = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) is not None)\n    return float(total_rank_sum)", "def feature(board: chess.Board) -> float:\n    'Measures the proximity of each side\u2019s pawns to the opponent\u2019s back rank, assessing promotion potential.'\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within attacking range of the opponent's king.\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    \n    if not opponent_king_square:\n        return 0.0\n    \n    attacking_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            attacking_pieces += 1\n            \n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares occupied by each player's pieces in the last three ranks.\"\n    white_occupied = 0\n    black_occupied = 0\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) >= 5:  # Ranks 6-8 for White\n            if piece.color == chess.WHITE:\n                white_occupied += 1\n            else:\n                black_occupied += 1\n    \n    return float(white_occupied - black_occupied)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are not participating in the attack on the opponent's king.\"\n    inactive_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            inactive_pieces += 1\n            \n    return float(inactive_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where the opponent's pieces are positioned, but not attacked by any of the current player's pieces.\"\n    unattacked_opponent_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            unattacked_opponent_squares += 1\n            \n    return float(unattacked_opponent_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the last two ranks of each player.\"\n    white_last_two_ranks = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_last_two_ranks = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    \n    return float(white_last_two_ranks + black_last_two_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of pieces supporting each other's attacks on the opponent's king.\"\n    supporting_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            attackers = board.attackers(not board.turn, square)\n            for attacker in attackers:\n                if board.is_attacked_by(board.turn, attacker):\n                    supporting_attacks += 1\n\n    return float(supporting_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered checks available for the current player.\"\n    discovered_checks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square and board.is_check():\n                    discovered_checks += 1\n                    \n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all attacking pieces to the opponent's king, with closer pieces being more advantageous.\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    \n    if not opponent_king_square:\n        return 0.0\n\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            total_distance += chess.square_distance(square, opponent_king_square)\n    \n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces targeting squares that are also attacked by the opponent.\"\n    overlapping_targets = 0\n    for square in board.legal_moves:\n        if board.is_attacked_by(not board.turn, square.to_square) and board.is_attacked_by(board.turn, square.to_square):\n            overlapping_targets += 1\n            \n    return float(overlapping_targets)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the center of the board (d4 and e4 are considered center squares).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4')]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center_square) for center_square in center_squares)\n        total_distance += distance\n        piece_count += 1\n\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares directly adjacent to both kings, as a measure of positional safety.\"\n    adjacent_squares = set()\n    for king in [board.king(chess.WHITE), board.king(chess.BLACK)]:\n        file = chess.square_file(king)\n        rank = chess.square_rank(king)\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                square = chess.square(file + df, rank + dr)\n                if 0 <= square < 64:\n                    adjacent_squares.add(square)\n    return float(len(adjacent_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of times a player's pieces can directly threaten the opponent's king.\"\n    threat_count = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece activity by calculating how many pieces can make immediate, impactful threats.\"\n    active_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(active_threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have multiple attacking options (i.e., can capture multiple opponent pieces in one turn).\"\n    multi_attackers = sum(len(board.attackers(not board.turn, square)) > 1 for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(multi_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of control over central squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the endgame stage (less than 10 total pieces for both players).\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(total_pieces < 10)", "def feature(board: chess.Board) -> float:\n    \"Measures the connectivity of pawns by counting the pawn pairs that can support each other.\"\n    pawn_positions = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN]\n    connected_pairs = sum(1 for square in pawn_positions if (chess.square_file(square) > 0 and board.piece_at(square - 1) == chess.PAWN) or (chess.square_file(square) < 7 and board.piece_at(square + 1) == chess.PAWN))\n    return float(connected_pairs)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces located on the first rank, indicating stronger defense.\"\n    defending_pieces_on_first_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and chess.square_rank(square) == 0)\n    return float(defending_pieces_on_first_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in piece mobility for both sides based on the number of legal moves available.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces occupying the back ranks for both players.\"\n    white_back_rank = sum(1 for square in range(chess.A8, chess.H8+1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A1, chess.H1+1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has that can immediately attack the opponent's king.\"\n    white_attackers = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    black_attackers = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pawns from their respective promotion ranks.\"\n    white_pawn_distance = sum(8 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total ranks of pawns for both players.\"\n    total_white_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE)\n    total_black_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK)\n    return float(total_white_ranks - total_black_ranks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces located on the second rank of each side.\"\n    white_second_rank = sum(1 for square in range(chess.A7, chess.H7+1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_second_rank = sum(1 for square in range(chess.A2, chess.H2+1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_second_rank - black_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of each player's pieces to the opponent's back rank.\"\n    white_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with a potential to influence control of the center (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of non-pawn pieces for each player.\"\n    piece_values = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(board.piece_map()[square].piece_type, 0) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_value = sum(piece_values.get(board.piece_map()[square].piece_type, 0) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by both players that are also attacked by the opponent.\"\n    controlled_squares = set()\n    opponent_attacked_squares = set()\n    \n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n        if board.is_attacked_by(board.turn, move.to_square):\n            opponent_attacked_squares.add(move.to_square)\n\n    return float(len(controlled_squares & opponent_attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of available attacking moves for each side and returns the difference.\"\n    white_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    black_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are held by queens of both players, indicating attacking potential.\"\n    queen_squares = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.QUEEN)\n    return float(queen_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves available for both players, indicating mobility.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of central squares under control by both players, indicating control of the board.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                   sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks for each piece's position for both players, where higher ranks suggest advanced pieces.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces threatened by the current player's pieces to identify potential captures.\"\n    threats = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            attackers = board.attackers(board.turn, square)\n            threats += len(attackers)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on each player's third rank, indicating potential threats to the opponent.\"\n    white_third_rank = sum(1 for square in range(chess.A3, chess.H3 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_third_rank = sum(1 for square in range(chess.A6, chess.H6 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_third_rank - black_third_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces on the board for both players, indicating vulnerability.\"\n    unprotected_count = sum(1 for square in board.piece_map() if not board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces defending the opponent's king.\"\n    defending_pieces = len(board.attackers(chess.WHITE, chess.parse_square('h8'))) if board.turn else len(board.attackers(chess.BLACK, chess.parse_square('a1')))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares currently occupied by both players' pieces.\"\n    occupied_squares = len([square for square, piece in board.piece_map().items() if piece is not None])\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawn advancements (how many ranks pawns have moved forward).\"\n    white_pawn_advancements = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawn_advancements = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawn_advancements + black_pawn_advancements)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by both sides' pieces.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces to the opponent's back rank.\"\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares that can be attacked by two or more pieces.\"\n    double_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available checks for both players.\"\n    white_checks = sum(1 for move in board.legal_moves if move.to_square in board.attackers(chess.BLACK, chess.parse_square('h8')))\n    black_checks = sum(1 for move in board.legal_moves if move.to_square in board.attackers(chess.WHITE, chess.parse_square('a1')))\n    return float(white_checks + black_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of developed pieces (not on the first two ranks) to total pieces for both sides.\"\n    developed_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 1)\n    developed_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 6)\n    total_pieces = len(board.piece_map())\n    return float((developed_white + developed_black) / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that can deliver check.\"\n    white_checkers = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    black_checkers = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_checkers - black_checkers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares not attacked or defended by any piece for both players.\"\n    undefended_squares = sum(1 for square in chess.SQUARES if not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square))\n    return float(undefended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (cannot move without revealing a check).\"\n    pinned_count = 0\n    for sq_from in chess.SQUARES:\n        piece = board.piece_at(sq_from)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == sq_from:\n                    if board.is_check():\n                        pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces on the second rank for both players.\"\n    material_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and (chess.square_rank(square) == 1 or chess.square_rank(square) == 6):\n            material_value += piece_values[piece.piece_type]\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares in the opponent's half that are controlled by the current player's pieces.\"\n    controlled_squares = 0\n    for square in chess.SQUARES:\n        if chess.square_rank(square) > 3:  # Opponent's half for White\n            if board.is_attacked_by(board.turn, square):\n                controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of mobility options (legal moves) available to each side and returns the difference.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawn promotions available for each player.\"\n    white_promotions = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 6)\n    black_promotions = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) == 1)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the minimum distance from any piece to the opponent's king.\"\n    opponent_king_square = next((square for square in chess.SQUARES if board.piece_at(square) == chess.KING and board.piece_at(square).color != board.turn), None)\n    if opponent_king_square is None:\n        return float('inf')\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlled by each side that are attacking the opponent's king.\"\n    controlled_attacks = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and board.piece_at(square) and board.piece_at(square).color == board.turn:\n            controlled_attacks += 1\n    return float(controlled_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each side's pieces in the opponent's half.\"\n    squares_in_opponent_half = sum(1 for square in board.piece_map() if (board.turn == chess.WHITE and chess.square_rank(square) > 3) or (board.turn == chess.BLACK and chess.square_rank(square) < 4))\n    return float(squares_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of unprotected pieces for each player.\"\n    unprotected_pieces_count = sum(1 for square in board.piece_map() if all(not board.is_attacked_by(board.piece_at(square).color, attacker_sq) for attacker_sq in board.attackers(not board.piece_at(square).color, square)))\n    return float(unprotected_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pawns from their respective promotion ranks.\"\n    total_distance = sum(chess.square_distance(square, chess.square_rank(7 if piece.color == chess.WHITE else 0)) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential threats available (pieces that can move to attack).\"\n    potential_threats = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(potential_threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the number of attacking pieces surrounding the opponent's king.\"\n    opponent_king_square = next((square for square in chess.SQUARES if board.piece_at(square) == chess.KING and board.piece_at(square).color != board.turn), None)\n    if opponent_king_square is None:\n        return float('inf')\n    attacking_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq) and any(board.piece_at(sq) for sq in board.attackers(board.piece_at(opponent_king_square).color, opponent_king_square)))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the opponent's back rank, indicating potential for control or vulnerability.\"\n    back_rank_pieces = sum(1 for square in chess.SQUARES if (board.turn == chess.WHITE and chess.square_rank(square) == 0) or (board.turn == chess.BLACK and chess.square_rank(square) == 7))\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) by each side.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in active piece counts; pieces that can currently move.\"\n    active_white = sum(1 for move in board.legal_moves if board.turn and board.piece_at(move.from_square).color == chess.WHITE)\n    active_black = sum(1 for move in board.legal_moves if not board.turn and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(active_white - active_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of dangerous pieces (pieces that can check the opposite king).\"\n    dangerous_white = sum(1 for square, piece in board.piece_map().items() \n                          if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    dangerous_black = sum(1 for square, piece in board.piece_map().items() \n                          if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(dangerous_white - dangerous_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked but not occupied by either player's pieces.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are advanced (beyond the 4th rank) for both players.\"\n    advanced_white = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.WHITE and chess.square_rank(square) > 3 and piece.piece_type == chess.PAWN)\n    advanced_black = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK and chess.square_rank(square) < 4 and piece.piece_type == chess.PAWN)\n    return float(advanced_white - advanced_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available in the current position.\"\n    checks_available = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are controlled by the current player that are adjacent to the opponent's back rank.\"\n    controlled_adjacent_to_back_rank = 0\n    for rank in range(0, 2):  # Check ranks 0 and 1 for Black, 7 and 6 for White\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.is_attacked_by(board.turn, square):\n                controlled_adjacent_to_back_rank += 1\n    return float(controlled_adjacent_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of remaining pieces for both sides.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value_white = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of dangling pawns (pawns that have no pawns to protect them on adjacent files).'\n    dangling_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                dangling_pawns += 1\n    return float(dangling_pawns)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces located on the back ranks of both players.'\n    back_rank_pieces = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        for file in range(8):\n            square = chess.square(file, 0 if color == chess.WHITE else 7)\n            if board.piece_at(square) is not None:\n                back_rank_pieces += 1\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pieces that are currently attacking the opponent\\'s king.'\n    current_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(board.turn, move.to_square))\n    opponent_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(current_attacks - opponent_attacks)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pawns that are positioned on their promotion ranks (7th rank for White, 2nd rank for Black).'\n    promotion_rank_pawns = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        promotion_rank = 7 if color == chess.WHITE else 1\n        for file in range(8):\n            square = chess.square(file, promotion_rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                promotion_rank_pawns += 1\n    return float(promotion_rank_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces controlled by each player in the center files (d and e files).'\n    center_control = [0, 0]  # index 0 for White, 1 for Black\n    center_files = [chess.D1, chess.D2, chess.E1, chess.E2]\n    for square in center_files:\n        piece = board.piece_at(square)\n        if piece:\n            color_index = 0 if piece.color == chess.WHITE else 1\n            center_control[color_index] += 1\n    return float(center_control[0] - center_control[1])", "def feature(board: chess.Board) -> float:\n    'Measures the total number of double attacks on pieces by both players.'\n    double_attacked_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            attackers = board.attackers(board.piece_at(square).color, square)\n            if len(attackers) >= 2:\n                double_attacked_count += 1\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of forks possible by each player based on their pieces positions.'\n    forks_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        attacked_squares = []\n        for target_move in board.legal_moves:\n            attacked_squares.append(target_move.to_square)\n        if len(set(attacked_squares)) > 1:\n            forks_count += 1\n        board.pop()\n    return float(forks_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material deficit for each player, indicating potential weaknesses.\"\n    white_material = sum([piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_material = sum([piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under threat from the opponent's pieces.\"\n    total_attacked_squares = len(set(square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))) if board.turn else len(set(square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)))\n    return float(total_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all non-pawn pieces; higher ranks indicate better position.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type != chess.PAWN)\n    num_non_pawn_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type != chess.PAWN)\n    return float(total_rank / num_non_pawn_pieces) if num_non_pawn_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can directly attack the opponent's king.\"\n    attacking_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == (chess.WHITE if board.turn else chess.BLACK) and board.is_attacked_by((chess.WHITE if board.turn else chess.BLACK), chess.KING))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the efficiency of each player's back rank defense; fewer pieces on the back rank implies weakness.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have no legal moves available.\"\n    immobile_pieces = sum(1 for square in board.piece_map() if not list(board.legal_moves) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(immobile_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances from all pieces to the opponent's king, helping assess threats.\"\n    total_distance = sum(chess.square_distance(square, board.king(chess.BLACK if board.turn else chess.WHITE)) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of available checks for both players to assess immediate threats.\"\n    checks_available = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are currently in their original squares.\"\n    original_position_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type in {chess.PAWN, chess.ROOK, chess.KNIGHT, chess.BISHOP, chess.QUEEN, chess.KING} and (  \n        (board.piece_at(square).color == chess.WHITE and square in [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1, chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]) or  \n        (board.piece_at(square).color == chess.BLACK and square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8, chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7])  \n    ))\n    return float(original_position_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces with open routes to attack the opponent's king.\"\n    attacking_routes = 0\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and move.to_square == opponent_king_square:\n                    attacking_routes += 1\n    return float(attacking_routes)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control over central squares (d4, d5, e4, e5) by the current player.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are in danger of being captured by only one opponent piece.\"\n    danger_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if len(board.attackers(not board.turn, square)) == 1:\n                danger_count += 1\n    return float(danger_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of piece ranks for all pieces attacking the opponent's king.\"\n    attacker_rank_sum = 0\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if board.is_attacked_by(board.turn, opponent_king_square):\n            attacker_rank_sum += chess.square_rank(square) + 1\n    return float(attacker_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered checks available for the current player.\"\n    discovered_checks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            for target_square in board.legal_moves:\n                if target_square.from_square == square:\n                    if board.is_check():\n                        discovered_checks += 1\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the density of pieces in the player's back ranks.\"\n    back_rank_density = sum(1 for square in range(chess.A1, chess.H1 + 1) \n                            if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(back_rank_density)", "def feature(board: chess.Board) -> float:\n    \"Measures the impact of pawn structure by counting isolated pawns on the board.\"\n    isolated_pawn_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            adjacent_pawn_count = (\n                board.piece_at(chess.parse_square(chess.square_name(file - 1 + 8 * chess.square_rank(square)))) is not None or \n                board.piece_at(chess.parse_square(chess.square_name(file + 1 + 8 * chess.square_rank(square)))) is not None\n            )\n            if not adjacent_pawn_count:\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available promotion squares for the current player's pawns.\"\n    promotion_squares = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == board.turn:\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                promotion_squares += 1\n    return float(promotion_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pins against pieces other than the king.\"\n    pin_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            directly_attacked = board.attackers(not board.turn, square)\n            if any(board.is_attacked_by(not board.turn, board.king(board.turn)) for target in directly_attacked):\n                pin_count += 1\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece activity by summing the possible legal moves for all pieces.\"\n    total_legal_moves = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for each side.\"\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of attacking pieces between the two players.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on squares that control the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    return float(sum(1 for square in center_squares if board.piece_at(square) is not None))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that cannot move (blocked pieces).\"\n    blocked_pieces_count = sum(1 for piece in board.piece_map().values() if not list(board.legal_moves) and piece.color == board.turn)\n    return float(blocked_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pieces within one square of the opposing king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    return float(len([sq for sq in chess.SQUARES if board.is_attacked_by(not board.turn, sq) and chess.square_distance(sq, king_square) <= 1]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for the side to move.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and board.is_check():\n            for attacker in board.attackers(not board.turn, board.king(not board.turn)):\n                if board.is_attacked_by(piece.color, square) and not board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's pieces.\"\n    attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of each player's pawns.\"\n    material_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            material_value += 100  # Standard pawn value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares where the opponent's pieces are completely unprotected.\"\n    return sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square) and all(not board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, target_square) for target_square in board.attackers(chess.BLACK if board.turn else chess.WHITE, square)))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of unique squares attacked by both players' pieces.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value of pieces that support each other.\"\n    total_support_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(board.turn, square):\n                total_support_value += piece.piece_type if piece.color == chess.WHITE else -piece.piece_type\n    return total_support_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by pieces that are blocking potential pawn promotions.\"\n    blocking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and ((square // 8 == 6 and board.piece_at(square).color == chess.WHITE) or (square // 8 == 1 and board.piece_at(square).color == chess.BLACK)))\n    return float(blocking_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of different threats (checks and captures) for both sides.\"\n    white_threats = sum(1 for move in board.legal_moves if board.is_check() or (move.promotion is not None and board.piece_at(move.from_square).color == chess.WHITE))\n    black_threats = sum(1 for move in board.legal_moves if board.is_check() or (move.promotion is not None and board.piece_at(move.from_square).color == chess.BLACK))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each color has that are attacking the opponent's king.\"\n    return float(sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square) and board.piece_at(square).color == board.turn))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that threaten multiple opponent pieces.\"\n    multi_threats = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and len(board.attackers(chess.BLACK if board.turn else chess.WHITE, square)) > 1)\n    return float(multi_threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pieces facing off against each other.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        if board.piece_at(square):\n            controlled_squares.update(board.attackers(board.piece_at(square).color, square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total difference in the number of pawns each player has on the board.\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of king safety squares for both players.\"\n    white_king_safe_squares = sum(1 for sq in range(64) if not board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq) == chess.KING)\n    black_king_safe_squares = sum(1 for sq in range(64) if not board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq) == chess.KING)\n    return float(white_king_safe_squares - black_king_safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential pawn promotions for both players.\"\n    white_pawn_promotions = sum(1 for sq in range(64) if board.piece_at(sq) == chess.PAWN and chess.square_rank(sq) == 6)\n    black_pawn_promotions = sum(1 for sq in range(64) if board.piece_at(sq) == chess.PAWN and chess.square_rank(sq) == 1)\n    return float(white_pawn_promotions - black_pawn_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in ranks of each player's pawns.\"\n    white_pawn_ranks = sum(chess.square_rank(sq) for sq in range(64) if board.piece_at(sq) == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawn_ranks = sum(chess.square_rank(sq) for sq in range(64) if board.piece_at(sq) == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces can deliver a check against the opponent's king.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_at(move.from_square).color == chess.WHITE)\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled exclusively by each player.\"\n    white_controlled_squares = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq) and not board.is_attacked_by(chess.BLACK, sq))\n    black_controlled_squares = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq) and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_controlled_squares - black_controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of possible checks available to each player in their turn.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_at(move.from_square).color == chess.WHITE)\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawns on the 7th rank, as they are close to promotion.\"\n    return sum(1 for sq in range(8) if board.piece_at(chess.A7 + sq) == chess.PAWN)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces locked in positions, indicating potential for exchange.\"\n    locked_pieces = sum(1 for sq in board.piece_map() if len(board.attackers(board.piece_at(sq).color, sq)) > 0)\n    return float(locked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled solely by a single color's pieces.\"\n    controlled_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and not board.is_attacked_by(chess.BLACK, sq)) - \\\n                         sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and not board.is_attacked_by(chess.WHITE, sq))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of empty squares in the last two ranks, indicative of piece advancement.\"\n    empty_squares = sum(1 for sq in range(56, 64) if board.piece_at(sq) is None) + sum(1 for sq in range(48, 56) if board.piece_at(sq) is None)\n    return float(empty_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are directly attacking the opponent's king.\"\n    attacking_king_moves = sum(1 for move in board.legal_moves if board.is_check())\n    return float(attacking_king_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center four squares of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_density = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(piece_density)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both players, indicating potential weaknesses.\"\n    doubled_pawns = 0\n    for file in range(8):\n        if board.piece_at(chess.A2 + file) == chess.PAWN and board.piece_at(chess.A3 + file) == chess.PAWN:\n            doubled_pawns += 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are positioned in the first two ranks, reflecting development.\"\n    development_pieces = sum(1 for sq in board.piece_map() if chess.square_rank(sq) < 2)\n    return float(development_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are within two squares of the opponent's back rank, indicating threat potential.\"\n    proximity_to_back_rank = sum(1 for sq in board.piece_map() if abs(chess.square_rank(sq) - (7 if board.turn else 0)) <= 2)\n    return float(proximity_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently attacking the opponent\u2019s most advanced pawn.\"\n    attacking_advanced_pawn = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.piece_at(sq).color, sq) and chess.square_rank(sq) == (6 if board.turn else 1))\n    return float(attacking_advanced_pawn)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for piece_square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(piece_square, opponent_king_square)\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each player that are on the 7th rank for White or the 2nd rank for Black.\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that can deliver a check to the total number of pieces on the board.\"\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    total_pieces = len(board.piece_map())\n    return check_count / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under attack by both players' pieces.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest piece of the opponent to the current player's king.\"\n    min_distance = float('inf')\n    current_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(square, current_king_square)\n            if distance < min_distance:\n                min_distance = distance\n    return float(min_distance) if min_distance != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are on their original squares.\"\n    original_position_count = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) == 0) or (piece.color == chess.BLACK and chess.square_rank(square) == 7):\n            original_position_count += 1\n    return float(original_position_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves that can result in capturing an opponent's piece.\"\n    capture_moves_count = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and board.piece_at(move.to_square).color != board.turn)\n    return float(capture_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pawns to their respective promotion ranks.\"\n    total_pawn_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            promotion_rank = 7 if piece.color == chess.WHITE else 0\n            total_pawn_distance += chess.square_distance(square, promotion_rank)\n    return float(total_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pawns for both sides.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present.\"\n    controlled_squares = len([square for square in chess.SQUARES if board.piece_at(square) and any(board.attackers(color, square) for color in [chess.WHITE, chess.BLACK])])\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to their closest pawn for both players.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_distance_to_pawn = min([chess.square_distance(white_king_square, sq) for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE], default=0)\n    black_distance_to_pawn = min([chess.square_distance(black_king_square, sq) for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK], default=0)\n    return float(white_distance_to_pawn - black_distance_to_pawn)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available for the opponent as a potential threat.\"\n    legal_moves_for_opponent = len(list(board.legal_moves))\n    return float(-legal_moves_for_opponent)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available to each king, indicating potential activity.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_moves = len(list(board.legal_moves)) if white_king_square else 0\n    black_moves = len(list(board.legal_moves)) if black_king_square else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pawns for both sides.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where pawns are positioned, providing insight into pawn structure.\"\n    occupied_squares = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the current player, emphasizing control.\"\n    attacked_squares = len(set(move.to_square for move in board.legal_moves if move.from_square in board.attackers(board.turn, move.to_square)))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pieces' ranks to assess the distribution of pieces across the board.\"\n    rank_difference = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE:\n            rank_difference += chess.square_rank(square)\n        else:\n            rank_difference -= chess.square_rank(square)\n    return rank_difference", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can promote on the next move, indicating potential for advancement.\"\n    promoting_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promoting_pieces += 1\n    return float(promoting_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the opponent's king, reflecting overall threat level.\"\n    distance_sum = 0.0\n    count = 0\n    opponent_king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    for square in board.piece_map():\n        count += 1\n        distance_sum += chess.square_distance(square, opponent_king_square)\n    return distance_sum / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces positioned on the center squares, indicating central control.\"\n    center_control = 0.0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for square in center_squares:\n        if board.piece_at(square) is not None:\n            center_control += 1\n    return center_control", "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of a knight in the opponent's half of the board.\"\n    knight_present = any(board.piece_at(square) and board.piece_at(square).piece_type == chess.KNIGHT and (chess.square_rank(square) > 4) for square in board.piece_map())\n    return float(knight_present)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently supported by other pieces.\"\n    supported_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and any(board.is_attacked_by(not board.turn, square) for square in board.attackers(board.turn, square)))\n    return float(supported_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective back ranks.\"\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn structure quality by counting blocked pawns.\"\n    blocked_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and any(board.piece_at(square + offset) for offset in [-8, -7, -6, -1]))\n    return float(blocked_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that pieces from both players can potentially occupy.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        controlled_squares.update(move.to_square for move in board.legal_moves if move.from_square == square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can attack the opponent's king.\"\n    attacking_moves = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, chess.parse_square('e8' if board.turn == chess.BLACK else 'e1')))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces clustered in the center of the board (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    density = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(density)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are available for potential promotion by pawns on the 7th rank.\"\n    promotion_squares = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    return float(promotion_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares that are currently attacked by both players.'\n    attackers_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    'Measures the density of pieces on the board by counting the number of pieces per rank.'\n    pieces_count_per_rank = [sum(1 for square in range(rank * 8, (rank + 1) * 8) if board.piece_at(square) is not None) for rank in range(8)]\n    return float(sum(pieces_count_per_rank) / 8)", "def feature(board: chess.Board) -> float:\n    'Calculates the proximity of pawns to promotion for both players combined.'\n    proximity_score = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN)\n    return float(proximity_score)", "def feature(board: chess.Board) -> float:\n    'Determines the number of pieces protected by a pawn, useful for assessing pawn structure quality.'\n    protected_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and any(board.is_attacked_by(board.piece_at(square).color, target) for target in board.attackers(board.piece_at(square).color, square)))\n    return float(protected_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of moves available to the player about to play that result in a check.'\n    check_moves = sum(1 for move in board.legal_moves if board.is_check() and board.pseudo_legal_moves)\n    return float(check_moves)", "def feature(board: chess.Board) -> float:\n    'Evaluates the mobility of pawns by counting how many squares they can move to.'\n    pawn_mobility = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and len(list(board.legal_moves)) > 0)\n    return float(pawn_mobility)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares where a pawn can potentially promote for both players.'\n    white_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the kings from their respective opponent\\'s corners.'\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.A8) + chess.square_distance(white_king_square, chess.H8)\n    black_distance = chess.square_distance(black_king_square, chess.A1) + chess.square_distance(black_king_square, chess.H1)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the total distance of all pawns from their respective promotion ranks.'\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares where the kings can move to without being in check.'\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_available_moves = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_available_moves = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    return float(white_available_moves - black_available_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by both kings.'\n    controlled_squares = 0\n    king_squares = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING]\n    for square in king_squares:\n        controlled_squares += len(board.attackers(board.piece_at(square).color, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of defending pieces for both players.'\n    white_defenders = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_defenders - black_defenders)", "def feature(board: chess.Board) -> float:\n    'Calculates the overall piece mobility advantage by comparing available moves for both players.'\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares that are simultaneously attacked by both players.'\n    double_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(double_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (cannot move without exposing the king).\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not board.turn, square) and not any(move.from_square == square for move in board.legal_moves))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by both players.\"\n    attacked_squares = set(move.to_square for move in board.legal_moves)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces that are on the board versus those off.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    current_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(current_material - opponent_material)", "def feature(board: chess.Board) -> float:\n    \"Counts how many squares are occupied by both players' pieces.\"\n    occupied_squares = sum(1 for square in board.piece_map().keys())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of moves available to each player and returns their difference.\"\n    current_moves = len(list(board.legal_moves))\n    opponent_moves = len(list(board.legal_moves))\n    return float(current_moves - opponent_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares each player can control with pieces positioned on the last two ranks.\"\n    control_last_two_ranks = sum(1 for square in board.piece_map().keys() if chess.square_rank(square) >= 6)\n    return float(control_last_two_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of both kings to the center of the board as an indicator of activity.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    center_square = chess.parse_square('e4')  # Center square\n    white_distance = chess.square_distance(white_king_square, center_square)\n    black_distance = chess.square_distance(black_king_square, center_square)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of doubled pawns for both sides.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    white_doubled = 0\n    black_doubled = 0\n    white_files = {}\n    black_files = {}\n    \n    for pawn in pawns:\n        if board.piece_at(pawn).color == chess.WHITE:\n            file = chess.square_file(pawn)\n            white_files[file] = white_files.get(file, 0) + 1\n        else:\n            file = chess.square_file(pawn)\n            black_files[file] = black_files.get(file, 0) + 1\n            \n    white_doubled = sum(1 for count in white_files.values() if count > 1)\n    black_doubled = sum(1 for count in black_files.values() if count > 1)\n    \n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares from which pieces can attack the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    attacking_squares = set()\n\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and move.to_square == opponent_king_square:\n                    attacking_squares.add(square)\n    \n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, d5, e4, e5) by each side.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces positioned on the 7th rank (for White) and 2nd rank (for Black).\"\n    white_seventh_rank = len([sq for sq in board.piece_map() if chess.square_rank(sq) == 6 and board.piece_at(sq).color == chess.WHITE])\n    black_second_rank = len([sq for sq in board.piece_map() if chess.square_rank(sq) == 1 and board.piece_at(sq).color == chess.BLACK])\n    return float(white_seventh_rank - black_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are less active, judged by their position with respect to the center.\"\n    inactive_value = 0\n    for square, piece in board.piece_map().items():\n        distance_to_center = chess.square_distance(square, chess.parse_square('e4'))  # Center\n        if distance_to_center > 2:  # Arbitrary value for 'inactive'\n            if piece.color == chess.WHITE:\n                inactive_value += piece.piece_type  # Each piece has a material value (use values: 1 for pawn, 3 for knight/bishop, etc.)\n            else:\n                inactive_value -= piece.piece_type\n    return float(inactive_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential promotions for each player.\"\n    white_promotions = sum(1 for sq in board.pieces(chess.PAWN, chess.WHITE) if chess.square_rank(sq) == 6)  # Pawns on 7th rank\n    black_promotions = sum(1 for sq in board.pieces(chess.PAWN, chess.BLACK) if chess.square_rank(sq) == 1)  # Pawns on 2nd rank\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that can currently contribute to defensive formations (being protected).\"\n    defending_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(not board.turn, target_sq) for target_sq in board.attackers(board.turn, square)):\n                defending_count += 1\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the ranks of both players' pieces to assess advancement.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pawns each player has on the board.'\n    white_pawns = len([square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN])\n    black_pawns = len([square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance from the opponent\u2019s king to the nearest opposing piece.'\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    nearest_distance = min(chess.square_distance(king_square, square) for square, piece in board.piece_map().items() if piece.color != board.turn)\n    return float(nearest_distance)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are currently pinned against their own king by the opponent.'\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            # Check if the piece is pinned by looking for the attacking piece along the line of the king\n            king_square = board.king(piece.color)\n            if board.is_attacked_by(not piece.color, square) and chess.square_distance(square, king_square) < 8:\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares protected by multiple pieces of the current player.'\n    protected_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(board.turn, square)\n            if len(attackers) > 1:\n                protected_squares.add(square)\n    return float(len(protected_squares))", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of central squares (d4, e4, d5, e5) controlled by both players.'\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    control = {'white': 0, 'black': 0}\n    for square in central_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control['white'] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control['black'] += 1\n    return float(control['white'] - control['black'])", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares from which the current player can threaten the opponent\u2019s king.'\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    threat_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            threatened_squares = board.legal_moves\n            for move in threatened_squares:\n                if move.to_square == king_square:\n                    threat_squares.add(square)\n    return float(len(threat_squares))", "def feature(board: chess.Board) -> float:\n    'Calculates the proportion of pieces in play that are supporting other pieces.'\n    supporting_count = 0\n    total_pieces = len(board.piece_map())\n    for square, piece in board.piece_map().items():\n        for attacker_square in board.attackers(not piece.color, square):\n            if board.piece_at(attacker_square) and board.piece_at(attacker_square).color == piece.color:\n                supporting_count += 1\n    return float(supporting_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares controlled by the current player that have no defending pieces.'\n    controlled_squares = 0\n    piece_map = board.piece_map()\n    for square in piece_map:\n        if piece_map[square].color == board.turn:\n            for target_square in board.attackers(board.turn, square):\n                if board.piece_at(target_square) is None:\n                    controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of potential forks for the current player by looking for attack opportunities on two or more pieces.'\n    fork_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        attacked = {}\n        for target_square in board.attackers(not board.turn, move.to_square):\n            if board.piece_at(target_square):\n                attacked[target_square] = attacked.get(target_square, 0) + 1\n        if len(attacked) > 1:\n            fork_count += 1\n        board.pop()\n    return float(fork_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces to the opponent\u2019s king to assess threat level.'\n    total_distance = 0\n    piece_count = 0\n    opponent_king_square = board.king(not board.turn)\n\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            distance = chess.square_distance(square, opponent_king_square)\n            total_distance += distance\n            piece_count += 1\n\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the total cumulative rank of pieces that are in advanced positions (4th rank or beyond).'\n    total_rank = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_rank(square) >= 3:\n            total_rank += chess.square_rank(square) + 1  # To convert 0-7 to 1-8\n\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares completely controlled (attacked and defended) by the current player.'\n    controlled_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and len(board.attackers(not board.turn, square)) == 0:\n            controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the column control where pieces are positioned; focuses on central control.'\n    side_control = [0, 0, 0, 0]  # Columns 0-3 or a-d\n    central_columns = [0, 1, 2, 3]\n\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            column = chess.square_file(square)\n            if column in central_columns:\n                side_control[piece.color] += 1\n\n    return float(side_control[chess.WHITE] - side_control[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Measures the number of legal attacking moves each player has available on their next turn.'\n    attacking_moves_count = len(list(board.legal_moves))\n    return float(attacking_moves_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares attacked by both sides collectively.'\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    'Evaluates the number of pieces on the seventh rank for both players.'\n    seventh_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square))\n    return float(seventh_rank_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pawns each player has.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns + black_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the total distance of all pieces to their respective nearest back rank.'\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares on the eighth and second ranks where a player has pieces.'\n    rank_status = 0\n    for square in chess.SQUARES:\n        if (chess.square_rank(square) == 0 or chess.square_rank(square) == 7) and board.piece_at(square):\n            rank_status += 1\n    return float(rank_status)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the current player\u2019s pieces to the opponent\u2019s king'\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    \n    if opponent_king_square is None:\n        return 0.0\n\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_distance(square, opponent_king_square)\n\n    return total_distance", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the board that are on a4, d4, or h4'\n    specific_squares = [chess.A4, chess.D4, chess.H4]\n    count = sum(1 for sq in specific_squares if board.piece_at(sq) is not None)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares where a player can deliver a check on their next turn'\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of legal moves available for the opponent'\n    opponent_moves = sum(1 for move in board.legal_moves if not board.gives_check(move))\n    return float(opponent_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares that are currently attacked by both players'\n    squares_attacked = set()\n    for square in range(64):  # Iterate over all squares\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            squares_attacked.add(square)\n    \n    return float(len(squares_attacked))", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pieces on the board that are attacking the opponent\u2019s pieces'\n    attacking_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(piece.color, square)\n            for attacker in attackers:\n                if board.piece_at(attacker) and board.piece_at(attacker).color != piece.color:\n                    attacking_count += 1\n\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for both players on the 7th rank.\"\n    count = 0\n    for file in range(8):\n        if board.piece_at(chess.square(file, 6)):\n            count += 1\n        if board.piece_at(chess.square(file, 1)):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are attacked by at least two pieces of the current player.\"\n    control_count = 0\n    control_map = {}\n    \n    for move in board.legal_moves:\n        to_square = move.to_square\n        control_map[to_square] = control_map.get(to_square, 0) + 1\n        \n    for square, count in control_map.items():\n        if count > 1:\n            control_count += 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pawns to their respective promotion ranks.\"\n    distance_sum = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                distance_sum += chess.square_rank(square)\n            else:\n                distance_sum += 7 - chess.square_rank(square)\n    \n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares from which the current player's pieces can control enemy pawns.\"\n    controlled_enemy_pawn_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target in board.attackers(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square):\n                if board.piece_at(target) and board.piece_at(target).piece_type == chess.PAWN and board.piece_at(target).color != piece.color:\n                    controlled_enemy_pawn_count += 1\n                    break\n                    \n    return float(controlled_enemy_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected enemy pieces for the player to move.\"\n    unprotected_enemy_count = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            unprotected_enemy_count += 1\n    \n    return float(unprotected_enemy_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of defending squares for the current player's pieces.\"\n    defending_squares_count = 0\n    piece_defense_positions = {}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    defended_square = move.to_square\n                    piece_defense_positions[defended_square] = piece_defense_positions.get(defended_square, 0) + 1\n                \n    defending_squares_count = len(piece_defense_positions.keys())\n    return float(defending_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from each player's pawns to their respective back ranks.\"\n    total_distance = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                total_distance += chess.square_rank(square)\n            else:\n                total_distance += 7 - chess.square_rank(square)\n    \n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of rook pawns for both players.\"\n    rook_pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_file(square) in (0, 7))\n    return float(rook_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity score based on the rank of each piece.\"\n    score = sum(chess.square_rank(square) for square, piece in board.piece_map().items())\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can directly check the opponent's king without needing to move first.\"\n    direct_checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(direct_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of unprotected squares around the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    unprotected_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None)\n    return float(unprotected_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the third rank for both players.\"\n    third_rank_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) == 2)\n    return float(third_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many squares are being defended by precisely two pieces of the same color.\"\n    double_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.WHITE, square))\n    return float(double_defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the cumulative distance of all pieces to their respective development squares.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the last two ranks of the player's side.\"\n    player_side_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 5)\n    return float(player_side_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by the current player's pieces that are not in their optimal squares.\"\n    mispositioned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) < 4:\n            mispositioned_count += 1\n    return float(mispositioned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares available for each player's pieces to move to.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns to the promotion square for each player.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total potential for piece development, defined by the number of pieces not on their 2nd or 7th ranks.\"\n    undeveloped = sum(1 for sq, piece in board.piece_map().items() \n                      if (piece.color == chess.WHITE and chess.square_rank(sq) < 6) or\n                         (piece.color == chess.BLACK and chess.square_rank(sq) > 1))\n    return float(undeveloped)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that are on their optimal squares (2nd for white, 7th for black).\"\n    optimal_pieces = sum(1 for sq, piece in board.piece_map().items()\n                         if (piece.color == chess.WHITE and chess.square_rank(sq) == 1) or\n                            (piece.color == chess.BLACK and chess.square_rank(sq) == 6))\n    total_pieces = len(board.piece_map())\n    return float(optimal_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks that each player can deliver, representing immediate threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check())\n    black_checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within one square of the opponent's king, indicating potential threats.\"\n    opponent_king_position = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    threatening_pieces = sum(1 for sq, piece in board.piece_map().items() \n                             if piece.color == board.turn and chess.square_distance(sq, opponent_king_position) == 1)\n    return float(threatening_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each player has on their respective 7th ranks.\"\n    total_white_pawns_on_7th = sum(1 for sq, piece in board.piece_map().items() \n                                     if piece.color == chess.WHITE and chess.square_rank(sq) == 6 and piece.piece_type == chess.PAWN)\n    total_black_pawns_on_7th = sum(1 for sq, piece in board.piece_map().items() \n                                     if piece.color == chess.BLACK and chess.square_rank(sq) == 1 and piece.piece_type == chess.PAWN)\n    return float(total_white_pawns_on_7th - total_black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the total rank sum of pieces that are defended by other pieces confirmed as attacking.\"\n    defended_by_attack = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items()\n                              if piece.color == board.turn and any(board.is_attacked_by(not piece.color, sq_opp) for sq_opp in board.attackers(not piece.color, sq)))\n    return float(defended_by_attack)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player, indicating weaknesses in their structure.\"\n    isolated_pawns = sum(1 for sq, piece in board.piece_map().items()\n                         if piece.color == board.turn and piece.piece_type == chess.PAWN and \n                         (board.piece_at(sq - 1) is None and board.piece_at(sq + 1) is None))\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces targeting the opponent's back rank, which indicates pressure on the opponent.\"\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    attacking_pieces = sum(1 for sq, piece in board.piece_map().items()\n                           if piece.color == board.turn and sq // 8 == opponent_back_rank)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns for both sides in the last two ranks.\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() \n                      if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) >= 6)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() \n                      if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) <= 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for immediate checks by counting the pieces that can deliver a check.\"\n    checks_available = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by more than one piece of the current player.\"\n    attacked_squares = {}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(board.turn, square):\n                if target_square in attacked_squares:\n                    attacked_squares[target_square] += 1\n                else:\n                    attacked_squares[target_square] = 1\n    return float(sum(1 for count in attacked_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares vulnerable to attack (not defended) for both players.\"\n    vulnerable_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square) and not board.is_attacked_by(board.turn, square):\n            vulnerable_squares += 1\n    return float(vulnerable_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility difference between both players.\"\n    white_moves = len(list(board.legal_moves))\n    board.push(chess.Move.null())  # Make null move to calculate Black's moves\n    black_moves = len(list(board.legal_moves))\n    board.pop()  # Undo the null move\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of isolated pawns on the board.\"\n    isolated_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_adjacent = [chess.square_file(square) - 1, chess.square_file(square) + 1]\n            if not any(board.piece_at(chess.square_rank(square) * 8 + f) for f in file_adjacent):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the advanced ranks between both players' pieces.\"\n    white_advanced_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced_ranks - black_advanced_ranks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 7th rank for each player and returns their difference.\"\n    white_pawns_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawns_7th - black_pawns_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the average ranks of the pieces for both players.\"\n    white_avg_rank = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE) / max(1, len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE]))\n    black_avg_rank = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK) / max(1, len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK]))\n    return float(white_avg_rank - black_avg_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pawns and returns the difference.\"\n    white_pawn_squares = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawn_squares = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawn_squares - black_pawn_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that can legally move into the opponent's half of the board.\"\n    white_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and any(move.to_square > 31 for move in board.legal_moves if move.from_square == sq))\n    black_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and any(move.to_square < 32 for move in board.legal_moves if move.from_square == sq))\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces, giving higher weight to each player's knights to assess tactical potential.\"\n    white_knight_count = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.KNIGHT)\n    black_knight_count = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.KNIGHT)\n    total_white = len(board.piece_map().keys())\n    total_black = len(board.piece_map().keys())\n    return float((white_knight_count + total_white) - (black_knight_count + total_black))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unique squares attacked by both players.\"\n    white_attacked = set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_attacked = set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(len(white_attacked) - len(black_attacked))", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of each player's pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_distance = sum(min(chess.square_distance(sq, csq) for csq in center_squares) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_distance = sum(min(chess.square_distance(sq, csq) for csq in center_squares) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of currently protected pieces for each player and returns their difference.\"\n    white_protected = sum(1 for sq in board.piece_map() if any(board.is_attacked_by(chess.BLACK, sq) for sq in board.attackers(chess.WHITE, sq)))\n    black_protected = sum(1 for sq in board.piece_map() if any(board.is_attacked_by(chess.WHITE, sq) for sq in board.attackers(chess.BLACK, sq)))\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are directly adjacent to the enemy king.\"\n    enemy_king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING and piece.color == (not board.turn):\n            enemy_king_square = square\n            break\n    if enemy_king_square is None:\n        return 0.0\n    adjacent_squares_count = sum(1 for sq in chess.SQUARES if chess.square_distance(sq, enemy_king_square) == 1)\n    return float(adjacent_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of piece types between both players.\"\n    piece_counts = {chess.WHITE: {}, chess.BLACK: {}}\n    for square, piece in board.piece_map().items():\n        p_type = piece.piece_type\n        color = piece.color\n        if p_type not in piece_counts[color]:\n            piece_counts[color][p_type] = 0\n        piece_counts[color][p_type] += 1\n    return float(sum(piece_counts[chess.WHITE].values()) - sum(piece_counts[chess.BLACK].values()))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the enemy king directly.\"\n    enemy_king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING and piece.color == (not board.turn):\n            enemy_king_square = square\n            break\n    if enemy_king_square is None:\n        return 0.0\n    attacking_count = sum(1 for move in board.legal_moves if move.to_square == enemy_king_square)\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected enemy pieces that can be captured on the next move.\"\n    unprotected_enemy_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == (not board.turn):\n            attackers = board.attackers(board.turn, square)\n            if not attackers:\n                unprotected_enemy_count += 1\n    return float(unprotected_enemy_count)", "def feature(board: chess.Board) -> float:\n    \"Sketches the player\u2019s initiative by counting pieces advanced beyond the 4th rank.\"\n    advanced_pieces_count = sum(1 for square, piece in board.piece_map().items() \n                                 if piece.color == board.turn and chess.square_rank(square) > 3)\n    return float(advanced_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of a player\u2019s pawns to the opponent's back rank.\"\n    distance_to_back_rank = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type == chess.PAWN:\n            distance_to_back_rank += 7 - chess.square_rank(square)\n    return float(distance_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the impact of aligned pieces in terms of pawn structure.\"\n    aligned_pawns = sum(1 for file in range(8) if board.piece_at(chess.square(1, file)) and \n                        board.piece_at(chess.square(2, file)))\n    return float(aligned_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of safe squares for the current player's pieces.\"\n    safe_squares_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Current player's pieces\n            is_safe = True\n            for target in board.legal_moves:\n                if target.from_square == square and board.is_attacked_by(not board.turn, target.to_square):\n                    is_safe = False\n                    break\n            if is_safe:\n                safe_squares_count += 1\n    return float(safe_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently threatening the opponent's king.\"\n    threat_count = 0\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, opponent_king_square):\n            threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by both players.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn or piece.color != board.turn:\n            controlled_squares.add(square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opposing pieces that are attacking blocks to the current player.\"\n    opposing_threat_count = 0\n    for square in range(64):\n        if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is None:\n            opposing_threat_count += 1\n    return float(opposing_threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that would make ideal placements for each player's pieces.\"\n    ideal_positions_count = 0\n    ideal_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square in ideal_squares:\n        if board.piece_at(square) is not None:\n            ideal_positions_count += 1\n    return float(ideal_positions_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of the current player's pieces by counting potential attacking moves.\"\n    mobility_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            mobility_count += len([move for move in board.legal_moves if move.from_square == square])\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces positioned in the opponent's half of the board.\"\n    opponent_half_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(square) > 3:\n            opponent_half_count += 1\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of safe squares that are not currently occupied by any piece.\"\n    safe_empty_squares = 0\n    for square in range(64):\n        if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is None:\n            safe_empty_squares += 1\n    return float(safe_empty_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces each side has advantage in terms of mobility.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.turn)\n    black_mobility = sum(1 for move in board.legal_moves if not board.turn)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the central squares (d4, d5, e4, e5) for both sides.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board that are pinned (unable to move without exposing the king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            if board.attackers(piece.color, square):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for both players; higher ranks indicate advancement.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_rank_sum - black_rank_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of available checks in the current position.\"\n    return float(len([move for move in board.legal_moves if board.gives_check(move)]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are attacked but not defended by any piece.\"\n    attacked_squares = {move.to_square for move in board.legal_moves}\n    defended_squares = {square for square in attacked_squares if board.is_attacked_by(board.turn, square)}\n    return float(len(attacked_squares) - len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for each side.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for both players, as it indicates promotion potential.\"\n    white_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall pawn structure by counting doubled pawns for both players.\"\n    doubled_pawns = 0\n    pawns_files = {file: 0 for file in range(8)}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawns_files[chess.square_file(square)] += 1\n            \n    doubled_pawns = sum(1 for count in pawns_files.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by the current player's pawns.\"\n    controlled_by_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            controlled_by_pawns += len(list(board.attackers(piece.color, square)))\n    return float(controlled_by_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of the number of pawns on the 7th rank to the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    pawns_on_seventh = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6)  # 7th rank is indexed by 6\n    return pawns_on_seventh / total_pawns if total_pawns > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the 2nd rank (for White) or 7th rank (for Black).\"\n    pieces_on_second_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 1 and board.piece_at(square).color == chess.WHITE)\n    pieces_on_seventh_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 6 and board.piece_at(square).color == chess.BLACK)\n    return pieces_on_second_rank - pieces_on_seventh_rank", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of open files for pawns (files where no pawns are present).\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces each player has controlling the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces with a potential to promote (pawns on the 7th rank).\"\n    promoting_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6 and board.piece_at(square).color == chess.WHITE)\n    return float(promoting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the current player's pieces to the opponent's back rank.\"\n    total_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of files occupied by pieces for each player.\"\n    occupied_files = len(set(chess.square_file(square) for square in board.piece_map()))\n    return float(occupied_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of connected pawns (adjacent pawns) for each side.\"\n    white_connected_pawns = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 1)).color == chess.WHITE and \n                                          ((file > 0 and board.piece_at(chess.square(file - 1, 1)) and board.piece_at(chess.square(file - 1, 1)).color == chess.WHITE) or \n                                           (file < 7 and board.piece_at(chess.square(file + 1, 1)) and board.piece_at(chess.square(file + 1, 1)).color == chess.WHITE)))\n    return float(white_connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of kings that are on their starting squares (original positions).\"\n    white_king_start = 1 if board.piece_at(chess.E1) and board.piece_at(chess.E1).color == chess.WHITE else 0\n    black_king_start = 1 if board.piece_at(chess.E8) and board.piece_at(chess.E8).color == chess.BLACK else 0\n    return float(white_king_start + black_king_start)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are in danger of being captured next turn (attacked but unprotected).\"\n    threatened_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and \n                            board.is_attacked_by(not board.turn, square) and\n                            not any(board.is_attacked_by(board.turn, att_square) for att_square in board.attackers(not board.turn, square)))\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are in an attacking position (have legal moves that can capture an opponent's piece).\"\n    attacking_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and any(board.is_attacked_by(not board.turn, move.to_square) for move in board.legal_moves))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces occupying their respective initial squares for both players.\"\n    initial_squares = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1,\n                       chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    white_initial = sum(1 for sq in initial_squares[:8] if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_initial = sum(1 for sq in initial_squares[8:] if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_initial - black_initial)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where both players have pieces present, indicating potential conflict.\"\n    occupied_squares = sum(1 for sq in chess.SQUARES if board.piece_at(sq) is not None)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the distance of all pawns from their respective promotion ranks.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are positioned on the 7th rank for both players, indicating pressure on the opponent's side.\"\n    white_on_seventh = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_on_seventh = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_on_seventh - black_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces supporting each player's pawns.\"\n    white_support = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    black_support = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(white_support - black_support)", "def feature(board: chess.Board) -> float:\n    \"Calculates the minimum distance from each player's pieces to their respective back ranks.\"\n    min_distance_white = min(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    min_distance_black = min(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(min_distance_white - min_distance_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces attacking each player's king.\"\n    white_attacks = sum(1 for sq in board.attackers(chess.WHITE, chess.parse_square('e1')))\n    black_attacks = sum(1 for sq in board.attackers(chess.BLACK, chess.parse_square('e8')))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent's pieces that are unprotected, based on current player.\"\n    unprotected_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.piece_at(sq).color, sq) is False and board.piece_at(sq).color != board.turn)\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in the number of undefended squares on the board for both players.\"\n    white_undefended = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq) and not board.is_attacked_by(chess.BLACK, sq))\n    black_undefended = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq) and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_undefended - black_undefended)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the sum of ranks of all pieces for both players.\"\n    rank_sum_white = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    rank_sum_black = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(rank_sum_white - rank_sum_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double-attack opportunities available on the board.\"\n    double_attack_count = sum(1 for sq in range(64) if len(board.attackers(chess.WHITE, sq)) > 1 or len(board.attackers(chess.BLACK, sq)) > 1)\n    return float(double_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of opposing pieces on squares that are of higher rank (closer to promotion) than your own pieces.\" \n    higher_ranked_squares = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) < chess.square_rank(sq))\n    return float(higher_ranked_squares)", "def feature(board: chess.Board) -> float:\n    \"Computes the distance of all pawns from their respective promotion squares.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                total_distance += chess.square_rank(square)  # distance to 8th rank\n            else:\n                total_distance += 7 - chess.square_rank(square)  # distance to 1st rank\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked but not defended by both sides.\"\n    attacked_not_defended = 0\n    all_squares = set(chess.SQUARES)\n    white_attacked = set()\n    black_attacked = set()\n    \n    for square in all_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            white_attacked.add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            black_attacked.add(square)\n    \n    only_white_attacked = white_attacked - black_attacked\n    only_black_attacked = black_attacked - white_attacked\n    \n    attacked_not_defended = len(only_white_attacked) + len(only_black_attacked)\n    \n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.add(square)\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces threatened by at least two enemy pieces.\"\n    threatened_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.WHITE, square):\n            threatened_count += 1\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board that can move to the opponent's territory.\"\n    moveable_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and chess.square_rank(move.to_square) > chess.square_rank(square):\n                    moveable_pieces += 1\n    return float(moveable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are defended by more than one piece.\"\n    defended_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(board.turn, square)\n            if len(attackers) > 1:\n                defended_count += 1\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by the current player.\"\n    attacked_squares = set()\n    for move in board.legal_moves:\n        attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total rank distance of pieces from the opponent's back rank.\"\n    total_rank_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            total_rank_distance += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n    return float(total_rank_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in play that are obstructing each other's movement.\"\n    obstructed_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for square_two in board.piece_map():\n                if square != square_two and piece.color == board.piece_map()[square_two].color:\n                    if chess.square_distance(square, square_two) == 1:\n                        obstructed_count += 1\n    return float(obstructed_count // 2)  # Each obstruction counted twice", "def feature(board: chess.Board) -> float:\n    \"Analyzes the total number of kingside pawns for each player.\"\n    kingside_pawn_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_file(square) > 3:\n                kingside_pawn_count[chess.WHITE] += 1\n            elif piece.color == chess.BLACK and chess.square_file(square) < 4:\n                kingside_pawn_count[chess.BLACK] += 1\n\n    return float(kingside_pawn_count[chess.WHITE] - kingside_pawn_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of connected pawns for the current player.\"\n    connected_pawn_count = 0\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn]\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        rank = chess.square_rank(pawn)\n        if (board.piece_at(chess.parse_square(chess.square_name(pawn).replace(str(rank), str(rank-1)))) and \n            board.piece_at(chess.parse_square(chess.square_name(pawn).replace(str(rank), str(rank+1))))):\n            connected_pawn_count += 1\n    return float(connected_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are attacking the same square for both players.\"\n    attacking_counts = {chess.WHITE: {}, chess.BLACK: {}}\n    for square in chess.SQUARES:\n        for attacker in board.attackers(chess.WHITE, square):\n            attacking_counts[chess.WHITE][square] = attacking_counts[chess.WHITE].get(square, 0) + 1\n        for attacker in board.attackers(chess.BLACK, square):\n            attacking_counts[chess.BLACK][square] = attacking_counts[chess.BLACK].get(square, 0) + 1\n    return float(sum(1 for square in chess.SQUARES if attacking_counts[chess.WHITE].get(square, 0) > 1 and attacking_counts[chess.BLACK].get(square, 0) > 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of vulnerable pieces (attacked but unprotected).\"\n    vulnerable_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square) and not any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(not board.turn, square)):\n                vulnerable_count += 1\n    return float(vulnerable_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces positioned on the opponent's 7th rank for White and 2nd rank for Black.\"\n    attacking_rank = 6 if board.turn == chess.WHITE else 1\n    attacking_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) == attacking_rank and piece.color == board.turn)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the maximum number of pieces that can potentially deliver check in the next move.\"\n    check_candidates = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_candidates += 1\n        board.pop()\n    return float(check_candidates)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that have both player's pieces present.\"\n    occupied_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pieces that are directly adjacent to opponent's king.\"\n    adjacent_squares = [chess.square_name(square) for square in chess.SQUARES if board.is_attacked_by(board.turn, square)]\n    adjacent_king = chess.square_name(board.king(not board.turn))\n    adjacent_count = sum(1 for square in adjacent_squares if chess.square_distance(chess.parse_square(square), chess.parse_square(adjacent_king)) == 1)\n    return float(adjacent_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between advanced ranks of pawns for both players.\"\n    white_advanced = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced - black_advanced)"]}