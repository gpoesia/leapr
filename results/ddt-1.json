{"used_features": ["def feature(board: chess.Board) -> float:\n    \"Returns the material balance favoring the color with more value\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    material_value = 0\n    for piece in board.piece_map().values():\n        material_value += piece_values.get(piece.piece_type, 0) * (1 if piece.color == chess.WHITE else -1)\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color'\n    white_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Count of queens for each color'\n    white_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN)\n    black_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN)\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    'Count of controlled squares by each side'\n    controlled_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of legal moves available for the side to move.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are unprotected'\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of controlled squares for each side'\n    controlled_squares = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK] += 1\n    return float(controlled_squares[chess.WHITE] - controlled_squares[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side'\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        for move in board.legal_moves:\n            if piece.color == chess.WHITE and move.from_square == square:\n                controlled_squares[chess.WHITE].add(move.to_square)\n            elif piece.color == chess.BLACK and move.from_square == square:\n                controlled_squares[chess.BLACK].add(move.to_square)\n    result = len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK])\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of distances of all pawns to their promotion ranks'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 7 if piece.color == chess.WHITE else 0\n            total_distance += chess.square_rank(square) - target_rank\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of pieces for each color and return the difference.'\n    values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of all pieces on the board for each color and return the difference'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are threatened by opponents'\n    threatened_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares threatened by opponents.\"\n    opponent_color = not board.turn\n    return float(sum(board.is_attacked_by(opponent_color, square) for square in chess.SQUARES))", "def feature(board: chess.Board) -> float:\n    'Count the number of attacks each color is making'\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Count the number of risks (unprotected pieces) for each color.\"\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    'Count threatened pieces for each color and return the difference'\n    threatened_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    threatened_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(threatened_white - threatened_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of threatened pieces for each color and return the difference'\n    white_threatened = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE)\n    black_threatened = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK)\n    return float(white_threatened - black_threatened)", "def feature(board: chess.Board) -> float:\n    'Count the number of protected pieces for each color and return the difference'\n    protected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE \n                          and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    protected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK \n                          and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(protected_white - protected_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each color.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculate the mobility by counting all legal moves per side'\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    'Count of pieces on the back rank for both sides'\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in range(0, 8):\n        for color in [chess.WHITE, chess.BLACK]:\n            if board.piece_at(chess.square(square, 0 if color == chess.WHITE else 7)) is not None:\n                back_rank_count[color] += 1\n    return float(back_rank_count[chess.WHITE] - back_rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by each color and return the difference\"\n    white_controlled = len(set(square for attack in range(0, 64) for square in board.attackers(chess.WHITE, attack)))\n    black_controlled = len(set(square for attack in range(0, 64) for square in board.attackers(chess.BLACK, attack)))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for each color'\n    unprotected = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if not any(board.is_attacked_by(piece.color, attacker_square) for attacker_square in board.attackers(not piece.color, square)):\n            unprotected[piece.color] += 1\n    return float(unprotected[chess.WHITE] - unprotected[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Calculate the total distance of pieces from the nearest back rank for each color'\n    def total_distance(color):\n        return sum(chess.square_rank(sq) if color == chess.WHITE else (7 - chess.square_rank(sq)) for sq in board.piece_map() if board.piece_map()[sq].color == color)\n\n    white_distance = total_distance(chess.WHITE)\n    black_distance = total_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total value of pieces for each color on the board.\"\n    values = {chess.WHITE: 0, chess.BLACK: 0}\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        values[piece.color] += piece_values[piece.piece_type]\n    return float(values[chess.WHITE] - values[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculate the total value of all pieces for each color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() \n                      if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() \n                      if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of the values of all pieces on the board for both colors.'\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of unprotected pieces for each color and return the difference.\"\n    def unprotected_count(color):\n        return sum(1 for sq, piece in board.piece_map().items() if piece.color == color and not board.is_attacked_by(not color, sq))\n    \n    white_unprotected = unprotected_count(chess.WHITE)\n    black_unprotected = unprotected_count(chess.BLACK)\n    return float(white_unprotected - black_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces in each player's back rank.\"\n    white_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board.'\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Identify the number of unprotected pieces for the player to move.\"\n    def is_unprotected(piece_square):\n        piece = board.piece_at(piece_square)\n        return piece and not any(board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, piece_square))\n\n    return float(sum(1 for square in board.piece_map() if is_unprotected(square)))", "def feature(board: chess.Board) -> float:\n    \"Count the total piece value for both sides.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board.'\n    result = len(board.piece_map())\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Calculate the total distance of all pieces to the back rank for each color.'\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Calculate the total distance of all pieces to the back rank for each color.'\n    total_distance = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        total_distance[piece.color] += distance\n    return float(total_distance[chess.WHITE] - total_distance[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculate the sum of distances of all pawns to their promotion ranks.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pawns for each color.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count the total distance of pieces from the nearest back rank for each color.'\n    total_distance_white = sum(chess.square_distance(square, chess.A1) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    total_distance_black = sum(chess.square_distance(square, chess.A8) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(total_distance_white - total_distance_black)"], "all_features": ["def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces each player has on the board\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Returns the material balance favoring the color with more value\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    material_value = 0\n    for piece in board.piece_map().values():\n        material_value += piece_values.get(piece.piece_type, 0) * (1 if piece.color == chess.WHITE else -1)\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Returns the number of squares controlled by the player to move\"\n    color = board.turn\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces attacking the opponent's king\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != color:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attackers = board.attackers(color, opponent_king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Returns 1.0 if the current player is in check, otherwise 0.0\"\n    return float(board.is_check())", "def feature(board: chess.Board) -> float:\n    \"Returns 1.0 if the move number is less than 25, otherwise 0.0\"\n    return float(1.0 if board.fullmove_number < 25 else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Returns the distance of the king to the center of the board\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n    distance_to_center = chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.D4)\n    return float(16 - distance_to_center)  # Closer to center gives higher value", "def feature(board: chess.Board) -> float:\n    \"Returns the number of isolated pawns for the current player's pawns\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    isolated_pawn_count = 0\n    for square in range(8):\n        pawn_square = chess.parse_square(f'{chr(97 + square)}3' if color == chess.WHITE else f'{chr(97 + square)}6')\n        if board.piece_at(pawn_square) and board.piece_at(pawn_square).piece_type == chess.PAWN and board.piece_at(pawn_square).color == color:\n            left_adjacent = board.piece_at(pawn_square - 1) if chess.square_file(pawn_square) > 0 else None\n            right_adjacent = board.piece_at(pawn_square + 1) if chess.square_file(pawn_square) < 7 else None\n            if (left_adjacent is None or left_adjacent.color != color) and (right_adjacent is None or right_adjacent.color != color):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Returns the halfmove clock value\"\n    return float(board.halfmove_clock)", "def feature(board: chess.Board) -> float:\n    \"Returns 1.0 if the game is insufficient material, otherwise 0.0\"\n    return float(1.0 if board.is_insufficient_material() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Evaluate material balance for each color'\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color'\n    white_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the mobility of the current player based on legal moves'\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    'Check if the current player is in checkmate'\n    return float(board.is_checkmate())", "def feature(board: chess.Board) -> float:\n    'Evaluate the number of pawns for each color'\n    white_pawns = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN])\n    black_pawns = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Evaluate the number of pieces attacked by the current player'\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    'Determine the distance of kings to each other'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    'Check if there is insufficient material for a draw'\n    return float(board.is_insufficient_material())", "def feature(board: chess.Board) -> float:\n    'Sum of the values of all pieces on the board for each color'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count of queens for each color'\n    white_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN)\n    black_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN)\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    'Count of rooks for each color'\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    'Distance of the kings from each other'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    'Count of attacking pieces for the player to move'\n    color = chess.WHITE if board.turn else chess.BLACK\n    attackers_count = sum(1 for square in board.piece_map() if board.is_attacked_by(color, square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    'Presence of check for the player to move'\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Checkmate status for the player to move'\n    return float(1.0 if board.is_checkmate() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Stalemate status for the player to move'\n    return float(1.0 if board.is_stalemate() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Count of pawns for each color'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count of pieces for each color'\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    'Sum of the piece values for both sides'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count of pieces for each color'\n    return float(len([p for p in board.piece_map().values() if p.color == chess.WHITE]) -\n                 len([p for p in board.piece_map().values() if p.color == chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    'Difference in the number of queens for each side'\n    white_queens = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.QUEEN)\n    black_queens = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.QUEEN)\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    'Number of attacking pieces for the color to move'\n    color = chess.WHITE if board.turn else chess.BLACK\n    return float(len([p for sq in board.legal_moves if board.is_attacked_by(color, sq.from_square)\n                      for p in board.attackers(color, sq.from_square)]))", "def feature(board: chess.Board) -> float:\n    'Count of controlled squares by each side'\n    controlled_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    'Check if the current turn player is in check'\n    return float(board.is_check())", "def feature(board: chess.Board) -> float:\n    'Check if the current turn player is in checkmate'\n    return float(board.is_checkmate())", "def feature(board: chess.Board) -> float:\n    'Check if the current position is stalemate'\n    return float(board.is_stalemate())", "def feature(board: chess.Board) -> float:\n    'Count of pawns for each side'\n    white_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN)\n    black_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pawns on the board.\"\n    pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces for the side to move.\"\n    color = board.turn\n    pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == color)\n    return float(pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the material value of pieces for the side to move.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                       chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    color = board.turn\n    total_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == color)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by each color.\"\n    color = board.turn\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(color, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Check if the current player is in check.\"\n    in_check = board.is_check()\n    return float(in_check)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the number of queens for each color.\"\n    queens_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.QUEEN)\n    return float(queens_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of legal moves available for the side to move.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Check for stalemate condition.\"\n    is_stalemate = board.is_stalemate()\n    return float(is_stalemate)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the number of vulnerable pieces (attacked but not defended).\"\n    vulnerable_count = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and board.is_attacked_by(not board.turn, square) and \n                           not any(board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(not board.turn, square)))\n    return float(vulnerable_count)", "def feature(board: chess.Board) -> float:\n    'Count the total number of non-pawn pieces for each color'\n    total_non_pawn = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(total_non_pawn)", "def feature(board: chess.Board) -> float:\n    'Calculate the difference in the number of major pieces (rook and queen) for each color'\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.QUEEN, chess.ROOK})\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.QUEEN, chess.ROOK})\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    'Sum the values of all pieces on the board ignoring pawns'\n    piece_values = {chess.KING: 0, chess.QUEEN: 9, chess.ROOK: 5, chess.BISHOP: 3, chess.KNIGHT: 3, chess.PAWN: 1}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are unprotected'\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the mobility by counting the possible moves for the side to move'\n    move_count = len(list(board.legal_moves))\n    return float(move_count)", "def feature(board: chess.Board) -> float:\n    'Check for king safety by counting move away from check'\n    if board.is_check():\n        return 0.0\n    return 1.0", "def feature(board: chess.Board) -> float:\n    'Evaluate the pawn structure by counting isolated pawns'\n    isolated_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and not board.piece_at(chess.square(file - 1, chess.square_rank(square))) or \n                file < 7 and not board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    'Counts total material value of all pieces on the board'\n    material_value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        material_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    'Counts number of pieces for each color'\n    piece_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        piece_count[piece.color] += 1\n    return float(piece_count[chess.WHITE] - piece_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Counts number of queens for each color'\n    queen_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.QUEEN:\n            queen_count[piece.color] += 1\n    return float(queen_count[chess.WHITE] - queen_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Calculates the number of controlled squares for each side'\n    controlled_squares = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK] += 1\n    return float(controlled_squares[chess.WHITE] - controlled_squares[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Counts the number of legal moves available for the side to move'\n    legal_moves = list(board.legal_moves)\n    return float(len(legal_moves))", "def feature(board: chess.Board) -> float:\n    'Calculates the king safety score based on board position'\n    king_safety = 0\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attackers = board.attackers(not board.turn, king_square)\n    king_safety += len(attackers) * -100  # Arbitrary penalty per attacker\n    return float(king_safety)", "def feature(board: chess.Board) -> float:\n    'Assesses pawn structure by counting isolated and doubled pawns'\n    pawn_structure_score = 0\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    files = [0] * 8\n    for pawn in pawns:\n        files[chess.square_file(pawn)] += 1\n    pawn_structure_score -= sum(1 for count in files if count > 1)  # Penalty for doubled pawns\n    pawn_structure_score += sum(1 for count in files if count == 0)  # Bonus for isolated pawns\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    'Evaluates piece activity based on number of pieces developed'\n    active_pieces = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            active_pieces += 1  # Count pieces that can move\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    'Evaluates passed pawns for the current player'\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            if all(board.piece_at(chess.parse_square(chess.square_name(f + 8 * (1 - 2 * int(board.turn))))) is None for f in range(file)):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pawns for each color'\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    result = white_pawns - black_pawns\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color'\n    result = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE) - sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side'\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        for move in board.legal_moves:\n            if piece.color == chess.WHITE and move.from_square == square:\n                controlled_squares[chess.WHITE].add(move.to_square)\n            elif piece.color == chess.BLACK and move.from_square == square:\n                controlled_squares[chess.BLACK].add(move.to_square)\n    result = len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK])\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move'\n    result = len(list(board.legal_moves))\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for the side to move'\n    color = chess.WHITE if board.turn else chess.BLACK\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == color and not board.is_attacked_by(not color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the difference in material value based on piece types'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = total_white - total_black\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Check if the current player is in check'\n    result = float(1.0 if board.is_check() else 0.0)\n    return result", "def feature(board: chess.Board) -> float:\n    'Calculate the number of squares attacked by the side to move'\n    attacking_squares = set()\n    color = chess.WHITE if board.turn else chess.BLACK\n    for square in board.piece_map():\n        if board.piece_at(square).color == color:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacking_squares.add(move.to_square)\n    result = len(attacking_squares)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Check for checkmate condition for the current player'\n    result = float(-1.0 if board.is_checkmate() else 0.0)\n    return result", "def feature(board: chess.Board) -> float:\n    'Determine if the game is a stalemate'\n    result = float(1.0 if board.is_stalemate() else 0.0)\n    return result", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board'\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    'Calculate the total material value for both sides'\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of protected pieces for the side to move'\n    color = board.turn\n    protected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            attackers = board.attackers(not color, square)\n            if not attackers:\n                protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of squares attacked by the side to move'\n    color = board.turn\n    attacked_squares = set()\n    for square in board.piece_map():\n        if board.piece_map()[square].color == color:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each side'\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count the number of discovered checks that can be made by each side'\n    discovered_checks = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if board.is_check():\n                        discovered_checks += 1\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of distances of all pawns to their promotion ranks'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 7 if piece.color == chess.WHITE else 0\n            total_distance += chess.square_rank(square) - target_rank\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Count the number of pinned pieces for the side to move'\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side'\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE:\n            controlled_squares[chess.WHITE].update(board.attackers(chess.BLACK, square))\n        else:\n            controlled_squares[chess.BLACK].update(board.attackers(chess.WHITE, square))\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of pieces for each color and return the difference.'\n    values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color and return the difference.'\n    white_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of queens for each color and return the difference.'\n    white_queens = len([square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN])\n    black_queens = len([square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN])\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of controlled squares by each side and return the difference.'\n    def controlled_squares(color):\n        return len([square for square in chess.SQUARES if board.is_attacked_by(color, square)])\n    \n    white_control = controlled_squares(chess.WHITE)\n    black_control = controlled_squares(chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of legal moves for the side to move.'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for the side to move.'\n    color = chess.WHITE if board.turn else chess.BLACK\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == color and not board.attackers(not color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side and return the difference.'\n    white_controlled = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_controlled = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of distances of all pawns to their promotion ranks for each color.'\n    def sum_pawn_distances(color):\n        distance = 0\n        rank = 7 if color == chess.WHITE else 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                distance += chess.square_rank(square) - rank\n        return distance\n    \n    white_distance = sum_pawn_distances(chess.WHITE)\n    black_distance = sum_pawn_distances(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces for each color and return the difference'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of all pieces on the board for each color and return the difference'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by the side to move'\n    attacking_squares = set()\n    for move in board.legal_moves:\n        attacking_squares.add(move.to_square)\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for the side to move'\n    color = board.turn\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            if not board.is_attacked_by(not color, square):\n                unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Count the difference in the number of queens for each color'\n    white_queen_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN)\n    black_queen_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN)\n    return float(white_queen_count - black_queen_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of distances of all pawns to their promotion ranks'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                total_distance += chess.square_rank(square)\n            else:\n                total_distance += 7 - chess.square_rank(square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of squares attacked by each side and return the difference'\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Check if the position is a checkmate for the side to move'\n    return float(1.0 if board.is_checkmate() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Check if the position is a stalemate for the side to move'\n    return float(1.0 if board.is_stalemate() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces for each color and return the difference'\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the total piece value for each color based on standard values'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are threatened by opponents'\n    threatened_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for the side to move'\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not board.turn, square))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    'Count pieces that are on central squares (d4, e4, d5, e5)'\n    central_squares = {chess.D4, chess.E4, chess.D5, chess.E5}\n    central_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the average distance of all remaining pieces to their promotion ranks'\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 7 if piece.color == chess.WHITE else 0\n            total_distance += chess.square_rank(square) - target_rank\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move'\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    'Check if the current position is a check for the side to move'\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    'Evaluate if the position is a stalemate'\n    return float(1.0 if board.is_stalemate() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces for each color and return the difference.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total material value for each color and return the difference.\"\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of legal moves available for the side to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by pieces for each color.\"\n    control_map = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in range(64):\n        for move in board.legal_moves:\n            if move.from_square == square:\n                control_map[board.color_at(square)].add(move.to_square)\n                \n    return float(len(control_map[chess.WHITE]) - len(control_map[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares threatened by opponents.\"\n    opponent_color = not board.turn\n    return float(sum(board.is_attacked_by(opponent_color, square) for square in chess.SQUARES))", "def feature(board: chess.Board) -> float:\n    \"Calculate the sum of distances of all pawns to their promotion ranks.\"\n    total_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces that are out of play (inactive).\"\n    inactive_count = sum(1 for piece in board.piece_map().values() if not any(board.is_attacked_by(piece.color, sq) for sq in chess.SQUARES))\n    return float(inactive_count)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board'\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of pieces for each color'\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of attacks each color is making'\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each color'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count how many squares are controlled by each color'\n    controlled_squares_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_squares_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are pinned'\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of legal moves available for the side to move'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Count the number of squares attacked by both sides'\n    white_attacked_squares = set(sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacked_squares = set(sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(len(white_attacked_squares | black_attacked_squares))  # Union of both sets", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that can be captured in one move'\n    capturable_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(capturable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of pawns for each color.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by each color.\"\n    controlled_squares_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_squares_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Count the total value of pieces for both colors.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculate the distance of all pieces from their home ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        rank_distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        total_distance += rank_distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of risks (unprotected pieces) for each color.\"\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of legal moves available for the side to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces in the endgame (with more than 4 pawns for either side).\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float((white_pawns > 4) - (black_pawns > 4))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares attacked by both colors.\"\n    attacked_squares_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    attacked_squares_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color and return the difference'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the total material value for each color and return the difference'\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each color'\n    def controlled_squares(color):\n        controlled = set()\n        for piece in board.piece_map().values():\n            if piece.color == color:\n                controlled.update(board.legal_moves)\n        return len(controlled)\n\n    white_control = controlled_squares(chess.WHITE)\n    black_control = controlled_squares(chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Count threatened pieces for each color and return the difference'\n    threatened_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    threatened_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(threatened_white - threatened_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are unprotected'\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if not board.attackers(piece.color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of queens for each color and return the difference'\n    white_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN)\n    black_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN)\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    'Compute the sum of distances of all pawns to their promotion ranks'\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            total_distance += distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Count the number of attacks each color is making'\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Calculate the total number of squares threatened by opponents'\n    white_threatened = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_threatened = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_threatened - black_threatened)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces of each color and return the difference'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of all pieces on the board for each color'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side and return the difference'\n    white_controlled = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_controlled = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    'Count the number of threatened pieces for each color and return the difference'\n    white_threatened = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE)\n    black_threatened = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK)\n    return float(white_threatened - black_threatened)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are unprotected'\n    unprotected_count = 0\n    for sq, piece in board.piece_map().items():\n        if not board.is_attacked_by(piece.color, sq):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the total number of squares that each side is threatening'\n    white_threatened_squares = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    black_threatened_squares = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(white_threatened_squares - black_threatened_squares)", "def feature(board: chess.Board) -> float:\n    'Count the number of control points for each color (each square controlled)'\n    white_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    black_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Calculate the distance of all pawns to their promotion ranks and return as a sum'\n    total_distance = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank_distance = 7 - chess.square_rank(sq) if piece.color == chess.WHITE else chess.square_rank(sq)\n            total_distance += rank_distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Count the number of checks each color is giving and returning the difference'\n    white_checks = int(board.is_check() and board.turn)\n    black_checks = int(board.is_check() and not board.turn)\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for both sides and return the difference'\n    white_count = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_count = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Calculate the number of checks on the opponent\u2019s king'\n    checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    'Count the number of protected pieces for each color and return the difference'\n    protected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE \n                          and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    protected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK \n                          and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(protected_white - protected_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for each color and return the difference'\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE \n                            and not any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK \n                            and not any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    'Sum the square value for each piece on the board based on common piece square tables'\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(value)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares attacked by each color and return the difference'\n    attacked_white = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq))\n    attacked_black = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq))\n    return float(attacked_white - attacked_black)", "def feature(board: chess.Board) -> float:\n    'Calculate the distance of all pawns to their promotion ranks summed up'\n    WHITE_PROMOTION_RANK = 7\n    BLACK_PROMOTION_RANK = 0\n    distance = sum(WHITE_PROMOTION_RANK - chess.square_rank(square) \n                   for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    distance += sum(chess.square_rank(square) - BLACK_PROMOTION_RANK \n                    for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of favorable positions for the kings'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are attacking the opponent\u2019s king'\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    attacking_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and board.is_attacked_by(piece.color, opponent_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board.'\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each color.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Check if a king is in check.'\n    return float(board.is_check())", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces each side has attacking opponent pieces.'\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of squares controlled by each color.'\n    controlled_squares_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    'Count the legal moves for the side to move.'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Calculate the distance of all pawns to their promotion ranks.'\n    pawn_distance = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                pawn_distance += (7 - chess.square_rank(square))\n            else:\n                pawn_distance += chess.square_rank(square)\n    return float(pawn_distance)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are currently unprotected.'\n    unprotected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if not board.attackers(piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the difference in material value between both sides.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    value_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    value_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(value_white - value_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces in the center of the board.'\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square))\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each color and return the difference'\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count the number of knights for each color and return the difference'\n    white_knights = len([p for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.WHITE])\n    black_knights = len([p for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.BLACK])\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each color'\n    controlled_squares_white = len(set([move.to_square for move in board.legal_moves if board.turn]))\n    controlled_squares_black = len(set([move.to_square for move in board.legal_moves if not board.turn]))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces excluding pawns for each color'\n    piece_types = {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING}\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in piece_types])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in piece_types])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of piece threats for each color'\n    threats_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    threats_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(threats_white - threats_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for each side'\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares attacked by both sides'\n    attacked_squares_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    attacked_squares_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    'Calculate the mobility by counting all legal moves per side'\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    'Calculate the distance of all pieces from their starting position'\n    distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance += chess.square_distance(square, chess.parse_square(chess.square_name(square)))\n        else:\n            distance += chess.square_distance(square, chess.parse_square(chess.square_name(square)))\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    'Calculate the difference in the number of queens for both sides'\n    queens_white = len([p for p in board.piece_map().values() if p.piece_type == chess.QUEEN and p.color == chess.WHITE])\n    queens_black = len([p for p in board.piece_map().values() if p.piece_type == chess.QUEEN and p.color == chess.BLACK])\n    return float(queens_white - queens_black)", "def feature(board: chess.Board) -> float:\n    'Total material value for both sides'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return total_value", "def feature(board: chess.Board) -> float:\n    'Count of knights for each color'\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    return float(knight_count)", "def feature(board: chess.Board) -> float:\n    'Total number of attacked squares for the current player'\n    color = board.turn\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(color, square))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    'Count of opposing pieces for each color'\n    opponent_color = not board.turn\n    opposing_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == opponent_color)\n    return float(opposing_piece_count)", "def feature(board: chess.Board) -> float:\n    'Number of legal moves available for the current position'\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    'Count of doubled pawns for each color'\n    pawn_positions = {chess.WHITE: set(), chess.BLACK: set()}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_positions[piece.color].add(file)\n    doubled_pawns = sum(len(set) > 1 for set in pawn_positions.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    'Distance from kings to the center for both colors'\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    king_distances = []\n    for king_color in [chess.WHITE, chess.BLACK]:\n        king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == king_color), None)\n        if king_square is not None:\n            distance = min(chess.square_distance(king_square, center_square) for center_square in center_squares)\n            king_distances.append(distance)\n    return float(king_distances[0] - king_distances[1]) if len(king_distances) == 2 else 0.0", "def feature(board: chess.Board) -> float:\n    'Count of pieces on the back rank for both sides'\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in range(0, 8):\n        for color in [chess.WHITE, chess.BLACK]:\n            if board.piece_at(chess.square(square, 0 if color == chess.WHITE else 7)) is not None:\n                back_rank_count[color] += 1\n    return float(back_rank_count[chess.WHITE] - back_rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count of central control, pieces on d4, d5, e4, e5'\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    central_control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of rooks for each color and return the difference\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces in the back rank for each color and return the difference\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) is not None and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) is not None and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by each color and return the difference\"\n    white_controlled = len(set(square for attack in range(0, 64) for square in board.attackers(chess.WHITE, attack)))\n    black_controlled = len(set(square for attack in range(0, 64) for square in board.attackers(chess.BLACK, attack)))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the pawn structure and return a score based on holes\"\n    def count_holes(color):\n        holes = 0\n        for file in range(8):\n            if color == chess.WHITE:\n                if board.piece_at(chess.square(0, file)) is None and (board.piece_at(chess.square(1, file)) is None or board.piece_at(chess.square(1, file)).piece_type == chess.PAWN):\n                    holes += 1\n            else:\n                if board.piece_at(chess.square(7, file)) is None and (board.piece_at(chess.square(6, file)) is None or board.piece_at(chess.square(6, file)).piece_type == chess.PAWN):\n                    holes += 1\n        return holes\n\n    white_holes = count_holes(chess.WHITE)\n    black_holes = count_holes(chess.BLACK)\n    return float(white_holes - black_holes)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color and return the difference'\n    material_balance = sum(1 if piece.color == chess.WHITE else -1 for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of squares controlled by each side'\n    controlled_squares = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK] += 1\n    return float(controlled_squares[chess.WHITE] - controlled_squares[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of queens for each color'\n    queens = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.QUEEN:\n            queens[piece.color] += 1\n    return float(queens[chess.WHITE] - queens[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each color'\n    pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            pawns[piece.color] += 1\n    return float(pawns[chess.WHITE] - pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for each color'\n    unprotected = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if not any(board.is_attacked_by(piece.color, attacker_square) for attacker_square in board.attackers(not piece.color, square)):\n            unprotected[piece.color] += 1\n    return float(unprotected[chess.WHITE] - unprotected[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of distances of all pawns to their promotion ranks'\n    pawn_promotions = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank_distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square) - 0\n            pawn_promotions[piece.color] += rank_distance\n    return float(pawn_promotions[chess.WHITE] - pawn_promotions[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move.'\n    legal_moves = len(list(board.legal_moves))\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares threatened by opponents'\n    threatened_squares = set()\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            for square in board.legal_moves:\n                if board.is_attacked_by(not piece.color, square.to_square):\n                    threatened_squares.add(square.to_square)\n    return float(len(threatened_squares))", "def feature(board: chess.Board) -> float:\n    'Count the number of attacks each color is making'\n    attacks = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            attacks[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            attacks[chess.BLACK] += 1\n    return float(attacks[chess.WHITE] - attacks[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count threatened pieces for each color and return the difference'\n    threatened_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            threatened_pieces[piece.color] += 1\n    return float(threatened_pieces[chess.WHITE] - threatened_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each side and return the difference'\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of isolated pawns for each color'\n    def is_isolated(sq, color):\n        file = chess.square_file(sq)\n        return (board.piece_at(sq) == chess.PAWN and\n                (file == 0 or board.piece_at(chess.square(sq // 8, file - 1)) is None) and\n                (file == 7 or board.piece_at(chess.square(sq // 8, file + 1)) is None))\n\n    white_isolated = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and is_isolated(sq, chess.WHITE))\n    black_isolated = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and is_isolated(sq, chess.BLACK))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    'Count how many squares each color\u2019s pieces control'\n    white_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Calculate the total distance of pieces from the nearest back rank for each color'\n    def total_distance(color):\n        return sum(chess.square_rank(sq) if color == chess.WHITE else (7 - chess.square_rank(sq)) for sq in board.piece_map() if board.piece_map()[sq].color == color)\n\n    white_distance = total_distance(chess.WHITE)\n    black_distance = total_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for each side'\n    def count_unprotected(color):\n        unprotected = 0\n        for sq in board.piece_map():\n            piece = board.piece_map()[sq]\n            if piece.color == color and not board.attackers(not color, sq):\n                unprotected += 1\n        return unprotected\n\n    white_unprotected = count_unprotected(chess.WHITE)\n    black_unprotected = count_unprotected(chess.BLACK)\n    return float(white_unprotected - black_unprotected)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of all pieces on the board for each color and return the difference'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    \n    def total_value(color):\n        return sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == color)\n\n    white_value = total_value(chess.WHITE)\n    black_value = total_value(chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculate the difference in the number of pieces for each color.\"\n    pieces_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        pieces_count[piece.color] += 1\n    return float(pieces_count[chess.WHITE] - pieces_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces that are in the back rank for both sides.\"\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) == 7:\n            back_rank_count[chess.WHITE] += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) == 0:\n            back_rank_count[chess.BLACK] += 1\n    return float(back_rank_count[chess.WHITE] - back_rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the total number of squares controlled by both sides.\"\n    control_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_count[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control_count[chess.BLACK] += 1\n    return float(control_count[chess.WHITE] - control_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the number of protected pieces for each color.\"\n    protected = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            continue\n        for attacking_square in board.attackers(not piece.color, square):\n            if board.piece_at(attacking_square):\n                protected[piece.color] += 1\n                break\n    return float(protected[chess.WHITE] - protected[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the number of legal moves available for the color to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculate the total value of pieces for each color on the board.\"\n    values = {chess.WHITE: 0, chess.BLACK: 0}\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        values[piece.color] += piece_values[piece.piece_type]\n    return float(values[chess.WHITE] - values[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces with no legal moves.\"\n    no_move_count = sum(1 for piece in board.piece_map().values() if not list(board.legal_moves))\n    return float(no_move_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total value of all pieces for each color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() \n                      if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() \n                      if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of different types of pieces on the board.\"\n    piece_types = {piece.piece_type for piece in board.piece_map().values()}\n    return float(len(piece_types))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by the side to move.\"\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Count the number of unprotected pieces for the side to move.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() \n                            if piece.color == board.turn and \n                            not board.attackers(not board.turn, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of potential threats (pieces attacking) each color has.\"\n    threat_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of legal moves available for the side to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares attacked by each color.\"\n    attacked_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square):\n            attacked_squares.add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            attacked_squares.add(square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for both sides to assess material balance.'\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the difference in the number of pawns for each color.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count the number of knights for both sides.'\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side.'\n    control_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    'Sum the distances of all pawns to their promotion rank.'\n    pawn_distances = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_distances)", "def feature(board: chess.Board) -> float:\n    'Calculate the total piece mobility for each side by counting legal moves.'\n    white_mobility = sum(1 for move in board.legal_moves if board.turn == chess.WHITE and move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if board.turn == chess.BLACK and move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are double-attacked by opponents.'\n    double_attacked = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and len(board.attackers(not board.turn, square)) >= 2:\n            double_attacked += 1\n    return float(double_attacked)", "def feature(board: chess.Board) -> float:\n    'Count the number of protected pieces for each color.'\n    protected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    protected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(protected_white - protected_black)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of the values of all pieces on the board for both colors.'\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces for each color and return the difference.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total value of pieces for each color and return the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of legal moves for the side to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Count the number of pawns for each color and return the difference.\"\n    white_pawns = len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN])\n    black_pawns = len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by each color and return the difference.\"\n    def controlled_squares(color):\n        return sum(board.is_attacked_by(color, sq) for sq in chess.SQUARES)\n\n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Count the number of unprotected pieces for each color and return the difference.\"\n    def unprotected_count(color):\n        return sum(1 for sq, piece in board.piece_map().items() if piece.color == color and not board.is_attacked_by(not color, sq))\n    \n    white_unprotected = unprotected_count(chess.WHITE)\n    black_unprotected = unprotected_count(chess.BLACK)\n    return float(white_unprotected - black_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares threatened by opponents.\"\n    threatened_squares = set(sq for sq in chess.SQUARES for attacker in board.attackers(chess.WHITE, sq) if attacker)\n    return float(len(threatened_squares))", "def feature(board: chess.Board) -> float:\n    \"Count the number of back rank pieces for both sides.\"\n    def back_rank_pieces(color):\n        return sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == color)\n\n    white_back_rank = back_rank_pieces(chess.WHITE)\n    black_back_rank = back_rank_pieces(chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculate the sum of distances of all pawns to their promotion ranks.\"\n    def total_pawn_distance(color):\n        pawns = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == color]\n        return sum(7 - chess.square_rank(sq) if color == chess.WHITE else chess.square_rank(sq) for sq in pawns)\n\n    return float(total_pawn_distance(chess.WHITE) - total_pawn_distance(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Count the number of queens for each color and return the difference.\"\n    white_queens = len([1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN])\n    black_queens = len([1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN])\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    \"Count and return the total number of pieces for each color.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of squares under attack by each color.\"\n    white_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces in each player's back rank.\"\n    white_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculate the sum of values of pieces for each color.\"\n    values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King has no value in material but is critical\n    }\n    white_value = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of legal moves for the side to move.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of unprotected pieces for each color.\"\n    white_unprotected = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and not board.attackers(chess.BLACK, sq))\n    black_unprotected = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and not board.attackers(chess.WHITE, sq))\n    return float(white_unprotected - black_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Calculate the mobility by summing all legal moves per side.\"\n    white_mobility = len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the threats made by each color's pieces.\"\n    white_threats = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    black_threats = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total distance of all pieces to their respective back ranks.\"\n    total_distance = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(sq)\n        else:\n            total_distance += 7 - chess.square_rank(sq)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board.'\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    'Calculate the difference in material value of both colors.'\n    material_value = sum(piece.piece_type for piece in board.piece_map().values())\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces in the back rank for each color.'\n    back_rank_pieces = sum(1 for square, piece in board.piece_map().items() \n                            if (piece.color == chess.WHITE and piece.piece_type != chess.KING and chess.square_rank(square) == 7) or\n                               (piece.color == chess.BLACK and piece.piece_type != chess.KING and chess.square_rank(square) == 0))\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the distance of each king from its back rank.'\n    white_king_square = next(square for square in board.piece_map() \n                              if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() \n                              if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_distance = 7 - chess.square_rank(white_king_square)\n    black_distance = chess.square_rank(black_king_square)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Count the total number of squares attacked by each color.'\n    white_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side.'\n    controlled_count = sum(1 for square in chess.SQUARES \n                           if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of moves available for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Sum the piece values for each color and return the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of protected pieces for the player to move.\"\n    def is_protected(piece_square):\n        piece = board.piece_at(piece_square)\n        return piece and any(board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, piece_square))\n\n    return float(sum(1 for square in board.piece_map() if is_protected(square)))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by the player to move.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares.update(board.legal_moves)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces in the back rank for the player to move.\"\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    return float(len([piece for square, piece in board.piece_map().items() if chess.square_rank(square) == back_rank and piece.color == board.turn]))", "def feature(board: chess.Board) -> float:\n    \"Identify the number of unprotected pieces for the player to move.\"\n    def is_unprotected(piece_square):\n        piece = board.piece_at(piece_square)\n        return piece and not any(board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, piece_square))\n\n    return float(sum(1 for square in board.piece_map() if is_unprotected(square)))", "def feature(board: chess.Board) -> float:\n    \"Calculate the total distance of all pawns to their promotion ranks.\"\n    total_distance = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            distance = 7 - rank if piece.color == chess.WHITE else rank\n            total_distance += distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of threatened pieces for the player to move.\"\n    threatened_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                threatened_pieces += 1\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the number of attacks each color is making.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Count the number of protected squares for each side.\"\n    protected_squares_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq) is None)\n    protected_squares_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq) is None)\n    return float(protected_squares_white - protected_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Count the total piece value for both sides.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of squares attacked by both sides.\"\n    attacked_squares_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    attacked_squares_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces in the back ranks for both sides.\"\n    back_rank_white = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculate the distance of kings from their corners.\"\n    king_white = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    king_black = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    distance_white = chess.square_distance(king_white, chess.A1) if king_white is not None else float('inf')\n    distance_black = chess.square_distance(king_black, chess.H8) if king_black is not None else float('inf')\n    return float(distance_white - distance_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of unprotected pieces for the player to move.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    unprotected_count = sum(1 for sq, piece in board.piece_map().items() if piece.color == color and len(board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, sq)) == 0)\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces of each type for the side to move.\"\n    piece_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for piece in board.piece_map().values():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            piece_count[piece.piece_type] += 1\n    return float(sum(piece_count.values()))", "def feature(board: chess.Board) -> float:\n    \"Count the ratio of pawns to total pieces for the side to move.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    pawns = sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type == chess.PAWN)\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == color)\n    return float(pawns / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculate the total mobility by counting the legal moves available for both sides.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn else 0\n    legal_moves_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Count the number of isolated pawns for the side to move.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    isolated_pawn_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == color and piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if (board.piece_at(chess.parse_square(chess.square_name(sq).replace('2', '3'))) is None and\n                board.piece_at(chess.parse_square(chess.square_name(sq).replace('2', '1'))) is None):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns on the board.'\n    result = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces on the board.'\n    result = len(board.piece_map())\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Calculate the number of pieces in the back rank for the player to move.'\n    rank = 0 if board.turn == chess.WHITE else 7\n    result = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) == rank)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move.'\n    result = len(list(board.legal_moves))\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by the player to move.'\n    controlled_squares = set()\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares |= set(board.attackers(not board.turn, square))\n    result = len(controlled_squares)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of pieces for the color to move.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    result = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Calculate the total value of pieces for the opponent.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    result = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces currently attacked by opponents.'\n    attacked_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(attacked_pieces)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for the player to move.'\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.is_attacked_by(not board.turn, square) and piece.piece_type != chess.KING)\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculate the sum of distances of all pawns to their promotion ranks.'\n    pawn_distances = sum(chess.square_rank(pawn_square) if piece.color == chess.WHITE else 7 - chess.square_rank(pawn_square)\n                         for pawn_square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_distances)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color and return the difference.'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of back rank pieces for each side.'\n    white_back_rank = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    'Calculate the total distance of all pieces to the back rank for each color.'\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Count the total number of squares attacked by each color.'\n    white_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    'Count how many pieces are in danger of being captured next turn for each side.'\n    white_threatened = sum(1 for square, piece in board.piece_map().items()\n                            if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_threatened = sum(1 for square, piece in board.piece_map().items()\n                            if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_threatened - black_threatened)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces less than 2 ranks from the enemy back rank for each side.'\n    white_proximity = sum(1 for square, piece in board.piece_map().items() \n                          if piece.color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_proximity = sum(1 for square, piece in board.piece_map().items() \n                          if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_proximity - black_proximity)", "def feature(board: chess.Board) -> float:\n    'Evaluate the difference in controlled squares between the two colors with respect to their pieces.'\n    white_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Count the total number of pieces for each color and return a weighted difference.'\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of pawns for each color.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Count the total value of all pieces on the board.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each side.'\n    controlled_squares = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK] += 1\n    control_difference = controlled_squares[chess.WHITE] - controlled_squares[chess.BLACK]\n    return float(control_difference)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves for the current player.'\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces that are unprotected.'\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == board.turn and not board.attackers(not piece.color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces on the back rank for each side.'\n    back_rank_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if (board.piece_at(square) is not None and \n            board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0):\n            back_rank_pieces[chess.WHITE] += 1\n        if (board.piece_at(square) is not None and \n            board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7):\n            back_rank_pieces[chess.BLACK] += 1\n    return float(back_rank_pieces[chess.WHITE] - back_rank_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Calculate the total distance of all pieces to the back rank for each color.'\n    total_distance = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        total_distance[piece.color] += distance\n    return float(total_distance[chess.WHITE] - total_distance[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of squares threatened by opponents.'\n    threatened_squares = len([square for square in chess.SQUARES if board.is_attacked_by(not board.turn, square)])\n    return float(threatened_squares)", "def feature(board: chess.Board) -> float:\n    'Identify the number of unprotected pieces for the player to move.'\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == board.turn and not board.attackers(not piece.color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces threatened for each color and return the difference.'\n    threatened_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square):\n            threatened_count[chess.WHITE] += 1\n        if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square):\n            threatened_count[chess.BLACK] += 1\n    return float(threatened_count[chess.WHITE] - threatened_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Count the number of controlled squares for each color and return the difference.'\n    controlled_squares_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares_count[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares_count[chess.BLACK] += 1\n    return float(controlled_squares_count[chess.WHITE] - controlled_squares_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces for each color.\"\n    return float(len([p for p in board.piece_map().values() if p.color == chess.WHITE]) - \n                 len([p for p in board.piece_map().values() if p.color == chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Count the number of rooks for each color.\"\n    return float(len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.ROOK]) - \n                 len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.ROOK]))", "def feature(board: chess.Board) -> float:\n    \"Count the total number of controlled squares for the side to move.\"\n    color = board.turn\n    controlled_squares = sum(1 for move in board.legal_moves)\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Count the number of unprotected pieces for the side to move.\"\n    color = board.turn\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == color and \n                            not board.is_attacked_by(not color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pawns for each color.\"\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE]) - \n                 len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Calculate the sum of distances of all pawns to their promotion ranks.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares attacked by each player.\"\n    attack_count_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    attack_count_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(attack_count_white - attack_count_black)", "def feature(board: chess.Board) -> float:\n    \"Calculate the distance of all pieces from the back rank for the side to move.\"\n    color = board.turn\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == color)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of threats each color is making.\"\n    return float(len([move for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square)]))", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Count the number of squares controlled by the side to move.\"\n    controlled_squares = 0\n    for move in board.legal_moves:\n        controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces of the player to move.\"\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the value of pieces on the board for the player to move.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pawns for each color.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculate the difference in mobility by counting legal moves for both colors.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Count the number of threatened pieces for the side to move.\"\n    threatened_count = 0\n    for square in board.piece_map().keys():\n        if board.is_attacked_by(board.turn, square):\n            threatened_count += 1\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces not protected on the board.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.attackers(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Sum the ranks of all pieces on the board for the side to move.\"\n    total_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculate the distance of all pieces to the nearest back rank for each color.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces on the back rank for the side to move.\"\n    back_rank_count = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(square) == back_rank:\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces for each color and return the difference.'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    'Calculate the total material value for each side.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Count the number of squares controlled by each color and return the difference.'\n    controlled_squares_white = set()\n    controlled_squares_black = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if piece.color == chess.WHITE:\n                        controlled_squares_white.add(move.to_square)\n                    else:\n                        controlled_squares_black.add(move.to_square)\n    return float(len(controlled_squares_white) - len(controlled_squares_black))", "def feature(board: chess.Board) -> float:\n    'Count the number of back rank pieces for each side.'\n    back_rank_white = sum(1 for square in [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n                          if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n                          if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of unprotected pieces for the active color.'\n    active_color = board.turn\n    unprotected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == active_color:\n            if not board.is_attacked_by(not active_color, square):\n                unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    'Count the total distance of pieces from the nearest back rank for each color.'\n    total_distance_white = sum(chess.square_distance(square, chess.A1) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    total_distance_black = sum(chess.square_distance(square, chess.A8) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(total_distance_white - total_distance_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of threatened pieces for each color and return the difference.'\n    threatened_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).color == chess.WHITE)\n    threatened_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.BLACK)\n    return float(threatened_white - threatened_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of controlled squares for each side and return the difference.'\n    controlled_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    'Count the number of legal moves available for the side to move.'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Count the number of pieces threatening the enemy king.'\n    enemy_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    threatening_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, enemy_king_square) and board.piece_at(square).color == board.turn)\n    return float(threatening_count)"]}